[
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for commcare.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "completion": "import { commonExecute } from '@openfn/language-common';\n\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for commcare.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n    const initialState = {\n        references: [],\n        data: null,\n    };\n\n    return state => {\n        state.configuration.authType = 'basic';\n        state.configuration.baseUrl = 'https://www.commcarehq.org/a/'.concat(\n            state.configuration.applicationName\n        );\n        return commonExecute(...operations)({ ...initialState, ...state });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Submit form data\n * @public\n * @example\n *  submit(\n *    fields(\n *      field(\"@\", function(state) {\n *        return {\n *          \"xmlns\": \"http://openrosa.org/formdesigner/form-id-here\"\n *        };\n *      }),\n *      field(\"question1\", dataValue(\"answer1\")),\n *      field(\"question2\", \"Some answer here.\")\n *    )\n *  )\n * @function\n * @param {Object} formData - Object including form data.\n * @returns {Operation}\n */\nexport function submit(formData: any): Operation;",
    "completion": "import { expandReferences } from '@openfn/language-common';\nimport { request } from 'superagent';\nimport js2xmlparser from 'js2xmlparser';\nimport FormData from 'form-data';\n\n/**\n * Submit form data\n * @public\n * @example\n *  submit(\n *    fields(\n *      field(\"@\", function(state) {\n *        return {\n *          \"xmlns\": \"http://openrosa.org/formdesigner/form-id-here\"\n *        };\n *      }),\n *      field(\"question1\", dataValue(\"answer1\")),\n *      field(\"question2\", \"Some answer here.\")\n *    )\n *  )\n * @function\n * @param {Object} formData - Object including form data.\n * @returns {Operation}\n */\nexport function submit(formData) {\n    return state => {\n        const jsonBody = expandReferences(formData)(state);\n        const body = js2xmlparser('data', jsonBody);\n\n        const {\n            applicationName,\n            username,\n            password,\n            appId,\n            hostUrl,\n        } = state.configuration;\n\n        const url = (hostUrl || 'https://www.commcarehq.org').concat(\n            '/a/',\n            applicationName,\n            '/receiver/',\n            appId,\n            '/'\n        );\n\n        console.log('Posting to url: '.concat(url));\n        console.log('Raw JSON body: '.concat(JSON.stringify(jsonBody)));\n        console.log('X-form submission: '.concat(body));\n\n        // Included clientPost function\n        return new Promise((resolve, reject) => {\n            request\n                .post(url)\n                .auth(username, password)\n                .set('Content-Type', 'application/xml')\n                .send(body)\n                .end((error, res) => {\n                    if (!!error || !res.ok) {\n                        reject(error);\n                    }\n                    resolve(res);\n                });\n        })\n            .then(response => {\n                console.log(`Server responded with a ${response.status}:`);\n                console.log(response);\n                return { ...state, references: [response, ...state.references] };\n            })\n            .catch(err => {\n                throw { ...err, config: {}, request: {} };\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Convert form data to xls then submit.\n * @public\n * @example\n * submitXls(\n *    [\n *      {name: 'Mamadou', phone: '000000'},\n *    ],\n *    {\n *      case_type: 'student',\n *      search_field: 'external_id',\n *      create_new_cases: 'on',\n *    }\n * )\n * @function\n * @param {Object} formData - Object including form data.\n * @param {Object} params - Request params including case type and external id.\n * @returns {Operation}\n */\nexport function submitXls(formData: any, params: any): Operation;",
    "completion": "import { http } from '@openfn/language-http';\nimport FormData from 'form-data';\nimport xlsx from 'xlsx';\n\n/**\n * Convert form data to xls then submit.\n * @public\n * @example\n * submitXls(\n *    [\n *      {name: 'Mamadou', phone: '000000'},\n *    ],\n *    {\n *      case_type: 'student',\n *      search_field: 'external_id',\n *      create_new_cases: 'on',\n *    }\n * )\n * @function\n * @param {Object} formData - Object including form data.\n * @param {Object} params - Request params including case type and external id.\n * @returns {Operation}\n */\nexport function submitXls(formData, params) {\n    return state => {\n        const { applicationName, hostUrl, username, apiKey } = state.configuration;\n        const json = expandReferences(formData)(state);\n        const { case_type, search_field, create_new_cases } = params;\n        const url = (hostUrl || 'https://www.commcarehq.org').concat(\n            '/a/',\n            applicationName,\n            '/importer/excel/bulk_upload_api/'\n        );\n\n        const workbook = xlsx.utils.book_new();\n        const worksheet = xlsx.utils.json_to_sheet(json);\n        const ws_name = 'SheetJS';\n        xlsx.utils.book_append_sheet(workbook, worksheet, ws_name);\n\n        // Generate buffer\n        const buffer = xlsx.write(workbook, { type: 'buffer', bookType: 'xls' });\n        const data = new FormData();\n\n        data.append('file', buffer, { filename: 'output.xls' });\n        data.append('case_type', case_type);\n        data.append('search_field', search_field);\n        data.append('create_new_cases', create_new_cases);\n\n        console.log('Posting to url: '.concat(url));\n        return http\n            .post({\n                url,\n                data,\n                headers: {\n                    ...data.getHeaders(),\n                    Authorization: `ApiKey ${username}:${apiKey}`,\n                },\n            })(state)\n            .then(response => {\n                return { ...state, data: { body: response.data } };\n            })\n            .catch(err => {\n                throw { ...err, config: {}, request: {} };\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Make a GET request to CommCare's Reports API\n * and POST the response to somewhere else.\n * @public\n * @example\n * fetchReportData(reportId, params, postUrl)\n * @function\n * @param {String} reportId - API name of the report.\n * @param {Object} params - Query params, incl: limit, offset, and custom report filters.\n * @param {String} postUrl - Url to which the response object will be posted.\n * @returns {Operation}\n */\nexport function fetchReportData(reportId: string, params: any, postUrl: string): Operation;",
    "completion": "import { http, post } from '@openfn/language-http';\n\n/**\n * Make a GET request to CommCare's Reports API\n * and POST the response to somewhere else.\n * @public\n * @example\n * fetchReportData(reportId, params, postUrl)\n * @function\n * @param {String} reportId - API name of the report.\n * @param {Object} params - Query params, incl: limit, offset, and custom report filters.\n * @param {String} postUrl - Url to which the response object will be posted.\n * @returns {Operation}\n */\nexport function fetchReportData(reportId, params, postUrl) {\n    return http.get(`api/v0.5/configurablereportdata/${reportId}/`, {\n        query: function (state) {\n            console.log(\n                'getting from url: '.concat(\n                    state.configuration.baseUrl,\n                    `/api/v0.5/configurablereportdata/${reportId}/`\n                )\n            );\n            console.log('with params: '.concat(params));\n            return params;\n        },\n        callback: function (state) {\n            var reportData = state.response.body;\n            return post(postUrl, {\n                body: reportData,\n            })(state).then(function (state) {\n                delete state.response;\n                console.log('fetchReportData succeeded.');\n                console.log('Posted to: '.concat(postUrl));\n                return state;\n            });\n        },\n    });\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Performs a post request\n * @example\n *  clientPost(formData)\n * @function\n * @param {Object} formData - Form Data with auth params and body\n * @returns {State}\n */\nfunction clientPost({ url, body, username, password }): State;",
    "completion": "import request from 'superagent';\n\n/**\n * Performs a post request\n * @example\n *  clientPost(formData)\n * @function\n * @param {Object} formData - Form Data with auth params and body\n * @returns {State}\n */\nfunction clientPost({ url, body, username, password }) {\n    return new Promise((resolve, reject) => {\n        request\n            .post(url)\n            .auth(username, password)\n            .set('Content-Type', 'application/xml')\n            .send(body)\n            .end((error, res) => {\n                if (!!error || !res.ok) {\n                    reject(error);\n                }\n                resolve(res);\n            });\n    });\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Gets patient matching a uuid\n * @example\n * getPatient(\"123\")\n * @function\n * @param {string} uuid - A uuid for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @example <caption>Get a patient by uuid</caption>\n * getPatient('681f8785-c9ca-4dc8-a091-7b869316ff93')\n * @returns {Operation}\n */\nexport function getPatient(uuid: string, callback?: Function): Operation;",
    "completion": "import {\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n\nlet agent = null;\n/**\n * Logs in to OpenMRS, gets a session token.\n * Agent used in main function\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\nexport const Log = {\n  success: message => console.log(`\u2713 Success at ${new Date()}:\\n\u221f ${message}`),\n  warn: message => console.log(`\u26a0 Warning at ${new Date()}:\\n\u221f ${message}`),\n  error: message => console.log(`\u2717 Error at ${new Date()}:\\n\u221f ${message}`),\n  info: message => console.log(`\u2139 Info at ${new Date()}:\\n\u221f ${message}`),\n};\n\nexport function handleError(error) {\n  if (error.response) {\n    const { method, path } = error.response.req;\n    const { status } = error.response;\n    if (Object.keys(error.response.body).length === 0) {\n      throw new Error(\n        `Server responded with:  \\n${JSON.stringify(error.response, null, 2)}`\n      );\n    }\n\n    const errorString = [\n      `Request: ${method} ${path}`,\n      `Got: ${status}`,\n      'Body:',\n      JSON.stringify(error.response.body, null, 2),\n    ].join('\\n');\n\n    throw new Error(errorString);\n  } else {\n    throw error;\n  }\n}\n\nexport function handleResponse(response, state, callback) {\n  const { body } = response;\n  const nextState = composeNextState(state, { body });\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\n/**\n * Logs in to OpenMRS, gets a session token.\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\n/**\n * Gets patient matching a uuid\n * @example\n * getPatient(\"123\")\n * @function\n * @param {string} uuid - A uuid for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @example <caption>Get a patient by uuid</caption>\n * getPatient('681f8785-c9ca-4dc8-a091-7b869316ff93')\n * @returns {Operation}\n */\nexport function getPatient(uuid, callback = false) {\n  return state => {\n    Log.info(`Searching for patient with uuid: ${uuid}`);\n    const { instanceUrl } = state.configuration;\n    const defaultQuery = { v: 'full', limit: 1 };\n    const url = `${instanceUrl}/ws/rest/v1/patient/${uuid}`;\n\n    return agent\n      .get(url)\n      .accept('json')\n      .query(defaultQuery)\n      .then(response => {\n        Log.success(`Found patient.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Gets encounters matching params\n * @example\n * getEncounters({patient: \"123\", fromdate: \"2023-05-18\"})\n * @function\n * @param {object} query - Object for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounters(query: object, callback?: Function): Operation;",
    "completion": "import {\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n\nlet agent = null;\n/**\n * Logs in to OpenMRS, gets a session token.\n * Agent used in main function\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\nexport const Log = {\n  success: message => console.log(`\u2713 Success at ${new Date()}:\\n\u221f ${message}`),\n  warn: message => console.log(`\u26a0 Warning at ${new Date()}:\\n\u221f ${message}`),\n  error: message => console.log(`\u2717 Error at ${new Date()}:\\n\u221f ${message}`),\n  info: message => console.log(`\u2139 Info at ${new Date()}:\\n\u221f ${message}`),\n};\n\nexport function handleError(error) {\n  if (error.response) {\n    const { method, path } = error.response.req;\n    const { status } = error.response;\n    if (Object.keys(error.response.body).length === 0) {\n      throw new Error(\n        `Server responded with:  \\n${JSON.stringify(error.response, null, 2)}`\n      );\n    }\n\n    const errorString = [\n      `Request: ${method} ${path}`,\n      `Got: ${status}`,\n      'Body:',\n      JSON.stringify(error.response.body, null, 2),\n    ].join('\\n');\n\n    throw new Error(errorString);\n  } else {\n    throw error;\n  }\n}\n\nexport function handleResponse(response, state, callback) {\n  const { body } = response;\n  const nextState = composeNextState(state, { body });\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\n/**\n * Gets encounters matching params\n * @example\n * getEncounters({patient: \"123\", fromdate: \"2023-05-18\"})\n * @function\n * @param {object} query - Object for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounters(query, callback = false) {\n  return state => {\n    const qs = expandReferences(query)(state);\n    const { instanceUrl } = state.configuration;\n    const url = `${instanceUrl}/ws/rest/v1/encounter`;\n\n    Log.info(`Searching for encounters: ${JSON.stringify(qs, null, 2)}`);\n\n    return agent\n      .get(url)\n      .accept('json')\n      .query(qs)\n      .then(response => {\n        Log.success(`Found an encounter.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Creates a new patient\n * @example\n * createPatient({\n *   identifiers: [\n *     {\n *       identifier: '4023287',\n *       identifierType: '05a29f94-c0ed-11e2-94be-8c13b969e334',\n *       preferred: true,\n *     },\n *   ],\n *   person: {\n *     gender: 'M',\n *     age: 42,\n *     birthdate: '1970-01-01T00:00:00.000+0100',\n *     birthdateEstimated: false,\n *     names: [\n *       {\n *         givenName: 'Doe',\n *         familyName: 'John',\n *       },\n *     ],\n *   },\n * })\n * @function\n * @param {object} data - Object parameters of the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createPatient(data: object, callback?: Function): Operation;",
    "completion": "import {\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n\nlet agent = null;\n/**\n * Logs in to OpenMRS, gets a session token.\n * Agent used in main function\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\nexport const Log = {\n  success: message => console.log(`\u2713 Success at ${new Date()}:\\n\u221f ${message}`),\n  warn: message => console.log(`\u26a0 Warning at ${new Date()}:\\n\u221f ${message}`),\n  error: message => console.log(`\u2717 Error at ${new Date()}:\\n\u221f ${message}`),\n  info: message => console.log(`\u2139 Info at ${new Date()}:\\n\u221f ${message}`),\n};\n\nexport function handleError(error) {\n  if (error.response) {\n    const { method, path } = error.response.req;\n    const { status } = error.response;\n    if (Object.keys(error.response.body).length === 0) {\n      throw new Error(\n        `Server responded with:  \\n${JSON.stringify(error.response, null, 2)}`\n      );\n    }\n\n    const errorString = [\n      `Request: ${method} ${path}`,\n      `Got: ${status}`,\n      'Body:',\n      JSON.stringify(error.response.body, null, 2),\n    ].join('\\n');\n\n    throw new Error(errorString);\n  } else {\n    throw error;\n  }\n}\n\nexport function handleResponse(response, state, callback) {\n  const { body } = response;\n  const nextState = composeNextState(state, { body });\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\n/**\n * Creates a new patient\n * @example\n * createPatient({\n *   identifiers: [\n *     {\n *       identifier: '4023287',\n *       identifierType: '05a29f94-c0ed-11e2-94be-8c13b969e334',\n *       preferred: true,\n *     },\n *   ],\n *   person: {\n *     gender: 'M',\n *     age: 42,\n *     birthdate: '1970-01-01T00:00:00.000+0100',\n *     birthdateEstimated: false,\n *     names: [\n *       {\n *         givenName: 'Doe',\n *         familyName: 'John',\n *       },\n *     ],\n *   },\n * })\n * @function\n * @param {object} data - Object parameters of the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createPatient(data, callback = false) {\n  return state => {\n    const body = expandReferences(data)(state);\n    const { instanceUrl } = state.configuration;\n    const url = `${instanceUrl}/ws/rest/v1/patient`;\n\n    Log.info(`Creating a patient.`);\n\n    return agent\n      .post(url)\n      .type('json')\n      .send(body)\n      .then(response => {\n        Log.success(`Created a new patient.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Fetch all non-retired patients that match any specified parameters\n * @example\n * searchPatient({ q: Sarah })\n * @function\n * @param {object} query - Object with query for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function searchPatient(query: object, callback?: Function): Operation;",
    "completion": "import {\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n\nlet agent = null;\n/**\n * Logs in to OpenMRS, gets a session token.\n * Agent used in main function\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\nexport const Log = {\n  success: message => console.log(`\u2713 Success at ${new Date()}:\\n\u221f ${message}`),\n  warn: message => console.log(`\u26a0 Warning at ${new Date()}:\\n\u221f ${message}`),\n  error: message => console.log(`\u2717 Error at ${new Date()}:\\n\u221f ${message}`),\n  info: message => console.log(`\u2139 Info at ${new Date()}:\\n\u221f ${message}`),\n};\n\nexport function handleError(error) {\n  if (error.response) {\n    const { method, path } = error.response.req;\n    const { status } = error.response;\n    if (Object.keys(error.response.body).length === 0) {\n      throw new Error(\n        `Server responded with:  \\n${JSON.stringify(error.response, null, 2)}`\n      );\n    }\n\n    const errorString = [\n      `Request: ${method} ${path}`,\n      `Got: ${status}`,\n      'Body:',\n      JSON.stringify(error.response.body, null, 2),\n    ].join('\\n');\n\n    throw new Error(errorString);\n  } else {\n    throw error;\n  }\n}\n\nexport function handleResponse(response, state, callback) {\n  const { body } = response;\n  const nextState = composeNextState(state, { body });\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\n/**\n * Fetch all non-retired patients that match any specified parameters\n * @example\n * searchPatient({ q: Sarah })\n * @function\n * @param {object} query - Object with query for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function searchPatient(query, callback = false) {\n  return state => {\n    const qs = expandReferences(query)(state);\n    Log.info(`Searching for patient with name: ${qs.q}`);\n    const { instanceUrl } = state.configuration;\n\n    const url = `${instanceUrl}/ws/rest/v1/patient`;\n\n    return agent\n      .get(url)\n      .accept('json')\n      .query(qs)\n      .then(response => {\n        const data = response.body;\n        const count = data.results.length;\n\n        if (count > 0) {\n          Log.success(\n            `Search successful. Returned ${count} patient${count > 1 ? 's' : ''\n            }.`\n          );\n          return handleResponse(response, state, callback);\n        } else {\n          Log.warn(`${count} records were found.`);\n        }\n      })\n      .catch(handleError);\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Creates an encounter\n * @example <caption>Create an encounter</caption>\n * createEncounter({\n *   encounterDatetime: '2023-05-25T06:08:25.000+0000',\n *   patient: '1fdaa696-e759-4a7d-a066-f1ae557c151b',\n *   encounterType: 'dd528487-82a5-4082-9c72-ed246bd49591',\n *   location: 'ba685651-ed3b-4e63-9b35-78893060758a',\n *   encounterProviders: [],\n *   visit: {\n *     patient: '1fdaa696-e759-4a7d-a066-f1ae557c151b',\n *     visitType: '7b0f5697-27e3-40c4-8bae-f4049abfb4ed',\n *     startDatetime: '2023-05-25T06:08:25.000+0000',\n *     stopDatetime: '2023-05-25T06:09:25.000+0000',\n *   },\n * })\n * @function\n * @param {object} data - Data parameters of the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createEncounter(data: object, callback?: Function): Operation;",
    "completion": "import {\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n\nlet agent = null;\n/**\n * Logs in to OpenMRS, gets a session token.\n * Agent used in createEncouter function\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\nexport const Log = {\n  success: message => console.log(`\u2713 Success at ${new Date()}:\\n\u221f ${message}`),\n  warn: message => console.log(`\u26a0 Warning at ${new Date()}:\\n\u221f ${message}`),\n  error: message => console.log(`\u2717 Error at ${new Date()}:\\n\u221f ${message}`),\n  info: message => console.log(`\u2139 Info at ${new Date()}:\\n\u221f ${message}`),\n};\n\nexport function handleError(error) {\n  if (error.response) {\n    const { method, path } = error.response.req;\n    const { status } = error.response;\n    if (Object.keys(error.response.body).length === 0) {\n      throw new Error(\n        `Server responded with:  \\n${JSON.stringify(error.response, null, 2)}`\n      );\n    }\n\n    const errorString = [\n      `Request: ${method} ${path}`,\n      `Got: ${status}`,\n      'Body:',\n      JSON.stringify(error.response.body, null, 2),\n    ].join('\\n');\n\n    throw new Error(errorString);\n  } else {\n    throw error;\n  }\n}\n\nexport function handleResponse(response, state, callback) {\n  const { body } = response;\n  const nextState = composeNextState(state, { body });\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\n/**\n * Creates an encounter\n * @example <caption>Create an encounter</caption>\n * createEncounter({\n *   encounterDatetime: '2023-05-25T06:08:25.000+0000',\n *   patient: '1fdaa696-e759-4a7d-a066-f1ae557c151b',\n *   encounterType: 'dd528487-82a5-4082-9c72-ed246bd49591',\n *   location: 'ba685651-ed3b-4e63-9b35-78893060758a',\n *   encounterProviders: [],\n *   visit: {\n *     patient: '1fdaa696-e759-4a7d-a066-f1ae557c151b',\n *     visitType: '7b0f5697-27e3-40c4-8bae-f4049abfb4ed',\n *     startDatetime: '2023-05-25T06:08:25.000+0000',\n *     stopDatetime: '2023-05-25T06:09:25.000+0000',\n *   },\n * })\n * @function\n * @param {object} data - Data parameters of the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createEncounter(data, callback = false) {\n  return state => {\n    const { instanceUrl } = state.configuration;\n    const body = expandReferences(data)(state);\n    const url = `${instanceUrl}/ws/rest/v1/encounter`;\n\n    Log.info(`Creating an encounter.`);\n\n    return agent\n      .post(url)\n      .type('json')\n      .send(body)\n      .then(response => {\n        Log.success(`Created an encounter.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Make a post request to any OpenMRS endpoint\n * @example\n * post(\n *   \"idgen/identifiersource/8549f706-7e85-4c1d-9424-217d50a2988b/identifier\",\n *   {}\n * );\n * @function\n * @param {string} path - Path to resource\n * @param {object} data - Object which defines data that will be used to create a given instance of resource\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function post(path: string, data: object, callback?: Function): Operation;",
    "completion": "import {\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n\nlet agent = null;\n/**\n * Logs in to OpenMRS, gets a session token.\n * Agent used in main function\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\nexport const Log = {\n  success: message => console.log(`\u2713 Success at ${new Date()}:\\n\u221f ${message}`),\n  warn: message => console.log(`\u26a0 Warning at ${new Date()}:\\n\u221f ${message}`),\n  error: message => console.log(`\u2717 Error at ${new Date()}:\\n\u221f ${message}`),\n  info: message => console.log(`\u2139 Info at ${new Date()}:\\n\u221f ${message}`),\n};\n\nexport function handleError(error) {\n  if (error.response) {\n    const { method, path } = error.response.req;\n    const { status } = error.response;\n    if (Object.keys(error.response.body).length === 0) {\n      throw new Error(\n        `Server responded with:  \\n${JSON.stringify(error.response, null, 2)}`\n      );\n    }\n\n    const errorString = [\n      `Request: ${method} ${path}`,\n      `Got: ${status}`,\n      'Body:',\n      JSON.stringify(error.response.body, null, 2),\n    ].join('\\n');\n\n    throw new Error(errorString);\n  } else {\n    throw error;\n  }\n}\n\nexport function handleResponse(response, state, callback) {\n  const { body } = response;\n  const nextState = composeNextState(state, { body });\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\n/**\n * Make a post request to any OpenMRS endpoint\n * @example\n * post(\n *   \"idgen/identifiersource/8549f706-7e85-4c1d-9424-217d50a2988b/identifier\",\n *   {}\n * );\n * @function\n * @param {string} path - Path to resource\n * @param {object} data - Object which defines data that will be used to create a given instance of resource\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function post(path, data, callback = false) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedData = expandReferences(data)(state);\n    const { instanceUrl } = state.configuration;\n\n    const urlPath = `${instanceUrl}/ws/rest/v1/${resolvedPath}`;\n\n    return agent\n      .post(urlPath)\n      .type('json')\n      .send(resolvedData)\n      .then(response => handleResponse(response, state, callback))\n      .catch(handleError);\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Update data. A generic helper function to update a resource object of any type.\n * Updating an object requires to send `all required fields` or the `full body`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be updated. E.g. `person`, `patient`, etc.\n * @param {string} path - The `id` or `path` to the `object` to be updated. E.g. `e739808f-f166-42ae-aaf3-8b3e8fa13fda` or `e739808f-f166-42ae-aaf3-8b3e8fa13fda/{collection-name}/{object-id}`\n * @param {Object} data - Data to update. It requires to send `all required fields` or the `full body`. If you want `partial updates`, use `patch` operation.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a person</caption>\n * update(\"person\", '3cad37ad-984d-4c65-a019-3eb120c9c373',{\"gender\":\"M\",\"birthdate\":\"1997-01-13\"})\n */\nexport function update(resourceType: string, path: string, data: any, callback?: Function): Operation;",
    "completion": "import {\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n\nlet agent = null;\n/**\n * Logs in to OpenMRS, gets a session token.\n * Agent used in main function\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\nexport const Log = {\n  success: message => console.log(`\u2713 Success at ${new Date()}:\\n\u221f ${message}`),\n  warn: message => console.log(`\u26a0 Warning at ${new Date()}:\\n\u221f ${message}`),\n  error: message => console.log(`\u2717 Error at ${new Date()}:\\n\u221f ${message}`),\n  info: message => console.log(`\u2139 Info at ${new Date()}:\\n\u221f ${message}`),\n};\n\nexport function handleError(error) {\n  if (error.response) {\n    const { method, path } = error.response.req;\n    const { status } = error.response;\n    if (Object.keys(error.response.body).length === 0) {\n      throw new Error(\n        `Server responded with:  \\n${JSON.stringify(error.response, null, 2)}`\n      );\n    }\n\n    const errorString = [\n      `Request: ${method} ${path}`,\n      `Got: ${status}`,\n      'Body:',\n      JSON.stringify(error.response.body, null, 2),\n    ].join('\\n');\n\n    throw new Error(errorString);\n  } else {\n    throw error;\n  }\n}\n\nexport function handleResponse(response, state, callback) {\n  const { body } = response;\n  const nextState = composeNextState(state, { body });\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\n/**\n * Update data. A generic helper function to update a resource object of any type.\n * Updating an object requires to send `all required fields` or the `full body`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be updated. E.g. `person`, `patient`, etc.\n * @param {string} path - The `id` or `path` to the `object` to be updated. E.g. `e739808f-f166-42ae-aaf3-8b3e8fa13fda` or `e739808f-f166-42ae-aaf3-8b3e8fa13fda/{collection-name}/{object-id}`\n * @param {Object} data - Data to update. It requires to send `all required fields` or the `full body`. If you want `partial updates`, use `patch` operation.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a person</caption>\n * update(\"person\", '3cad37ad-984d-4c65-a019-3eb120c9c373',{\"gender\":\"M\",\"birthdate\":\"1997-01-13\"})\n */\nexport function update(resourceType, path, data, callback = false) {\n  return state => {\n    Log.info(`Preparing update operation...`);\n\n    const { instanceUrl } = state.configuration;\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedData = expandReferences(data)(state);\n\n    const url = `${instanceUrl}/ws/rest/v1/${resolvedResourceType}/${resolvedPath}`;\n\n    return agent\n      .post(url)\n      .type('json')\n      .send(resolvedData)\n      .then(response => {\n        Log.success(`Updated ${resolvedResourceType} at ${resolvedPath}`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Fetch all non-retired persons that match any specified parameters\n * @example\n * searchPerson({ q: Sarah })\n * @function\n * @param {object} query - object with query for the person\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function searchPerson(query: object, callback?: Function): Operation;",
    "completion": "import {\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n\nlet agent = null;\n/**\n * Logs in to OpenMRS, gets a session token.\n * Agent used in main function\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\nexport const Log = {\n  success: message => console.log(`\u2713 Success at ${new Date()}:\\n\u221f ${message}`),\n  warn: message => console.log(`\u26a0 Warning at ${new Date()}:\\n\u221f ${message}`),\n  error: message => console.log(`\u2717 Error at ${new Date()}:\\n\u221f ${message}`),\n  info: message => console.log(`\u2139 Info at ${new Date()}:\\n\u221f ${message}`),\n};\n\nexport function handleError(error) {\n  if (error.response) {\n    const { method, path } = error.response.req;\n    const { status } = error.response;\n    if (Object.keys(error.response.body).length === 0) {\n      throw new Error(\n        `Server responded with:  \\n${JSON.stringify(error.response, null, 2)}`\n      );\n    }\n\n    const errorString = [\n      `Request: ${method} ${path}`,\n      `Got: ${status}`,\n      'Body:',\n      JSON.stringify(error.response.body, null, 2),\n    ].join('\\n');\n\n    throw new Error(errorString);\n  } else {\n    throw error;\n  }\n}\n\nexport function handleResponse(response, state, callback) {\n  const { body } = response;\n  const nextState = composeNextState(state, { body });\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\n/**\n * Fetch all non-retired persons that match any specified parameters\n * @example\n * searchPerson({ q: Sarah })\n * @function\n * @param {object} query - object with query for the person\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function searchPerson(query, callback = false) {\n  return state => {\n    const qs = expandReferences(query)(state);\n    Log.info(`Searching for person with name: ${qs.q}`);\n\n    const { instanceUrl } = state.configuration;\n\n    const url = `${instanceUrl}/ws/rest/v1/person`;\n\n    return agent\n      .get(url)\n      .accept('json')\n      .query(qs)\n      .then(response => {\n        const data = response.body;\n        const count = data.results.length;\n\n        if (count > 0) {\n          Log.success(\n            `Search successful. Returned ${count} person${count > 1 ? 's' : ''\n            }.`\n          );\n          return handleResponse(response, state, callback);\n        } else {\n          Log.warn(`${count} records were found.`);\n        }\n      })\n      .catch(handleError);\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `person`, `patient`, `encounter`, ...\n * @param {OpenMRSData} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>Create a person</caption>\n * create(\"person\", {\n *   names: [\n *     {\n *       givenName: \"Mohit\",\n *       familyName: \"Kumar\",\n *     },\n *   ],\n *   gender: \"M\",\n *   birthdate: \"1997-09-02\",\n *   addresses: [\n *     {\n *       address1: \"30, Vivekananda Layout, Munnekolal,Marathahalli\",\n *       cityVillage: \"Bengaluru\",\n *       country: \"India\",\n *       postalCode: \"560037\",\n *     },\n *   ],\n * });\n */\nexport function create(resourceType: string, data: OpenMRSData, callback?: Function): Operation;",
    "completion": "import {\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n\nlet agent = null;\n/**\n * Logs in to OpenMRS, gets a session token.\n * Agent used in main function\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\nexport const Log = {\n  success: message => console.log(`\u2713 Success at ${new Date()}:\\n\u221f ${message}`),\n  warn: message => console.log(`\u26a0 Warning at ${new Date()}:\\n\u221f ${message}`),\n  error: message => console.log(`\u2717 Error at ${new Date()}:\\n\u221f ${message}`),\n  info: message => console.log(`\u2139 Info at ${new Date()}:\\n\u221f ${message}`),\n};\n\nexport function handleError(error) {\n  if (error.response) {\n    const { method, path } = error.response.req;\n    const { status } = error.response;\n    if (Object.keys(error.response.body).length === 0) {\n      throw new Error(\n        `Server responded with:  \\n${JSON.stringify(error.response, null, 2)}`\n      );\n    }\n\n    const errorString = [\n      `Request: ${method} ${path}`,\n      `Got: ${status}`,\n      'Body:',\n      JSON.stringify(error.response.body, null, 2),\n    ].join('\\n');\n\n    throw new Error(errorString);\n  } else {\n    throw error;\n  }\n}\n\nexport function handleResponse(response, state, callback) {\n  const { body } = response;\n  const nextState = composeNextState(state, { body });\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\n/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `person`, `patient`, `encounter`, ...\n * @param {OpenMRSData} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>Create a person</caption>\n * create(\"person\", {\n *   names: [\n *     {\n *       givenName: \"Mohit\",\n *       familyName: \"Kumar\",\n *     },\n *   ],\n *   gender: \"M\",\n *   birthdate: \"1997-09-02\",\n *   addresses: [\n *     {\n *       address1: \"30, Vivekananda Layout, Munnekolal,Marathahalli\",\n *       cityVillage: \"Bengaluru\",\n *       country: \"India\",\n *       postalCode: \"560037\",\n *     },\n *   ],\n * });\n */\nexport function create(resourceType, data, callback = false) {\n  return state => {\n    Log.info(`Preparing create operation...`);\n\n    const resolvedData = expandReferences(data)(state);\n    const resolvedResourceType = expandReferences(resourceType)(state);\n\n    const { instanceUrl } = state.configuration;\n    const url = `${instanceUrl}/ws/rest/v1/${resolvedResourceType}`;\n\n    return agent\n      .post(url)\n      .type('json')\n      .send(resolvedData)\n      .then(response => {\n        const details = `with response ${JSON.stringify(\n          response.body,\n          null,\n          2\n        )}`;\n\n        Log.success(`Created ${resolvedResourceType} ${details}`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Gets encounter matching a uuid\n * @example\n * getEncounter(\"123\")\n * @function\n * @param {object} uuid - A uuid for the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounter(uuid: object, callback?: Function): Operation;",
    "completion": "import {\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n\nlet agent = null;\n/**\n * Logs in to OpenMRS, gets a session token.\n * Agent used in main function\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\nexport const Log = {\n  success: message => console.log(`\u2713 Success at ${new Date()}:\\n\u221f ${message}`),\n  warn: message => console.log(`\u26a0 Warning at ${new Date()}:\\n\u221f ${message}`),\n  error: message => console.log(`\u2717 Error at ${new Date()}:\\n\u221f ${message}`),\n  info: message => console.log(`\u2139 Info at ${new Date()}:\\n\u221f ${message}`),\n};\n\nexport function handleError(error) {\n  if (error.response) {\n    const { method, path } = error.response.req;\n    const { status } = error.response;\n    if (Object.keys(error.response.body).length === 0) {\n      throw new Error(\n        `Server responded with:  \\n${JSON.stringify(error.response, null, 2)}`\n      );\n    }\n\n    const errorString = [\n      `Request: ${method} ${path}`,\n      `Got: ${status}`,\n      'Body:',\n      JSON.stringify(error.response.body, null, 2),\n    ].join('\\n');\n\n    throw new Error(errorString);\n  } else {\n    throw error;\n  }\n}\n\nexport function handleResponse(response, state, callback) {\n  const { body } = response;\n  const nextState = composeNextState(state, { body });\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\n/**\n * Gets encounter matching a uuid\n * @example\n * getEncounter(\"123\")\n * @function\n * @param {object} uuid - A uuid for the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounter(uuid, callback = false) {\n  return state => {\n    Log.info(`Searching for encounter with uuid: ${uuid}`);\n    const { instanceUrl } = state.configuration;\n\n    const url = `${instanceUrl}/ws/rest/v1/encounter/${uuid}`;\n\n    return agent\n      .get(url)\n      .accept('json')\n      .then(response => {\n        Log.success(`Found an encounter.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Upsert a record. A generic helper function used to atomically either insert a row, or on the basis of the row already existing, UPDATE that existing row instead.\n * @public\n * @function\n * @param {string} resourceType - The type of a resource to `upsert`. E.g. `trackedEntityInstances`\n * @param {Object} query - A query object that allows to uniquely identify the resource to update. If no matches found, then the resource will be created.\n * @param {Object} data - The data to use for update or create depending on the result of the query.\n * @param {function} [callback] - Optional callback to handle the response\n * @throws {RangeError} - Throws range error\n * @returns {Operation}\n * @example <caption>For an existing patient using upsert</caption>\n * upsert('patient', { q: '10007JJ' }, { person: { age: 50 } });\n * @example <caption>For non existing patient creating a patient record using upsert </caption>\n * upsert(\n *   \"patient\",\n *   { q: \"1000EHE\" },\n *   {\n *     identifiers: [\n *       {\n *         identifier: \"1000EHE\",\n *         identifierType: \"05a29f94-c0ed-11e2-94be-8c13b969e334\",\n *         location: \"44c3efb0-2583-4c80-a79e-1f756a03c0a1\",\n *         preferred: true,\n *       },\n *     ],\n *     person: {\n *       gender: \"M\",\n *       age: 42,\n *     },\n *   }\n * );\n */\nexport function upsert(resourceType: string, query: any, data: any, callback?: Function): Operation;",
    "completion": "import {\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n\nlet agent = null;\n/**\n * Logs in to OpenMRS, gets a session token.\n * Agent used in main function\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\nexport const Log = {\n  success: message => console.log(`\u2713 Success at ${new Date()}:\\n\u221f ${message}`),\n  warn: message => console.log(`\u26a0 Warning at ${new Date()}:\\n\u221f ${message}`),\n  error: message => console.log(`\u2717 Error at ${new Date()}:\\n\u221f ${message}`),\n  info: message => console.log(`\u2139 Info at ${new Date()}:\\n\u221f ${message}`),\n};\n\nexport function handleError(error) {\n  if (error.response) {\n    const { method, path } = error.response.req;\n    const { status } = error.response;\n    if (Object.keys(error.response.body).length === 0) {\n      throw new Error(\n        `Server responded with:  \\n${JSON.stringify(error.response, null, 2)}`\n      );\n    }\n\n    const errorString = [\n      `Request: ${method} ${path}`,\n      `Got: ${status}`,\n      'Body:',\n      JSON.stringify(error.response.body, null, 2),\n    ].join('\\n');\n\n    throw new Error(errorString);\n  } else {\n    throw error;\n  }\n}\n\nexport function handleResponse(response, state, callback) {\n  const { body } = response;\n  const nextState = composeNextState(state, { body });\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\n/**\n * Upsert a record. A generic helper function used to automically either insert a row, or on the basis of the row already existing, UPDATE that existing row instead.\n * @public\n * @function\n * @param {string} resourceType - The type of a resource to `upsert`. E.g. `trackedEntityInstances`\n * @param {Object} query - A query object that allows to uniquely identify the resource to update. If no matches found, then the resource will be created.\n * @param {Object} data - The data to use for update or create depending on the result of the query.\n * @param {function} [callback] - Optional callback to handle the response\n * @throws {RangeError} - Throws range error\n * @returns {Operation}\n * @example <caption>For an existing patient using upsert</caption>\n * upsert('patient', { q: '10007JJ' }, { person: { age: 50 } });\n * @example <caption>For non existing patient creating a patient record using upsert </caption>\n * upsert(\n *   \"patient\",\n *   { q: \"1000EHE\" },\n *   {\n *     identifiers: [\n *       {\n *         identifier: \"1000EHE\",\n *         identifierType: \"05a29f94-c0ed-11e2-94be-8c13b969e334\",\n *         location: \"44c3efb0-2583-4c80-a79e-1f756a03c0a1\",\n *         preferred: true,\n *       },\n *     ],\n *     person: {\n *       gender: \"M\",\n *       age: 42,\n *     },\n *   }\n * );\n */\nexport function upsert(\n  resourceType, // resourceType supplied to both the `get` and the `create/update`\n  query, // query supplied to the `get`\n  data, // data supplied to the `create/update`\n  callback = false // callback for the upsert itself.\n) {\n  return state => {\n    Log.info(`Preparing upsert via 'get' then 'create' OR 'update'...`);\n\n    return get(\n      resourceType,\n      query\n    )(state)\n      .then(resp => {\n        const resources = resp.data.body.results;\n        if (resources.length > 1) {\n          throw new RangeError(\n            `Cannot upsert on Non-unique attribute. The operation found more than one records for your request.`\n          );\n        } else if (resources.length <= 0) {\n          return create(resourceType, data)(state);\n        } else {\n          // Pick out the first (and only) resource in the array and grab its\n          // ID to be used in the subsequent `update` by the path determined\n          const path = resources[0]['uuid'];\n          return update(resourceType, path, data)(state);\n        }\n      })\n      .then(result => {\n        Log.success(`Performed a \"composed upsert\" on ${resourceType}`);\n        return handleResponse(result, state, callback);\n      });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Make a get request to any OpenMRS endpoint\n * @example\n * get(\"patient\", {\n *   q: \"Patient\",\n *   limit: 1,\n * });\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - parameters for the request\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function get(path: string, query: object, callback?: Function): Operation;",
    "completion": "import {\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n\nlet agent = null;\n/**\n * Logs in to OpenMRS, gets a session token.\n * Agent used in main function\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\nexport const Log = {\n  success: message => console.log(`\u2713 Success at ${new Date()}:\\n\u221f ${message}`),\n  warn: message => console.log(`\u26a0 Warning at ${new Date()}:\\n\u221f ${message}`),\n  error: message => console.log(`\u2717 Error at ${new Date()}:\\n\u221f ${message}`),\n  info: message => console.log(`\u2139 Info at ${new Date()}:\\n\u221f ${message}`),\n};\n\nexport function handleError(error) {\n  if (error.response) {\n    const { method, path } = error.response.req;\n    const { status } = error.response;\n    if (Object.keys(error.response.body).length === 0) {\n      throw new Error(\n        `Server responded with:  \\n${JSON.stringify(error.response, null, 2)}`\n      );\n    }\n\n    const errorString = [\n      `Request: ${method} ${path}`,\n      `Got: ${status}`,\n      'Body:',\n      JSON.stringify(error.response.body, null, 2),\n    ].join('\\n');\n\n    throw new Error(errorString);\n  } else {\n    throw error;\n  }\n}\n\nexport function handleResponse(response, state, callback) {\n  const { body } = response;\n  const nextState = composeNextState(state, { body });\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\n/**\n * Make a get request to any OpenMRS endpoint\n * @example\n * get(\"patient\", {\n *   q: \"Patient\",\n *   limit: 1,\n * });\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - parameters for the request\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function get(path, query, callback = false) {\n  return state => {\n    const { instanceUrl } = state.configuration;\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedQuery = expandReferences(query)(state);\n    const urlPath = `${instanceUrl}/ws/rest/v1/${resolvedPath}`;\n\n    return agent\n      .get(urlPath)\n      .query(resolvedQuery)\n      .then(response => handleResponse(response, state, callback))\n      .catch(handleError);\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "completion": "import {\n    execute as commonExecute,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Execute a sequence of operations with login.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n    const initialState = {\n        references: [],\n        data: null,\n    };\n\n    return state => {\n        return commonExecute(\n            login,\n            ...operations\n            /* logout */\n        )({ ...initialState, ...state }).catch(e => {\n            console.error(e);\n            /* logout(); */\n            process.exit(1);\n        });\n    };\n}\n\nfunction login(state) {\n    const { apiUrl, password, email } = state.configuration;\n\n    return axios({\n        method: 'post',\n        url: `${apiUrl}/users/login`,\n        data: {\n            email,\n            password,\n        },\n    }).then(response => {\n        console.log('Authentication succeeded.');\n        const { id } = response.data;\n        return {\n            ...state,\n            configuration: { ...state.configuration, apiUrl, access_token: id },\n        };\n    });\n}\n\nfunction logout(state) {\n    const { apiUrl, access_token } = state.configuration;\n    return axios({\n        method: 'post',\n        url: `${apiUrl}/users/logout?access_token=${access_token}`,\n    }).then(() => {\n        console.log('logged out');\n        delete state.configuration;\n        return state;\n    });\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Fetch the list of outbreaks\n * @public\n * @example\n *  listOutbreaks(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listOutbreaks(callback: Function): Operation;",
    "completion": "import {\n    composeNextState,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Fetch the list of outbreaks\n * @public\n * @example\n *  listOutbreaks(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listOutbreaks(callback) {\n    return state => {\n        const { apiUrl, access_token } = state.configuration;\n\n        return axios({\n            method: 'GET',\n            baseURL: apiUrl,\n            url: '/outbreaks',\n            params: {\n                access_token,\n            },\n        })\n            .then(response => {\n                const nextState = composeNextState(state, response.data);\n                if (callback) return callback(nextState);\n                return nextState;\n            })\n            .catch(error => {\n                return error;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get one or multiple reference data from a query filter\n * @public\n * @example\n *  getReferenceData({\"where\":{\"categoryId\": \"LNG_REFERENCE_DATA_CATEGORY_CENTRE_NAME\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getReferenceData(query: object, callback: Function): Operation;",
    "completion": "import {\n    composeNextState,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Get one or multiple reference data from a query filter\n * @public\n * @example\n *  getReferenceData({\"where\":{\"categoryId\": \"LNG_REFERENCE_DATA_CATEGORY_CENTRE_NAME\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getReferenceData(query, callback) {\n    return state => {\n        const { apiUrl, access_token } = state.configuration;\n\n        const filter = JSON.stringify(query);\n\n        return axios({\n            method: 'GET',\n            baseURL: apiUrl,\n            url: '/reference-data',\n            params: {\n                filter,\n                access_token,\n            },\n        })\n            .then(response => {\n                const nextState = composeNextState(state, response.data);\n                if (callback) return callback(nextState);\n                return nextState;\n            })\n            .catch(error => {\n                return error;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Fetch the list of contacts within a particular outbreak using its ID.\n * @public\n * @example\n *  listContacts(\"343d-dc3e\", // Outbreak Id\n *    state => {\n *       console.log(state);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listContacts(id: string, callback: Function): Operation;",
    "completion": "import {\n  composeNextState,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Fetch the list of contacts within a particular outbreak using its ID.\n * @public\n * @example\n *  listContacts(\"343d-dc3e\", // Outbreak Id\n *    state => {\n *       console.log(state);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listContacts(id, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: `/outbreaks/${id}/contacts`,\n      params: {\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get one or multiple locations from a query filter\n * @public\n * @example\n *  getLocation({\"where\":{\"name\": \"30 DE OCTUBRE\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLocation(query: object, callback: Function): Operation;",
    "completion": "import {\n    composeNextState,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Get one or multiple locations from a query filter\n * @public\n * @example\n *  getLocation({\"where\":{\"name\": \"30 DE OCTUBRE\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLocation(query, callback) {\n    return state => {\n        const { apiUrl, access_token } = state.configuration;\n\n        const filter = JSON.stringify(query);\n\n        return axios({\n            method: 'GET',\n            baseURL: apiUrl,\n            url: '/locations',\n            params: {\n                filter,\n                access_token,\n            },\n        })\n            .then(response => {\n                const nextState = composeNextState(state, response.data);\n                if (callback) return callback(nextState);\n                return nextState;\n            })\n            .catch(error => {\n                return error;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Fetch the list of cases within a particular outbreak using its ID.\n * @public\n * @example\n *  listCases(\"343d-dc3e\", state => {\n *    console.log(state);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listCases(id: string, callback: Function): Operation;",
    "completion": "import {\n    composeNextState,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Fetch the list of cases within a particular outbreak using its ID.\n * @public\n * @example\n *  listCases(\"343d-dc3e\", state => {\n *    console.log(state);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listCases(id, callback) {\n    return state => {\n        const { apiUrl, access_token } = state.configuration;\n\n        return axios({\n            method: 'GET',\n            baseURL: apiUrl,\n            url: `/outbreaks/${id}/cases`,\n            params: {\n                access_token,\n            },\n        })\n            .then(response => {\n                const nextState = composeNextState(state, response.data);\n                if (callback) return callback(nextState);\n                return nextState;\n            })\n            .catch(error => {\n                return error;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Upsert reference data to godata\n * @public\n * @example\n *  upsertReferenceData('id', {...})\n * @function\n * @param {string} externalId - External Id to match\n * @param {object} goDataReferenceData - an object with some reference data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertReferenceData(externalId: string, goDataReferenceData: object, callback: Function): Operation;",
    "completion": "import {\n    composeNextState,\n    expandReferences,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Upsert reference data to godata\n * @public\n * @example\n *  upsertReferenceData('id', {...})\n * @function\n * @param {string} externalId - External Id to match\n * @param {object} goDataReferenceData - an object with some reference data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertReferenceData(externalId, goDataReferenceData, callback) {\n    return state => {\n        const { apiUrl, access_token } = state.configuration;\n\n        const data = expandReferences(goDataReferenceData)(state);\n\n        const query = { where: {} };\n        query.where[externalId] = data[externalId];\n\n        const filter = JSON.stringify(query);\n\n        return axios({\n            method: 'GET',\n            baseURL: apiUrl,\n            url: '/reference-data',\n            params: {\n                filter,\n                access_token,\n            },\n        })\n            .then(response => {\n                if (response.data.length > 1) {\n                    console.log(\n                        response.data.length,\n                        'reference data found; aborting upsert.'\n                    );\n                    return response;\n                } else if (response.data.length === 1) {\n                    console.log('Reference data found. Performing update.');\n                    const referenceDataId = response.data[0].id;\n                    console.log('referenceDataId', referenceDataId);\n                    return axios({\n                        method: 'PUT',\n                        baseURL: apiUrl,\n                        url: `/reference-data/${referenceDataId}`,\n                        params: {\n                            access_token,\n                        },\n                        data,\n                    })\n                        .then(response => {\n                            const nextState = composeNextState(state, response.data);\n                            if (callback) return callback(nextState);\n                            return nextState;\n                        })\n                        .catch(error => {\n                            return error;\n                        });\n                } else {\n                    console.log('No reference data found. Performing create.');\n                    return axios({\n                        method: 'POST',\n                        baseURL: apiUrl,\n                        url: '/reference-data',\n                        params: {\n                            access_token,\n                        },\n                        data,\n                    })\n                        .then(response => {\n                            const nextState = composeNextState(state, response.data);\n                            if (callback) return callback(nextState);\n                            return nextState;\n                        })\n                        .catch(error => {\n                            return error;\n                        });\n                }\n            })\n            .catch(error => {\n                return error;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Fetch the list of reference data\n * @public\n * @example\n *  listReferenceData(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listReferenceData(callback: Function): Operation;",
    "completion": "import {\n    composeNextState,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Fetch the list of reference data\n * @public\n * @example\n *  listReferenceData(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listReferenceData(callback) {\n    return state => {\n        const { apiUrl, access_token } = state.configuration;\n\n        return axios({\n            method: 'GET',\n            baseURL: apiUrl,\n            url: '/reference-data',\n            params: {\n                access_token,\n            },\n        })\n            .then(response => {\n                const nextState = composeNextState(state, response.data);\n                if (callback) return callback(nextState);\n                return nextState;\n            })\n            .catch(error => {\n                return error;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get one or multiple outbreaks from a query filter\n * @public\n * @example\n *  getOutbreak({\"where\":{\"name\": \"Outbreak demo\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getOutbreak(query: object, callback: Function): Operation;",
    "completion": "import {\n    composeNextState,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Get one or multiple outbreaks from a query filter\n * @public\n * @example\n *  getOutbreak({\"where\":{\"name\": \"Outbreak demo\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getOutbreak(query, callback) {\n    return state => {\n        const { apiUrl, access_token } = state.configuration;\n\n        const filter = JSON.stringify(query);\n\n        return axios({\n            method: 'GET',\n            baseURL: apiUrl,\n            url: '/outbreaks',\n            params: {\n                filter,\n                access_token,\n            },\n        })\n            .then(response => {\n                const nextState = composeNextState(state, response.data);\n                if (callback) return callback(nextState);\n                return nextState;\n            })\n            .catch(error => {\n                return error;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get one or multiple cases within an outbreak from a query filter\n * @public\n * @example\n * getCase(\n *    '3b55-cdf4',\n *    { 'where.relationship': { active: true }, where: { firstName: 'Luca'} },\n *    state => {\n *      console.log(state);\n *      return state;\n *    }\n * );\n * @function\n * @param {string} id - Outbreak id\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getCase(id: string, query: object, callback: Function): Operation;",
    "completion": "import {\n    composeNextState,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Get one or multiple cases within an outbreak from a query filter\n * @public\n * @example\n * getCase(\n *    '3b55-cdf4',\n *    { 'where.relationship': { active: true }, where: { firstName: 'Luca'} },\n *    state => {\n *      console.log(state);\n *      return state;\n *    }\n * );\n * @function\n * @param {string} id - Outbreak id\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getCase(id, query, callback) {\n    return state => {\n        const { apiUrl, access_token } = state.configuration;\n\n        const filter = JSON.stringify(query);\n\n        return axios({\n            baseURL: apiUrl,\n            url: `/outbreaks/${id}/cases`,\n            method: 'GET',\n            params: {\n                filter,\n                access_token,\n            },\n        })\n            .then(response => {\n                const nextState = composeNextState(state, response.data);\n                if (callback) return callback(nextState);\n                return nextState;\n            })\n            .catch(error => {\n                return error;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Upsert contact to godata using an external id to match a specific record.\n * @public\n * @example\n *  upsertContact(\"4dce-3eedce3-rd33\", 'visualId',\n *    {\n *      firstName: 'Luca',\n *      gender: 'male',\n *      'age:years': '20'\n *      ...\n *    }\n *  )\n * @function\n * @param {string} id - Outbreak id\n * @param {string} externalId - External Id to match\n * @param {object} goDataContact - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertContact(id: string, externalId: string, goDataContact: object, callback: Function): Operation;",
    "completion": "import {\n    composeNextState,\n    expandReferences,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Upsert contact to godata using an external id to match a specific record.\n * @public\n * @example\n *  upsertContact(\"4dce-3eedce3-rd33\", 'visualId',\n *    {\n *      firstName: 'Luca',\n *      gender: 'male',\n *      'age:years': '20'\n *      ...\n *    }\n *  )\n * @function\n * @param {string} id - Outbreak id\n * @param {string} externalId - External Id to match\n * @param {object} goDataContact - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertContact(id, externalId, goDataContact, callback) {\n    return state => {\n        const { apiUrl, access_token } = state.configuration;\n\n        const data = expandReferences(goDataContact)(state);\n\n        const query = { where: {} };\n        query.where[externalId] = data[externalId];\n\n        const filter = JSON.stringify(query);\n\n        return axios({\n            baseURL: apiUrl,\n            url: `/outbreaks/${id}/contacts`,\n            method: 'GET',\n            params: {\n                filter,\n                access_token,\n            },\n        })\n            .then(response => {\n                if (response.data.length > 1) {\n                    console.log('Multiple contacts found. Aborting upsert.');\n                    console.log(response.data.length, 'contacts');\n                } else if (response.data.length === 1) {\n                    console.log('Contact found. Performing update.');\n                    const contactId = response.data[0].id;\n                    return axios({\n                        method: 'PUT',\n                        baseURL: apiUrl,\n                        url: `/outbreaks/${id}/contacts/${contactId}`,\n                        params: {\n                            access_token,\n                        },\n                        data,\n                    })\n                        .then(response => {\n                            const nextState = composeNextState(state, response.data);\n                            if (callback) return callback(nextState);\n                            return nextState;\n                        })\n                        .catch(error => {\n                            return error;\n                        });\n                } else {\n                    console.log('No contact found. Performing create.');\n                    return axios({\n                        method: 'POST',\n                        baseURL: apiUrl,\n                        url: `/outbreaks/${id}/contacts/`,\n                        params: {\n                            access_token,\n                        },\n                        data,\n                    })\n                        .then(response => {\n                            const nextState = composeNextState(state, response.data);\n                            if (callback) return callback(nextState);\n                            return nextState;\n                        })\n                        .catch(error => {\n                            return error;\n                        });\n                }\n            })\n            .catch(error => {\n                return error;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Upsert case to godata using an external id to mach a specific record\n * @public\n * @example\n *  upsertCase(\"4dce-3eedce3-rd33\", 'visualId',\n *    data: state => {\n *      const patient = state.data.body;\n *       return {\n *         firstName: patient.Patient_name.split(' ')[0],\n *         lastName: patient.Patient_name.split(' ')[1],\n *         visualId: patient.Case_ID,\n *         'age:years': patient.Age_in_year,\n *         gender: patient.Sex,\n *       };\n *  })\n * @function\n * @param {string} id - Outbreak id\n * @param {string} externalId - External Id to match\n * @param {object} goDataCase - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertCase(id: string, externalId: string, goDataCase: object, callback: Function): Operation;",
    "completion": "import {\n    composeNextState,\n    expandReferences,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Upsert case to godata using an external id to mach a specific record\n * @public\n * @example\n *  upsertCase(\"4dce-3eedce3-rd33\", 'visualId',\n *    data: state => {\n *      const patient = state.data.body;\n *       return {\n *         firstName: patient.Patient_name.split(' ')[0],\n *         lastName: patient.Patient_name.split(' ')[1],\n *         visualId: patient.Case_ID,\n *         'age:years': patient.Age_in_year,\n *         gender: patient.Sex,\n *       };\n *  })\n * @function\n * @param {string} id - Outbreak id\n * @param {string} externalId - External Id to match\n * @param {object} goDataCase - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertCase(id, externalId, goDataCase, callback) {\n    return state => {\n        const { apiUrl, access_token } = state.configuration;\n\n        const data = expandReferences(goDataCase)(state);\n\n        const query = { where: {} };\n        query.where[externalId] = data[externalId];\n\n        const filter = JSON.stringify(query);\n\n        return axios({\n            baseURL: apiUrl,\n            url: `/outbreaks/${id}/cases`,\n            method: 'GET',\n            params: {\n                filter,\n                access_token,\n            },\n        })\n            .then(response => {\n                if (response.data.length > 1) {\n                    console.log(response.data.length, 'cases found; aborting upsert.');\n                } else if (response.data.length === 1) {\n                    console.log('Case found. Performing update.');\n                    const caseId = response.data[0].id;\n                    data['id'] = caseId;\n                    delete data.visualId;\n                    return axios({\n                        method: 'PUT',\n                        baseURL: apiUrl,\n                        url: `/outbreaks/${id}/cases/${caseId}`,\n                        params: {\n                            access_token,\n                        },\n                        data,\n                    })\n                        .then(response => {\n                            const nextState = composeNextState(state, response.data);\n                            if (callback) return callback(nextState);\n                            return nextState;\n                        })\n                        .catch(error => {\n                            return error;\n                        });\n                } else {\n                    console.log('No case found. Performing create.');\n                    return axios({\n                        method: 'POST',\n                        baseURL: apiUrl,\n                        url: `/outbreaks/${id}/cases/`,\n                        params: {\n                            access_token,\n                        },\n                        data,\n                    })\n                        .then(response => {\n                            const nextState = composeNextState(state, response.data);\n                            if (callback) return callback(nextState);\n                            return nextState;\n                        })\n                        .catch(error => {\n                            return error;\n                        });\n                }\n            })\n            .catch(error => {\n                return error;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get one or multiple contacts within an outbreak from a query filter\n * @public\n * @example\n *  getContact(\"343d-dc3e\", {\"where\":{\"firstName\": \"Luca\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getContact(id: string, query: object, callback: Function): Operation;",
    "completion": "import {\n    composeNextState,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Get one or multiple contacts within an outbreak from a query filter\n * @public\n * @example\n *  getContact(\"343d-dc3e\", {\"where\":{\"firstName\": \"Luca\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getContact(id, query, callback) {\n    return state => {\n        const { apiUrl, access_token } = state.configuration;\n\n        const filter = JSON.stringify(query);\n\n        return axios({\n            baseURL: apiUrl,\n            url: `/outbreaks/${id}/contacts`,\n            method: 'GET',\n            params: {\n                filter,\n                access_token,\n            },\n        })\n            .then(response => {\n                const nextState = composeNextState(state, response.data);\n                if (callback) return callback(nextState);\n                return nextState;\n            })\n            .catch(error => {\n                return error;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Fetch the list of locations\n * @public\n * @example\n *  listLocations(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listLocations(callback: Function): Operation;",
    "completion": "import {\n    composeNextState,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Fetch the list of locations\n * @public\n * @example\n *  listLocations(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listLocations(callback) {\n    return state => {\n        const { apiUrl, access_token } = state.configuration;\n\n        return axios({\n            method: 'GET',\n            baseURL: apiUrl,\n            url: '/locations',\n            params: {\n                access_token,\n            },\n        })\n            .then(response => {\n                const nextState = composeNextState(state, response.data);\n                if (callback) return callback(nextState);\n                return nextState;\n            })\n            .catch(error => {\n                return error;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Upsert outbreak to godata\n * @public\n * @example\n *  upsertOutbreak({externalId: \"3dec33-ede3\", data: {...}})\n * @function\n * @param {object} outbreak - an object with an externalId and some outbreak data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertOutbreak(outbreak: object, callback: Function): Operation;",
    "completion": "import {\n    composeNextState,\n    expandReferences,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Upsert outbreak to godata\n * @public\n * @example\n *  upsertOutbreak({externalId: \"3dec33-ede3\", data: {...}})\n * @function\n * @param {object} outbreak - an object with an externalId and some outbreak data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertOutbreak(outbreak, callback) {\n    return state => {\n        const { apiUrl, access_token } = state.configuration;\n\n        const { externalId, data } = expandReferences(outbreak)(state);\n\n        const filter = JSON.stringify({ where: { id: externalId } });\n\n        return axios({\n            method: 'GET',\n            baseURL: apiUrl,\n            url: '/outbreaks',\n            params: {\n                filter,\n                access_token,\n            },\n        })\n            .then(response => {\n                if (response.data.length > 0) {\n                    console.log('Outbreak found. Performing update.');\n                    const outbreakId = response.data[0].id;\n                    return axios({\n                        method: 'PUT',\n                        baseURL: apiUrl,\n                        url: `/outbreaks/${outbreakId}`,\n                        params: {\n                            access_token,\n                        },\n                        data,\n                    })\n                        .then(response => {\n                            const nextState = composeNextState(state, response.data);\n                            if (callback) return callback(nextState);\n                            return nextState;\n                        })\n                        .catch(error => {\n                            return error;\n                        });\n                } else {\n                    console.log('No outbreak found. Performing create.');\n                    return axios({\n                        method: 'POST',\n                        baseURL: apiUrl,\n                        url: '/outbreaks',\n                        params: {\n                            access_token,\n                        },\n                        data,\n                    })\n                        .then(response => {\n                            const nextState = composeNextState(state, response.data);\n                            if (callback) return callback(nextState);\n                            return nextState;\n                        })\n                        .catch(error => {\n                            return error;\n                        });\n                }\n            })\n            .catch(error => {\n                return error;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Upsert location to godata\n * @public\n * @example\n *  upsertLocation('name', {...})\n * @function\n * @param {string} externalId - External Id to match\n * @param {object} goDataLocation - an object with some location data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertLocation(externalId: string, goDataLocation: object, callback: Function): Operation;",
    "completion": "import {\n    composeNextState,\n    expandReferences,\n} from '@openfn/language-common';\nimport axios from 'axios';\n\n/**\n * Upsert location to godata\n * @public\n * @example\n *  upsertLocation('name', {...})\n * @function\n * @param {string} externalId - External Id to match\n * @param {object} goDataLocation - an object with some location data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertLocation(externalId, goDataLocation, callback) {\n    return state => {\n        const { apiUrl, access_token } = state.configuration;\n\n        const data = expandReferences(goDataLocation)(state);\n\n        const query = { where: {} };\n        query.where[externalId] = data[externalId];\n\n        const filter = JSON.stringify(query);\n\n        return axios({\n            method: 'GET',\n            baseURL: apiUrl,\n            url: '/locations',\n            params: {\n                filter,\n                access_token,\n            },\n        })\n            .then(response => {\n                if (response.data.length > 1) {\n                    console.log(\n                        response.data.length,\n                        'locations found; aborting upsert.'\n                    );\n                    return response;\n                } else if (response.data.length === 1) {\n                    console.log('Location found. Performing update.');\n                    const locationId = response.data[0].id;\n                    return axios({\n                        method: 'PUT',\n                        baseURL: apiUrl,\n                        url: `/locations/${locationId}`,\n                        params: {\n                            access_token,\n                        },\n                        data,\n                    })\n                        .then(response => {\n                            const nextState = composeNextState(state, response.data);\n                            if (callback) return callback(nextState);\n                            return nextState;\n                        })\n                        .catch(error => {\n                            return error;\n                        });\n                } else {\n                    console.log('No location found. Performing create.');\n                    return axios({\n                        method: 'POST',\n                        baseURL: apiUrl,\n                        url: '/locations',\n                        params: {\n                            access_token,\n                        },\n                        data,\n                    })\n                        .then(response => {\n                            const nextState = composeNextState(state, response.data);\n                            if (callback) return callback(nextState);\n                            return nextState;\n                        })\n                        .catch(error => {\n                            return error;\n                        });\n                }\n            })\n            .catch(error => {\n                return error;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Create an entity.\n * @function\n * @param {Object} params - Parameters including entityName and body.\n * @returns {Operation}\n */\nexport function createEntity(params: any): (state: any) => Promise<any>;",
    "completion": "import { expandReferences } from '@openfn/language-common';\nimport { request } from 'request';\n\n/**\n * Create an entity.\n * @function\n * @param {Object} params - Parameters including entityName and body.\n * @returns {Operation}\n */\nexport function createEntity(params) {\n    return state => {\n        function assembleError({ response, error }) {\n            if (response && [200, 201, 202, 204].indexOf(response.statusCode) > -1)\n                return false;\n            if (error) return error;\n            return new Error(`Server responded with ${response.statusCode}`);\n        }\n\n        const { resource, accessToken, apiVersion } = state.configuration;\n\n        const { entityName, body } = expandReferences(params)(state);\n\n        const url = `${resource}/api/data/v${apiVersion}/${entityName}`;\n\n        const headers = {\n            'OData-MaxVersion': '4.0',\n            'OData-Version': '4.0',\n            'Content-Type': 'application/json',\n            Authorization: accessToken,\n        };\n\n        console.log('Posting to url: ' + url);\n        console.log('With body: ' + JSON.stringify(body, null, 2));\n\n        return new Promise((resolve, reject) => {\n            request.post(\n                {\n                    url: url,\n                    json: body,\n                    headers,\n                },\n                function (err, response) {\n                    const error = assembleError({ error: err, response });\n                    if (error) {\n                        reject(error);\n                    } else {\n                        console.log('Create entity succeeded.');\n                        resolve(response);\n                    }\n                }\n            );\n        }).then(data => {\n            const nextState = {\n                ...state,\n                response: { statusCode: data.statusCode, body: data.body },\n            };\n            return nextState;\n        });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get deployment information for a specific form\n * @example\n * getDeploymentInfo({formId: 'aXecHjmbATuF6iGFmvBLBX'}, state => {\n *   console.log(state.data);\n *   return state;\n * });\n * @function\n * @param {object} params - Form Id and data to make the fetch or filter\n * @param {function} callback - (Optional) Callback function to execute after fetching form deployment information\n * @returns {Operation}\n */\nexport function getDeploymentInfo(params: object, callback: Function): Operation;",
    "completion": "import {\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n\n/**\n * Get deployment information for a specific form\n * @example\n * getDeploymentInfo({formId: 'aXecHjmbATuF6iGFmvBLBX'}, state => {\n *   console.log(state.data);\n *   return state;\n * });\n * @function\n * @param {object} params - Form Id and data to make the fetch or filter\n * @param {function} callback - (Optional) Callback function to execute after fetching form deployment information\n * @returns {Operation}\n */\nexport function getDeploymentInfo(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { baseURL, apiVersion, username, password } = state.configuration;\n    const { formId } = resolvedParams;\n\n    const url = `${baseURL}/api/${apiVersion}/assets/${formId}/deployment/?format=json`;\n    const auth = { username, password };\n\n    const config = {\n      url,\n      params: resolvedParams.query,\n      auth,\n    };\n\n    return http\n      .get(config)(state)\n      .then(response => {\n        console.log('\u2713', 'deployment information fetched.');\n\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get submissions for a specific form\n * @example\n * getSubmissions({formId: 'aXecHjmbATuF6iGFmvBLBX'}, state => {\n *   console.log(state.data);\n *   return state;\n * });\n * @function\n * @param {object} params - Form Id and data to make the fetch or filter\n * @param {function} callback - (Optional) Callback function to execute after fetching form submissions\n * @returns {Operation}\n */\nexport function getSubmissions(params: object, callback: Function): Operation;",
    "completion": "import {\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n\n/**\n * Get submissions for a specific form\n * @example\n * getSubmissions({formId: 'aXecHjmbATuF6iGFmvBLBX'}, state => {\n *   console.log(state.data);\n *   return state;\n * });\n * @function\n * @param {object} params - Form Id and data to make the fetch or filter\n * @param {function} callback - (Optional) Callback function to execute after fetching form submissions\n * @returns {Operation}\n */\nexport function getSubmissions(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { baseURL, apiVersion, username, password } = state.configuration;\n    const { formId } = resolvedParams;\n\n    const url = `${baseURL}/api/${apiVersion}/assets/${formId}/data/?format=json`;\n    const auth = { username, password };\n\n    const config = {\n      url,\n      params: resolvedParams.query,\n      auth,\n    };\n\n    return http\n      .get(config)(state)\n      .then(response => {\n        console.log('\u2713', response.data.count, 'submissions fetched.');\n\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Make a request to get the list of forms\n * @public\n * @example\n * getForms({}, state => {\n *    console.log(state.data);\n *    return state;\n * });\n * @function\n * @param {object} params - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function to execute after fetching form list\n * @returns {Operation}\n */\nexport function getForms(params: object, callback: Function): Operation;",
    "completion": "import {\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n\n/**\n * Make a request to get the list of forms\n * @public\n * @example\n * getForms({}, state => {\n *    console.log(state.data);\n *    return state;\n * });\n * @function\n * @param {object} params - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function to execute after fetching form list\n * @returns {Operation}\n */\nexport function getForms(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { baseURL, apiVersion, username, password } = state.configuration;\n\n    const url = `${baseURL}/api/${apiVersion}/assets/?format=json`;\n    const auth = { username, password };\n\n    const config = {\n      url,\n      params: resolvedParams,\n      auth,\n    };\n\n    return http\n      .get(config)(state)\n      .then(response => {\n        console.log('\u2713', response.data.count, 'forms fetched.');\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for telerivet.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "completion": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for telerivet.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Send a message on telerivet\n * @example\n * execute(\n *   send(data)\n * )(state)\n * @function\n * @param {object} sendData - Payload data for the message\n * @returns {Operation}\n */\nexport function send(sendData: object): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport request from 'superagent';\n\n/**\n * Send a message on telerivet\n * @example\n * execute(\n *   send(data)\n * )(state)\n * @function\n * @param {object} sendData - Payload data for the message\n * @returns {Operation}\n */\nexport function send(sendData) {\n  return state => {\n    const body = expandReferences(sendData)(state);\n\n    const { projectId, apiKey } = state.configuration;\n\n    const url = 'https://api.telerivet.com/v1/projects/'.concat(\n      projectId,\n      '/messages/send'\n    );\n\n    console.log(url);\n    console.log('Posting message to send:');\n    console.log(body);\n\n    return new Promise((resolve, reject) => {\n      request\n        .post(url)\n        .type('json')\n        .accept('json')\n        .auth(apiKey)\n        .send(JSON.stringify(body))\n        .end((error, res) => {\n          if (!!error || !res.ok) {\n            reject(error);\n          }\n          resolve(res);\n        });\n    }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * To add a row data to a database table\n * @example\n * addRow(\n * 'testing_openfn',\n * 'Customers',\n * fields(field('Subject', dataValue('formId')), field('Status', 'Closed'))\n * );\n * @function\n * @param {string} db - Database\n * @param {string} table - Database table\n * @param {object} rowData - row data to be added into the database\n * @returns {Operation}\n */\nexport function addRow(db: string, table: string, rowData: object): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\n\n/**\n * To add a row data to a database table\n * @example\n * addRow(\n * 'testing_openfn',\n * 'Customers',\n * fields(field('Subject', dataValue('formId')), field('Status', 'Closed'))\n * );\n * @function\n * @param {string} db - Database\n * @param {string} table - Database table\n * @param {object} rowData - row data to be added into the database\n * @returns {Operation}\n */\nexport function addRow(db, table, rowData) {\n  return state => {\n    const action = 'ADDROW';\n    const body = expandReferences(rowData)(state);\n\n    const { account, authToken, apiVersion } = state.configuration;\n\n    const url = `https://reportsapi.zoho.com/api/`.concat(\n      account,\n      '/',\n      db,\n      '/',\n      table\n    );\n\n    console.log('POST URL:');\n    console.log(url);\n    console.log('POST Parameters:');\n    console.log(body);\n\n    return new Promise((resolve, reject) => {\n      request\n        .post(url)\n        .type('form')\n        .query({\n          ZOHO_ACTION: action,\n          ZOHO_OUTPUT_FORMAT: 'JSON',\n          ZOHO_ERROR_FORMAT: 'JSON',\n          authtoken: authToken,\n          ZOHO_API_VERSION: apiVersion,\n        })\n        .send(body)\n        .end((error, res) => {\n          if (!!error || !res.ok) {\n            reject(error);\n          }\n\n          resolve(res);\n        });\n    }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Make a POST request with a certificate\n * @public\n * @example\n * postData({\n *  url: urlDTP,\n *  body: obj,\n *  headers: {\n *    'Ocp-Apim-Subscription-Key': configuration['Ocp-Apim-Subscription-Key'],\n *  },\n *  agentOptions: {\n *    key,\n *    cert,\n *  },\n * }, callback)(state)\n * @function\n * @param {object} params - Url, Headers and Body parameters\n * @param {function} callback - (Optional) A callback function\n * @returns {Operation}\n */\nexport function postData(params: object, callback: Function): Operation;",
    "completion": "import {\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n\n/**\n * Make a POST request with a certificate\n * @public\n * @example\n * postData({\n *  url: urlDTP,\n *  body: obj,\n *  headers: {\n *    'Ocp-Apim-Subscription-Key': configuration['Ocp-Apim-Subscription-Key'],\n *  },\n *  agentOptions: {\n *    key,\n *    cert,\n *  },\n * }, callback)(state)\n * @function\n * @param {object} params - Url, Headers and Body parameters\n * @param {function} callback - (Optional) A callback function\n * @returns {Operation}\n */\nexport function postData(params, callback) {\n  return state => {\n    const { url, body, headers, agentOptions } = expandReferences(params)(\n      state\n    );\n\n    return http\n      .post({\n        method: 'post',\n        url,\n        data: body,\n        headers,\n        agentOptions,\n      })(state)\n      .then(response => {\n        console.log('POST succeeded.');\n\n        const nextState = composeNextState(state, response);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        console.log(error);\n        return error;\n      });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "completion": "import {\n  execute as commonExecute,\n} from '@openfn/language-common';\nimport {\n  normalizeOauthConfig,\n} from '@openfn/language-common/util';\n\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n      configuration: normalizeOauthConfig(state.configuration),\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Create some resource in Google Cloud Healthcare\n * @public\n * @example\n * createFhirResource(\n *   {\n *     cloudRegion: \"us-central1\",\n *     projectId: \"adjective-noun-123\",\n *     datasetId: \"my-dataset\",\n *     fhirStoreId: \"my-fhir-store\",\n *   },\n *   {\n *     resourceType: \"Patient\",\n *     name: [{ use: \"official\", family: \"Smith\", given: [\"Darcy\"] }],\n *     gender: \"female\",\n *     birthDate: \"1970-01-01\",\n *   }\n * );\n * @example\n * createFhirResource(\n *   {\n *     cloudRegion: \"us-central1\",\n *     projectId: \"adjective-noun-123\",\n *     datasetId: \"my-dataset\",\n *     fhirStoreId: \"my-fhir-store\",\n *   },\n *   (state) => ({\n *     resourceType: \"Encounter\",\n *     status: \"finished\",\n *     class: {\n *       system: \"http://hl7.org/fhir/v3/ActCode\",\n *       code: \"IMP\",\n *       display: \"inpatient encounter\",\n *     },\n *     reasonCode: [\n *       {\n *         text: \"The patient had an abnormal heart rate. She was concerned about this.\",\n *       },\n *     ],\n *     subject: {\n *       reference: `Patient/${state.data.id}`,\n *     },\n *   })\n * );\n *\n * @function\n * @param {{cloudRegion: string, projectId: string, datasetId: string, fhirStoreId: string}} [fhirStore] - The FHIR store information.\n *    - `cloudRegion` (string): The cloud region where the FHIR store is located.\n *    - `projectId` (string): The ID of the project that contains the FHIR store.\n *    - `datasetId` (string): The ID of the dataset that contains the FHIR store.\n *    - `fhirStoreId` (string): The ID of the FHIR store.\n * @param {object} resource - The FHIR resource data to be created\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createFhirResource(fhirStore?: {\n    cloudRegion: string;\n    projectId: string;\n    datasetId: string;\n    fhirStoreId: string;\n}, resource: object, callback: Function): Operation;",
    "completion": "import {\n  composeNextState,\n} from '@openfn/language-common';\nimport {\n  expandReferences\n} from '@openfn/language-common/util';\n\n\nexport function buildUrl({\n  apiVersion,\n  projectId,\n  cloudRegion,\n  datasetId,\n  fhirStoreId,\n  resourceType,\n}) {\n  const setApiVersion = apiVersion ? apiVersion : 'v1';\n  const baseUrl = `https://healthcare.googleapis.com/${setApiVersion}`;\n\n  return `${baseUrl}/projects/${projectId}/locations/${cloudRegion}/datasets/${datasetId}/fhirStores/${fhirStoreId}/fhir/${resourceType}`;\n}\n\nexport const request = async (url, params = {}, method = 'GET') => {\n  const { auth } = params;\n  delete params.auth;\n\n  const options = {\n    method,\n    body: JSON.stringify(params),\n    headers: {\n      'Content-Type': 'application/fhir+json',\n      Authorization: `Bearer ${auth.accessToken}`,\n    },\n  };\n\n  if (method == 'GET') delete options.body;\n\n  const resolvedUrl =\n    method == 'GET' ? `${url}?${new URLSearchParams(params).toString()}` : url;\n\n  const response = await fetch(resolvedUrl, options);\n  const data = await response.json();\n\n  handleResponseError(response, data, method);\n\n  return data;\n};\n\n/**\n * Create some resource in Google Cloud Healthcare\n * @public\n * @example\n * createFhirResource(\n *   {\n *     cloudRegion: \"us-central1\",\n *     projectId: \"adjective-noun-123\",\n *     datasetId: \"my-dataset\",\n *     fhirStoreId: \"my-fhir-store\",\n *   },\n *   {\n *     resourceType: \"Patient\",\n *     name: [{ use: \"official\", family: \"Smith\", given: [\"Darcy\"] }],\n *     gender: \"female\",\n *     birthDate: \"1970-01-01\",\n *   }\n * );\n * @example\n * createFhirResource(\n *   {\n *     cloudRegion: \"us-central1\",\n *     projectId: \"adjective-noun-123\",\n *     datasetId: \"my-dataset\",\n *     fhirStoreId: \"my-fhir-store\",\n *   },\n *   (state) => ({\n *     resourceType: \"Encounter\",\n *     status: \"finished\",\n *     class: {\n *       system: \"http://hl7.org/fhir/v3/ActCode\",\n *       code: \"IMP\",\n *       display: \"inpatient encounter\",\n *     },\n *     reasonCode: [\n *       {\n *         text: \"The patient had an abnormal heart rate. She was concerned about this.\",\n *       },\n *     ],\n *     subject: {\n *       reference: `Patient/${state.data.id}`,\n *     },\n *   })\n * );\n *\n * @function\n * @param {{cloudRegion: string, projectId: string, datasetId: string, fhirStoreId: string}} [fhirStore] - The FHIR store information.\n *    - `cloudRegion` (string): The cloud region where the FHIR store is located.\n *    - `projectId` (string): The ID of the project that contains the FHIR store.\n *    - `datasetId` (string): The ID of the dataset that contains the FHIR store.\n *    - `fhirStoreId` (string): The ID of the FHIR store.\n * @param {object} resource - The FHIR resource data to be created\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createFhirResource(fhirStore, resource, callback) {\n  return async state => {\n    const { apiVersion, accessToken } = state.configuration;\n\n    const [resolvedFhirStore, resolvedResource] = expandReferences(\n      state,\n      fhirStore,\n      resource\n    );\n    const { resourceType } = resolvedResource;\n    const { cloudRegion, projectId, datasetId, fhirStoreId } =\n      resolvedFhirStore;\n\n    const requiredKeys = [\n      'cloudRegion',\n      'projectId',\n      'datasetId',\n      'fhirStoreId',\n    ];\n\n    const missingKeys = requiredKeys.filter(key => !(key in resolvedFhirStore));\n\n    if (missingKeys.length > 0) {\n      throw new Error(`Missing key(s) in fhirStore: ${missingKeys.join(', ')}`);\n    }\n\n    const url = buildUrl({\n      apiVersion,\n      projectId,\n      cloudRegion,\n      datasetId,\n      fhirStoreId,\n      resourceType,\n    });\n\n    const payload = {\n      auth: { accessToken },\n      ...resolvedResource,\n    };\n\n    return request(url, payload, 'POST').then(response => {\n      console.log(\n        `Created FHIR ${resourceType} resource with ID ${response.id}`\n      );\n      const nextState = {\n        ...composeNextState(state, response),\n        response,\n      };\n      if (callback) return callback(nextState);\n      return nextState;\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get locations from Primero\n *\n * Use this function to get a paginated list of all locations that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1).\n * Another parameter is `hierarchy: true` (Defaults to false)\n * @public\n * @example <caption>Get loocations from Primero with query parameters</caption>\n * getLocations({\n *   page: 1,\n *   per: 20\n * })\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLocations(query: object, callback: Function): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport request from 'request';\n\nexport function scrubResponse(response) {\n  if (response) response.request.headers.Authorization = '--REDACTED--';\n\n  return response;\n}\n\nexport function assembleError({ response, error, params }) {\n  if (response) {\n    const customCodes = params.options && params.options.successCodes;\n    if ((customCodes || [200, 201, 202, 204]).indexOf(response.statusCode) > -1)\n      return false;\n  }\n\n  if (error) return error;\n\n  return new Error(\n    `Server responded with:\\n${JSON.stringify(response, null, 2)}`\n  );\n}\n\nexport function tryJson(data) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return { body: data };\n  }\n}\n\nconst composeNextState = (state, data, meta) => {\n  const nextState = {\n    ...state,\n    data,\n    references: [...state.references, state.data],\n  };\n\n  if (meta) {\n    return { ...nextState, metadata: meta };\n  }\n  return nextState;\n};\n\n/**\n * Get locations from Primero\n *\n * Use this function to get a paginated list of all locations that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1).\n * Another parameter is `hierarchy: true` (Defaults to false)\n * @public\n * @example <caption>Get loocations from Primero with query parameters</caption>\n * getLocations({\n *   page: 1,\n *   per: 20\n * })\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLocations(query, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const expandedQuery = expandReferences(query)(state);\n\n    const params = {\n      method: 'GET',\n      url: `${url}/api/v2/locations`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs: expandedQuery,\n    };\n\n    return new Promise((resolve, reject) => {\n      request(params, async function (err, resp, body) {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          console.log(\n            `Primero says: '${response.statusCode} ${response.statusMessage}'`\n          );\n          const resp = tryJson(body);\n          const locations = resp.data;\n          console.log(\n            `${locations.length\n            } locations retrieved from request: ${JSON.stringify(\n              response.request,\n              null,\n              2\n            )}`\n          );\n\n          const nextState = composeNextState(state, locations);\n          if (callback) resolve(callback(nextState));\n          resolve(nextState);\n        }\n      });\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Create referrals in Primero\n *\n * Use this function to bulk refer to one or multiple cases from Primero to a single user\n * @public\n * @example <caption>Create referrals for multiple cases in Primero</caption>\n * createReferrals({\n *   data: {\n *     ids: [\n *       \"749e9c6e-60db-45ec-8f5a-69da7c223a79\",\n *       \"dcea6052-07d9-4cfa-9abf-9a36987cdd25\",\n *     ],\n *     transitioned_to: \"primero_cp\",\n *     notes: \"This is a bulk referral\",\n *   },\n * });\n * @function\n * @param {object} params - an object with referral data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function createReferrals(params: object, callback: Function): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport request from 'request';\n\nexport function scrubResponse(response) {\n  if (response) response.request.headers.Authorization = '--REDACTED--';\n\n  return response;\n}\n\nexport function assembleError({ response, error, params }) {\n  if (response) {\n    const customCodes = params.options && params.options.successCodes;\n    if ((customCodes || [200, 201, 202, 204]).indexOf(response.statusCode) > -1)\n      return false;\n  }\n\n  if (error) return error;\n\n  return new Error(\n    `Server responded with:\\n${JSON.stringify(response, null, 2)}`\n  );\n}\n\nexport function tryJson(data) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return { body: data };\n  }\n}\n\nconst composeNextState = (state, data, meta) => {\n  const nextState = {\n    ...state,\n    data,\n    references: [...state.references, state.data],\n  };\n\n  if (meta) {\n    return { ...nextState, metadata: meta };\n  }\n  return nextState;\n};\n\n/**\n * Create referrals in Primero\n *\n * Use this function to bulk refer to one or multiple cases from Primero to a single user\n * @public\n * @example <caption>Create referrals for multiple cases in Primero</caption>\n * createReferrals({\n *   data: {\n *     ids: [\n *       \"749e9c6e-60db-45ec-8f5a-69da7c223a79\",\n *       \"dcea6052-07d9-4cfa-9abf-9a36987cdd25\",\n *     ],\n *     transitioned_to: \"primero_cp\",\n *     notes: \"This is a bulk referral\",\n *   },\n * });\n * @function\n * @param {object} params - an object with referral data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function createReferrals(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const { data } = expandReferences(params)(state);\n\n    const requestParams = {\n      method: 'POST',\n      url: `${url}/api/v2/cases/referrals`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n        options: {\n          successCodes: [200, 201, 202, 203, 204],\n        },\n      },\n      json: { data: data },\n    };\n\n    return new Promise((resolve, reject) => {\n      request(requestParams, (err, resp, body) => {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          const resp = tryJson(body);\n          console.log(\n            `Post succeeded: ${response.statusCode} ${response.statusMessage}`\n          );\n          const nextState = composeNextState(state, resp.data.body);\n          if (callback) resolve(callback(nextState));\n          resolve(nextState);\n        }\n      });\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get lookups from Primero\n *\n * Use this function to get a paginated list of all lookups that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1)\n * @public\n * @example <caption>Get lookups from Primero with query parameters</caption>\n * getLookups({\n *   per: 10000,\n *   page: 5\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLookups(query: object, callback: Function): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport request from 'request';\n\nexport function scrubResponse(response) {\n  if (response) response.request.headers.Authorization = '--REDACTED--';\n\n  return response;\n}\n\nexport function assembleError({ response, error, params }) {\n  if (response) {\n    const customCodes = params.options && params.options.successCodes;\n    if ((customCodes || [200, 201, 202, 204]).indexOf(response.statusCode) > -1)\n      return false;\n  }\n\n  if (error) return error;\n\n  return new Error(\n    `Server responded with:\\n${JSON.stringify(response, null, 2)}`\n  );\n}\n\nexport function tryJson(data) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return { body: data };\n  }\n}\n\nconst composeNextState = (state, data, meta) => {\n  const nextState = {\n    ...state,\n    data,\n    references: [...state.references, state.data],\n  };\n\n  if (meta) {\n    return { ...nextState, metadata: meta };\n  }\n  return nextState;\n};\n\n/**\n * Get lookups from Primero\n *\n * Use this function to get a paginated list of all lookups that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1)\n * @public\n * @example <caption>Get lookups from Primero with query parameters</caption>\n * getLookups({\n *   per: 10000,\n *   page: 5\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLookups(query, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const expandedQuery = expandReferences(query)(state);\n\n    const params = {\n      method: 'GET',\n      url: `${url}/api/v2/lookups`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs: expandedQuery,\n    };\n\n    return new Promise((resolve, reject) => {\n      request(params, async function (err, resp, body) {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          console.log(\n            `Primero says: '${response.statusCode} ${response.statusMessage}'`\n          );\n          const resp = tryJson(body);\n          const lookups = resp.data;\n          console.log(\n            `${lookups.length} lookups retrieved from request: ${JSON.stringify(\n              response.request,\n              null,\n              2\n            )}`\n          );\n\n          const nextState = composeNextState(state, lookups);\n          if (callback) resolve(callback(nextState));\n          resolve(nextState);\n        }\n      });\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get cases from Primero\n *\n * Use this function to get cases from Primero based on a set of query parameters.\n * Note that in many implementations, the `remote` attribute should be set to `true` to ensure that only cases marked for remote access will be retrieved.\n * You can specify a `case_id` value to fetch a unique case and a query string to filter result.\n * @public\n * @example <caption> Get cases from Primero with query parameters</caption>\n * getCases({\n *   remote: true,\n *   query: \"sex=male\",\n * });\n * @example <caption>Get case from Primero for a specific case id</caption>\n * getCases({\n *   remote: true,\n *   case_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} query - an object with a query param at minimum, option to getReferrals\n * @param {object} options - (Optional) an object with a getReferrals key to fetch referrals\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getCases(query: object, options: object, callback: Function): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport request from 'request';\n\nexport function scrubResponse(response) {\n  if (response) response.request.headers.Authorization = '--REDACTED--';\n\n  return response;\n}\n\nexport function assembleError({ response, error, params }) {\n  if (response) {\n    const customCodes = params.options && params.options.successCodes;\n    if ((customCodes || [200, 201, 202, 204]).indexOf(response.statusCode) > -1)\n      return false;\n  }\n\n  if (error) return error;\n\n  return new Error(\n    `Server responded with:\\n${JSON.stringify(response, null, 2)}`\n  );\n}\n\nexport function tryJson(data) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return { body: data };\n  }\n}\n\nconst composeNextState = (state, data, meta) => {\n  const nextState = {\n    ...state,\n    data,\n    references: [...state.references, state.data],\n  };\n\n  if (meta) {\n    return { ...nextState, metadata: meta };\n  }\n  return nextState;\n};\n\n/**\n * Get cases from Primero\n *\n * Use this function to get cases from Primero based on a set of query parameters.\n * Note that in many implementations, the `remote` attribute should be set to `true` to ensure that only cases marked for remote access will be retrieved.\n * You can specify a `case_id` value to fetch a unique case and a query string to filter result.\n * @public\n * @example <caption> Get cases from Primero with query parameters</caption>\n * getCases({\n *   remote: true,\n *   query: \"sex=male\",\n * });\n * @example <caption>Get case from Primero for a specific case id</caption>\n * getCases({\n *   remote: true,\n *   case_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} query - an object with a query param at minimum, option to getReferrals\n * @param {object} options - (Optional) an object with a getReferrals key to fetch referrals\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getCases(query, options, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const expandedQuery = expandReferences(query)(state);\n    const expandedOptions = expandReferences(options)(state);\n\n    const params = {\n      method: 'GET',\n      url: `${url}/api/v2/cases`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs: expandedQuery,\n    };\n\n    return new Promise((resolve, reject) => {\n      request(params, async function (err, resp, body) {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          console.log(\n            `Primero says: '${response.statusCode} ${response.statusMessage}'`\n          );\n          const resp = tryJson(body);\n          const cases = resp.data;\n          const metadata = resp.metadata;\n          console.log(\n            `${cases.length} cases retrieved from request: ${JSON.stringify(\n              response.request,\n              null,\n              2\n            )}`\n          );\n\n          if (expandedOptions?.withReferrals) {\n            for await (const c of cases) {\n              const requestParams = {\n                method: 'GET',\n                url: `${url}/api/v2/cases/${c.id}/referrals`,\n                headers: {\n                  Authorization: auth.token,\n                  'Content-Type': 'application/json',\n                },\n              };\n\n              const referrals = await new Promise(resolve => {\n                request(requestParams, (e, r, b) => {\n                  // console.log('\ud83d\udea8 \ud83d\udea8 \ud83d\udea8 referrals response', b);\n                  resolve(tryJson(b).data);\n                });\n              });\n\n              c.referrals = referrals;\n            }\n          }\n\n          const nextState = composeNextState(state, cases, metadata);\n          if (callback) resolve(callback(nextState));\n          resolve(nextState);\n        }\n      });\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Create a new case in Primero\n *\n * Use this function to create a new case in Primero based on a set of Data.\n * @public\n * @example <caption>Create a new case in Primero based on a set of Data</caption>\n * createCase({\n *   data: {\n *     age: 16,\n *     sex: \"female\",\n *     name: \"Edwine Edgemont\",\n *   },\n * });\n * @function\n * @param {object} params - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function createCase(params: object, callback: Function): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport request from 'request';\n\nexport function scrubResponse(response) {\n  if (response) response.request.headers.Authorization = '--REDACTED--';\n\n  return response;\n}\n\nexport function assembleError({ response, error, params }) {\n  if (response) {\n    const customCodes = params.options && params.options.successCodes;\n    if ((customCodes || [200, 201, 202, 204]).indexOf(response.statusCode) > -1)\n      return false;\n  }\n\n  if (error) return error;\n\n  return new Error(\n    `Server responded with:\\n${JSON.stringify(response, null, 2)}`\n  );\n}\n\nexport function tryJson(data) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return { body: data };\n  }\n}\n\nconst composeNextState = (state, data, meta) => {\n  const nextState = {\n    ...state,\n    data,\n    references: [...state.references, state.data],\n  };\n\n  if (meta) {\n    return { ...nextState, metadata: meta };\n  }\n  return nextState;\n};\n\n/**\n * Create a new case in Primero\n *\n * Use this function to create a new case in Primero based on a set of Data.\n * @public\n * @example <caption>Create a new case in Primero based on a set of Data</caption>\n * createCase({\n *   data: {\n *     age: 16,\n *     sex: \"female\",\n *     name: \"Edwine Edgemont\",\n *   },\n * });\n * @function\n * @param {object} params - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function createCase(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const { data } = expandReferences(params)(state);\n\n    const requestParams = {\n      method: 'POST',\n      url: `${url}/api/v2/cases`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n        options: {\n          successCodes: [200, 201, 202, 203, 204],\n        },\n      },\n      json: { data: data },\n    };\n\n    return new Promise((resolve, reject) => {\n      request(requestParams, (err, resp, body) => {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          const resp = tryJson(body);\n          console.log(\n            `Post succeeded: ${response.statusCode} ${response.statusMessage}`\n          );\n          const nextState = composeNextState(state, resp.body?.data);\n          if (callback) resolve(callback(nextState));\n          resolve(nextState);\n        }\n      });\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Update an existing case in Primero\n *\n * Use this function to update an existing case from Primero.\n * In this implementation, the function uses a case ID to check for the case to update,\n * Then merge the values submitted in this call into an existing case.\n * Fields not specified in this request will not be modified.\n * For nested subform fields, the subform arrays will be recursively merged,\n * keeping both the existing values and appending the new\n * @public\n * @example <caption>Update case for a specific case id</caption>\n * updateCase(\"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\", {\n *   data: {\n *     age: 16,\n *     sex: \"female\",\n *     name: \"Fiona Edgemont\",\n *   },\n * });\n * @function\n * @param {string} id - A case ID to use for the update.\n * @param {object} params - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function updateCase(id: string, params: object, callback: Function): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport request from 'request';\n\nexport function scrubResponse(response) {\n  if (response) response.request.headers.Authorization = '--REDACTED--';\n\n  return response;\n}\n\nexport function assembleError({ response, error, params }) {\n  if (response) {\n    const customCodes = params.options && params.options.successCodes;\n    if ((customCodes || [200, 201, 202, 204]).indexOf(response.statusCode) > -1)\n      return false;\n  }\n\n  if (error) return error;\n\n  return new Error(\n    `Server responded with:\\n${JSON.stringify(response, null, 2)}`\n  );\n}\n\nexport function tryJson(data) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return { body: data };\n  }\n}\n\nconst composeNextState = (state, data, meta) => {\n  const nextState = {\n    ...state,\n    data,\n    references: [...state.references, state.data],\n  };\n\n  if (meta) {\n    return { ...nextState, metadata: meta };\n  }\n  return nextState;\n};\n\n/**\n * Update an existing case in Primero\n *\n * Use this function to update an existing case from Primero.\n * In this implementation, the function uses a case ID to check for the case to update,\n * Then merge the values submitted in this call into an existing case.\n * Fields not specified in this request will not be modified.\n * For nested subform fields, the subform arrays will be recursively merged,\n * keeping both the existing values and appending the new\n * @public\n * @example <caption>Update case for a specific case id</caption>\n * updateCase(\"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\", {\n *   data: {\n *     age: 16,\n *     sex: \"female\",\n *     name: \"Fiona Edgemont\",\n *   },\n * });\n * @function\n * @param {string} id - A case ID to use for the update.\n * @param {object} params - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function updateCase(id, params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n    const { data } = expandReferences(params)(state);\n\n    const requestParams = {\n      method: 'PATCH',\n      url: `${url}/api/v2/cases/${id}`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      json: { data: data },\n    };\n\n    return new Promise((resolve, reject) => {\n      request(requestParams, (err, resp, body) => {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          const resp = tryJson(body);\n          console.log(\n            `PATCH succeeded: ${response.statusCode} ${response.statusMessage}`\n          );\n          const nextState = composeNextState(state, resp.body?.data);\n          if (callback) resolve(callback(nextState));\n          resolve(nextState);\n        }\n      });\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Upsert case to Primero\n *\n * Use this function to update an existing case from Primero or to create it otherwise.\n * In this implementation, we first fetch the list of cases,\n * then we check if the case exist before choosing the right operation to do.\n * @public\n * @example <caption>Upsert case for a specific case id</caption>\n * upsertCase({\n *   externalIds: [\"case_id\"],\n *   data: state => ({\n *     age: 20,\n *     sex: \"male\",\n *     name: \"Alex\",\n *     status: \"open\",\n *     case_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n *   }),\n * });\n * @function\n * @param {object} params - an object with an externalIds and some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertCase(params: object, callback: Function): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport request from 'request';\n\nexport function scrubResponse(response) {\n  if (response) response.request.headers.Authorization = '--REDACTED--';\n\n  return response;\n}\n\nexport function assembleError({ response, error, params }) {\n  if (response) {\n    const customCodes = params.options && params.options.successCodes;\n    if ((customCodes || [200, 201, 202, 204]).indexOf(response.statusCode) > -1)\n      return false;\n  }\n\n  if (error) return error;\n\n  return new Error(\n    `Server responded with:\\n${JSON.stringify(response, null, 2)}`\n  );\n}\n\nexport function tryJson(data) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return { body: data };\n  }\n}\n\nconst composeNextState = (state, data, meta) => {\n  const nextState = {\n    ...state,\n    data,\n    references: [...state.references, state.data],\n  };\n\n  if (meta) {\n    return { ...nextState, metadata: meta };\n  }\n  return nextState;\n};\n\n/**\n * Upsert case to Primero\n *\n * Use this function to update an existing case from Primero or to create it otherwise.\n * In this implementation, we first fetch the list of cases,\n * then we check if the case exist before choosing the right operation to do.\n * @public\n * @example <caption>Upsert case for a specific case id</caption>\n * upsertCase({\n *   externalIds: [\"case_id\"],\n *   data: state => ({\n *     age: 20,\n *     sex: \"male\",\n *     name: \"Alex\",\n *     status: \"open\",\n *     case_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n *   }),\n * });\n * @function\n * @param {object} params - an object with an externalIds and some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertCase(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n    const { data, externalIds } = expandReferences(params)(state);\n\n    const qs = {\n      remote: true,\n      scope: {},\n    };\n\n    externalIds\n      .filter(x => data[x])\n      .forEach(x => {\n        // For every externalId field that is provided, add a key to the\n        // scope object in our qs (queryString) and set the value for that key to\n        // whatever value is found IN THE DATA for the given externalId.\n        return (qs[x] = `${data[x]}`);\n      });\n\n    const requestParams = {\n      method: 'GET',\n      url: `${url}/api/v2/cases`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs,\n    };\n\n    // NOTE: while record_id is used in the GET, it must be dropped before -----\n    // subsequent create or update calls are made as it's not valid in Primero.\n    delete data['record_id'];\n    // -------------------------------------------------------------------------\n\n    return new Promise((resolve, reject) => {\n      request(requestParams, (err, resp, body) => {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          const resp = tryJson(body);\n          if (resp.data.length == 0) {\n            console.log('No case found. Performing create.');\n            resolve(createCase({ data }, callback)(state));\n          } else if (resp.data.length > 0) {\n            console.log('Case found. Performing update.');\n            resolve(updateCase(resp.data[0].id, { data }, callback)(state));\n          }\n        }\n      });\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Update a single referral for a specific case in Primero\n * @public\n * @example <caption>Update referral by record id</caption>\n * updateReferral({\n *   caseExternalId: \"record_id\",\n *   id: \"749e9c6e-60db-45ec-8f5a-69da7c223a79\",\n *   caseId: \"dcea6052-07d9-4cfa-9abf-9a36987cdd25\",\n *   data: (state) => state.data,\n * });\n * @function\n * @param {object} params - an object with an caseExternalId value to use, the id and the referral id to update.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function updateReferral(params: object, callback: Function): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport request from 'request';\n\nexport function scrubResponse(response) {\n  if (response) response.request.headers.Authorization = '--REDACTED--';\n\n  return response;\n}\n\nexport function assembleError({ response, error, params }) {\n  if (response) {\n    const customCodes = params.options && params.options.successCodes;\n    if ((customCodes || [200, 201, 202, 204]).indexOf(response.statusCode) > -1)\n      return false;\n  }\n\n  if (error) return error;\n\n  return new Error(\n    `Server responded with:\\n${JSON.stringify(response, null, 2)}`\n  );\n}\n\nexport function tryJson(data) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return { body: data };\n  }\n}\n\nconst composeNextState = (state, data, meta) => {\n  const nextState = {\n    ...state,\n    data,\n    references: [...state.references, state.data],\n  };\n\n  if (meta) {\n    return { ...nextState, metadata: meta };\n  }\n  return nextState;\n};\n\n/**\n * Update a single referral for a specific case in Primero\n * @public\n * @example <caption>Update referral by record id</caption>\n * updateReferral({\n *   caseExternalId: \"record_id\",\n *   id: \"749e9c6e-60db-45ec-8f5a-69da7c223a79\",\n *   caseId: \"dcea6052-07d9-4cfa-9abf-9a36987cdd25\",\n *   data: (state) => state.data,\n * });\n * @function\n * @param {object} params - an object with an caseExternalId value to use, the id and the referral id to update.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function updateReferral(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const { caseExternalId, caseId, id, data } =\n      expandReferences(params)(state);\n\n    let requestParams = {};\n\n    if (caseExternalId === 'record_id') {\n      console.log('Updating referral by record id...');\n      requestParams = {\n        method: 'PATCH',\n        url: `${url}/api/v2/cases/${caseId}/referrals/${id}`,\n        headers: {\n          Authorization: auth.token,\n          'Content-Type': 'application/json',\n        },\n        json: { data: data },\n      };\n      return queryHandler(state, requestParams, callback);\n    } else {\n      console.log('Updating referral by case id...');\n      const qs = {\n        case_id: `${caseId}`,\n      };\n      requestParams = {\n        method: 'GET',\n        url: `${url}/api/v2/cases`,\n        headers: {\n          Authorization: auth.token,\n          'Content-Type': 'application/json',\n        },\n        qs,\n      };\n      return new Promise((resolve, reject) => {\n        request(requestParams, (err, resp, body) => {\n          const response = scrubResponse(resp);\n          const error = assembleError({ error: err, response, params });\n          if (error) {\n            reject(error);\n          } else {\n            const resp = tryJson(body);\n            if (resp.data.length == 0) {\n              console.log('No case found.');\n              resolve(state);\n              return state;\n            } else if (resp.data.length === 1) {\n              console.log('Case found. Fetching referrals.');\n\n              const caseRecordId = resp.data[0].id;\n              requestParams = {\n                method: 'PATCH',\n                url: `${url}/api/v2/cases/${caseRecordId}/referrals/${id}`,\n\n                headers: {\n                  Authorization: auth.token,\n                  'Content-Type': 'application/json',\n                },\n                json: { data: data },\n              };\n              resolve(queryHandler(state, requestParams, callback));\n            } else {\n              reject(\n                'Multiple cases found. Try using another externalId and ensure that it is unique.'\n              );\n            }\n          }\n        });\n      });\n    }\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get forms from Primero\n *\n * Use this function to get forms from Primero that are accessible to this user based on a set of query parameters.\n * The user can filter the form list by record type and module.\n * @public\n * @example <caption>Get the list of all forms</caption>\n * getForms();\n *\n * @example <caption>Get the list of all forms for a specific module</caption>\n * getForms({\n *   module_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getForms(query: object, callback: Function): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport request from 'request';\n\nexport function scrubResponse(response) {\n  if (response) response.request.headers.Authorization = '--REDACTED--';\n\n  return response;\n}\n\nexport function assembleError({ response, error, params }) {\n  if (response) {\n    const customCodes = params.options && params.options.successCodes;\n    if ((customCodes || [200, 201, 202, 204]).indexOf(response.statusCode) > -1)\n      return false;\n  }\n\n  if (error) return error;\n\n  return new Error(\n    `Server responded with:\\n${JSON.stringify(response, null, 2)}`\n  );\n}\n\nexport function tryJson(data) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return { body: data };\n  }\n}\n\nconst composeNextState = (state, data, meta) => {\n  const nextState = {\n    ...state,\n    data,\n    references: [...state.references, state.data],\n  };\n\n  if (meta) {\n    return { ...nextState, metadata: meta };\n  }\n  return nextState;\n};\n\n/**\n * Get forms from Primero\n *\n * Use this function to get forms from Primero that are accessible to this user based on a set of query parameters.\n * The user can filter the form list by record type and module.\n * @public\n * @example <caption>Get the list of all forms</caption>\n * getForms();\n *\n * @example <caption>Get the list of all forms for a specific module</caption>\n * getForms({\n *   module_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getForms(query, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const expandedQuery = expandReferences(query)(state);\n\n    const params = {\n      method: 'GET',\n      url: `${url}/api/v2/forms`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs: expandedQuery,\n    };\n\n    return new Promise((resolve, reject) => {\n      request(params, async function (err, resp, body) {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          console.log(\n            `Primero says: '${response.statusCode} ${response.statusMessage}'`\n          );\n          const resp = tryJson(body);\n          const forms = resp.data;\n          console.log(\n            `${forms.length} forms retrieved from request: ${JSON.stringify(\n              response.request,\n              null,\n              2\n            )}`\n          );\n\n          const nextState = composeNextState(state, forms);\n          if (callback) resolve(callback(nextState));\n          resolve(nextState);\n        }\n      });\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get referrals for a specific case in Primero\n *\n * Use this function to get the list of referrals of one case from Primero.\n * The search can be done using either `record id` or `case id`.\n * @public\n * @example <caption>Get referrals for a case in Primero by record id</caption>\n * getReferrals({\n *   externalId: \"record_id\",\n *   id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @example <caption>Get referrals for a case in Primero by case id</caption>\n *  getReferrals({\n *   id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} params - an object with an externalId field to select the attribute to use for matching on case and an externalId value for that case.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getReferrals(params: object, callback: Function): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport request from 'request';\n\nexport function scrubResponse(response) {\n  if (response) response.request.headers.Authorization = '--REDACTED--';\n\n  return response;\n}\n\nexport function assembleError({ response, error, params }) {\n  if (response) {\n    const customCodes = params.options && params.options.successCodes;\n    if ((customCodes || [200, 201, 202, 204]).indexOf(response.statusCode) > -1)\n      return false;\n  }\n\n  if (error) return error;\n\n  return new Error(\n    `Server responded with:\\n${JSON.stringify(response, null, 2)}`\n  );\n}\n\nexport function tryJson(data) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return { body: data };\n  }\n}\n\nconst composeNextState = (state, data, meta) => {\n  const nextState = {\n    ...state,\n    data,\n    references: [...state.references, state.data],\n  };\n\n  if (meta) {\n    return { ...nextState, metadata: meta };\n  }\n  return nextState;\n};\n\n/**\n * Get referrals for a specific case in Primero\n *\n * Use this function to get the list of referrals of one case from Primero.\n * The search can be done using either `record id` or `case id`.\n * @public\n * @example <caption>Get referrals for a case in Primero by record id</caption>\n * getReferrals({\n *   externalId: \"record_id\",\n *   id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @example <caption>Get referrals for a case in Primero by case id</caption>\n *  getReferrals({\n *   id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} params - an object with an externalId field to select the attribute to use for matching on case and an externalId value for that case.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getReferrals(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const { externalId, id } = expandReferences(params)(state);\n\n    let requestParams = {};\n\n    if (externalId === 'record_id') {\n      console.log('Fetching by record id...');\n      requestParams = {\n        method: 'GET',\n        url: `${url}/api/v2/cases/${id}/referrals`,\n        headers: {\n          Authorization: auth.token,\n          'Content-Type': 'application/json',\n        },\n      };\n      return queryHandler(state, requestParams, callback);\n    } else {\n      console.log('Fetching by case id...');\n      const qs = {\n        case_id: `${id}`,\n      };\n      requestParams = {\n        method: 'GET',\n        url: `${url}/api/v2/cases`,\n        headers: {\n          Authorization: auth.token,\n          'Content-Type': 'application/json',\n        },\n        qs,\n      };\n      return new Promise((resolve, reject) => {\n        request(requestParams, (err, resp, body) => {\n          const response = scrubResponse(resp);\n          const error = assembleError({ error: err, response, params });\n          if (error) {\n            reject(error);\n          } else {\n            const resp = tryJson(body);\n            if (resp.data.length == 0) {\n              reject('No case found');\n              return state;\n            } else if (resp.data.length === 1) {\n              console.log('Case found. Fetching referrals.');\n              const id = resp.data[0].id;\n              requestParams = {\n                method: 'GET',\n                url: `${url}/api/v2/cases/${id}/referrals`,\n                headers: {\n                  Authorization: auth.token,\n                  'Content-Type': 'application/json',\n                },\n              };\n              resolve(queryHandler(state, requestParams, callback));\n            } else {\n              reject(\n                'Multiple cases found. Try using another externalId and ensure that it is unique.'\n              );\n            }\n          }\n        });\n      });\n    }\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Create an encounter\n * @example\n * execute(\n *   encounter(data)\n * )(state)\n * @function\n * @param {object} encounterData - Payload data for the encounter\n * @returns {Operation}\n */\nexport function encounter(encounterData: object): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport { resolve as resolveUrl } from 'url';\nimport request from 'superagent'\n\n/**\n * Create an encounter\n * @example\n * execute(\n *   encounter(data)\n * )(state)\n * @function\n * @param {object} encounterData - Payload data for the encounter\n * @returns {Operation}\n */\nexport function encounter(encounterData) {\n  return state => {\n    const body = expandReferences(encounterData)(state);\n\n    const { username, password, apiUrl } = state.configuration;\n\n    const url = resolveUrl(apiUrl + '/', 'chw/encounter');\n\n    console.log('Posting encounter:');\n    console.log(JSON.stringify(body, null, 2));\n\n    return new Promise((resolve, reject) => {\n      request.post(url)\n        .type('json')\n        .accept('json')\n        .auth(username, password)\n        .send(JSON.stringify(body))\n        .end((error, res) => {\n          if (!!error || !res.ok) {\n            reject(error)\n          }\n\n          resolve(res)\n        })\n\n    }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Create some resource in msgraph\n * @public\n * @example\n * create(\"applications\", {\"displayName\": \"My App\"})\n * @function\n * @param {string} resource - The type of entity that will be created\n * @param {object} data - The data to create the new resource\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function create(resource: string, data: object, callback: Function): Operation;",
    "completion": "import { expandReferences } from '@openfn/language-common/util';\nimport {\n  request,\n  handleResponse,\n} from './Utils';\n\nexport function setUrl(resource, apiVersion) {\n  if (isValidHttpUrl(resource)) return resource;\n\n  const pathSuffix = apiVersion\n    ? `${apiVersion}/${resource}`\n    : `v1.0/${resource}`;\n  return `https://graph.microsoft.com/${pathSuffix}`;\n}\n\n/**\n * This is an asynchronous function that sends a request to a specified URL with optional parameters\n * and headers, and returns the response data in JSON format.\n * @param {string} url - The URL of the API endpoint that the request is being made to.\n * @param {object} [options] - An object containing any additional parameters to be sent with the request, such\n * as query parameters or request body data. It is an optional parameter and defaults to an empty\n * object if not provided.\n * @returns The `request` function is returning the parsed JSON data from the response of the HTTP\n * request made to the specified `url` with the given `params` and `method`. If there is an error in\n * the response, the function will throw an error.\n */\nexport const request = async (path, params) => {\n  let url = path;\n  const options = { ...defaultOptions, ...params };\n  const { parseAs, query, method, accessToken } = options;\n  delete options.parseAs;\n  delete options.accessToken;\n\n  options.headers['Authorization'] = makeAuthHeader(accessToken);\n\n  if (method === 'GET' && query) {\n    url = `${path}?${new URLSearchParams(query).toString()}`;\n  }\n\n  const response = await fetch(url, options);\n  const contentType = response.headers.get('Content-Type');\n\n  // If not json then return a stream\n  let data;\n  if (parseAs) {\n    if (parseAs === 'json') data = await response.json();\n    if (parseAs === 'text') data = await response.text();\n  } else {\n    data = contentType?.includes('application/json')\n      ? await response.json()\n      : response.body;\n  }\n\n  handleResponseError(response, data, method);\n\n  return data;\n};\n\nexport function handleResponse(response, state, callback) {\n  let nextState;\n  // Don't compose state if response is a stream\n  if (isStream(response)) {\n    nextState = {\n      ...state,\n      data: response,\n    };\n  } else {\n    nextState = {\n      ...composeNextState(state, response),\n      response,\n    };\n  }\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\nexport function handleResponseError(response, data, method) {\n  const { status, statusText, url } = response;\n\n  if (!response.ok) {\n    const errorString = [\n      `Message: ${statusText}`,\n      `Request: ${method} ${url}`,\n      `Status: ${status}`,\n      `Body: ${JSON.stringify(data, null, 2).replace(/\\n/g, '\\n\\t  ')}`,\n    ].join('\\n\\t\u221f ');\n    throw new Error(errorString);\n  }\n}\n\n/**\n * Create some resource in msgraph\n * @public\n * @example\n * create(\"applications\", {\"displayName\": \"My App\"})\n * @function\n * @param {string} resource - The type of entity that will be created\n * @param {object} data - The data to create the new resource\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function create(resource, data, callback) {\n  return state => {\n    const [resolvedResource, resolvedData] = expandReferences(\n      state,\n      resource,\n      data\n    );\n\n    const { accessToken, apiVersion } = state.configuration;\n\n    const url = setUrl({ apiVersion, resolvedResource });\n\n    const options = {\n      accessToken,\n      body: JSON.stringify(resolvedData),\n      method: 'POST',\n    };\n\n    return request(url, options).then(response =>\n      handleResponse(response, state, callback)\n    );\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Make a GET request to msgraph resource\n * @public\n * @example\n *  get('sites/root/lists')\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function get(path: string, query: object, callback?: Function): Operation;",
    "completion": "import { expandReferences } from '@openfn/language-common/util';\nimport {\n  request,\n  setUrl,\n  handleResponse,\n} from './Utils';\n\nexport function setUrl(resource, apiVersion) {\n  if (isValidHttpUrl(resource)) return resource;\n\n  const pathSuffix = apiVersion\n    ? `${apiVersion}/${resource}`\n    : `v1.0/${resource}`;\n  return `https://graph.microsoft.com/${pathSuffix}`;\n}\n\n/**\n * This is an asynchronous function that sends a request to a specified URL with optional parameters\n * and headers, and returns the response data in JSON format.\n * @param {string} url - The URL of the API endpoint that the request is being made to.\n * @param {object} [options] - An object containing any additional parameters to be sent with the request, such\n * as query parameters or request body data. It is an optional parameter and defaults to an empty\n * object if not provided.\n * @returns The `request` function is returning the parsed JSON data from the response of the HTTP\n * request made to the specified `url` with the given `params` and `method`. If there is an error in\n * the response, the function will throw an error.\n */\nexport const request = async (path, params) => {\n  let url = path;\n  const options = { ...defaultOptions, ...params };\n  const { parseAs, query, method, accessToken } = options;\n  delete options.parseAs;\n  delete options.accessToken;\n\n  options.headers['Authorization'] = makeAuthHeader(accessToken);\n\n  if (method === 'GET' && query) {\n    url = `${path}?${new URLSearchParams(query).toString()}`;\n  }\n\n  const response = await fetch(url, options);\n  const contentType = response.headers.get('Content-Type');\n\n  // If not json then return a stream\n  let data;\n  if (parseAs) {\n    if (parseAs === 'json') data = await response.json();\n    if (parseAs === 'text') data = await response.text();\n  } else {\n    data = contentType?.includes('application/json')\n      ? await response.json()\n      : response.body;\n  }\n\n  handleResponseError(response, data, method);\n\n  return data;\n};\n\nexport function handleResponse(response, state, callback) {\n  let nextState;\n  // Don't compose state if response is a stream\n  if (isStream(response)) {\n    nextState = {\n      ...state,\n      data: response,\n    };\n  } else {\n    nextState = {\n      ...composeNextState(state, response),\n      response,\n    };\n  }\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\nexport function handleResponseError(response, data, method) {\n  const { status, statusText, url } = response;\n\n  if (!response.ok) {\n    const errorString = [\n      `Message: ${statusText}`,\n      `Request: ${method} ${url}`,\n      `Status: ${status}`,\n      `Body: ${JSON.stringify(data, null, 2).replace(/\\n/g, '\\n\\t  ')}`,\n    ].join('\\n\\t\u221f ');\n    throw new Error(errorString);\n  }\n}\n\n\n/**\n * Make a GET request to msgraph resource\n * @public\n * @example\n *  get('sites/root/lists')\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function get(path, query, callback = false) {\n  return state => {\n    const { accessToken, apiVersion } = state.configuration;\n    const [resolvedPath, resolvedQuery] = expandReferences(state, path, query);\n\n    const url = setUrl(resolvedPath, apiVersion);\n\n    return request(url, { query: resolvedQuery, accessToken }).then(response =>\n      handleResponse(response, state, callback)\n    );\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get a Drive or SharePoint document library. The drive metadata will be written\n * to state.drives, where it can be used by other adaptor functions.\n * Pass { id } to get a drive by id or { id, owner } to get default drive for\n * some parent resource, like a group\n * @public\n * @example <caption>Get a drive by ID</caption>\n * getDrive({ id: \"YXzpkoLwR06bxC8tNdg71m\" })\n * @example <caption>Get the default drive for a site</caption>\n * getDrive({ id: \"openfn.sharepoint.com\", owner: \"sites\" })\n * @param specifier {Object} - A definition of the drive to retrieve\n *    - id {string} - The ID of the resource or owner.\n *    - owner {string} - The type of drive owner (e.g. sites, groups).\n * @param {string} name - The local name of the drive used to write to state.drives, ie, state.drives[name]\n * @param {function} [callback = s => s] (Optional) Callback function\n * @return {Operation}\n */\nexport function getDrive(specifier: any, name?: string, callback?: Function): Operation;",
    "completion": "import { expandReferences } from '@openfn/language-common/util';\n\n\nexport function setUrl(resource, apiVersion) {\n  if (isValidHttpUrl(resource)) return resource;\n\n  const pathSuffix = apiVersion\n    ? `${apiVersion}/${resource}`\n    : `v1.0/${resource}`;\n  return `https://graph.microsoft.com/${pathSuffix}`;\n}\n\n/**\n * This is an asynchronous function that sends a request to a specified URL with optional parameters\n * and headers, and returns the response data in JSON format.\n * @param {string} url - The URL of the API endpoint that the request is being made to.\n * @param {object} [options] - An object containing any additional parameters to be sent with the request, such\n * as query parameters or request body data. It is an optional parameter and defaults to an empty\n * object if not provided.\n * @returns The `request` function is returning the parsed JSON data from the response of the HTTP\n * request made to the specified `url` with the given `params` and `method`. If there is an error in\n * the response, the function will throw an error.\n */\nexport const request = async (path, params) => {\n  let url = path;\n  const options = { ...defaultOptions, ...params };\n  const { parseAs, query, method, accessToken } = options;\n  delete options.parseAs;\n  delete options.accessToken;\n\n  options.headers['Authorization'] = makeAuthHeader(accessToken);\n\n  if (method === 'GET' && query) {\n    url = `${path}?${new URLSearchParams(query).toString()}`;\n  }\n\n  const response = await fetch(url, options);\n  const contentType = response.headers.get('Content-Type');\n\n  // If not json then return a stream\n  let data;\n  if (parseAs) {\n    if (parseAs === 'json') data = await response.json();\n    if (parseAs === 'text') data = await response.text();\n  } else {\n    data = contentType?.includes('application/json')\n      ? await response.json()\n      : response.body;\n  }\n\n  handleResponseError(response, data, method);\n\n  return data;\n};\n\nexport function handleResponseError(response, data, method) {\n  const { status, statusText, url } = response;\n\n  if (!response.ok) {\n    const errorString = [\n      `Message: ${statusText}`,\n      `Request: ${method} ${url}`,\n      `Status: ${status}`,\n      `Body: ${JSON.stringify(data, null, 2).replace(/\\n/g, '\\n\\t  ')}`,\n    ].join('\\n\\t\u221f ');\n    throw new Error(errorString);\n  }\n}\n\n/**\n * Get a Drive or SharePoint document library. The drive metadata will be written\n * to state.drives, where it can be used by other adaptor functions.\n * Pass { id } to get a drive by id or { id, owner } to get default drive for\n * some parent resource, like a group\n * @public\n * @example <caption>Get a drive by ID</caption>\n * getDrive({ id: \"YXzpkoLwR06bxC8tNdg71m\" })\n * @example <caption>Get the default drive for a site</caption>\n * getDrive({ id: \"openfn.sharepoint.com\", owner: \"sites\" })\n * @param specifier {Object} - A definition of the drive to retrieve\n *    - id {string} - The ID of the resource or owner.\n *    - owner {string} - The type of drive owner (e.g. sites, groups).\n * @param {string} name - The local name of the drive used to write to state.drives, ie, state.drives[name]\n * @param {function} [callback = s => s] (Optional) Callback function\n * @return {Operation}\n */\nexport function getDrive(specifier, name = 'default', callback = s => s) {\n  return state => {\n    const { accessToken, apiVersion } = state.configuration;\n    const [resolvedSpecifier, resolvedName] = expandReferences(\n      state,\n      specifier,\n      name\n    );\n\n    const { id, owner = 'drive' } = resolvedSpecifier;\n\n    let resource;\n    if (owner === 'drive') {\n      resource = `drives/${id}`;\n    } else {\n      resource = `${owner}/${id}/drive`;\n    }\n\n    const url = setUrl(resource, apiVersion);\n\n    return request(url, { accessToken }).then(response => {\n      state.drives[resolvedName] = response;\n      return callback(state);\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Update data. A generic helper function to update a resource object of any type.\n * Updating an object requires to send `all required fields` or the `full body`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be updated. E.g. `dataElements`, `organisationUnits`, etc.\n * @param {string} path - The `id` or `path` to the `object` to be updated. E.g. `FTRrcoaog83` or `FTRrcoaog83/{collection-name}/{object-id}`\n * @param {Object} data - Data to update. It requires to send `all required fields` or the `full body`. If you want `partial updates`, use `patch` operation.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * update('programs', 'qAZJCrNJK8H', {\n *   name: '14e1aa02c3f0a31618e096f2c6d03bed',\n *   shortName: '14e1aa02',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * update('events', 'PVqUD2hvU4E', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'Ngelehun CHC',\n *   status: 'COMPLETED',\n *   storedBy: 'admin',\n *   dataValues: [],\n * });\n */\nexport function update(resourceType: string, path: string, data: any, options?: any, callback?: Function): Operation;",
    "completion": "import axios from 'axios';\nimport Qs from 'qs';\nimport { expandReferences } from '@openfn/language-common';\n\nexport function generateUrl(configuration, options, resourceType, path = null) {\n    let { hostUrl, apiVersion } = configuration;\n    const urlString = '/' + resourceType;\n\n    // Note that users can override the apiVersion from configuration with args\n    if (options?.apiVersion) apiVersion = options.apiVersion;\n\n    const apiMessage = apiVersion\n        ? `Using DHIS2 api version ${apiVersion}`\n        : 'Using latest available version of the DHIS2 api on this server.';\n\n    console.log(apiMessage);\n\n    const url = buildUrl(urlString, hostUrl, apiVersion);\n\n    if (path) return `${url}/${path}`;\n    return url;\n}\n\nexport function handleResponse(result, state, callback) {\n    const { data } = result;\n    if (callback) return callback(composeNextState(state, data));\n    return composeNextState(state, data);\n}\n\nexport function request({ username, password }, axiosRequest) {\n    const { method, url, params } = axiosRequest;\n\n    console.log(`Sending ${method} request to ${url}`);\n    if (params) console.log(` with params:`, params);\n\n    // NOTE: We don't follow redirects for unsafe methods: https://github.com/axios/axios/issues/2460\n    const safeRedirect = ['get', 'head', 'options', 'trace'].includes(\n        method.toLowerCase()\n    );\n\n    return axios({\n        headers: { 'Content-Type': 'application/json' },\n        responseType: 'json',\n        maxRedirects: safeRedirect ? 5 : 0,\n        auth: { username, password },\n        paramsSerializer: params => Qs.stringify(params, { arrayFormat: 'repeat' }),\n        // Note that providing headers or auth in the request object will overwrite.\n        ...axiosRequest,\n    });\n}\n\n/**\n * Update data. A generic helper function to update a resource object of any type.\n * Updating an object requires to send `all required fields` or the `full body`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be updated. E.g. `dataElements`, `organisationUnits`, etc.\n * @param {string} path - The `id` or `path` to the `object` to be updated. E.g. `FTRrcoaog83` or `FTRrcoaog83/{collection-name}/{object-id}`\n * @param {Object} data - Data to update. It requires to send `all required fields` or the `full body`. If you want `partial updates`, use `patch` operation.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * update('programs', 'qAZJCrNJK8H', {\n *   name: '14e1aa02c3f0a31618e096f2c6d03bed',\n *   shortName: '14e1aa02',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * update('events', 'PVqUD2hvU4E', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'Ngelehun CHC',\n *   status: 'COMPLETED',\n *   storedBy: 'admin',\n *   dataValues: [],\n * });\n */\nexport function update(\n    resourceType,\n    path,\n    data,\n    options = {},\n    callback = false\n) {\n    return state => {\n        console.log(`Preparing update operation...`);\n\n        const resolvedResourceType = expandReferences(resourceType)(state);\n        const resolvedPath = expandReferences(path)(state);\n        const resolvedData = expandReferences(data)(state);\n        const resolvedOptions = expandReferences(options)(state);\n\n        const { params, requestConfig } = resolvedOptions;\n        const { configuration } = state;\n\n        return request(configuration, {\n            method: 'put',\n            url: generateUrl(\n                configuration,\n                resolvedOptions,\n                resolvedResourceType,\n                path\n            ),\n            params,\n            data: resolvedData,\n            ...requestConfig,\n        }).then(result => {\n            console.log(`Updated ${resolvedResourceType} at ${resolvedPath}`);\n            return handleResponse(result, state, callback);\n        });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `trackedEntityInstances`, `programs`, `events`, ...\n * @magic resourceType $.children.resourceTypes[*]\n * @param {Dhis2Data} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * create('programs', {\n *   name: 'name 20',\n *   shortName: 'n20',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * create('events', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'DiszpKrYNg8',\n *   status: 'COMPLETED',\n * });\n * @example <caption>a dataSet</caption>\n * create('dataSets', { name: 'OpenFn Data Set', periodType: 'Monthly' });\n * @example <caption>a dataElement</caption>\n * create('dataElements', {\n *   aggregationType: 'SUM',\n *   domainType: 'AGGREGATE',\n *   valueType: 'NUMBER',\n *   name: 'Paracetamol',\n *   shortName: 'Para',\n * });\n * @example <caption>a dataElementGroup</caption>\n * create('dataElementGroups', {\n *   name: 'Data Element Group 1',\n *   dataElements: [],\n * });\n * @example <caption>a dataValueSet</caption>\n * create('dataValueSets', {\n *   dataElement: 'f7n9E0hX8qk',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   value: '12',\n * });\n * @example <caption>an enrollment</caption>\n * create('enrollments', {\n *   trackedEntityInstance: 'bmshzEacgxa',\n *   orgUnit: 'TSyzvBiovKh',\n *   program: 'gZBxv9Ujxg0',\n *   enrollmentDate: '2013-09-17',\n *   incidentDate: '2013-09-17',\n * });\n */\nexport function create(resourceType: string, data: Dhis2Data, options?: any, callback?: Function): Operation;",
    "completion": "import axios from 'axios';\nimport Qs from 'qs';\nimport { expandReferences } from '@openfn/language-common';\n\nexport function generateUrl(configuration, options, resourceType, path = null) {\n    let { hostUrl, apiVersion } = configuration;\n    const urlString = '/' + resourceType;\n\n    // Note that users can override the apiVersion from configuration with args\n    if (options?.apiVersion) apiVersion = options.apiVersion;\n\n    const apiMessage = apiVersion\n        ? `Using DHIS2 api version ${apiVersion}`\n        : 'Using latest available version of the DHIS2 api on this server.';\n\n    console.log(apiMessage);\n\n    const url = buildUrl(urlString, hostUrl, apiVersion);\n\n    if (path) return `${url}/${path}`;\n    return url;\n}\n\nexport function handleResponse(result, state, callback) {\n    const { data } = result;\n    if (callback) return callback(composeNextState(state, data));\n    return composeNextState(state, data);\n}\n\nexport function nestArray(data, key) {\n    return isArray(data) ? { [key]: data } : data;\n}\n\nexport function request({ username, password }, axiosRequest) {\n    const { method, url, params } = axiosRequest;\n\n    console.log(`Sending ${method} request to ${url}`);\n    if (params) console.log(` with params:`, params);\n\n    // NOTE: We don't follow redirects for unsafe methods: https://github.com/axios/axios/issues/2460\n    const safeRedirect = ['get', 'head', 'options', 'trace'].includes(\n        method.toLowerCase()\n    );\n\n    return axios({\n        headers: { 'Content-Type': 'application/json' },\n        responseType: 'json',\n        maxRedirects: safeRedirect ? 5 : 0,\n        auth: { username, password },\n        paramsSerializer: params => Qs.stringify(params, { arrayFormat: 'repeat' }),\n        // Note that providing headers or auth in the request object will overwrite.\n        ...axiosRequest,\n    });\n}\n\n/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `trackedEntityInstances`, `programs`, `events`, ...\n * @magic resourceType $.children.resourceTypes[*]\n * @param {Dhis2Data} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * create('programs', {\n *   name: 'name 20',\n *   shortName: 'n20',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * create('events', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'DiszpKrYNg8',\n *   status: 'COMPLETED',\n * });\n * @example <caption>a dataSet</caption>\n * create('dataSets', { name: 'OpenFn Data Set', periodType: 'Monthly' });\n * @example <caption>a dataElement</caption>\n * create('dataElements', {\n *   aggregationType: 'SUM',\n *   domainType: 'AGGREGATE',\n *   valueType: 'NUMBER',\n *   name: 'Paracetamol',\n *   shortName: 'Para',\n * });\n * @example <caption>a dataElementGroup</caption>\n * create('dataElementGroups', {\n *   name: 'Data Element Group 1',\n *   dataElements: [],\n * });\n * @example <caption>a dataValueSet</caption>\n * create('dataValueSets', {\n *   dataElement: 'f7n9E0hX8qk',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   value: '12',\n * });\n * @example <caption>an enrollment</caption>\n * create('enrollments', {\n *   trackedEntityInstance: 'bmshzEacgxa',\n *   orgUnit: 'TSyzvBiovKh',\n *   program: 'gZBxv9Ujxg0',\n *   enrollmentDate: '2013-09-17',\n *   incidentDate: '2013-09-17',\n * });\n */\nexport function create(resourceType, data, options = {}, callback = false) {\n    return state => {\n        console.log(`Preparing create operation...`);\n\n        const resolvedResourceType = expandReferences(resourceType)(state);\n        const resolvedData = expandReferences(data)(state);\n        const resolvedOptions = expandReferences(options)(state);\n\n        const { params, requestConfig } = resolvedOptions;\n        const { configuration } = state;\n\n        return request(configuration, {\n            method: 'post',\n            url: generateUrl(configuration, resolvedOptions, resolvedResourceType),\n            params,\n            data: nestArray(resolvedData, resolvedResourceType),\n            ...requestConfig,\n        }).then(result => {\n            const details = `with response ${JSON.stringify(result.data, null, 2)}`;\n            console.log(`Created ${resolvedResourceType} ${details}`);\n\n            const { location } = result.headers;\n            if (location) console.log(`Record available @ ${location}`);\n\n            return handleResponse(result, state, callback);\n        });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Fetch the list of contacts within a particular outbreak using its ID.\n * @public\n * @example\n *  listContacts(\"343d-dc3e\", // Outbreak Id\n *    state => {\n *       console.log(state);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listContacts(id: string, callback: Function): Operation;",
    "completion": "import axios from 'axios';\nimport Qs from 'qs';\nimport { expandReferences } from '@openfn/language-common';\n\nexport function generateUrl(configuration, options, resourceType, path = null) {\n    let { hostUrl, apiVersion } = configuration;\n    const urlString = '/' + resourceType;\n\n    // Note that users can override the apiVersion from configuration with args\n    if (options?.apiVersion) apiVersion = options.apiVersion;\n\n    const apiMessage = apiVersion\n        ? `Using DHIS2 api version ${apiVersion}`\n        : 'Using latest available version of the DHIS2 api on this server.';\n\n    console.log(apiMessage);\n\n    const url = buildUrl(urlString, hostUrl, apiVersion);\n\n    if (path) return `${url}/${path}`;\n    return url;\n}\n\nexport function handleResponse(result, state, callback) {\n    const { data } = result;\n    if (callback) return callback(composeNextState(state, data));\n    return composeNextState(state, data);\n}\n\nexport function request({ username, password }, axiosRequest) {\n    const { method, url, params } = axiosRequest;\n\n    console.log(`Sending ${method} request to ${url}`);\n    if (params) console.log(` with params:`, params);\n\n    // NOTE: We don't follow redirects for unsafe methods: https://github.com/axios/axios/issues/2460\n    const safeRedirect = ['get', 'head', 'options', 'trace'].includes(\n        method.toLowerCase()\n    );\n\n    return axios({\n        headers: { 'Content-Type': 'application/json' },\n        responseType: 'json',\n        maxRedirects: safeRedirect ? 5 : 0,\n        auth: { username, password },\n        paramsSerializer: params => Qs.stringify(params, { arrayFormat: 'repeat' }),\n        // Note that providing headers or auth in the request object will overwrite.\n        ...axiosRequest,\n    });\n}\n\n/**\n * Delete a record. A generic helper function to delete an object\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be deleted. E.g. `trackedEntityInstances`, `organisationUnits`, etc.\n * @param {string} path - Can be an `id` of an `object` or `path` to the `nested object` to `delete`.\n * @param {Object} [data] - Optional. This is useful when you want to remove multiple objects from a collection in one request. You can send `data` as, for example, `{\"identifiableObjects\": [{\"id\": \"IDA\"}, {\"id\": \"IDB\"}, {\"id\": \"IDC\"}]}`. See more {@link https://docs.dhis2.org/2.34/en/dhis2_developer_manual/web-api.html#deleting-objects on DHIS2 API docs}\n * @param {{apiVersion: number,operationName: string,resourceType: string}} [options] - Optional `options` for `del` operation including params e.g. `{preheatCache: true, strategy: 'UPDATE', mergeMode: 'REPLACE'}`. Run `discover` or see {@link https://docs.dhis2.org/2.34/en/dhis2_developer_manual/web-api.html#create-update-parameters DHIS2 documentation}. Defaults to `{operationName: 'delete', apiVersion: state.configuration.apiVersion, responseType: 'json'}`\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a tracked entity instance</caption>\n * destroy('trackedEntityInstances', 'LcRd6Nyaq7T');\n */\nexport function destroy(\n    resourceType,\n    path,\n    data = null,\n    options = {},\n    callback = false\n) {\n    return state => {\n        console.log('Preparing destroy operation...');\n\n        const resolvedResourceType = expandReferences(resourceType)(state);\n        const resolvedPath = expandReferences(path)(state);\n        const resolvedData = expandReferences(data)(state);\n        const resolvedOptions = expandReferences(options)(state);\n\n        const { params, requestConfig } = resolvedOptions;\n        const { configuration } = state;\n\n        return request({\n            method: 'delete',\n            url: generateUrl(\n                configuration,\n                resolvedOptions,\n                resolvedResourceType,\n                resolvedPath\n            ),\n            params,\n            resolvedData,\n            ...requestConfig,\n        }).then(result => {\n            console.log(`Deleted ${resolvedResourceType} at ${resolvedPath}`);\n            return handleResponse(result, state, callback);\n        });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Upsert a record. A generic helper function used to atomically either insert a row, or on the basis of the row already existing, UPDATE that existing row instead.\n * @public\n * @function\n * @param {string} resourceType - The type of a resource to `upsert`. E.g. `trackedEntityInstances`\n * @param {Object} query - A query object that allows to uniquely identify the resource to update. If no matches found, then the resource will be created.\n * @param {Object} data - The data to use for update or create depending on the result of the query.\n * @param {{ apiVersion: object, requestConfig: object, params: object }} [options] - Optional configuration that will be applied to both the `get` and the `create` or `update` operations.\n * @param {function} [callback] - Optional callback to handle the response\n * @throws {RangeError} - Throws range error\n * @returns {Operation}\n * @example <caption>Example `expression.js` of upsert</caption>\n * upsert('trackedEntityInstances', {\n *  ou: 'TSyzvBiovKh',\n *  filter: ['w75KJ2mc4zz:Eq:Qassim'],\n * }, {\n *  orgUnit: 'TSyzvBiovKh',\n *  trackedEntityType: 'nEenWmSyUEp',\n *  attributes: [\n *    {\n *      attribute: 'w75KJ2mc4zz',\n *      value: 'Qassim',\n *    },\n *  ],\n * });\n */\nexport function upsert(resourceType: string, query: any, data: any, options?: {\n    apiVersion: object;\n    requestConfig: object;\n    params: object;\n}, callback?: Function): Operation;",
    "completion": "import axios from 'axios';\nimport Qs from 'qs';\n\nexport function generateUrl(configuration, options, resourceType, path = null) {\n    let { hostUrl, apiVersion } = configuration;\n    const urlString = '/' + resourceType;\n\n    // Note that users can override the apiVersion from configuration with args\n    if (options?.apiVersion) apiVersion = options.apiVersion;\n\n    const apiMessage = apiVersion\n        ? `Using DHIS2 api version ${apiVersion}`\n        : 'Using latest available version of the DHIS2 api on this server.';\n\n    console.log(apiMessage);\n\n    const url = buildUrl(urlString, hostUrl, apiVersion);\n\n    if (path) return `${url}/${path}`;\n    return url;\n}\n\nexport function handleResponse(result, state, callback) {\n    const { data } = result;\n    if (callback) return callback(composeNextState(state, data));\n    return composeNextState(state, data);\n}\n\nexport function request({ username, password }, axiosRequest) {\n    const { method, url, params } = axiosRequest;\n\n    console.log(`Sending ${method} request to ${url}`);\n    if (params) console.log(` with params:`, params);\n\n    const safeRedirect = ['get', 'head', 'options', 'trace'].includes(\n        method.toLowerCase()\n    );\n\n    return axios({\n        headers: { 'Content-Type': 'application/json' },\n        responseType: 'json',\n        maxRedirects: safeRedirect ? 5 : 0,\n        auth: { username, password },\n        paramsSerializer: params => Qs.stringify(params, { arrayFormat: 'repeat' }),\n        // Note that providing headers or auth in the request object will overwrite.\n        ...axiosRequest,\n    });\n}\n\n/**\n * Upsert a record. A generic helper function used to atomically either insert a row, or on the basis of the row already existing, UPDATE that existing row instead.\n * @public\n * @function\n * @param {string} resourceType - The type of a resource to `upsert`. E.g. `trackedEntityInstances`\n * @param {Object} query - A query object that allows to uniquely identify the resource to update. If no matches found, then the resource will be created.\n * @param {Object} data - The data to use for update or create depending on the result of the query.\n * @param {{ apiVersion: object, requestConfig: object, params: object }} [options] - Optional configuration that will be applied to both the `get` and the `create` or `update` operations.\n * @param {function} [callback] - Optional callback to handle the response\n * @throws {RangeError} - Throws range error\n * @returns {Operation}\n * @example <caption>Example `expression.js` of upsert</caption>\n * upsert('trackedEntityInstances', {\n *  ou: 'TSyzvBiovKh',\n *  filter: ['w75KJ2mc4zz:Eq:Qassim'],\n * }, {\n *  orgUnit: 'TSyzvBiovKh',\n *  trackedEntityType: 'nEenWmSyUEp',\n *  attributes: [\n *    {\n *      attribute: 'w75KJ2mc4zz',\n *      value: 'Qassim',\n *    },\n *  ],\n * });\n */\nexport function upsert(\n    resourceType,\n    query,\n    data,\n    options = {},\n    callback = false\n) {\n    return state => {\n        console.log(`Preparing upsert via 'get' then 'create' OR 'update'...`);\n\n        return get(\n            resourceType,\n            query,\n            options\n        )(state)\n            .then(resp => {\n                const resources = resp.data[resourceType];\n                if (resources.length > 1) {\n                    throw new RangeError(\n                        `Cannot upsert on Non-unique attribute. The operation found ${resources.length} ${resourceType} matching the given attributes.`\n                    );\n                }\n\n                if (resources.length === 1) {\n                    return update(\n                        resourceType,\n                        resources[0].id,\n                        data,\n                        options,\n                        callback\n                    )(state);\n                } else {\n                    return create(resourceType, data, options, callback)(state);\n                }\n            })\n            .catch(error => {\n                console.error(`Error during upsert: ${error.message}`);\n                return Promise.reject(error);\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get data. Generic helper method for getting data of any kind from DHIS2.\n * - This can be used to get `DataValueSets`,`events`,`trackedEntityInstances`,`etc.`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to get(use its `plural` name). E.g. `dataElements`, `trackedEntityInstances`,`organisationUnits`, etc.\n * @param {Object} query - A query object that will limit what resources are retrieved when converted into request params.\n * @param {Object} [options] - Optional `options` to define URL parameters via params beyond filters, request configuration (e.g. `auth`) and DHIS2 api version to use.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation} state\n * @example <caption>all data values for the 'pBOMPrpg1QX' dataset</caption>\n * get('dataValueSets', {\n *   dataSet: 'pBOMPrpg1QX',\n *   orgUnit: 'DiszpKrYNg8',\n *   period: '201401',\n *   fields: '*',\n * });\n * @example <caption>all programs for an organization unit</caption>\n * get('programs', { orgUnit: 'TSyzvBiovKh', fields: '*' });\n * @example <caption>a single tracked entity instance by a unique external ID</caption>\n * get('trackedEntityInstances', {\n *   ou: 'DiszpKrYNg8',\n *   filter: ['flGbXLXCrEo:Eq:124', 'w75KJ2mc4zz:Eq:John'],\n * });\n */\nexport function get(resourceType: string, query: any, options?: any, callback?: Function): Operation;",
    "completion": "import axios from 'axios';\nimport Qs from 'qs';\nimport { expandReferences } from '@openfn/language-common';\n\nexport function generateUrl(configuration, options, resourceType, path = null) {\n    let { hostUrl, apiVersion } = configuration;\n    const urlString = '/' + resourceType;\n\n    // Note that users can override the apiVersion from configuration with args\n    if (options?.apiVersion) apiVersion = options.apiVersion;\n\n    const apiMessage = apiVersion\n        ? `Using DHIS2 api version ${apiVersion}`\n        : 'Using latest available version of the DHIS2 api on this server.';\n\n    console.log(apiMessage);\n\n    const url = buildUrl(urlString, hostUrl, apiVersion);\n\n    if (path) return `${url}/${path}`;\n    return url;\n}\n\nexport function handleResponse(result, state, callback) {\n    const { data } = result;\n    if (callback) return callback(composeNextState(state, data));\n    return composeNextState(state, data);\n}\n\nexport function request({ username, password }, axiosRequest) {\n    const { method, url, params } = axiosRequest;\n\n    console.log(`Sending ${method} request to ${url}`);\n    if (params) console.log(` with params:`, params);\n\n    const safeRedirect = ['get', 'head', 'options', 'trace'].includes(\n        method.toLowerCase()\n    );\n\n    return axios({\n        headers: { 'Content-Type': 'application/json' },\n        responseType: 'json',\n        maxRedirects: safeRedirect ? 5 : 0,\n        auth: { username, password },\n        paramsSerializer: params => Qs.stringify(params, { arrayFormat: 'repeat' }),\n        // Note that providing headers or auth in the request object will overwrite.\n        ...axiosRequest,\n    });\n}\n\n/**\n * Get data. Generic helper method for getting data of any kind from DHIS2.\n * - This can be used to get `DataValueSets`,`events`,`trackedEntityInstances`,`etc.`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to get(use its `plural` name). E.g. `dataElements`, `trackedEntityInstances`,`organisationUnits`, etc.\n * @param {Object} query - A query object that will limit what resources are retrieved when converted into request params.\n * @param {Object} [options] - Optional `options` to define URL parameters via params beyond filters, request configuration (e.g. `auth`) and DHIS2 api version to use.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation} state\n * @example <caption>all data values for the 'pBOMPrpg1QX' dataset</caption>\n * get('dataValueSets', {\n *   dataSet: 'pBOMPrpg1QX',\n *   orgUnit: 'DiszpKrYNg8',\n *   period: '201401',\n *   fields: '*',\n * });\n * @example <caption>all programs for an organization unit</caption>\n * get('programs', { orgUnit: 'TSyzvBiovKh', fields: '*' });\n * @example <caption>a single tracked entity instance by a unique external ID</caption>\n * get('trackedEntityInstances', {\n *   ou: 'DiszpKrYNg8',\n *   filter: ['flGbXLXCrEo:Eq:124', 'w75KJ2mc4zz:Eq:John'],\n * });\n */\nexport function get(resourceType, query, options = {}, callback = false) {\n    return state => {\n        console.log('Preparing get operation...');\n\n        const resolvedResourceType = expandReferences(resourceType)(state);\n        const resolvedQuery = expandReferences(query)(state);\n        const resolvedOptions = expandReferences(options)(state);\n\n        const { params, requestConfig } = resolvedOptions;\n        const { configuration } = state;\n\n        return request(configuration, {\n            method: 'get',\n            url: generateUrl(configuration, resolvedOptions, resolvedResourceType),\n            params: { ...resolvedQuery, ...params },\n            responseType: 'json',\n            ...requestConfig,\n        }).then(result => {\n            console.log(`Retrieved ${resolvedResourceType}`);\n            return handleResponse(result, state, callback);\n        });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Post a message on Facebook\n * @public\n * @example\n * postMessage({\n *  \"recipient\": {\n *     \"id\": \"your-psid\"\n *   },\n *   \"message\": {\n *     \"text\": \"your-message\"\n *   }\n * })\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function postMessage(params: object): Operation;",
    "completion": "/**\n * Post a message on Facebook\n * @public\n * @example\n * postMessage({\n *  \"recipient\": {\n *     \"id\": \"your-psid\"\n *   },\n *   \"message\": {\n *     \"text\": \"your-message\"\n *   }\n * })\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function postMessage(params) {\n    return state => {\n      function assembleError({ response, error }) {\n        if (response && [200, 201, 202, 204].indexOf(response.statusCode) > -1)\n          return false;\n        if (error) return error;\n        return new Error(`Server responded with ${response.statusCode}`);\n      }\n  \n      const { accessToken } = state.configuration;\n  \n      const url = `https://graph.facebook.com/v2.6/me/messages?access_token=${accessToken}`;\n  \n      const { headers, message, recipient } = expandReferences(params)(state);\n  \n      const body = {\n        messaging_type: 'UPDATE',\n        recipient: recipient,\n        message: message,\n      };\n  \n      return new Promise((resolve, reject) => {\n        console.log('Request body:');\n        console.log('\\n' + JSON.stringify(body, null, 4) + '\\n');\n        request.post(\n          {\n            url,\n            headers,\n            json: body,\n          },\n          function (err, response, body) {\n            const error = assembleError({ error: err, response });\n            if (error) {\n              reject(error);\n              console.log(response);\n            } else {\n              console.log('Printing response...\\n');\n              console.log(JSON.stringify(response, null, 4) + '\\n');\n              console.log('Post Message succeeded.');\n              resolve(body);\n            }\n          }\n        );\n      }).then(response => {\n        const nextState = composeNextState(state, response);\n        return nextState;\n      });\n    };\n  }"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Create an event\n * @example\n * execute(\n *   event(eventData)\n * )(state)\n * @function\n * @param {object} eventData - Payload data for the event\n * @returns {Operation}\n */\nexport function submitSite(collection_id: any, submissionData: any): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport request from 'request';\n\n/**\n * Create an event\n * @example\n * execute(\n *   event(eventData)\n * )(state)\n * @function\n * @param {object} eventData - Payload data for the event\n * @returns {Operation}\n */\nexport function submitSite(collection_id, submissionData) {\n  function assembleError({ response, error }) {\n    if ([200, 201, 202].indexOf(response.statusCode) > -1) return false;\n    if (error) return error;\n    return new Error(\n      `Server responded with ${response.statusCode} \\n ${response.body}`\n    );\n  }\n\n  return state => {\n    const body = expandReferences(submissionData)(state);\n    console.log(\n      'Submitting site to collection ' +\n      collection_id +\n      ':' +\n      '\\n' +\n      JSON.stringify(body, null, 4) +\n      '\\n'\n    );\n\n    const { username, password, baseUrl } = state.configuration;\n\n    // /api/collections/:collection_id/sites.json\n    const url = resolveUrl(\n      baseUrl + '/',\n      'api/collections/' + collection_id + '/sites.json'\n    );\n\n    return new Promise((resolve, reject) => {\n      request.post(\n        {\n          url: url,\n          json: body,\n          auth: {\n            user: username,\n            pass: password,\n            sendImmediately: true,\n          },\n          headers: {\n            'content-disposition': 'form-data; name=\\\\\"site\\\\\"',\n          },\n        },\n        function (err, response, body) {\n          const error = assembleError({ error: err, response });\n          if (error) {\n            reject(error);\n          } else {\n            console.log('Printing response...\\n');\n            console.log(JSON.stringify(response, null, 4) + '\\n');\n            console.log('Site submission succeeded.');\n            resolve(body);\n          }\n        }\n      );\n    });\n\n    return request.post({\n      username,\n      password,\n      body,\n      url,\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Create a collection request\n * @example\n * execute(\n *   createCollectionRequest(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the collection request\n * @returns {Operation}\n */\nexport function createCollectionRequest(data: object): Operation;",
    "completion": "import { resolve as resolveUrl } from 'url';\nimport { expandReferences } from '@openfn/language-common';\nimport request from 'superagent'\n\n/**\n * Create a collection request\n * @example\n * execute(\n *   createCollectionRequest(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the collection request\n * @returns {Operation}\n */\nexport function createCollectionRequest(data) {\n    return state => {\n        const body = expandReferences(data)(state);\n\n        const { apiUrl, apiToken } = state.configuration;\n\n        const url = resolveUrl(apiUrl + '/', 'collectionrequests');\n\n        console.log('Posting collection request:');\n        console.log(body);\n\n        return new Promise((resolve, reject) => {\n            request.post(url)\n                .type('json')\n                .accept('json')\n                .set('Authorization', `Token ${apiToken}`)\n                .send(JSON.stringify(body))\n                .end((error, res) => {\n                    if (!!error || !res.ok) {\n                        reject(error)\n                    }\n\n                    resolve(res)\n                })\n        }).then(result => {\n            console.log('Success:', result);\n            return { ...state, references: [result, ...state.references] };\n        });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Create a payment\n * @example\n * execute(\n *   createPayment(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the payment\n * @returns {Operation}\n */\nexport function createPayment(data: object): Operation;",
    "completion": "import { resolve as resolveUrl } from 'url';\nimport { expandReferences } from '@openfn/language-common';\nimport request from 'superagent'\n\n/**\n * Create a payment\n * @example\n * execute(\n *   createPayment(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the payment\n * @returns {Operation}\n */\nexport function createPayment(data) {\n    return state => {\n        const body = expandReferences(data)(state);\n\n        const { apiUrl, apiToken } = state.configuration;\n\n        const url = resolveUrl(apiUrl + '/', 'payments');\n\n        console.log('Posting payment:');\n        console.log(body);\n\n        return new Promise((resolve, reject) => {\n            request.post(url)\n                .type('json')\n                .accept('json')\n                .set('Authorization', `Token ${apiToken}`)\n                .send(JSON.stringify(body))\n                .end((error, res) => {\n                    if (!!error || !res.ok) {\n                        reject(error)\n                    }\n\n                    resolve(res)\n                })\n        }).then(result => {\n            console.log('Success:', result);\n            return { ...state, references: [result, ...state.references] };\n        });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Create a contact\n * @example\n * execute(\n *   createContact(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the contact\n * @returns {Operation}\n */\nexport function createContact(data: object): Operation;",
    "completion": "import { resolve as resolveUrl } from 'url';\nimport { expandReferences } from '@openfn/language-common';\nimport request from 'superagent'\n\n/**\n * Create a contact\n * @example\n * execute(\n *   createContact(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the contact\n * @returns {Operation}\n */\nexport function createContact(data) {\n    return state => {\n        const body = expandReferences(data)(state);\n\n        const { apiUrl, apiToken } = state.configuration;\n\n        const url = resolveUrl(apiUrl + '/', 'contacts');\n\n        console.log('Posting contact:');\n        console.log(body);\n\n        return new Promise((resolve, reject) => {\n            request.post(url)\n                .type('json')\n                .accept('json')\n                .set('Authorization', `Token ${apiToken}`)\n                .send(JSON.stringify(body))\n                .end((error, res) => {\n                    if (!!error || !res.ok) {\n                        reject(error)\n                    }\n\n                    resolve(res)\n                })\n        }).then(result => {\n            console.log('Success:', result);\n            return { ...state, references: [result, ...state.references] };\n        });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for khanacademy.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "completion": "import {\n  execute as commonExecute,\n} from '@openfn/language-common';\n\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for khanacademy.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Fetch data from the Khan Academy API\n * @example\n * execute(\n *   fetch(params)\n * )(state)\n * @function\n * @param {object} params - data to make the query\n * @returns {Operation}\n */\nexport function fetch(params: object): Operation;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport { resolve as resolveUrl } from 'url';\nimport request from 'request';\nimport qs from 'qs';\n\n/**\n * Fetch data from the Khan Academy API\n * @example\n * execute(\n *   fetch(params)\n * )(state)\n * @function\n * @param {object} params - data to make the query\n * @returns {Operation}\n */\nexport function fetch(params) {\n  function assembleError({ response, error }) {\n    if (response && [200, 201, 202].indexOf(response.statusCode) > -1)\n      return false;\n    if (error) return error;\n    return new Error(`Server responded with ${response.statusCode}`);\n  }\n\n  return state => {\n    const { email, password, consumerKey, secretKey } = state.configuration;\n\n    const { getEndpoint, queryParams, postUrl } =\n      expandReferences(params)(state);\n\n    const query = qs.stringify(queryParams);\n\n    const getUrl = resolveUrl(\n      'https://www.khanacademy.org/api/v1' + '/',\n      getEndpoint + '?' + query\n    );\n\n    console.log('Fetching data from URL: ' + getUrl);\n\n    var getTokenURL = 'https://www.khanacademy.org/api/auth2/request_token';\n    var authorizeURL = 'https://www.khanacademy.org/api/auth2/authorize';\n    var accessTokenUrl = 'https://www.khanacademy.org/api/auth2/access_token';\n\n    var nativeOAuthOptions = {\n      consumer_key: consumerKey,\n      consumer_secret: secretKey,\n    };\n\n    return (\n      new Promise((resolve, reject) => {\n        request.post(\n          {\n            url: getTokenURL,\n            oauth: nativeOAuthOptions,\n          },\n          function (err, response, body) {\n            const error = assembleError({ error: err, response });\n            if (error) {\n              console.error('Token request failed.... KHAAAAAAN!');\n              reject(error);\n            } else {\n              console.log('Token request successful.');\n              resolve(qs.parse(body));\n            }\n          }\n        );\n      })\n\n        .then(body => {\n          // save for later!\n          var auth = {\n            oauth_token: body.oauth_token,\n            oauth_token_secret: body.oauth_token_secret,\n          };\n\n          // pull out the oauth_token and use it in the next post to authorize\n          var bodyParams = {\n            oauth_token: body.oauth_token,\n            identifier: email,\n            password: password,\n          };\n\n          // authorize the token\n          return new Promise((resolve, reject) => {\n            request.post(\n              {\n                followAllRedirects: true,\n                url: authorizeURL,\n                form: bodyParams,\n              },\n              function (err, response, body) {\n                const error = assembleError({ error: err, response });\n                if (error) {\n                  console.error('Token authorization failed... KHAAAAAAN!');\n                  reject(error);\n                } else {\n                  console.log('Token auhorization successful.');\n                  resolve(auth);\n                }\n              }\n            );\n          });\n        })\n\n        .then(auth => {\n          // configure authorized request for oauth\n          var hasToken = {\n            consumer_key: consumerKey,\n            consumer_secret: secretKey,\n            token: auth.oauth_token,\n            token_secret: auth.oauth_token_secret,\n          };\n\n          // exchange for an access token\n          return new Promise((resolve, reject) => {\n            request.get(\n              {\n                url: accessTokenUrl,\n                oauth: hasToken,\n              },\n              function (err, response, body) {\n                const error = assembleError({ error: err, response });\n                if (error) {\n                  console.error('Token exchange failed.... KHAAAAAAN!');\n                  reject(error);\n                } else {\n                  console.log('Token exchange successful.');\n                  resolve(qs.parse(body));\n                }\n              }\n            );\n          });\n        })\n\n        .then(body => {\n          // confiure request with shiny new access token\n          var hasAccess = {\n            consumer_key: consumerKey,\n            consumer_secret: secretKey,\n            token: body.oauth_token,\n            token_secret: body.oauth_token_secret,\n          };\n\n          // make authenticated GET from Khan!\n          return new Promise((resolve, reject) => {\n            request.get(\n              {\n                url: getUrl,\n                oauth: hasAccess,\n              },\n              function (err, response, body) {\n                const error = assembleError({ error: err, response });\n                if (error) {\n                  console.error('GET failed.... KHAAAAAAN!');\n                  reject(error);\n                } else {\n                  console.log('GET succeeded.');\n                  console.log(body);\n                  resolve(body);\n                }\n              }\n            );\n          });\n        })\n\n        // post it somewhere else\n        .then(body => {\n          return new Promise((resolve, reject) => {\n            request.post(\n              {\n                url: postUrl,\n                json: JSON.parse(body),\n              },\n              function (err, response, body) {\n                const error = assembleError({ error: err, response });\n                if (error) {\n                  console.error('POST failed.... KHAAAAAAN!');\n                  reject(error);\n                } else {\n                  console.log('POST succeeded.');\n                  resolve(body);\n                }\n              }\n            );\n          });\n        })\n    );\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Sends a message to a list of contacts and/or URNs\n * @public\n * @example\n * sendBroadcast({\n *   text: \"Hello world\",\n *   urns: [\"twitter:sirmixalot\"],\n *   contacts: [\"a052b00c-15b3-48e6-9771-edbaa277a353\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function sendBroadcast(params: object, callback: Function): Operation;",
    "completion": "import {\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n\n/**\n * Sends a message to a list of contacts and/or URNs\n * @public\n * @example\n * sendBroadcast({\n *   text: \"Hello world\",\n *   urns: [\"twitter:sirmixalot\"],\n *   contacts: [\"a052b00c-15b3-48e6-9771-edbaa277a353\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function sendBroadcast(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { host, apiVersion, token } = state.configuration;\n\n    const url = `${host}/api/${apiVersion || 'v2'}/broadcasts.json`;\n\n    const config = {\n      url,\n      data: resolvedParams,\n      headers: {\n        Authorization: `Token ${token}`,\n        'Content-Type': 'application/json',\n      },\n    };\n\n    return http\n      .post(config)(state)\n      .catch(error => {\n        console.log(error.response);\n        throw 'That was an error from RapidPro.';\n      })\n      .then(response => {\n        console.log('Broadcast queued:', response.data);\n        const nextState = {\n          ...composeNextState(state, response.data),\n          response,\n        };\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Start a RapidPro flow for a number of contacts\n * @public\n * @example\n * startFlow({\n *   flow: \"f5901b62-ba76-4003-9c62-72fdacc1b7b7\",\n *   restart_participants: false,\n *   contacts: [\"a052b00c-15b3-48e6-9771-edbaa277a353\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function startFlow(params: object, callback: Function): Operation;",
    "completion": "import {\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n\n/**\n * Start a RapidPro flow for a number of contacts\n * @public\n * @example\n * startFlow({\n *   flow: \"f5901b62-ba76-4003-9c62-72fdacc1b7b7\",\n *   restart_participants: false,\n *   contacts: [\"a052b00c-15b3-48e6-9771-edbaa277a353\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function startFlow(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { host, apiVersion, token } = state.configuration;\n\n    const url = `${host}/api/${apiVersion || 'v2'}/flow_starts.json`;\n\n    const config = {\n      url,\n      data: resolvedParams,\n      headers: {\n        Authorization: `Token ${token}`,\n        'Content-Type': 'application/json',\n      },\n    };\n\n    return http\n      .post(config)(state)\n      .catch(error => {\n        console.log(error.response);\n        throw 'That was an error from RapidPro.';\n      })\n      .then(response => {\n        console.log('Flow started:', response.data);\n        const nextState = {\n          ...composeNextState(state, response.data),\n          response,\n        };\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Upserts a contact to RapidPro by URN\n * @public\n * @example\n * upsertContact({\n *   name: \"Mamadou\",\n *   language: \"ENG\",\n *   urns: [\"tel:+250788123123\"]\n * });\n * @function\n * @param {object} params - data to upsert a contact\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertContact(params: object, callback: Function): Operation;",
    "completion": "import {\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n\n/**\n * Upserts a contact to RapidPro by URN\n * @public\n * @example\n * upsertContact({\n *   name: \"Mamadou\",\n *   language: \"ENG\",\n *   urns: [\"tel:+250788123123\"]\n * });\n * @function\n * @param {object} params - data to upsert a contact\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertContact(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { host, apiVersion, token } = state.configuration;\n\n    const url = `${host}/api/${apiVersion || 'v2'}/contacts.json`;\n\n    const config = {\n      url,\n      data: resolvedParams,\n      headers: { Authorization: `Token ${token}` },\n    };\n\n    return http\n      .post(config)(state)\n      .then(resp => {\n        console.log('Contact added with uuid:', resp.data.uuid);\n        return resp;\n      })\n      .catch(err => {\n        const { data } = err.response;\n        if (\n          data &&\n          data.urns &&\n          Array.isArray(data.urns) &&\n          data.urns.find(x => x.includes('URN belongs to another'))\n        ) {\n          const newUrl = `${url}?urn=${config.data.urns[0]}`;\n          delete config.data['urns'];\n          return http\n            .post({ ...config, url: newUrl })(state)\n            .then(resp => {\n              console.log('Contact updated with uuid:', resp.data.uuid);\n              return resp;\n            });\n        } else {\n          console.log(JSON.stringify(data, null, 2));\n\n          delete err.response.request;\n          delete err.response.config;\n\n          throw err.response;\n        }\n      })\n      .then(response => {\n        const nextState = {\n          ...composeNextState(state, response.data),\n          response,\n        };\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Adds a new contact to RapidPro\n * @public\n * @example\n * addContact({\n *   name: \"Mamadou\",\n *   language: \"ENG\",\n *   urns: [\"tel:+250788123123\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function addContact(params: object, callback: Function): Operation;",
    "completion": "import {\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n\n/**\n * Adds a new contact to RapidPro\n * @public\n * @example\n * addContact({\n *   name: \"Mamadou\",\n *   language: \"ENG\",\n *   urns: [\"tel:+250788123123\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function addContact(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { host, apiVersion, token } = state.configuration;\n\n    const url = `${host}/api/${apiVersion || 'v2'}/contacts.json`;\n\n    const config = {\n      url,\n      data: resolvedParams,\n      headers: { Authorization: `Token ${token}` },\n    };\n\n    return http\n      .post(config)(state)\n      .then(response => {\n        console.log('Contact added with uuid:', response.data.uuid);\n        const nextState = {\n          ...composeNextState(state, response.data),\n          response,\n        };\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function send(params: any): (state: any) => Promise<any>;",
    "completion": "import {\n  expandReferences,\n} from '@openfn/language-common';\nimport request from 'request';\n\n/**\n * Sends an SMS message using the SMPP protocol.\n *\n * @function\n * @param {Object} params - The parameters for sending the SMS.\n * @param {string} params.recipient - The recipient's phone number.\n * @param {string} params.sender - The sender's phone number.\n * @param {string} params.text - The text content of the SMS.\n * @param {string} params.smsId - The unique identifier for the SMS.\n * @returns {Function} - A function that takes a state and returns a promise.\n * @throws {Error} - Throws an error if the server responds with a non-success status code.\n * @example\n * const sendSMS = send({\n *   recipient: '+1234567890',\n *   sender: '+9876543210',\n *   text: 'Hello, World!',\n *   smsId: '123456789'\n * });\n *\n * const newState = sendSMS(initialState)\n *   .then((updatedState) => {\n *     console.log('SMS sent successfully:', updatedState.response.body);\n *   })\n *   .catch((error) => {\n *     console.error('Error sending SMS:', error.message);\n *   });\n */\nexport function send(params) {\n  return state => {\n    const { recipient, sender, text, smsId } = expandReferences(params)(state);\n\n    const { systemId, password, clientHost, inboxId } = state.configuration;\n\n    const url = `${clientHost}/smpp/${inboxId}/send`;\n\n    const body = { recipient, sender, text, smsId };\n\n    const auth = {\n      username: systemId,\n      password: password,\n    };\n\n    function assembleError({ response, error }) {\n      if (response && [200, 201, 202, 204].indexOf(response.statusCode) > -1)\n        return false;\n      if (error) return error;\n      return new Error(`Server responded with ${response.statusCode}`);\n    }\n\n    console.log('Sending message... ' + url);\n    console.log('With body: ' + JSON.stringify(body, null, 2));\n\n    return new Promise((resolve, reject) => {\n      request.post(\n        {\n          url: url,\n          json: body,\n          auth,\n        },\n        function (err, response, body) {\n          const error = assembleError({ error: err, response });\n          if (error) {\n            reject(error);\n          } else {\n            console.log(\n              'Message sent to SMPP server: ' +\n              response.statusCode +\n              '/' +\n              response.statusMessage\n            );\n            resolve(response);\n          }\n        }\n      );\n    }).then(data => {\n      const nextState = { ...state, response: { body: data } };\n      return nextState;\n    });\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Add rows to a table\n * @example\n * execute(\n *   addRow(table, rowData)\n * )(state)\n * @function\n * @param {String} table - Table name\n * @param {object} rowData - data to add in the row\n * @returns {Operation}\n */\nexport function addRow(table, rowData): Operation;",
    "completion": "import { expandReferences, jsonSql } from 'json-sql';\nimport request from 'superagent'\n\n/**\n * Add rows to a table\n * @example\n * execute(\n *   addRow(table, rowData)\n * )(state)\n * @function\n * @param {String} table - Table name\n * @param {object} rowData - data to add in the row\n * @returns {Operation}\n */\nexport function addRow(table, rowData) {\n    return state => {\n        const dataObject = expandReferences(rowData)(state);\n\n        const sql = jsonSql.build({\n            type: 'insert',\n            table: table,\n            values: dataObject,\n        });\n\n        const body = Object.keys(sql.values).reduce(function (query, valueKey) {\n            return query.replace(`\\$${valueKey}`, `'${sql.values[valueKey]}'`);\n        }, sql.query);\n\n        const { account, apiKey } = state.configuration;\n\n        const url = 'https://'.concat(account, '.carto.com/api/v2/sql');\n\n        console.log(url);\n        console.log('Executing SQL query:');\n        console.log(body);\n\n        return new Promise((resolve, reject) => {\n            request.get(url)\n                .query({ q: body })\n                .query({ api_key: apiKey })\n                .end((error, res) => {\n                    if (!!error || !res.ok) {\n                        reject(error)\n                    }\n\n                    resolve(res)\n                })\n\n        }).then(result => {\n            console.log('Success:', result);\n            return { ...state, references: [result, ...state.references] };\n        });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Execute an SQL statement\n * @example\n * execute(\n *   sql(sqlQuery)\n * )(state)\n * @function\n * @param {object} sqlQuery - Payload data for the message\n * @returns {Operation}\n */\nexport function sql(sqlQuery): Operation;",
    "completion": "import request from 'superagent'\n\n/**\n * Execute an SQL statement\n * @example\n * execute(\n *   sql(sqlQuery)\n * )(state)\n * @function\n * @param {object} sqlQuery - Payload data for the message\n * @returns {Operation}\n */\nexport function sql(sqlQuery) {\n    return state => {\n        const body = sqlQuery(state);\n\n        const { account, apiKey } = state.configuration;\n\n        const url = 'https://'.concat(account, '.carto.com/api/v2/sql');\n\n        console.log(url);\n        console.log('Executing SQL query:');\n        console.log(body);\n\n        return new Promise((resolve, reject) => {\n            request.get(url)\n                .query({ q: body })\n                .query({ api_key: apiKey })\n                .end((error, res) => {\n                    if (!!error || !res.ok) {\n                        reject(error)\n                    }\n\n                    resolve(res)\n                })\n\n        }).then(result => {\n            console.log('Success:', result);\n            return { ...state, references: [result, ...state.references] };\n        });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Creates a resource in a destination system on FHIR using a POST request\n * @public\n * @example\n * create(\"Bundle\", {...state.data: type: \"collection\"})\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function create(path: string, params: object, callback: Function): Operation;",
    "completion": "import { fetch } from 'undici';\nimport { composeNextState } from '@openfn/language-common';\n\nexport function handleResponse(response, state, callback) {\n  const nextState = {\n    ...composeNextState(state, response),\n    response,\n  };\n  if (callback) return callback(nextState);\n  return nextState;\n}\n\nexport function handleResponseError(response, data, method) {\n  const { status, statusText, url } = response;\n\n  if (!response.ok) {\n    const errorString = [\n      `Message: ${statusText}`,\n      `Request: ${method} ${url}`,\n      `Status: ${status}`,\n      `Body: ${JSON.stringify(data, null, 2).replace(/\\n/g, '\\n\\t  ')}`,\n    ].join('\\n\\t\u221f ');\n    throw new Error(errorString);\n  }\n}\n\n/**\n * This is an asynchronous function that sends a request to a specified URL with optional parameters\n * and headers, and returns the response data in JSON format.\n * @param {string} url - The URL of the API endpoint that the request is being made to.\n * @param {object} [params] - An object containing any additional parameters to be sent with the request, such\n * as query parameters or request body data. It is an optional parameter and defaults to an empty\n * object if not provided.\n * @param {string} [method=GET] - The HTTP method to be used for the request. It defaults to 'GET' if not\n * specified.\n * @returns The `request` function is returning the parsed JSON data from the response of the HTTP\n * request made to the specified `url` with the given `params` and `method`. If there is an error in\n * the response, the function will throw an error.\n */\nexport const request = async (urlString, params = {}, method = 'GET') => {\n  let url = urlString;\n  const defaultHeaders = { 'Content-Type': 'application/fhir+json' };\n  const { headers } = params;\n  const setHeaders = { ...headers, ...defaultHeaders };\n\n  delete params.headers;\n\n  let options = {\n    method,\n    headers: setHeaders, // Add nonce for WP REST API\n  };\n\n  if ('GET' === method) {\n    url = `${urlString}?${new URLSearchParams(params).toString()}`;\n  } else {\n    options.body = JSON.stringify(params);\n  }\n\n  const response = await fetch(url, options);\n  const contentType = response.headers.get('Content-Type');\n\n  const data = contentType?.includes('application/fhir+json')\n    ? await response.json()\n    : await response.text();\n\n  handleResponseError(response, data, method);\n\n  return data;\n};\n\n/**\n * Creates a resource in a destination system on FHIR using a POST request\n * @public\n * @example\n * create(\"Bundle\", {...state.data: type: \"collection\"})\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function create(path, params, callback) {\n  return state => {\n    const [resolvedpath, resolvedParams] = expandReferences(\n      state,\n      path,\n      params\n    );\n\n    const { baseUrl, apiPath } = state.configuration;\n\n    const url = `${baseUrl}/${apiPath}/${resolvedpath}`;\n\n    const options = {\n      headers: {\n        accept: 'application/fhir+json',\n        'Content-Type': 'application/fhir+json',\n      },\n      ...resolvedParams,\n    };\n\n    return request(url, options, 'POST').then(response =>\n      handleResponse(response, state, callback)\n    );\n  };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get Claim in a FHIR system\n * @public\n * @example\n * getClaim({ _include: \"Claim:patient\", _sort: \"-_lastUpdated\", _count: 200 });\n * @function\n * @param {string} claimId - (optional) claim id\n * @param {object} query - (optinal) query parameters\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function getClaim(claimId: string, query: object, callback?: Function): Operation;",
    "completion": "import { composeNextState } from '@openfn/language-common';\n\nexport function handleResponse(response, state, callback) {\n    const nextState = {\n        ...composeNextState(state, response),\n        response,\n    };\n    if (callback) return callback(nextState);\n    return nextState;\n}\n\nexport function handleResponseError(response, data, method) {\n    const { status, statusText, url } = response;\n\n    if (!response.ok) {\n        const errorString = [\n            `Message: ${statusText}`,\n            `Request: ${method} ${url}`,\n            `Status: ${status}`,\n            `Body: ${JSON.stringify(data, null, 2).replace(/\\n/g, '\\n\\t  ')}`,\n        ].join('\\n\\t\u221f ');\n        throw new Error(errorString);\n    }\n}\n\n/**\n * Get Claim in a FHIR system\n * @public\n * @example\n * getClaim({ _include: \"Claim:patient\", _sort: \"-_lastUpdated\", _count: 200 });\n * @function\n * @param {string} claimId - (optional) claim id\n * @param {object} query - (optinal) query parameters\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function getClaim(claimId, query, callback = s => s) {\n    return state => {\n        const [resourcedclaimId, resolvedQuery] = expandReferences(\n            state,\n            claimId,\n            query\n        );\n\n        const { baseUrl, apiPath } = state.configuration;\n        const url = resourcedclaimId\n            ? `${baseUrl}/${apiPath}/Claim/${resourcedclaimId}`\n            : `${baseUrl}/${apiPath}/Claim`;\n\n        return request(url, { ...resolvedQuery }).then(response =>\n            handleResponse(response, state, callback)\n        );\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get a resource in a FHIR system\n * @public\n * @example <caption>Get Claim from FHIR with optional query</caption>\n * get(\"Claim\", { _include: \"Claim:patient\", _sort: \"-_lastUpdated\", _count: 200 })\n * @example <caption>Get Patient from FHIR</caption>\n * get('Patient');\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - data to get the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function get(path: string, query: object, callback?: Function): Operation;",
    "completion": "import { composeNextState } from '@openfn/language-common';\n\nexport function handleResponse(response, state, callback) {\n    const nextState = {\n        ...composeNextState(state, response),\n        response,\n    };\n    if (callback) return callback(nextState);\n    return nextState;\n}\n\nexport function handleResponseError(response, data, method) {\n    const { status, statusText, url } = response;\n\n    if (!response.ok) {\n        const errorString = [\n            `Message: ${statusText}`,\n            `Request: ${method} ${url}`,\n            `Status: ${status}`,\n            `Body: ${JSON.stringify(data, null, 2).replace(/\\n/g, '\\n\\t  ')}`,\n        ].join('\\n\\t\u221f ');\n        throw new Error(errorString);\n    }\n}\n\n/**\n * Get a resource in a FHIR system\n * @public\n * @example <caption>Get Claim from FHIR with optional query</caption>\n * get(\"Claim\", { _include: \"Claim:patient\", _sort: \"-_lastUpdated\", _count: 200 })\n * @example <caption>Get Patient from FHIR</caption>\n * get('Patient');\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - data to get the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function get(path, query, callback = s => s) {\n    return state => {\n        const [resolvedPath, resolvedQuery] = expandReferences(state, path, query);\n\n        const { baseUrl, apiPath } = state.configuration;\n        const url = `${baseUrl}/${apiPath}/${resolvedPath}`;\n\n        return request(url, { ...resolvedQuery }).then(response =>\n            handleResponse(response, state, callback)\n        );\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Creates a transactionBundle for HAPI FHIR\n * @public\n * @example\n * createTransactionBundle({\n *   resourceType: \"Bundle\",\n *   type: \"transaction\",\n *   entry: [\n *     {\n *       fullUrl: \"https://hapi.fhir.org/baseR4/Patient/592442\",\n *       resource: {\n *         resourceType: \"Patient\",\n *         id: \"592442\",\n *         name: [{ given: \"Caleb\", family: \"Cushing\" }],\n *       },\n *       request: {\n *         method: \"POST\",\n *         url: \"Patient\",\n *       },\n *     },\n *   ],\n * });\n * @function\n * @param {object} params - data to create the new transaction\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function createTransactionBundle(params: object, callback: Function): Operation;",
    "completion": "import { composeNextState } from '@openfn/language-common';\n\nexport function handleResponse(response, state, callback) {\n    const nextState = {\n        ...composeNextState(state, response),\n        response,\n    };\n    if (callback) return callback(nextState);\n    return nextState;\n}\n\nexport function handleResponseError(response, data, method) {\n    const { status, statusText, url } = response;\n\n    if (!response.ok) {\n        const errorString = [\n            `Message: ${statusText}`,\n            `Request: ${method} ${url}`,\n            `Status: ${status}`,\n            `Body: ${JSON.stringify(data, null, 2).replace(/\\n/g, '\\n\\t  ')}`,\n        ].join('\\n\\t\u221f ');\n        throw new Error(errorString);\n    }\n}\n\n/**\n * Creates a transactionBundle for HAPI FHIR\n * @public\n * @example\n * createTransactionBundle({\n *   resourceType: \"Bundle\",\n *   type: \"transaction\",\n *   entry: [\n *     {\n *       fullUrl: \"https://hapi.fhir.org/baseR4/Patient/592442\",\n *       resource: {\n *         resourceType: \"Patient\",\n *         id: \"592442\",\n *         name: [{ given: \"Caleb\", family: \"Cushing\" }],\n *       },\n *       request: {\n *         method: \"POST\",\n *         url: \"Patient\",\n *       },\n *     },\n *   ],\n * });\n * @function\n * @param {object} params - data to create the new transaction\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function createTransactionBundle(params, callback) {\n    return state => {\n        const [resolvedParams] = expandReferences(state, params);\n\n        const { baseUrl, apiPath, authType, token } = state.configuration;\n\n        const url = `${baseUrl}/${apiPath}`;\n        const auth = `${authType} ${token}`;\n\n        const options = {\n            body: {\n                resourceType: 'Bundle',\n                type: 'transaction',\n                entry: resolvedParams,\n            },\n            auth,\n        };\n\n        return request(url, options, 'POST').then(response =>\n            handleResponse(response, state, callback)\n        );\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "completion": "// Include all necessary dependencies for this script\nimport { commonExecute } from '@openfn/language-common';\n\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n    const initialState = {\n        references: [],\n        data: null,\n    };\n\n    return state => {\n        return commonExecute(...operations)({\n            ...initialState,\n            ...state,\n        });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get the list of tasks for a given project.\n * @public\n * @example\n * getTasks(\"projectGid\",\n *  {\n *    opt_fields: \"name,notes,assignee\"\n *  })\n * @function\n * @param {string} projectGid - Globally unique identifier for the project\n * @param {object} params - Query params to include.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function getTasks(projectGid: string, params: object, callback: Function): Operation;",
    "completion": "import { composeNextState, expandReferences, http } from '@openfn/language-common';\n\n/**\n * Get the list of tasks for a given project.\n * @public\n * @param {string} projectGid - Globally unique identifier for the project\n * @param {object} params - Query params to include.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function getTasks(projectGid, params, callback) {\n    return state => {\n        const resolvedProjectGid = expandReferences(projectGid)(state);\n        const { opt_fields } = expandReferences(params)(state);\n\n        const { apiVersion, token } = state.configuration;\n\n        const url = `https://app.asana.com/api/${apiVersion}/projects/${resolvedProjectGid}/tasks`;\n\n        const config = {\n            url,\n            headers: { Authorization: `Bearer ${token}` },\n            params: {\n                opt_fields,\n            },\n        };\n\n        return http\n            .get(config)(state)\n            .then(response => {\n                const nextState = {\n                    ...composeNextState(state, response.data),\n                    response,\n                };\n                if (callback) return callback(nextState);\n                return nextState;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Create a task.\n * @public\n * @example\n * createTask(\n *  {\n *    name: 'test', \"approval_status\": \"pending\", \"assignee\": \"12345\"\n *  }\n * )\n * @function\n * @param {object} params - Body parameters\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function createTask(params: object, callback: Function): Operation;",
    "completion": "import { composeNextState, expandReferences, http } from '@openfn/language-common';\n\n/**\n * Create a task.\n * @public\n * @param {object} params - Body parameters\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function createTask(params, callback) {\n    return state => {\n        const resolvedParams = expandReferences(params)(state);\n\n        const { apiVersion, token } = state.configuration;\n\n        const url = `https://app.asana.com/api/${apiVersion}/tasks/`;\n\n        const config = {\n            url,\n            data: { data: resolvedParams },\n            headers: { Authorization: `Bearer ${token}` },\n        };\n\n        return http\n            .post(config)(state)\n            .then(response => {\n                const nextState = {\n                    ...composeNextState(state, response.data),\n                    response,\n                };\n                if (callback) return callback(nextState);\n                return nextState;\n            })\n            .catch(e => {\n                console.log('Asana says:', e.response.data);\n                throw e;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Update a specific task.\n * @public\n * @example\n * updateTask(\"taskGid\",\n *  {\n *    name: 'test', \"approval_status\": \"pending\", \"assignee\": \"12345\"\n *  }\n * )\n * @function\n * @param {string} taskGid - Globally unique identifier for the task\n * @param {object} params - Body parameters\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function updateTask(taskGid: string, params: object, callback: Function): Operation;",
    "completion": "import { composeNextState, expandReferences, http } from '@openfn/language-common';\n\n/**\n * Update a specific task.\n * @public\n * @param {string} taskGid - Globally unique identifier for the task\n * @param {object} params - Body parameters\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function updateTask(taskGid, params, callback) {\n    return state => {\n        const resolvedTaskGid = expandReferences(taskGid)(state);\n        const resolvedParams = expandReferences(params)(state);\n\n        const { apiVersion, token } = state.configuration;\n\n        const url = `https://app.asana.com/api/${apiVersion}/tasks/${resolvedTaskGid}/`;\n\n        const config = {\n            url,\n            data: { data: resolvedParams },\n            headers: { Authorization: `Bearer ${token}` },\n        };\n\n        return http\n            .put(config)(state)\n            .then(response => {\n                const nextState = {\n                    ...composeNextState(state, response.data),\n                    response,\n                };\n                if (callback) return callback(nextState);\n                return nextState;\n            })\n            .catch(e => {\n                console.log('Asana says:', e.response.data);\n                throw e;\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Update or create a task.\n * @public\n * @example\n * upsertTask(\n *  \"1201382240880\",\n *  {\n *    \"externalId\": \"name\",\n *    \"data\": {\n *      name: 'test', \"approval_status\": \"pending\", \"assignee\": \"12345\"\n *    }\n *\n *  }\n * )\n * @function\n * @param {string} projectGid - Globally unique identifier for the project\n * @param {object} params - an object with an externalId and some task data.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertTask(projectGid: string, params: object, callback: Function): Operation;",
    "completion": "import { composeNextState, expandReferences, http } from '@openfn/language-common';\n\n/**\n * Update or create a task.\n * @public\n * @param {string} projectGid - Globally unique identifier for the project\n * @param {object} params - an object with an externalId and some task data.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertTask(projectGid, params, callback) {\n    return state => {\n        const resolvedProjectGid = expandReferences(projectGid)(state);\n        const { externalId, data } = expandReferences(params)(state);\n\n        const { apiVersion, token } = state.configuration;\n\n        const url = `https://app.asana.com/api/${apiVersion}/projects/${resolvedProjectGid}/tasks`;\n\n        const config = {\n            url,\n            headers: { Authorization: `Bearer ${token}` },\n            params: {\n                opt_fields: `${externalId}`,\n            },\n        };\n\n        return http\n            .get(config)(state)\n            .then(response => {\n                const matchingTask = response.data.data.find(\n                    task => task[externalId] === data[externalId]\n                );\n                if (matchingTask) {\n                    console.log('Matching task found. Performing update.');\n                    console.log('Data to update', data);\n                    // projects and workspace ids should ne be included to update\n                    delete data.projects;\n                    delete data.workspace;\n                    return updateTask(matchingTask.gid, data, callback)(state);\n                } else {\n                    console.log('No matching task found. Performing create.');\n                    return createTask(data, callback)(state);\n                }\n            });\n    };\n}"
  },
  {
    "prompt": "/* TypeScript Declaration with JsDoc */\n/**\n * Get a single task of a given project.\n * @public\n * @example\n * getTask(\"taskGid\",\n *  {\n *    opt_fields: \"name,notes,assignee\"\n *  })\n * @function\n * @param {string} taskGid - Globally unique identifier for the task\n * @param {object} params - Query params to include.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function getTask(taskGid: string, params: object, callback: Function): Operation;",
    "completion": "import { composeNextState, expandReferences, http } from '@openfn/language-common';\n\n/**\n * Get a single task of a given project.\n * @public\n * @param {string} taskGid - Globally unique identifier for the task\n * @param {object} params - Query params to include.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function getTask(taskGid, params, callback) {\n    return state => {\n        const resolvedProjectGid = expandReferences(projectGid)(state);\n        const { opt_fields } = expandReferences(params)(state);\n\n        const { apiVersion, token } = state.configuration;\n\n        const url = `https://app.asana.com/api/${apiVersion}/projects/${resolvedProjectGid}/tasks`;\n\n        const config = {\n            url,\n            headers: { Authorization: `Bearer ${token}` },\n            params: {\n                opt_fields,\n            },\n        };\n\n        return http\n            .get(config)(state)\n            .then(response => {\n                const nextState = {\n                    ...composeNextState(state, response.data),\n                    response,\n                };\n                if (callback) return callback(nextState);\n                return nextState;\n            });\n    };\n}"
  }
]