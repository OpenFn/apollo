[
  {
    "name": "execute",
    "implementation": "\n\nimport {\n  execute as commonExecute,\n  http,\n  expandReferences,\n} from '@openfn/language-common';\nimport pkg from '@openfn/language-http';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for commcare.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    state.configuration.authType = 'basic';\n    state.configuration.baseUrl = 'https://www.commcarehq.org/a/'.concat(\n      state.configuration.applicationName\n    );\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for commcare.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for commcare.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\n\n\nimport {\n  execute as commonExecute,\n  http,\n  expandReferences,\n} from '@openfn/language-common';\nimport pkg from '@openfn/language-http';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for commcare.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    state.configuration.authType = 'basic';\n    state.configuration.baseUrl = 'https://www.commcarehq.org/a/'.concat(\n      state.configuration.applicationName\n    );\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "submitXls",
    "implementation": "\n\nimport {\n  execute as commonExecute,\n  http,\n  expandReferences,\n} from '@openfn/language-common';\nimport pkg from '@openfn/language-http';\n/**\n * Performs a post request\n * @example\n *  clientPost(formData)\n * @function\n * @param {Object} formData - Form Data with auth params and body\n * @returns {State}\n */\nfunction clientPost({ url, body, username, password }) {\n  return new Promise((resolve, reject) => {\n    request\n      .post(url)\n      .auth(username, password)\n      .set('Content-Type', 'application/xml')\n      .send(body)\n      .end((error, res) => {\n        if (!!error || !res.ok) {\n          reject(error);\n        }\n        resolve(res);\n      });\n  });\n}\n\n/**\n * Convert form data to xls then submit.\n * @public\n * @example\n * submitXls(\n *    [\n *      {name: 'Mamadou', phone: '000000'},\n *    ],\n *    {\n *      case_type: 'student',\n *      search_field: 'external_id',\n *      create_new_cases: 'on',\n *    }\n * )\n * @function\n * @param {Object} formData - Object including form data.\n * @param {Object} params - Request params including case type and external id.\n * @returns {Operation}\n */\nexport function submitXls(formData, params) {\n  return state => {\n    const { applicationName, hostUrl, username, apiKey } = state.configuration;\n\n    const json = expandReferences(formData)(state);\n    const { case_type, search_field, create_new_cases } = params;\n\n    const url = (hostUrl || 'https://www.commcarehq.org').concat(\n      '/a/',\n      applicationName,\n      '/importer/excel/bulk_upload_api/'\n    );\n\n    const workbook = xlsx.utils.book_new();\n    const worksheet = xlsx.utils.json_to_sheet(json);\n    const ws_name = 'SheetJS';\n    xlsx.utils.book_append_sheet(workbook, worksheet, ws_name);\n\n    // Generate buffer\n    const buffer = xlsx.write(workbook, { type: 'buffer', bookType: 'xls' });\n    // xlsx.writeFile(workbook, 'out.xls'); // If needing to write to filesystem\n\n    const data = new FormData();\n\n    data.append('file', buffer, { filename: 'output.xls' });\n    // data.append('file', fs.createReadStream('./out.xls'));\n    data.append('case_type', case_type);\n    data.append('search_field', search_field);\n    data.append('create_new_cases', create_new_cases);\n\n    console.log('Posting to url: '.concat(url));\n    return http\n      .post({\n        url,\n        data,\n        headers: {\n          ...data.getHeaders(),\n          Authorization: `ApiKey ${username}:${apiKey}`,\n        },\n      })(state)\n      .then(response => {\n        return { ...state, data: { body: response.data } };\n      })\n      .catch(err => {\n        throw { ...err, config: {}, request: {} };\n      });\n  };\n}",
    "signature": "/**\n * Convert form data to xls then submit.\n * @public\n * @example\n * submitXls(\n *    [\n *      {name: 'Mamadou', phone: '000000'},\n *    ],\n *    {\n *      case_type: 'student',\n *      search_field: 'external_id',\n *      create_new_cases: 'on',\n *    }\n * )\n * @function\n * @param {Object} formData - Object including form data.\n * @param {Object} params - Request params including case type and external id.\n * @returns {Operation}\n */\nexport function submitXls(formData: any, params: any): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that submits xls to/on/from form data.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that submits xls to/on/from form data.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Convert form data to xls then submit.\n * @public\n * @example\n * submitXls(\n *    [\n *      {name: 'Mamadou', phone: '000000'},\n *    ],\n *    {\n *      case_type: 'student',\n *      search_field: 'external_id',\n *      create_new_cases: 'on',\n *    }\n * )\n * @function\n * @param {Object} formData - Object including form data.\n * @param {Object} params - Request params including case type and external id.\n * @returns {Operation}\n */\nexport function submitXls(formData: any, params: any): Operation;\n\n### Implementation:\n\n\nimport {\n  execute as commonExecute,\n  http,\n  expandReferences,\n} from '@openfn/language-common';\nimport pkg from '@openfn/language-http';\n/**\n * Performs a post request\n * @example\n *  clientPost(formData)\n * @function\n * @param {Object} formData - Form Data with auth params and body\n * @returns {State}\n */\nfunction clientPost({ url, body, username, password }) {\n  return new Promise((resolve, reject) => {\n    request\n      .post(url)\n      .auth(username, password)\n      .set('Content-Type', 'application/xml')\n      .send(body)\n      .end((error, res) => {\n        if (!!error || !res.ok) {\n          reject(error);\n        }\n        resolve(res);\n      });\n  });\n}\n\n/**\n * Convert form data to xls then submit.\n * @public\n * @example\n * submitXls(\n *    [\n *      {name: 'Mamadou', phone: '000000'},\n *    ],\n *    {\n *      case_type: 'student',\n *      search_field: 'external_id',\n *      create_new_cases: 'on',\n *    }\n * )\n * @function\n * @param {Object} formData - Object including form data.\n * @param {Object} params - Request params including case type and external id.\n * @returns {Operation}\n */\nexport function submitXls(formData, params) {\n  return state => {\n    const { applicationName, hostUrl, username, apiKey } = state.configuration;\n\n    const json = expandReferences(formData)(state);\n    const { case_type, search_field, create_new_cases } = params;\n\n    const url = (hostUrl || 'https://www.commcarehq.org').concat(\n      '/a/',\n      applicationName,\n      '/importer/excel/bulk_upload_api/'\n    );\n\n    const workbook = xlsx.utils.book_new();\n    const worksheet = xlsx.utils.json_to_sheet(json);\n    const ws_name = 'SheetJS';\n    xlsx.utils.book_append_sheet(workbook, worksheet, ws_name);\n\n    // Generate buffer\n    const buffer = xlsx.write(workbook, { type: 'buffer', bookType: 'xls' });\n    // xlsx.writeFile(workbook, 'out.xls'); // If needing to write to filesystem\n\n    const data = new FormData();\n\n    data.append('file', buffer, { filename: 'output.xls' });\n    // data.append('file', fs.createReadStream('./out.xls'));\n    data.append('case_type', case_type);\n    data.append('search_field', search_field);\n    data.append('create_new_cases', create_new_cases);\n\n    console.log('Posting to url: '.concat(url));\n    return http\n      .post({\n        url,\n        data,\n        headers: {\n          ...data.getHeaders(),\n          Authorization: `ApiKey ${username}:${apiKey}`,\n        },\n      })(state)\n      .then(response => {\n        return { ...state, data: { body: response.data } };\n      })\n      .catch(err => {\n        throw { ...err, config: {}, request: {} };\n      });\n  };\n}\n"
  },
  {
    "name": "submit",
    "implementation": "\n\nimport {\n  execute as commonExecute,\n  http,\n  expandReferences,\n} from '@openfn/language-common';\nimport pkg from '@openfn/language-http';\n/**\n * Submit form data\n * @public\n * @example\n *  submit(\n *    fields(\n *      field(\"@\", function(state) {\n *        return {\n *          \"xmlns\": \"http://openrosa.org/formdesigner/form-id-here\"\n *        };\n *      }),\n *      field(\"question1\", dataValue(\"answer1\")),\n *      field(\"question2\", \"Some answer here.\")\n *    )\n *  )\n * @function\n * @param {Object} formData - Object including form data.\n * @returns {Operation}\n */\nexport function submit(formData) {\n  return state => {\n    const jsonBody = expandReferences(formData)(state);\n    const body = js2xmlparser('data', jsonBody);\n\n    const {\n      // this should be called project URL.\n      // it is what lives after www.commcarehq.org/a/...\n      applicationName,\n      username,\n      password,\n      appId,\n      hostUrl,\n    } = state.configuration;\n\n    const url = (hostUrl || 'https://www.commcarehq.org').concat(\n      '/a/',\n      applicationName,\n      '/receiver/',\n      appId,\n      '/'\n    );\n\n    console.log('Posting to url: '.concat(url));\n    console.log('Raw JSON body: '.concat(JSON.stringify(jsonBody)));\n    console.log('X-form submission: '.concat(body));\n\n    return clientPost({\n      url,\n      body,\n      username,\n      password,\n    }).then(response => {\n      console.log(`Server repsonded with a ${response.status}:`);\n      console.log(response);\n      return { ...state, references: [response, ...state.references] };\n    });\n  };\n}",
    "signature": "/**\n * Submit form data\n * @public\n * @example\n *  submit(\n *    fields(\n *      field(\"@\", function(state) {\n *        return {\n *          \"xmlns\": \"http://openrosa.org/formdesigner/form-id-here\"\n *        };\n *      }),\n *      field(\"question1\", dataValue(\"answer1\")),\n *      field(\"question2\", \"Some answer here.\")\n *    )\n *  )\n * @function\n * @param {Object} formData - Object including form data.\n * @returns {Operation}\n */\nexport function submit(formData: any): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that submits form data.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that submits form data.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Submit form data\n * @public\n * @example\n *  submit(\n *    fields(\n *      field(\"@\", function(state) {\n *        return {\n *          \"xmlns\": \"http://openrosa.org/formdesigner/form-id-here\"\n *        };\n *      }),\n *      field(\"question1\", dataValue(\"answer1\")),\n *      field(\"question2\", \"Some answer here.\")\n *    )\n *  )\n * @function\n * @param {Object} formData - Object including form data.\n * @returns {Operation}\n */\nexport function submit(formData: any): Operation;\n\n### Implementation:\n\n\nimport {\n  execute as commonExecute,\n  http,\n  expandReferences,\n} from '@openfn/language-common';\nimport pkg from '@openfn/language-http';\n/**\n * Submit form data\n * @public\n * @example\n *  submit(\n *    fields(\n *      field(\"@\", function(state) {\n *        return {\n *          \"xmlns\": \"http://openrosa.org/formdesigner/form-id-here\"\n *        };\n *      }),\n *      field(\"question1\", dataValue(\"answer1\")),\n *      field(\"question2\", \"Some answer here.\")\n *    )\n *  )\n * @function\n * @param {Object} formData - Object including form data.\n * @returns {Operation}\n */\nexport function submit(formData) {\n  return state => {\n    const jsonBody = expandReferences(formData)(state);\n    const body = js2xmlparser('data', jsonBody);\n\n    const {\n      // this should be called project URL.\n      // it is what lives after www.commcarehq.org/a/...\n      applicationName,\n      username,\n      password,\n      appId,\n      hostUrl,\n    } = state.configuration;\n\n    const url = (hostUrl || 'https://www.commcarehq.org').concat(\n      '/a/',\n      applicationName,\n      '/receiver/',\n      appId,\n      '/'\n    );\n\n    console.log('Posting to url: '.concat(url));\n    console.log('Raw JSON body: '.concat(JSON.stringify(jsonBody)));\n    console.log('X-form submission: '.concat(body));\n\n    return clientPost({\n      url,\n      body,\n      username,\n      password,\n    }).then(response => {\n      console.log(`Server repsonded with a ${response.status}:`);\n      console.log(response);\n      return { ...state, references: [response, ...state.references] };\n    });\n  };\n}\n"
  },
  {
    "name": "fetchReportData",
    "implementation": "\n\nimport {\n  execute as commonExecute,\n  http,\n  expandReferences,\n} from '@openfn/language-common';\nimport pkg from '@openfn/language-http';\n/**\n * Make a GET request to CommCare's Reports API\n * and POST the response to somewhere else.\n * @public\n * @example\n * fetchReportData(reportId, params, postUrl)\n * @function\n * @param {String} reportId - API name of the report.\n * @param {Object} params - Query params, incl: limit, offset, and custom report filters.\n * @param {String} postUrl - Url to which the response object will be posted.\n * @returns {Operation}\n */\nexport function fetchReportData(reportId, params, postUrl) {\n  return http.get(`api/v0.5/configurablereportdata/${reportId}/`, {\n    query:",
    "signature": "/**\n * Make a GET request to CommCare's Reports API\n * and POST the response to somewhere else.\n * @public\n * @example\n * fetchReportData(reportId, params, postUrl)\n * @function\n * @param {String} reportId - API name of the report.\n * @param {Object} params - Query params, incl: limit, offset, and custom report filters.\n * @param {String} postUrl - Url to which the response object will be posted.\n * @returns {Operation}\n */\nexport function fetchReportData(reportId: string, params: any, postUrl: string): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a GET request to CommCare's Reports API and POST",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a GET request to CommCare's Reports API and POST\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a GET request to CommCare's Reports API\n * and POST the response to somewhere else.\n * @public\n * @example\n * fetchReportData(reportId, params, postUrl)\n * @function\n * @param {String} reportId - API name of the report.\n * @param {Object} params - Query params, incl: limit, offset, and custom report filters.\n * @param {String} postUrl - Url to which the response object will be posted.\n * @returns {Operation}\n */\nexport function fetchReportData(reportId: string, params: any, postUrl: string): Operation;\n\n### Implementation:\n\n\nimport {\n  execute as commonExecute,\n  http,\n  expandReferences,\n} from '@openfn/language-common';\nimport pkg from '@openfn/language-http';\n/**\n * Make a GET request to CommCare's Reports API\n * and POST the response to somewhere else.\n * @public\n * @example\n * fetchReportData(reportId, params, postUrl)\n * @function\n * @param {String} reportId - API name of the report.\n * @param {Object} params - Query params, incl: limit, offset, and custom report filters.\n * @param {String} postUrl - Url to which the response object will be posted.\n * @returns {Operation}\n */\nexport function fetchReportData(reportId, params, postUrl) {\n  return http.get(`api/v0.5/configurablereportdata/${reportId}/`, {\n    query:\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for postgresql.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n    queries: [],\n  };\n\n  return state => {\n    return commonExecute(\n      createClient,\n      connect,\n      ...operations,\n      disconnect,\n      cleanupState\n    )({ ...initialState, ...state }).catch(e => {\n      console.error(e);\n      console.error('Unhandled error in the operations. Exiting process.');\n      process.exit(1);\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for postgresql.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for postgresql.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for postgresql.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n    queries: [],\n  };\n\n  return state => {\n    return commonExecute(\n      createClient,\n      connect,\n      ...operations,\n      disconnect,\n      cleanupState\n    )({ ...initialState, ...state }).catch(e => {\n      console.error(e);\n      console.error('Unhandled error in the operations. Exiting process.');\n      process.exit(1);\n    });\n  };\n}\n"
  },
  {
    "name": "sql",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute an SQL statement\n * @public\n * @example\n * sql(state => `select(*) from ${state.data.tableName};`, { writeSql: true })\n * @function\n * @param {function} sqlQuery - a function which takes state and returns a\n * string of SQL.\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function sql(sqlQuery, options, callback) {\n  return state => {\n    let { client } = state;\n\n    try {\n      const body = sqlQuery(state);\n\n      console.log('Preparing to execute sql statement');\n      return queryHandler(state, body, options, callback);\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}",
    "signature": "/**\n * Execute an SQL statement\n * @public\n * @example\n * sql(state => `select(*) from ${state.data.tableName};`, { writeSql: true })\n * @function\n * @param {function} sqlQuery - a function which takes state and returns a\n * string of SQL.\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function sql(sqlQuery: Function, options?: {\n    writeSql?: boolean;\n    execute?: boolean;\n}, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes an SQL statement.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes an SQL statement.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute an SQL statement\n * @public\n * @example\n * sql(state => `select(*) from ${state.data.tableName};`, { writeSql: true })\n * @function\n * @param {function} sqlQuery - a function which takes state and returns a\n * string of SQL.\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function sql(sqlQuery: Function, options?: {\n    writeSql?: boolean;\n    execute?: boolean;\n}, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute an SQL statement\n * @public\n * @example\n * sql(state => `select(*) from ${state.data.tableName};`, { writeSql: true })\n * @function\n * @param {function} sqlQuery - a function which takes state and returns a\n * string of SQL.\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function sql(sqlQuery, options, callback) {\n  return state => {\n    let { client } = state;\n\n    try {\n      const body = sqlQuery(state);\n\n      console.log('Preparing to execute sql statement');\n      return queryHandler(state, body, options, callback);\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}\n"
  },
  {
    "name": "findValue",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch a uuid key given a condition\n * @public\n * @example\n * findValue({\n *    uuid: 'id',\n *    relation: 'users',\n *    where: { first_name: 'Mamadou' },\n *    operator: { first_name: 'like' }\n *  })\n * @function\n * @param {object} [filter] - A filter object with the lookup table, a uuid and the condition\n * @param {string} [filter.uuid] - The uuid value to search for in the specified relation.\n * @param {string} [filter.relation] - The name of the relation to search for the uuid value.\n * @param {object} [filter.where] - An object that contains key-value pairs to filter the search results.\n * @param {object} [filter.operator] - An object that contains key-value pairs to specify the type of comparison to perform on the where clause.\n * @returns {value}\n */\nexport function findValue(filter) {\n  return state => {\n    let { client } = state;\n\n    const { uuid, relation, where, operator } = filter;\n    const whereData = expandReferences(where)(state);\n    const operatorData = expandReferences(operator)(state);\n\n    let conditionsArray = [];\n    for (let key in where)\n      conditionsArray.push(\n        `${key} ${operatorData ? operatorData[key] : '='} '${whereData[key]}'`\n      );\n\n    const condition =\n      conditionsArray.length > 0\n        ? `where ${conditionsArray.join(' and ')}`\n        : ''; // In a near future the 'and' can live in the filter.\n\n    try {\n      const body = `select ${uuid} from ${relation} ${condition}`;\n\n      console.log('Preparing to execute sql statement');\n      let returnValue = null;\n\n      return new Promise((resolve, reject) => {\n        client.query(body, (err, result) => {\n          if (err) {\n            console.log(err);\n            reject(err);\n            client.end();\n          } else {\n            if (result.rows.length > 0) {\n              returnValue = result.rows[0][uuid];\n            }\n            resolve(returnValue);\n          }\n        });\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}",
    "signature": "/**\n * Fetch a uuid key given a condition\n * @public\n * @example\n * findValue({\n *    uuid: 'id',\n *    relation: 'users',\n *    where: { first_name: 'Mamadou' },\n *    operator: { first_name: 'like' }\n *  })\n * @function\n * @param {object} [filter] - A filter object with the lookup table, a uuid and the condition\n * @param {string} [filter.uuid] - The uuid value to search for in the specified relation.\n * @param {string} [filter.relation] - The name of the relation to search for the uuid value.\n * @param {object} [filter.where] - An object that contains key-value pairs to filter the search results.\n * @param {object} [filter.operator] - An object that contains key-value pairs to specify the type of comparison to perform on the where clause.\n * @returns {value}\n */\nexport function findValue(filter?: {\n    uuid?: string;\n    relation?: string;\n    where?: object;\n    operator?: object;\n}): value;",
    "test": "",
    "instruction": "Create an OpenFn function that fetches a uuid key from a specified relation given a",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that fetches a uuid key from a specified relation given a\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Fetch a uuid key given a condition\n * @public\n * @example\n * findValue({\n *    uuid: 'id',\n *    relation: 'users',\n *    where: { first_name: 'Mamadou' },\n *    operator: { first_name: 'like' }\n *  })\n * @function\n * @param {object} [filter] - A filter object with the lookup table, a uuid and the condition\n * @param {string} [filter.uuid] - The uuid value to search for in the specified relation.\n * @param {string} [filter.relation] - The name of the relation to search for the uuid value.\n * @param {object} [filter.where] - An object that contains key-value pairs to filter the search results.\n * @param {object} [filter.operator] - An object that contains key-value pairs to specify the type of comparison to perform on the where clause.\n * @returns {value}\n */\nexport function findValue(filter?: {\n    uuid?: string;\n    relation?: string;\n    where?: object;\n    operator?: object;\n}): value;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch a uuid key given a condition\n * @public\n * @example\n * findValue({\n *    uuid: 'id',\n *    relation: 'users',\n *    where: { first_name: 'Mamadou' },\n *    operator: { first_name: 'like' }\n *  })\n * @function\n * @param {object} [filter] - A filter object with the lookup table, a uuid and the condition\n * @param {string} [filter.uuid] - The uuid value to search for in the specified relation.\n * @param {string} [filter.relation] - The name of the relation to search for the uuid value.\n * @param {object} [filter.where] - An object that contains key-value pairs to filter the search results.\n * @param {object} [filter.operator] - An object that contains key-value pairs to specify the type of comparison to perform on the where clause.\n * @returns {value}\n */\nexport function findValue(filter) {\n  return state => {\n    let { client } = state;\n\n    const { uuid, relation, where, operator } = filter;\n    const whereData = expandReferences(where)(state);\n    const operatorData = expandReferences(operator)(state);\n\n    let conditionsArray = [];\n    for (let key in where)\n      conditionsArray.push(\n        `${key} ${operatorData ? operatorData[key] : '='} '${whereData[key]}'`\n      );\n\n    const condition =\n      conditionsArray.length > 0\n        ? `where ${conditionsArray.join(' and ')}`\n        : ''; // In a near future the 'and' can live in the filter.\n\n    try {\n      const body = `select ${uuid} from ${relation} ${condition}`;\n\n      console.log('Preparing to execute sql statement');\n      let returnValue = null;\n\n      return new Promise((resolve, reject) => {\n        client.query(body, (err, result) => {\n          if (err) {\n            console.log(err);\n            reject(err);\n            client.end();\n          } else {\n            if (result.rows.length > 0) {\n              returnValue = result.rows[0][uuid];\n            }\n            resolve(returnValue);\n          }\n        });\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}\n"
  },
  {
    "name": "insert",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert a record\n * @public\n * @example\n * insert('users', { name: 'Elodie', id: 7 }, { setNull: \"'NaN'\", logValues: true });\n * @function\n * @param {string} table - The target table\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insert(table, record, options, callback) {\n  return state => {\n    const { client } = state;\n\n    try {\n      const data = expandReferences(record)(state);\n      const columns = Object.keys(data).sort();\n      const columnsList = columns.join(', ');\n      const values = columns.map(key => data[key]);\n\n      const query = handleValues(\n        format(`INSERT INTO ${table} (${columnsList}) VALUES (%L);`, values),\n        handleOptions(options)\n      );\n\n      const safeQuery = `INSERT INTO ${table} (${columnsList}) VALUES [--REDACTED--]];`;\n\n      const queryToLog = options && options.logValues ? query : safeQuery;\n      console.log('Preparing to insert via:', queryToLog);\n      return queryHandler(state, query, options, callback);\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}",
    "signature": "/**\n * Insert a record\n * @public\n * @example\n * insert('users', { name: 'Elodie', id: 7 }, { setNull: \"'NaN'\", logValues: true });\n * @function\n * @param {string} table - The target table\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insert(table: string, record: object, options?: {\n    setNull?: string;\n    logValues?: boolean;\n    writeSql?: boolean;\n    execute?: boolean;\n}, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that inserts a record to the target table.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that inserts a record to the target table.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Insert a record\n * @public\n * @example\n * insert('users', { name: 'Elodie', id: 7 }, { setNull: \"'NaN'\", logValues: true });\n * @function\n * @param {string} table - The target table\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insert(table: string, record: object, options?: {\n    setNull?: string;\n    logValues?: boolean;\n    writeSql?: boolean;\n    execute?: boolean;\n}, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert a record\n * @public\n * @example\n * insert('users', { name: 'Elodie', id: 7 }, { setNull: \"'NaN'\", logValues: true });\n * @function\n * @param {string} table - The target table\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insert(table, record, options, callback) {\n  return state => {\n    const { client } = state;\n\n    try {\n      const data = expandReferences(record)(state);\n      const columns = Object.keys(data).sort();\n      const columnsList = columns.join(', ');\n      const values = columns.map(key => data[key]);\n\n      const query = handleValues(\n        format(`INSERT INTO ${table} (${columnsList}) VALUES (%L);`, values),\n        handleOptions(options)\n      );\n\n      const safeQuery = `INSERT INTO ${table} (${columnsList}) VALUES [--REDACTED--]];`;\n\n      const queryToLog = options && options.logValues ? query : safeQuery;\n      console.log('Preparing to insert via:', queryToLog);\n      return queryHandler(state, query, options, callback);\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}\n"
  },
  {
    "name": "insertMany",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert many records, using the keys of the first as the column template\n * @public\n * @example\n * insertMany('users', state => state.data.recordArray, { setNull: \"'undefined'\", logValues: true });\n * @function\n * @param {string} table - The target table\n * @param {array} records - An array or a function that takes state and returns an array\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insertMany(table, records, options, callback) {\n  return state => {\n    let { client } = state;\n\n    try {\n      const data = expandReferences(records)(state);\n\n      return new Promise((resolve, reject) => {\n        if (!data || data.length === 0) {\n          console.log('No records provided; skipping insert.');\n          resolve(state);\n        }\n        // Note: we select the keys of the FIRST object as the canonical template.\n        const columns = Object.keys(data[0]);\n        const columnsList = columns.join(', ');\n        const valueSets = data.map(x => Object.values(x));\n\n        const query = handleValues(\n          format(`INSERT INTO ${table} (${columnsList}) VALUES %L;`, valueSets),\n          handleOptions(options)\n        );\n\n        const safeQuery = `INSERT INTO ${table} (${columnsList}) VALUES [--REDACTED--]];`;\n\n        const queryToLog = options && options.logValues ? query : safeQuery;\n        console.log('Preparing to insertMany via:', queryToLog);\n        resolve(queryHandler(state, query, options, callback));\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}",
    "signature": "/**\n * Insert many records, using the keys of the first as the column template\n * @public\n * @example\n * insertMany('users', state => state.data.recordArray, { setNull: \"'undefined'\", logValues: true });\n * @function\n * @param {string} table - The target table\n * @param {array} records - An array or a function that takes state and returns an array\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insertMany(table: string, records: any[], options?: {\n    setNull?: string;\n    logValues?: boolean;\n    writeSql?: boolean;\n    execute?: boolean;\n}, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that inserts many records to/on/from the target table.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that inserts many records to/on/from the target table.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Insert many records, using the keys of the first as the column template\n * @public\n * @example\n * insertMany('users', state => state.data.recordArray, { setNull: \"'undefined'\", logValues: true });\n * @function\n * @param {string} table - The target table\n * @param {array} records - An array or a function that takes state and returns an array\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insertMany(table: string, records: any[], options?: {\n    setNull?: string;\n    logValues?: boolean;\n    writeSql?: boolean;\n    execute?: boolean;\n}, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert many records, using the keys of the first as the column template\n * @public\n * @example\n * insertMany('users', state => state.data.recordArray, { setNull: \"'undefined'\", logValues: true });\n * @function\n * @param {string} table - The target table\n * @param {array} records - An array or a function that takes state and returns an array\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insertMany(table, records, options, callback) {\n  return state => {\n    let { client } = state;\n\n    try {\n      const data = expandReferences(records)(state);\n\n      return new Promise((resolve, reject) => {\n        if (!data || data.length === 0) {\n          console.log('No records provided; skipping insert.');\n          resolve(state);\n        }\n        // Note: we select the keys of the FIRST object as the canonical template.\n        const columns = Object.keys(data[0]);\n        const columnsList = columns.join(', ');\n        const valueSets = data.map(x => Object.values(x));\n\n        const query = handleValues(\n          format(`INSERT INTO ${table} (${columnsList}) VALUES %L;`, valueSets),\n          handleOptions(options)\n        );\n\n        const safeQuery = `INSERT INTO ${table} (${columnsList}) VALUES [--REDACTED--]];`;\n\n        const queryToLog = options && options.logValues ? query : safeQuery;\n        console.log('Preparing to insertMany via:', queryToLog);\n        resolve(queryHandler(state, query, options, callback));\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}\n"
  },
  {
    "name": "upsert",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert or update a record using ON CONFLICT UPDATE\n * @public\n * @example\n * upsert(\n *   'users', // the DB table\n *   'ON CONSTRAINT users_pkey', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   { name: 'Elodie', id: 7 },\n *   { setNull: [\"''\", \"'undefined'\"], writeSql:true, execute: true, logValues: true }\n * )\n * @function\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsert(table, uuid, record, options, callback) {\n  return state => {\n    let { client } = state;\n\n    try {\n      const data = expandReferences(record)(state);\n      const columns = Object.keys(data).sort();\n      const columnsList = columns.join(', ');\n      const values = columns.map(key => data[key]);\n      const conflict = uuid.split(' ').length > 1 ? uuid : `(${uuid})`;\n\n      const updateValues = columns\n        .map(key => {\n          return `${key}=excluded.${key}`;\n        })\n        .join(', ');\n\n      const insertValues = format(\n        `INSERT INTO ${table} (${columnsList}) VALUES (%L)`,\n        values\n      );\n\n      const query = handleValues(\n        `${insertValues}\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`,\n        handleOptions(options)\n      );\n\n      const safeQuery = `INSERT INTO ${table} (${columnsList}) VALUES [--REDACTED--]\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`;\n\n      const queryToLog = options && options.logValues ? query : safeQuery;\n      console.log('Preparing to upsert via:', queryToLog);\n      return queryHandler(state, query, options, callback);\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}",
    "signature": "/**\n * Insert or update a record using ON CONFLICT UPDATE\n * @public\n * @example\n * upsert(\n *   'users', // the DB table\n *   'ON CONSTRAINT users_pkey', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   { name: 'Elodie', id: 7 },\n *   { setNull: [\"''\", \"'undefined'\"], writeSql:true, execute: true, logValues: true }\n * )\n * @function\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsert(table: string, uuid: string, record: object, options?: {\n    setNull?: string;\n    writeSql?: boolean;\n    execute?: boolean;\n    logValues?: boolean;\n}, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts to/on/from a DB table.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts to/on/from a DB table.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Insert or update a record using ON CONFLICT UPDATE\n * @public\n * @example\n * upsert(\n *   'users', // the DB table\n *   'ON CONSTRAINT users_pkey', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   { name: 'Elodie', id: 7 },\n *   { setNull: [\"''\", \"'undefined'\"], writeSql:true, execute: true, logValues: true }\n * )\n * @function\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsert(table: string, uuid: string, record: object, options?: {\n    setNull?: string;\n    writeSql?: boolean;\n    execute?: boolean;\n    logValues?: boolean;\n}, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert or update a record using ON CONFLICT UPDATE\n * @public\n * @example\n * upsert(\n *   'users', // the DB table\n *   'ON CONSTRAINT users_pkey', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   { name: 'Elodie', id: 7 },\n *   { setNull: [\"''\", \"'undefined'\"], writeSql:true, execute: true, logValues: true }\n * )\n * @function\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsert(table, uuid, record, options, callback) {\n  return state => {\n    let { client } = state;\n\n    try {\n      const data = expandReferences(record)(state);\n      const columns = Object.keys(data).sort();\n      const columnsList = columns.join(', ');\n      const values = columns.map(key => data[key]);\n      const conflict = uuid.split(' ').length > 1 ? uuid : `(${uuid})`;\n\n      const updateValues = columns\n        .map(key => {\n          return `${key}=excluded.${key}`;\n        })\n        .join(', ');\n\n      const insertValues = format(\n        `INSERT INTO ${table} (${columnsList}) VALUES (%L)`,\n        values\n      );\n\n      const query = handleValues(\n        `${insertValues}\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`,\n        handleOptions(options)\n      );\n\n      const safeQuery = `INSERT INTO ${table} (${columnsList}) VALUES [--REDACTED--]\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`;\n\n      const queryToLog = options && options.logValues ? query : safeQuery;\n      console.log('Preparing to upsert via:', queryToLog);\n      return queryHandler(state, query, options, callback);\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}\n"
  },
  {
    "name": "upsertIf",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert or update a record based on a logical condition using ON CONFLICT UPDATE\n * @public\n * @example\n * upsertIf(\n *   dataValue('name'),\n *   'users', // the DB table\n *   'ON CONSTRAINT users_pkey', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   { name: 'Elodie', id: 7 },\n *   { writeSql:true, execute: true }\n * )\n * @function\n * @param {string} logical - a data to check existing value for.\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertIf(logical, table, uuid, record, options, callback) {\n  return state => {\n    let { client } = state;\n\n    try {\n      const data = expandReferences(record)(state);\n      const logicalData = expandReferences(logical)(state);\n\n      return new Promise((resolve, reject) => {\n        if (!logicalData) {\n          console.log(`Skipping upsert for ${uuid}.`);\n          resolve(state);\n          return state;\n        }\n        const columns = Object.keys(data).sort();\n        const columnsList = columns.join(', ');\n        const values = columns.map(key => data[key]);\n        const conflict = uuid.split(' ').length > 1 ? uuid : `(${uuid})`;\n\n        const updateValues = columns\n          .map(key => {\n            return `${key}=excluded.${key}`;\n          })\n          .join(', ');\n\n        const insertValues = format(\n          `INSERT INTO ${table} (${columnsList}) VALUES (%L)`,\n          values\n        );\n\n        const query = handleValues(\n          `${insertValues}\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`,\n          handleOptions(options)\n        );\n\n        const safeQuery = `INSERT INTO ${table} (${columnsList}) VALUES [--REDACTED--]\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`;\n\n        const queryToLog = options && options.logValues ? query : safeQuery;\n        console.log('Preparing to upsert via:', queryToLog);\n        resolve(queryHandler(state, query, options, callback));\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}",
    "signature": "/**\n * Insert or update a record based on a logical condition using ON CONFLICT UPDATE\n * @public\n * @example\n * upsertIf(\n *   dataValue('name'),\n *   'users', // the DB table\n *   'ON CONSTRAINT users_pkey', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   { name: 'Elodie', id: 7 },\n *   { writeSql:true, execute: true }\n * )\n * @function\n * @param {string} logical - a data to check existing value for.\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertIf(logical: string, table: string, uuid: string, record: object, options?: {\n    setNull?: string;\n    writeSql?: boolean;\n    execute?: boolean;\n    logValues?: boolean;\n}, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts a record to/on/from the '",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts a record to/on/from the '\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Insert or update a record based on a logical condition using ON CONFLICT UPDATE\n * @public\n * @example\n * upsertIf(\n *   dataValue('name'),\n *   'users', // the DB table\n *   'ON CONSTRAINT users_pkey', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   { name: 'Elodie', id: 7 },\n *   { writeSql:true, execute: true }\n * )\n * @function\n * @param {string} logical - a data to check existing value for.\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertIf(logical: string, table: string, uuid: string, record: object, options?: {\n    setNull?: string;\n    writeSql?: boolean;\n    execute?: boolean;\n    logValues?: boolean;\n}, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert or update a record based on a logical condition using ON CONFLICT UPDATE\n * @public\n * @example\n * upsertIf(\n *   dataValue('name'),\n *   'users', // the DB table\n *   'ON CONSTRAINT users_pkey', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   { name: 'Elodie', id: 7 },\n *   { writeSql:true, execute: true }\n * )\n * @function\n * @param {string} logical - a data to check existing value for.\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertIf(logical, table, uuid, record, options, callback) {\n  return state => {\n    let { client } = state;\n\n    try {\n      const data = expandReferences(record)(state);\n      const logicalData = expandReferences(logical)(state);\n\n      return new Promise((resolve, reject) => {\n        if (!logicalData) {\n          console.log(`Skipping upsert for ${uuid}.`);\n          resolve(state);\n          return state;\n        }\n        const columns = Object.keys(data).sort();\n        const columnsList = columns.join(', ');\n        const values = columns.map(key => data[key]);\n        const conflict = uuid.split(' ').length > 1 ? uuid : `(${uuid})`;\n\n        const updateValues = columns\n          .map(key => {\n            return `${key}=excluded.${key}`;\n          })\n          .join(', ');\n\n        const insertValues = format(\n          `INSERT INTO ${table} (${columnsList}) VALUES (%L)`,\n          values\n        );\n\n        const query = handleValues(\n          `${insertValues}\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`,\n          handleOptions(options)\n        );\n\n        const safeQuery = `INSERT INTO ${table} (${columnsList}) VALUES [--REDACTED--]\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`;\n\n        const queryToLog = options && options.logValues ? query : safeQuery;\n        console.log('Preparing to upsert via:', queryToLog);\n        resolve(queryHandler(state, query, options, callback));\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}\n"
  },
  {
    "name": "upsertMany",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert or update multiple records using ON CONFLICT UPDATE and excluded\n * @public\n * @example\n * upsertMany(\n *   'users', // the DB table\n *   'email', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   [\n *     { name: 'one', email: 'one@openfn.org' },\n *     { name: 'two', email: 'two@openfn.org' },\n *   ]\n *  { logValues: true }\n * )\n * @function\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {array} data - An array of objects or a function that returns an array\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertMany(table, uuid, data, options, callback) {\n  return state => {\n    let { client } = state;\n\n    try {\n      const records = expandReferences(data)(state);\n\n      return new Promise((resolve, reject) => {\n        if (!records || records.length === 0) {\n          console.log('No records provided; skipping upsert.');\n          resolve(state);\n        }\n\n        const columns = Object.keys(records[0]);\n        const columnsList = columns.join(', ');\n        const values = records.map(x => Object.values(x));\n        const conflict = uuid.split(' ').length > 1 ? uuid : `(${uuid})`;\n\n        const updateValues = columns\n          .map(key => {\n            return `${key}=excluded.${key}`;\n          })\n          .join(', ');\n\n        const insertValues = format(\n          `INSERT INTO ${table} (${columnsList}) VALUES %L`,\n          values\n        );\n\n        const query = handleValues(\n          `${insertValues}\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`,\n          handleOptions(options)\n        );\n\n        const safeQuery = `INSERT INTO ${table} (${columnsList}) VALUES [--REDACTED--]\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`;\n\n        const queryToLog = options && options.logValues ? query : safeQuery;\n        console.log('Preparing to upsert via:', queryToLog);\n        resolve(queryHandler(state, query, options, callback));\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}",
    "signature": "/**\n * Insert or update multiple records using ON CONFLICT UPDATE and excluded\n * @public\n * @example\n * upsertMany(\n *   'users', // the DB table\n *   'email', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   [\n *     { name: 'one', email: 'one@openfn.org' },\n *     { name: 'two', email: 'two@openfn.org' },\n *   ]\n *  { logValues: true }\n * )\n * @function\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {array} data - An array of objects or a function that returns an array\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertMany(table: string, uuid: string, data: any[], options?: {\n    setNull?: string;\n    writeSql?: boolean;\n    execute?: boolean;\n    logValues?: boolean;\n}, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts many records to/on/from the '",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts many records to/on/from the '\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Insert or update multiple records using ON CONFLICT UPDATE and excluded\n * @public\n * @example\n * upsertMany(\n *   'users', // the DB table\n *   'email', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   [\n *     { name: 'one', email: 'one@openfn.org' },\n *     { name: 'two', email: 'two@openfn.org' },\n *   ]\n *  { logValues: true }\n * )\n * @function\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {array} data - An array of objects or a function that returns an array\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertMany(table: string, uuid: string, data: any[], options?: {\n    setNull?: string;\n    writeSql?: boolean;\n    execute?: boolean;\n    logValues?: boolean;\n}, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert or update multiple records using ON CONFLICT UPDATE and excluded\n * @public\n * @example\n * upsertMany(\n *   'users', // the DB table\n *   'email', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   [\n *     { name: 'one', email: 'one@openfn.org' },\n *     { name: 'two', email: 'two@openfn.org' },\n *   ]\n *  { logValues: true }\n * )\n * @function\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {array} data - An array of objects or a function that returns an array\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertMany(table, uuid, data, options, callback) {\n  return state => {\n    let { client } = state;\n\n    try {\n      const records = expandReferences(data)(state);\n\n      return new Promise((resolve, reject) => {\n        if (!records || records.length === 0) {\n          console.log('No records provided; skipping upsert.');\n          resolve(state);\n        }\n\n        const columns = Object.keys(records[0]);\n        const columnsList = columns.join(', ');\n        const values = records.map(x => Object.values(x));\n        const conflict = uuid.split(' ').length > 1 ? uuid : `(${uuid})`;\n\n        const updateValues = columns\n          .map(key => {\n            return `${key}=excluded.${key}`;\n          })\n          .join(', ');\n\n        const insertValues = format(\n          `INSERT INTO ${table} (${columnsList}) VALUES %L`,\n          values\n        );\n\n        const query = handleValues(\n          `${insertValues}\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`,\n          handleOptions(options)\n        );\n\n        const safeQuery = `INSERT INTO ${table} (${columnsList}) VALUES [--REDACTED--]\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`;\n\n        const queryToLog = options && options.logValues ? query : safeQuery;\n        console.log('Preparing to upsert via:', queryToLog);\n        resolve(queryHandler(state, query, options, callback));\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}\n"
  },
  {
    "name": "describeTable",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * List the columns of a table in a database.\n * @public\n * @example\n * describeTable('clinic_visits')\n * @function\n * @param {string} tableName - The name of the table to describe\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function describeTable(tableName, options, callback) {\n  return state => {\n    let { client } = state;\n    const name = expandReferences(tableName)(state);\n\n    try {\n      const query = `SELECT column_name, udt_name, is_nullable\n        FROM information_schema.columns\n        WHERE table_name='${name}';`;\n\n      console.log('Preparing to describe table via:', query);\n      return queryHandler(state, query, options, callback);\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}",
    "signature": "/**\n * List the columns of a table in a database.\n * @public\n * @example\n * describeTable('clinic_visits')\n * @function\n * @param {string} tableName - The name of the table to describe\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function describeTable(tableName: string, options?: {\n    writeSql?: boolean;\n    execute?: boolean;\n}, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that lists the columns of a table in a database.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that lists the columns of a table in a database.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * List the columns of a table in a database.\n * @public\n * @example\n * describeTable('clinic_visits')\n * @function\n * @param {string} tableName - The name of the table to describe\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function describeTable(tableName: string, options?: {\n    writeSql?: boolean;\n    execute?: boolean;\n}, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * List the columns of a table in a database.\n * @public\n * @example\n * describeTable('clinic_visits')\n * @function\n * @param {string} tableName - The name of the table to describe\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function describeTable(tableName, options, callback) {\n  return state => {\n    let { client } = state;\n    const name = expandReferences(tableName)(state);\n\n    try {\n      const query = `SELECT column_name, udt_name, is_nullable\n        FROM information_schema.columns\n        WHERE table_name='${name}';`;\n\n      console.log('Preparing to describe table via:', query);\n      return queryHandler(state, query, options, callback);\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}\n"
  },
  {
    "name": "insertTable",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create a table in database when given an array of columns and a table_name.\n * @public\n * @example\n * insertTable('table_name', state => state.data.map(\n *   column => ({\n *     name: column.name,\n *     type: column.type,\n *     required: true, // optional\n *     unique: false, // optional - to be set to true for unique constraint\n *   })\n * ));\n * @function\n * @param {string} tableName - The name of the table to create\n * @param {array} columns - An array of form columns\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insertTable(tableName, columns, options, callback) {\n  return state => {\n    let { client } = state;\n    try {\n      const data = expandReferences(columns)(state);\n\n      return new Promise((resolve, reject) => {\n        if (!data || data.length === 0) {\n          console.log('No columns provided; skipping table creation.');\n          resolve(state);\n        }\n        const structureData = data\n          .map(\n            x =>\n              `${x.name} ${x.type} ${\n                x.hasOwnProperty('default')\n                  ? x.type.includes('varchar') ||\n                    x.type.includes('text') ||\n                    x.type.includes('BIT')\n                    ? `DEFAULT '${x.default}'`\n                    : `DEFAULT ${x.default}`\n                  : ''\n              } ${x.unique ? 'UNIQUE' : ''} ${\n                x.identity ? 'GENERATED BY DEFAULT AS IDENTITY' : ''\n              } ${x.required ? 'NOT NULL' : ''}`\n          )\n          .join(', ');\n\n        const query = `CREATE TABLE ${tableName} (\n        ${structureData}\n      );`;\n\n        console.log('Preparing to create table via:', query);\n        resolve(queryHandler(state, query, options, callback));\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}",
    "signature": "/**\n * Create a table in database when given an array of columns and a table_name.\n * @public\n * @example\n * insertTable('table_name', state => state.data.map(\n *   column => ({\n *     name: column.name,\n *     type: column.type,\n *     required: true, // optional\n *     unique: false, // optional - to be set to true for unique constraint\n *   })\n * ));\n * @function\n * @param {string} tableName - The name of the table to create\n * @param {array} columns - An array of form columns\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insertTable(tableName: string, columns: any[], options?: {\n    writeSql?: boolean;\n    execute?: boolean;\n}, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that inserts a table into a database from an array of columns and",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that inserts a table into a database from an array of columns and\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create a table in database when given an array of columns and a table_name.\n * @public\n * @example\n * insertTable('table_name', state => state.data.map(\n *   column => ({\n *     name: column.name,\n *     type: column.type,\n *     required: true, // optional\n *     unique: false, // optional - to be set to true for unique constraint\n *   })\n * ));\n * @function\n * @param {string} tableName - The name of the table to create\n * @param {array} columns - An array of form columns\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insertTable(tableName: string, columns: any[], options?: {\n    writeSql?: boolean;\n    execute?: boolean;\n}, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create a table in database when given an array of columns and a table_name.\n * @public\n * @example\n * insertTable('table_name', state => state.data.map(\n *   column => ({\n *     name: column.name,\n *     type: column.type,\n *     required: true, // optional\n *     unique: false, // optional - to be set to true for unique constraint\n *   })\n * ));\n * @function\n * @param {string} tableName - The name of the table to create\n * @param {array} columns - An array of form columns\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insertTable(tableName, columns, options, callback) {\n  return state => {\n    let { client } = state;\n    try {\n      const data = expandReferences(columns)(state);\n\n      return new Promise((resolve, reject) => {\n        if (!data || data.length === 0) {\n          console.log('No columns provided; skipping table creation.');\n          resolve(state);\n        }\n        const structureData = data\n          .map(\n            x =>\n              `${x.name} ${x.type} ${\n                x.hasOwnProperty('default')\n                  ? x.type.includes('varchar') ||\n                    x.type.includes('text') ||\n                    x.type.includes('BIT')\n                    ? `DEFAULT '${x.default}'`\n                    : `DEFAULT ${x.default}`\n                  : ''\n              } ${x.unique ? 'UNIQUE' : ''} ${\n                x.identity ? 'GENERATED BY DEFAULT AS IDENTITY' : ''\n              } ${x.required ? 'NOT NULL' : ''}`\n          )\n          .join(', ');\n\n        const query = `CREATE TABLE ${tableName} (\n        ${structureData}\n      );`;\n\n        console.log('Preparing to create table via:', query);\n        resolve(queryHandler(state, query, options, callback));\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}\n"
  },
  {
    "name": "modifyTable",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Alter an existing table in the database.\n * @public\n * @example\n * modifyTable('table_name', state => state.data.map(\n *   newColumn => ({\n *     name: newColumn.name,\n *     type: newColumn.type,\n *     required: true, // optional\n *     unique: false, // optional - to be set to true for unique constraint\n *   })\n * ));\n * @function\n * @param {string} tableName - The name of the table to alter\n * @param {array} columns - An array of form columns\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function modifyTable(tableName, columns, options, callback) {\n  return state => {\n    let { client } = state;\n\n    try {\n      const data = expandReferences(columns)(state);\n\n      return new Promise((resolve, reject) => {\n        if (!data || data.length === 0) {\n          console.log('No columns provided; skipping table modification.');\n          resolve(state);\n        }\n        const structureData = data\n          .map(\n            x =>\n              `ADD COLUMN ${x.name} ${x.type} ${\n                x.hasOwnProperty('default')\n                  ? x.type.includes('varchar') ||\n                    x.type.includes('text') ||\n                    x.type.includes('BIT')\n                    ? `DEFAULT '${x.default}'`\n                    : `DEFAULT ${x.default}`\n                  : ''\n              } ${x.identity ? 'GENERATED BY DEFAULT AS IDENTITY' : ''} ${\n                x.required ? 'NOT NULL' : ''\n              }`\n          )\n          .join(', ');\n\n        const query = `ALTER TABLE ${tableName} ${structureData};`;\n\n        console.log('Preparing to modify table via:', query);\n        resolve(queryHandler(state, query, options, callback));\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}",
    "signature": "/**\n * Alter an existing table in the database.\n * @public\n * @example\n * modifyTable('table_name', state => state.data.map(\n *   newColumn => ({\n *     name: newColumn.name,\n *     type: newColumn.type,\n *     required: true, // optional\n *     unique: false, // optional - to be set to true for unique constraint\n *   })\n * ));\n * @function\n * @param {string} tableName - The name of the table to alter\n * @param {array} columns - An array of form columns\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function modifyTable(tableName: string, columns: any[], options?: {\n    writeSql?: boolean;\n    execute?: boolean;\n}, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that modifies a table in the database.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that modifies a table in the database.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Alter an existing table in the database.\n * @public\n * @example\n * modifyTable('table_name', state => state.data.map(\n *   newColumn => ({\n *     name: newColumn.name,\n *     type: newColumn.type,\n *     required: true, // optional\n *     unique: false, // optional - to be set to true for unique constraint\n *   })\n * ));\n * @function\n * @param {string} tableName - The name of the table to alter\n * @param {array} columns - An array of form columns\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function modifyTable(tableName: string, columns: any[], options?: {\n    writeSql?: boolean;\n    execute?: boolean;\n}, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Alter an existing table in the database.\n * @public\n * @example\n * modifyTable('table_name', state => state.data.map(\n *   newColumn => ({\n *     name: newColumn.name,\n *     type: newColumn.type,\n *     required: true, // optional\n *     unique: false, // optional - to be set to true for unique constraint\n *   })\n * ));\n * @function\n * @param {string} tableName - The name of the table to alter\n * @param {array} columns - An array of form columns\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function modifyTable(tableName, columns, options, callback) {\n  return state => {\n    let { client } = state;\n\n    try {\n      const data = expandReferences(columns)(state);\n\n      return new Promise((resolve, reject) => {\n        if (!data || data.length === 0) {\n          console.log('No columns provided; skipping table modification.');\n          resolve(state);\n        }\n        const structureData = data\n          .map(\n            x =>\n              `ADD COLUMN ${x.name} ${x.type} ${\n                x.hasOwnProperty('default')\n                  ? x.type.includes('varchar') ||\n                    x.type.includes('text') ||\n                    x.type.includes('BIT')\n                    ? `DEFAULT '${x.default}'`\n                    : `DEFAULT ${x.default}`\n                  : ''\n              } ${x.identity ? 'GENERATED BY DEFAULT AS IDENTITY' : ''} ${\n                x.required ? 'NOT NULL' : ''\n              }`\n          )\n          .join(', ');\n\n        const query = `ALTER TABLE ${tableName} ${structureData};`;\n\n        console.log('Preparing to modify table via:', query);\n        resolve(queryHandler(state, query, options, callback));\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for OpenMRS.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Array} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  agent = null;\n\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(login, ...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for OpenMRS.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Array} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: any[]): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for OpenMRS.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Array} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: any[]): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for OpenMRS.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Array} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  agent = null;\n\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(login, ...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "getPatient",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Logs in to OpenMRS, gets a session token.\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\n/**\n * Gets patient matching a uuid\n * @example\n * getPatient(\"123\")\n * @function\n * @param {string} uuid - A uuid for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @example <caption>Get a patient by uuid</caption>\n * getPatient('681f8785-c9ca-4dc8-a091-7b869316ff93')\n * @returns {Operation}\n */\nexport function getPatient(uuid, callback = false) {\n  return state => {\n    Log.info(`Searching for patient with uuid: ${uuid}`);\n    const { instanceUrl } = state.configuration;\n    const defaultQuery = { v: 'full', limit: 1 };\n    const url = `${instanceUrl}/ws/rest/v1/patient/${uuid}`;\n\n    return agent\n      .get(url)\n      .accept('json')\n      .query(defaultQuery)\n      .then(response => {\n        Log.success(`Found patient.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Gets patient matching a uuid\n * @example\n * getPatient(\"123\")\n * @function\n * @param {string} uuid - A uuid for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @example <caption>Get a patient by uuid</caption>\n * getPatient('681f8785-c9ca-4dc8-a091-7b869316ff93')\n * @returns {Operation}\n */\nexport function getPatient(uuid: string, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets a patient from a uuid.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets a patient from a uuid.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Gets patient matching a uuid\n * @example\n * getPatient(\"123\")\n * @function\n * @param {string} uuid - A uuid for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @example <caption>Get a patient by uuid</caption>\n * getPatient('681f8785-c9ca-4dc8-a091-7b869316ff93')\n * @returns {Operation}\n */\nexport function getPatient(uuid: string, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Logs in to OpenMRS, gets a session token.\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { instanceUrl, username, password } = state.configuration;\n  agent = request.agent();\n  await agent.get(`${instanceUrl}/ws/rest/v1/session`).auth(username, password);\n\n  return state;\n}\n\n/**\n * Gets patient matching a uuid\n * @example\n * getPatient(\"123\")\n * @function\n * @param {string} uuid - A uuid for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @example <caption>Get a patient by uuid</caption>\n * getPatient('681f8785-c9ca-4dc8-a091-7b869316ff93')\n * @returns {Operation}\n */\nexport function getPatient(uuid, callback = false) {\n  return state => {\n    Log.info(`Searching for patient with uuid: ${uuid}`);\n    const { instanceUrl } = state.configuration;\n    const defaultQuery = { v: 'full', limit: 1 };\n    const url = `${instanceUrl}/ws/rest/v1/patient/${uuid}`;\n\n    return agent\n      .get(url)\n      .accept('json')\n      .query(defaultQuery)\n      .then(response => {\n        Log.success(`Found patient.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "createEncounter",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Creates an encounter\n * @example <caption>Create an encounter</caption>\n * createEncounter({\n *   encounterDatetime: '2023-05-25T06:08:25.000+0000',\n *   patient: '1fdaa696-e759-4a7d-a066-f1ae557c151b',\n *   encounterType: 'dd528487-82a5-4082-9c72-ed246bd49591',\n *   location: 'ba685651-ed3b-4e63-9b35-78893060758a',\n *   encounterProviders: [],\n *   visit: {\n *     patient: '1fdaa696-e759-4a7d-a066-f1ae557c151b',\n *     visitType: '7b0f5697-27e3-40c4-8bae-f4049abfb4ed',\n *     startDatetime: '2023-05-25T06:08:25.000+0000',\n *     stopDatetime: '2023-05-25T06:09:25.000+0000',\n *   },\n * })\n * @function\n * @param {object} data - Data parameters of the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createEncounter(data, callback = false) {\n  return state => {\n    const { instanceUrl } = state.configuration;\n    const body = expandReferences(data)(state);\n    const url = `${instanceUrl}/ws/rest/v1/encounter`;\n\n    Log.info(`Creating an encounter.`);\n\n    return agent\n      .post(url)\n      .type('json')\n      .send(body)\n      .then(response => {\n        Log.success(`Created an encounter.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Creates an encounter\n * @example <caption>Create an encounter</caption>\n * createEncounter({\n *   encounterDatetime: '2023-05-25T06:08:25.000+0000',\n *   patient: '1fdaa696-e759-4a7d-a066-f1ae557c151b',\n *   encounterType: 'dd528487-82a5-4082-9c72-ed246bd49591',\n *   location: 'ba685651-ed3b-4e63-9b35-78893060758a',\n *   encounterProviders: [],\n *   visit: {\n *     patient: '1fdaa696-e759-4a7d-a066-f1ae557c151b',\n *     visitType: '7b0f5697-27e3-40c4-8bae-f4049abfb4ed',\n *     startDatetime: '2023-05-25T06:08:25.000+0000',\n *     stopDatetime: '2023-05-25T06:09:25.000+0000',\n *   },\n * })\n * @function\n * @param {object} data - Data parameters of the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createEncounter(data: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that creates an encounter to/on/from data.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates an encounter to/on/from data.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Creates an encounter\n * @example <caption>Create an encounter</caption>\n * createEncounter({\n *   encounterDatetime: '2023-05-25T06:08:25.000+0000',\n *   patient: '1fdaa696-e759-4a7d-a066-f1ae557c151b',\n *   encounterType: 'dd528487-82a5-4082-9c72-ed246bd49591',\n *   location: 'ba685651-ed3b-4e63-9b35-78893060758a',\n *   encounterProviders: [],\n *   visit: {\n *     patient: '1fdaa696-e759-4a7d-a066-f1ae557c151b',\n *     visitType: '7b0f5697-27e3-40c4-8bae-f4049abfb4ed',\n *     startDatetime: '2023-05-25T06:08:25.000+0000',\n *     stopDatetime: '2023-05-25T06:09:25.000+0000',\n *   },\n * })\n * @function\n * @param {object} data - Data parameters of the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createEncounter(data: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Creates an encounter\n * @example <caption>Create an encounter</caption>\n * createEncounter({\n *   encounterDatetime: '2023-05-25T06:08:25.000+0000',\n *   patient: '1fdaa696-e759-4a7d-a066-f1ae557c151b',\n *   encounterType: 'dd528487-82a5-4082-9c72-ed246bd49591',\n *   location: 'ba685651-ed3b-4e63-9b35-78893060758a',\n *   encounterProviders: [],\n *   visit: {\n *     patient: '1fdaa696-e759-4a7d-a066-f1ae557c151b',\n *     visitType: '7b0f5697-27e3-40c4-8bae-f4049abfb4ed',\n *     startDatetime: '2023-05-25T06:08:25.000+0000',\n *     stopDatetime: '2023-05-25T06:09:25.000+0000',\n *   },\n * })\n * @function\n * @param {object} data - Data parameters of the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createEncounter(data, callback = false) {\n  return state => {\n    const { instanceUrl } = state.configuration;\n    const body = expandReferences(data)(state);\n    const url = `${instanceUrl}/ws/rest/v1/encounter`;\n\n    Log.info(`Creating an encounter.`);\n\n    return agent\n      .post(url)\n      .type('json')\n      .send(body)\n      .then(response => {\n        Log.success(`Created an encounter.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "get",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a get request to any OpenMRS endpoint\n * @example\n * get(\"patient\", {\n *   q: \"Patient\",\n *   limit: 1,\n * });\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - parameters for the request\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function get(path, query, callback = false) {\n  return state => {\n    const { instanceUrl } = state.configuration;\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedQuery = expandReferences(query)(state);\n    const urlPath = `${instanceUrl}/ws/rest/v1/${resolvedPath}`;\n\n    return agent\n      .get(urlPath)\n      .query(resolvedQuery)\n      .then(response => handleResponse(response, state, callback))\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Make a get request to any OpenMRS endpoint\n * @example\n * get(\"patient\", {\n *   q: \"Patient\",\n *   limit: 1,\n * });\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - parameters for the request\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function get(path: string, query: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a get request to any OpenMRS endpoint.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a get request to any OpenMRS endpoint.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a get request to any OpenMRS endpoint\n * @example\n * get(\"patient\", {\n *   q: \"Patient\",\n *   limit: 1,\n * });\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - parameters for the request\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function get(path: string, query: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a get request to any OpenMRS endpoint\n * @example\n * get(\"patient\", {\n *   q: \"Patient\",\n *   limit: 1,\n * });\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - parameters for the request\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function get(path, query, callback = false) {\n  return state => {\n    const { instanceUrl } = state.configuration;\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedQuery = expandReferences(query)(state);\n    const urlPath = `${instanceUrl}/ws/rest/v1/${resolvedPath}`;\n\n    return agent\n      .get(urlPath)\n      .query(resolvedQuery)\n      .then(response => handleResponse(response, state, callback))\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "post",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a post request to any OpenMRS endpoint\n * @example\n * post(\n *   \"idgen/identifiersource/8549f706-7e85-4c1d-9424-217d50a2988b/identifier\",\n *   {}\n * );\n * @function\n * @param {string} path - Path to resource\n * @param {object} data - Object which defines data that will be used to create a given instance of resource\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function post(path, data, callback = false) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedData = expandReferences(data)(state);\n    const { instanceUrl } = state.configuration;\n\n    const urlPath = `${instanceUrl}/ws/rest/v1/${resolvedPath}`;\n\n    return agent\n      .post(urlPath)\n      .type('json')\n      .send(resolvedData)\n      .then(response => handleResponse(response, state, callback))\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Make a post request to any OpenMRS endpoint\n * @example\n * post(\n *   \"idgen/identifiersource/8549f706-7e85-4c1d-9424-217d50a2988b/identifier\",\n *   {}\n * );\n * @function\n * @param {string} path - Path to resource\n * @param {object} data - Object which defines data that will be used to create a given instance of resource\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function post(path: string, data: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a post request to an OpenMRS endpoint.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a post request to an OpenMRS endpoint.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a post request to any OpenMRS endpoint\n * @example\n * post(\n *   \"idgen/identifiersource/8549f706-7e85-4c1d-9424-217d50a2988b/identifier\",\n *   {}\n * );\n * @function\n * @param {string} path - Path to resource\n * @param {object} data - Object which defines data that will be used to create a given instance of resource\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function post(path: string, data: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a post request to any OpenMRS endpoint\n * @example\n * post(\n *   \"idgen/identifiersource/8549f706-7e85-4c1d-9424-217d50a2988b/identifier\",\n *   {}\n * );\n * @function\n * @param {string} path - Path to resource\n * @param {object} data - Object which defines data that will be used to create a given instance of resource\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function post(path, data, callback = false) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedData = expandReferences(data)(state);\n    const { instanceUrl } = state.configuration;\n\n    const urlPath = `${instanceUrl}/ws/rest/v1/${resolvedPath}`;\n\n    return agent\n      .post(urlPath)\n      .type('json')\n      .send(resolvedData)\n      .then(response => handleResponse(response, state, callback))\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "searchPatient",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch all non-retired patients that match any specified parameters\n * @example\n * searchPatient({ q: Sarah })\n * @function\n * @param {object} query - Object with query for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function searchPatient(query, callback = false) {\n  return state => {\n    const qs = expandReferences(query)(state);\n    Log.info(`Searching for patient with name: ${qs.q}`);\n    const { instanceUrl } = state.configuration;\n\n    const url = `${instanceUrl}/ws/rest/v1/patient`;\n\n    return agent\n      .get(url)\n      .accept('json')\n      .query(qs)\n      .then(response => {\n        const data = response.body;\n        const count = data.results.length;\n\n        if (count > 0) {\n          Log.success(\n            `Search successful. Returned ${count} patient${\n              count > 1 ? 's' : ''\n            }.`\n          );\n          return handleResponse(response, state, callback);\n        } else {\n          Log.warn(`${count} records were found.`);\n        }\n      })\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Fetch all non-retired patients that match any specified parameters\n * @example\n * searchPatient({ q: Sarah })\n * @function\n * @param {object} query - Object with query for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function searchPatient(query: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that fetches all non-retired patients that match specified parameters",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that fetches all non-retired patients that match specified parameters\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Fetch all non-retired patients that match any specified parameters\n * @example\n * searchPatient({ q: Sarah })\n * @function\n * @param {object} query - Object with query for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function searchPatient(query: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch all non-retired patients that match any specified parameters\n * @example\n * searchPatient({ q: Sarah })\n * @function\n * @param {object} query - Object with query for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function searchPatient(query, callback = false) {\n  return state => {\n    const qs = expandReferences(query)(state);\n    Log.info(`Searching for patient with name: ${qs.q}`);\n    const { instanceUrl } = state.configuration;\n\n    const url = `${instanceUrl}/ws/rest/v1/patient`;\n\n    return agent\n      .get(url)\n      .accept('json')\n      .query(qs)\n      .then(response => {\n        const data = response.body;\n        const count = data.results.length;\n\n        if (count > 0) {\n          Log.success(\n            `Search successful. Returned ${count} patient${\n              count > 1 ? 's' : ''\n            }.`\n          );\n          return handleResponse(response, state, callback);\n        } else {\n          Log.warn(`${count} records were found.`);\n        }\n      })\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "searchPerson",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch all non-retired persons that match any specified parameters\n * @example\n * searchPerson({ q: Sarah })\n * @function\n * @param {object} query - object with query for the person\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function searchPerson(query, callback = false) {\n  return state => {\n    const qs = expandReferences(query)(state);\n    Log.info(`Searching for person with name: ${qs.q}`);\n\n    const { instanceUrl } = state.configuration;\n\n    const url = `${instanceUrl}/ws/rest/v1/person`;\n\n    return agent\n      .get(url)\n      .accept('json')\n      .query(qs)\n      .then(response => {\n        const data = response.body;\n        const count = data.results.length;\n\n        if (count > 0) {\n          Log.success(\n            `Search successful. Returned ${count} person${\n              count > 1 ? 's' : ''\n            }.`\n          );\n          return handleResponse(response, state, callback);\n        } else {\n          Log.warn(`${count} records were found.`);\n        }\n      })\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Fetch all non-retired persons that match any specified parameters\n * @example\n * searchPerson({ q: Sarah })\n * @function\n * @param {object} query - object with query for the person\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function searchPerson(query: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that fetches all non-retired persons that match any specified",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that fetches all non-retired persons that match any specified\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Fetch all non-retired persons that match any specified parameters\n * @example\n * searchPerson({ q: Sarah })\n * @function\n * @param {object} query - object with query for the person\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function searchPerson(query: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch all non-retired persons that match any specified parameters\n * @example\n * searchPerson({ q: Sarah })\n * @function\n * @param {object} query - object with query for the person\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function searchPerson(query, callback = false) {\n  return state => {\n    const qs = expandReferences(query)(state);\n    Log.info(`Searching for person with name: ${qs.q}`);\n\n    const { instanceUrl } = state.configuration;\n\n    const url = `${instanceUrl}/ws/rest/v1/person`;\n\n    return agent\n      .get(url)\n      .accept('json')\n      .query(qs)\n      .then(response => {\n        const data = response.body;\n        const count = data.results.length;\n\n        if (count > 0) {\n          Log.success(\n            `Search successful. Returned ${count} person${\n              count > 1 ? 's' : ''\n            }.`\n          );\n          return handleResponse(response, state, callback);\n        } else {\n          Log.warn(`${count} records were found.`);\n        }\n      })\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "createPatient",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Creates a new patient\n * @example\n * createPatient({\n *   identifiers: [\n *     {\n *       identifier: '4023287',\n *       identifierType: '05a29f94-c0ed-11e2-94be-8c13b969e334',\n *       preferred: true,\n *     },\n *   ],\n *   person: {\n *     gender: 'M',\n *     age: 42,\n *     birthdate: '1970-01-01T00:00:00.000+0100',\n *     birthdateEstimated: false,\n *     names: [\n *       {\n *         givenName: 'Doe',\n *         familyName: 'John',\n *       },\n *     ],\n *   },\n * })\n * @function\n * @param {object} data - Object parameters of the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createPatient(data, callback = false) {\n  return state => {\n    const body = expandReferences(data)(state);\n    const { instanceUrl } = state.configuration;\n    const url = `${instanceUrl}/ws/rest/v1/patient`;\n\n    Log.info(`Creating a patient.`);\n\n    return agent\n      .post(url)\n      .type('json')\n      .send(body)\n      .then(response => {\n        Log.success(`Created a new patient.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Creates a new patient\n * @example\n * createPatient({\n *   identifiers: [\n *     {\n *       identifier: '4023287',\n *       identifierType: '05a29f94-c0ed-11e2-94be-8c13b969e334',\n *       preferred: true,\n *     },\n *   ],\n *   person: {\n *     gender: 'M',\n *     age: 42,\n *     birthdate: '1970-01-01T00:00:00.000+0100',\n *     birthdateEstimated: false,\n *     names: [\n *       {\n *         givenName: 'Doe',\n *         familyName: 'John',\n *       },\n *     ],\n *   },\n * })\n * @function\n * @param {object} data - Object parameters of the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createPatient(data: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that creates a new patient.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates a new patient.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Creates a new patient\n * @example\n * createPatient({\n *   identifiers: [\n *     {\n *       identifier: '4023287',\n *       identifierType: '05a29f94-c0ed-11e2-94be-8c13b969e334',\n *       preferred: true,\n *     },\n *   ],\n *   person: {\n *     gender: 'M',\n *     age: 42,\n *     birthdate: '1970-01-01T00:00:00.000+0100',\n *     birthdateEstimated: false,\n *     names: [\n *       {\n *         givenName: 'Doe',\n *         familyName: 'John',\n *       },\n *     ],\n *   },\n * })\n * @function\n * @param {object} data - Object parameters of the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createPatient(data: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Creates a new patient\n * @example\n * createPatient({\n *   identifiers: [\n *     {\n *       identifier: '4023287',\n *       identifierType: '05a29f94-c0ed-11e2-94be-8c13b969e334',\n *       preferred: true,\n *     },\n *   ],\n *   person: {\n *     gender: 'M',\n *     age: 42,\n *     birthdate: '1970-01-01T00:00:00.000+0100',\n *     birthdateEstimated: false,\n *     names: [\n *       {\n *         givenName: 'Doe',\n *         familyName: 'John',\n *       },\n *     ],\n *   },\n * })\n * @function\n * @param {object} data - Object parameters of the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createPatient(data, callback = false) {\n  return state => {\n    const body = expandReferences(data)(state);\n    const { instanceUrl } = state.configuration;\n    const url = `${instanceUrl}/ws/rest/v1/patient`;\n\n    Log.info(`Creating a patient.`);\n\n    return agent\n      .post(url)\n      .type('json')\n      .send(body)\n      .then(response => {\n        Log.success(`Created a new patient.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "getEncounter",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Gets encounter matching a uuid\n * @example\n * getEncounter(\"123\")\n * @function\n * @param {object} uuid - A uuid for the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounter(uuid, callback = false) {\n  return state => {\n    Log.info(`Searching for encounter with uuid: ${uuid}`);\n    const { instanceUrl } = state.configuration;\n\n    const url = `${instanceUrl}/ws/rest/v1/encounter/${uuid}`;\n\n    return agent\n      .get(url)\n      .accept('json')\n      .then(response => {\n        Log.success(`Found an encounter.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Gets encounter matching a uuid\n * @example\n * getEncounter(\"123\")\n * @function\n * @param {object} uuid - A uuid for the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounter(uuid: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets an encounter matching a uuid.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets an encounter matching a uuid.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Gets encounter matching a uuid\n * @example\n * getEncounter(\"123\")\n * @function\n * @param {object} uuid - A uuid for the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounter(uuid: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Gets encounter matching a uuid\n * @example\n * getEncounter(\"123\")\n * @function\n * @param {object} uuid - A uuid for the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounter(uuid, callback = false) {\n  return state => {\n    Log.info(`Searching for encounter with uuid: ${uuid}`);\n    const { instanceUrl } = state.configuration;\n\n    const url = `${instanceUrl}/ws/rest/v1/encounter/${uuid}`;\n\n    return agent\n      .get(url)\n      .accept('json')\n      .then(response => {\n        Log.success(`Found an encounter.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "getEncounters",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Gets encounters matching params\n * @example\n * getEncounters({patient: \"123\", fromdate: \"2023-05-18\"})\n * @function\n * @param {object} query - Object for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounters(query, callback = false) {\n  return state => {\n    const qs = expandReferences(query)(state);\n    const { instanceUrl } = state.configuration;\n    const url = `${instanceUrl}/ws/rest/v1/encounter`;\n\n    Log.info(`Searching for encounters: ${JSON.stringify(qs, null, 2)}`);\n\n    return agent\n      .get(url)\n      .accept('json')\n      .query(qs)\n      .then(response => {\n        Log.success(`Found an encounter.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Gets encounters matching params\n * @example\n * getEncounters({patient: \"123\", fromdate: \"2023-05-18\"})\n * @function\n * @param {object} query - Object for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounters(query: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets encounters matching params from an object.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets encounters matching params from an object.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Gets encounters matching params\n * @example\n * getEncounters({patient: \"123\", fromdate: \"2023-05-18\"})\n * @function\n * @param {object} query - Object for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounters(query: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Gets encounters matching params\n * @example\n * getEncounters({patient: \"123\", fromdate: \"2023-05-18\"})\n * @function\n * @param {object} query - Object for the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounters(query, callback = false) {\n  return state => {\n    const qs = expandReferences(query)(state);\n    const { instanceUrl } = state.configuration;\n    const url = `${instanceUrl}/ws/rest/v1/encounter`;\n\n    Log.info(`Searching for encounters: ${JSON.stringify(qs, null, 2)}`);\n\n    return agent\n      .get(url)\n      .accept('json')\n      .query(qs)\n      .then(response => {\n        Log.success(`Found an encounter.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "create",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `person`, `patient`, `encounter`, ...\n * @param {OpenMRSData} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>Create a person</caption>\n * create(\"person\", {\n *   names: [\n *     {\n *       givenName: \"Mohit\",\n *       familyName: \"Kumar\",\n *     },\n *   ],\n *   gender: \"M\",\n *   birthdate: \"1997-09-02\",\n *   addresses: [\n *     {\n *       address1: \"30, Vivekananda Layout, Munnekolal,Marathahalli\",\n *       cityVillage: \"Bengaluru\",\n *       country: \"India\",\n *       postalCode: \"560037\",\n *     },\n *   ],\n * });\n */\nexport function create(resourceType, data, callback = false) {\n  return state => {\n    Log.info(`Preparing create operation...`);\n\n    const resolvedData = expandReferences(data)(state);\n    const resolvedResourceType = expandReferences(resourceType)(state);\n\n    const { instanceUrl } = state.configuration;\n    const url = `${instanceUrl}/ws/rest/v1/${resolvedResourceType}`;\n\n    return agent\n      .post(url)\n      .type('json')\n      .send(resolvedData)\n      .then(response => {\n        const details = `with response ${JSON.stringify(\n          response.body,\n          null,\n          2\n        )}`;\n\n        Log.success(`Created ${resolvedResourceType} ${details}`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `person`, `patient`, `encounter`, ...\n * @param {OpenMRSData} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>Create a person</caption>\n * create(\"person\", {\n *   names: [\n *     {\n *       givenName: \"Mohit\",\n *       familyName: \"Kumar\",\n *     },\n *   ],\n *   gender: \"M\",\n *   birthdate: \"1997-09-02\",\n *   addresses: [\n *     {\n *       address1: \"30, Vivekananda Layout, Munnekolal,Marathahalli\",\n *       cityVillage: \"Bengaluru\",\n *       country: \"India\",\n *       postalCode: \"560037\",\n *     },\n *   ],\n * });\n */\nexport function create(resourceType: string, data: OpenMRSData, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that creates a record to/on/from resourceType.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates a record to/on/from resourceType.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `person`, `patient`, `encounter`, ...\n * @param {OpenMRSData} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>Create a person</caption>\n * create(\"person\", {\n *   names: [\n *     {\n *       givenName: \"Mohit\",\n *       familyName: \"Kumar\",\n *     },\n *   ],\n *   gender: \"M\",\n *   birthdate: \"1997-09-02\",\n *   addresses: [\n *     {\n *       address1: \"30, Vivekananda Layout, Munnekolal,Marathahalli\",\n *       cityVillage: \"Bengaluru\",\n *       country: \"India\",\n *       postalCode: \"560037\",\n *     },\n *   ],\n * });\n */\nexport function create(resourceType: string, data: OpenMRSData, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `person`, `patient`, `encounter`, ...\n * @param {OpenMRSData} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>Create a person</caption>\n * create(\"person\", {\n *   names: [\n *     {\n *       givenName: \"Mohit\",\n *       familyName: \"Kumar\",\n *     },\n *   ],\n *   gender: \"M\",\n *   birthdate: \"1997-09-02\",\n *   addresses: [\n *     {\n *       address1: \"30, Vivekananda Layout, Munnekolal,Marathahalli\",\n *       cityVillage: \"Bengaluru\",\n *       country: \"India\",\n *       postalCode: \"560037\",\n *     },\n *   ],\n * });\n */\nexport function create(resourceType, data, callback = false) {\n  return state => {\n    Log.info(`Preparing create operation...`);\n\n    const resolvedData = expandReferences(data)(state);\n    const resolvedResourceType = expandReferences(resourceType)(state);\n\n    const { instanceUrl } = state.configuration;\n    const url = `${instanceUrl}/ws/rest/v1/${resolvedResourceType}`;\n\n    return agent\n      .post(url)\n      .type('json')\n      .send(resolvedData)\n      .then(response => {\n        const details = `with response ${JSON.stringify(\n          response.body,\n          null,\n          2\n        )}`;\n\n        Log.success(`Created ${resolvedResourceType} ${details}`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "update",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Update data. A generic helper function to update a resource object of any type.\n * Updating an object requires to send `all required fields` or the `full body`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be updated. E.g. `person`, `patient`, etc.\n * @param {string} path - The `id` or `path` to the `object` to be updated. E.g. `e739808f-f166-42ae-aaf3-8b3e8fa13fda` or `e739808f-f166-42ae-aaf3-8b3e8fa13fda/{collection-name}/{object-id}`\n * @param {Object} data - Data to update. It requires to send `all required fields` or the `full body`. If you want `partial updates`, use `patch` operation.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a person</caption>\n * update(\"person\", '3cad37ad-984d-4c65-a019-3eb120c9c373',{\"gender\":\"M\",\"birthdate\":\"1997-01-13\"})\n */\nexport function update(resourceType, path, data, callback = false) {\n  return state => {\n    Log.info(`Preparing update operation...`);\n\n    const { instanceUrl } = state.configuration;\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedData = expandReferences(data)(state);\n\n    const url = `${instanceUrl}/ws/rest/v1/${resolvedResourceType}/${resolvedPath}`;\n\n    return agent\n      .post(url)\n      .type('json')\n      .send(resolvedData)\n      .then(response => {\n        Log.success(`Updated ${resolvedResourceType} at ${resolvedPath}`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Update data. A generic helper function to update a resource object of any type.\n * Updating an object requires to send `all required fields` or the `full body`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be updated. E.g. `person`, `patient`, etc.\n * @param {string} path - The `id` or `path` to the `object` to be updated. E.g. `e739808f-f166-42ae-aaf3-8b3e8fa13fda` or `e739808f-f166-42ae-aaf3-8b3e8fa13fda/{collection-name}/{object-id}`\n * @param {Object} data - Data to update. It requires to send `all required fields` or the `full body`. If you want `partial updates`, use `patch` operation.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a person</caption>\n * update(\"person\", '3cad37ad-984d-4c65-a019-3eb120c9c373',{\"gender\":\"M\",\"birthdate\":\"1997-01-13\"})\n */\nexport function update(resourceType: string, path: string, data: any, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that updates data to/on/from a resource object.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that updates data to/on/from a resource object.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Update data. A generic helper function to update a resource object of any type.\n * Updating an object requires to send `all required fields` or the `full body`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be updated. E.g. `person`, `patient`, etc.\n * @param {string} path - The `id` or `path` to the `object` to be updated. E.g. `e739808f-f166-42ae-aaf3-8b3e8fa13fda` or `e739808f-f166-42ae-aaf3-8b3e8fa13fda/{collection-name}/{object-id}`\n * @param {Object} data - Data to update. It requires to send `all required fields` or the `full body`. If you want `partial updates`, use `patch` operation.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a person</caption>\n * update(\"person\", '3cad37ad-984d-4c65-a019-3eb120c9c373',{\"gender\":\"M\",\"birthdate\":\"1997-01-13\"})\n */\nexport function update(resourceType: string, path: string, data: any, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Update data. A generic helper function to update a resource object of any type.\n * Updating an object requires to send `all required fields` or the `full body`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be updated. E.g. `person`, `patient`, etc.\n * @param {string} path - The `id` or `path` to the `object` to be updated. E.g. `e739808f-f166-42ae-aaf3-8b3e8fa13fda` or `e739808f-f166-42ae-aaf3-8b3e8fa13fda/{collection-name}/{object-id}`\n * @param {Object} data - Data to update. It requires to send `all required fields` or the `full body`. If you want `partial updates`, use `patch` operation.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a person</caption>\n * update(\"person\", '3cad37ad-984d-4c65-a019-3eb120c9c373',{\"gender\":\"M\",\"birthdate\":\"1997-01-13\"})\n */\nexport function update(resourceType, path, data, callback = false) {\n  return state => {\n    Log.info(`Preparing update operation...`);\n\n    const { instanceUrl } = state.configuration;\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedData = expandReferences(data)(state);\n\n    const url = `${instanceUrl}/ws/rest/v1/${resolvedResourceType}/${resolvedPath}`;\n\n    return agent\n      .post(url)\n      .type('json')\n      .send(resolvedData)\n      .then(response => {\n        Log.success(`Updated ${resolvedResourceType} at ${resolvedPath}`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "upsert",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert a record. A generic helper function used to atomically either insert a row, or on the basis of the row already existing, UPDATE that existing row instead.\n * @public\n * @function\n * @param {string} resourceType - The type of a resource to `upsert`. E.g. `trackedEntityInstances`\n * @param {Object} query - A query object that allows to uniquely identify the resource to update. If no matches found, then the resource will be created.\n * @param {Object} data - The data to use for update or create depending on the result of the query.\n * @param {function} [callback] - Optional callback to handle the response\n * @throws {RangeError} - Throws range error\n * @returns {Operation}\n * @example <caption>For an existing patient using upsert</caption>\n * upsert('patient', { q: '10007JJ' }, { person: { age: 50 } });\n * @example <caption>For non existing patient creating a patient record using upsert </caption>\n * upsert(\n *   \"patient\",\n *   { q: \"1000EHE\" },\n *   {\n *     identifiers: [\n *       {\n *         identifier: \"1000EHE\",\n *         identifierType: \"05a29f94-c0ed-11e2-94be-8c13b969e334\",\n *         location: \"44c3efb0-2583-4c80-a79e-1f756a03c0a1\",\n *         preferred: true,\n *       },\n *     ],\n *     person: {\n *       gender: \"M\",\n *       age: 42,\n *     },\n *   }\n * );\n */\nexport function upsert(\n  resourceType, // resourceType supplied to both the `get` and the `create/update`\n  query, // query supplied to the `get`\n  data, // data supplied to the `create/update`\n  callback = false // callback for the upsert itself.\n) {\n  return state => {\n    Log.info(`Preparing upsert via 'get' then 'create' OR 'update'...`);\n\n    return get(\n      resourceType,\n      query\n    )(state)\n      .then(resp => {\n        const resources = resp.data.body.results;\n        if (resources.length > 1) {\n          throw new RangeError(\n            `Cannot upsert on Non-unique attribute. The operation found more than one records for your request.`\n          );\n        } else if (resources.length <= 0) {\n          return create(resourceType, data)(state);\n        } else {\n          // Pick out the first (and only) resource in the array and grab its\n          // ID to be used in the subsequent `update` by the path determined\n          const path = resources[0]['uuid'];\n          return update(resourceType, path, data)(state);\n        }\n      })\n      .then(result => {\n        Log.success(`Performed a \"composed upsert\" on ${resourceType}`);\n        return handleResponse(result, state, callback);\n      });\n  };\n}",
    "signature": "/**\n * Upsert a record. A generic helper function used to atomically either insert a row, or on the basis of the row already existing, UPDATE that existing row instead.\n * @public\n * @function\n * @param {string} resourceType - The type of a resource to `upsert`. E.g. `trackedEntityInstances`\n * @param {Object} query - A query object that allows to uniquely identify the resource to update. If no matches found, then the resource will be created.\n * @param {Object} data - The data to use for update or create depending on the result of the query.\n * @param {function} [callback] - Optional callback to handle the response\n * @throws {RangeError} - Throws range error\n * @returns {Operation}\n * @example <caption>For an existing patient using upsert</caption>\n * upsert('patient', { q: '10007JJ' }, { person: { age: 50 } });\n * @example <caption>For non existing patient creating a patient record using upsert </caption>\n * upsert(\n *   \"patient\",\n *   { q: \"1000EHE\" },\n *   {\n *     identifiers: [\n *       {\n *         identifier: \"1000EHE\",\n *         identifierType: \"05a29f94-c0ed-11e2-94be-8c13b969e334\",\n *         location: \"44c3efb0-2583-4c80-a79e-1f756a03c0a1\",\n *         preferred: true,\n *       },\n *     ],\n *     person: {\n *       gender: \"M\",\n *       age: 42,\n *     },\n *   }\n * );\n */\nexport function upsert(resourceType: string, query: any, data: any, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts to a resource.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts to a resource.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Upsert a record. A generic helper function used to atomically either insert a row, or on the basis of the row already existing, UPDATE that existing row instead.\n * @public\n * @function\n * @param {string} resourceType - The type of a resource to `upsert`. E.g. `trackedEntityInstances`\n * @param {Object} query - A query object that allows to uniquely identify the resource to update. If no matches found, then the resource will be created.\n * @param {Object} data - The data to use for update or create depending on the result of the query.\n * @param {function} [callback] - Optional callback to handle the response\n * @throws {RangeError} - Throws range error\n * @returns {Operation}\n * @example <caption>For an existing patient using upsert</caption>\n * upsert('patient', { q: '10007JJ' }, { person: { age: 50 } });\n * @example <caption>For non existing patient creating a patient record using upsert </caption>\n * upsert(\n *   \"patient\",\n *   { q: \"1000EHE\" },\n *   {\n *     identifiers: [\n *       {\n *         identifier: \"1000EHE\",\n *         identifierType: \"05a29f94-c0ed-11e2-94be-8c13b969e334\",\n *         location: \"44c3efb0-2583-4c80-a79e-1f756a03c0a1\",\n *         preferred: true,\n *       },\n *     ],\n *     person: {\n *       gender: \"M\",\n *       age: 42,\n *     },\n *   }\n * );\n */\nexport function upsert(resourceType: string, query: any, data: any, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert a record. A generic helper function used to atomically either insert a row, or on the basis of the row already existing, UPDATE that existing row instead.\n * @public\n * @function\n * @param {string} resourceType - The type of a resource to `upsert`. E.g. `trackedEntityInstances`\n * @param {Object} query - A query object that allows to uniquely identify the resource to update. If no matches found, then the resource will be created.\n * @param {Object} data - The data to use for update or create depending on the result of the query.\n * @param {function} [callback] - Optional callback to handle the response\n * @throws {RangeError} - Throws range error\n * @returns {Operation}\n * @example <caption>For an existing patient using upsert</caption>\n * upsert('patient', { q: '10007JJ' }, { person: { age: 50 } });\n * @example <caption>For non existing patient creating a patient record using upsert </caption>\n * upsert(\n *   \"patient\",\n *   { q: \"1000EHE\" },\n *   {\n *     identifiers: [\n *       {\n *         identifier: \"1000EHE\",\n *         identifierType: \"05a29f94-c0ed-11e2-94be-8c13b969e334\",\n *         location: \"44c3efb0-2583-4c80-a79e-1f756a03c0a1\",\n *         preferred: true,\n *       },\n *     ],\n *     person: {\n *       gender: \"M\",\n *       age: 42,\n *     },\n *   }\n * );\n */\nexport function upsert(\n  resourceType, // resourceType supplied to both the `get` and the `create/update`\n  query, // query supplied to the `get`\n  data, // data supplied to the `create/update`\n  callback = false // callback for the upsert itself.\n) {\n  return state => {\n    Log.info(`Preparing upsert via 'get' then 'create' OR 'update'...`);\n\n    return get(\n      resourceType,\n      query\n    )(state)\n      .then(resp => {\n        const resources = resp.data.body.results;\n        if (resources.length > 1) {\n          throw new RangeError(\n            `Cannot upsert on Non-unique attribute. The operation found more than one records for your request.`\n          );\n        } else if (resources.length <= 0) {\n          return create(resourceType, data)(state);\n        } else {\n          // Pick out the first (and only) resource in the array and grab its\n          // ID to be used in the subsequent `update` by the path determined\n          const path = resources[0]['uuid'];\n          return update(resourceType, path, data)(state);\n        }\n      })\n      .then(result => {\n        Log.success(`Performed a \"composed upsert\" on ${resourceType}`);\n        return handleResponse(result, state, callback);\n      });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      login,\n      ...operations\n      /* logout */\n    )({ ...initialState, ...state }).catch(e => {\n      console.error(e);\n      /* logout(); */\n      process.exit(1);\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      login,\n      ...operations\n      /* logout */\n    )({ ...initialState, ...state }).catch(e => {\n      console.error(e);\n      /* logout(); */\n      process.exit(1);\n    });\n  };\n}\n"
  },
  {
    "name": "listContacts",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch the list of contacts within a particular outbreak using its ID.\n * @public\n * @example\n *  listContacts(\"343d-dc3e\", // Outbreak Id\n *    state => {\n *       console.log(state);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listContacts(id, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: `/outbreaks/${id}/contacts`,\n      params: {\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Fetch the list of contacts within a particular outbreak using its ID.\n * @public\n * @example\n *  listContacts(\"343d-dc3e\", // Outbreak Id\n *    state => {\n *       console.log(state);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listContacts(id: string, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that fetches the list of contacts from a particular outbreak using its",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that fetches the list of contacts from a particular outbreak using its\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Fetch the list of contacts within a particular outbreak using its ID.\n * @public\n * @example\n *  listContacts(\"343d-dc3e\", // Outbreak Id\n *    state => {\n *       console.log(state);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listContacts(id: string, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch the list of contacts within a particular outbreak using its ID.\n * @public\n * @example\n *  listContacts(\"343d-dc3e\", // Outbreak Id\n *    state => {\n *       console.log(state);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listContacts(id, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: `/outbreaks/${id}/contacts`,\n      params: {\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "getContact",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get one or multiple contacts within an outbreak from a query filter\n * @public\n * @example\n *  getContact(\"343d-dc3e\", {\"where\":{\"firstName\": \"Luca\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getContact(id, query, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      baseURL: apiUrl,\n      url: `/outbreaks/${id}/contacts`,\n      method: 'GET',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Get one or multiple contacts within an outbreak from a query filter\n * @public\n * @example\n *  getContact(\"343d-dc3e\", {\"where\":{\"firstName\": \"Luca\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getContact(id: string, query: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets one or multiple contacts from an outbreak.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets one or multiple contacts from an outbreak.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get one or multiple contacts within an outbreak from a query filter\n * @public\n * @example\n *  getContact(\"343d-dc3e\", {\"where\":{\"firstName\": \"Luca\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getContact(id: string, query: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get one or multiple contacts within an outbreak from a query filter\n * @public\n * @example\n *  getContact(\"343d-dc3e\", {\"where\":{\"firstName\": \"Luca\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getContact(id, query, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      baseURL: apiUrl,\n      url: `/outbreaks/${id}/contacts`,\n      method: 'GET',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "upsertContact",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert contact to godata using an external id to match a specific record.\n * @public\n * @example\n *  upsertContact(\"4dce-3eedce3-rd33\", 'visualId',\n *    {\n *      firstName: 'Luca',\n *      gender: 'male',\n *      'age:years': '20'\n *      ...\n *    }\n *  )\n * @function\n * @param {string} id - Outbreak id\n * @param {string} externalId - External Id to match\n * @param {object} goDataContact - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertContact(id, externalId, goDataContact, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const data = expandReferences(goDataContact)(state);\n\n    const query = { where: {} };\n    query.where[externalId] = data[externalId];\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      baseURL: apiUrl,\n      url: `/outbreaks/${id}/contacts`,\n      method: 'GET',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        if (response.data.length > 1) {\n          console.log('Multiple contacts found. Aborting upsert.');\n          console.log(response.data.length, 'contacts');\n        } else if (response.data.length === 1) {\n          console.log('Contact found. Performing update.');\n          const contactId = response.data[0].id;\n          return axios({\n            method: 'PUT',\n            baseURL: apiUrl,\n            url: `/outbreaks/${id}/contacts/${contactId}`,\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        } else {\n          console.log('No contact found. Performing create.');\n          return axios({\n            method: 'POST',\n            baseURL: apiUrl,\n            url: `/outbreaks/${id}/contacts/`,\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        }\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Upsert contact to godata using an external id to match a specific record.\n * @public\n * @example\n *  upsertContact(\"4dce-3eedce3-rd33\", 'visualId',\n *    {\n *      firstName: 'Luca',\n *      gender: 'male',\n *      'age:years': '20'\n *      ...\n *    }\n *  )\n * @function\n * @param {string} id - Outbreak id\n * @param {string} externalId - External Id to match\n * @param {object} goDataContact - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertContact(id: string, externalId: string, goDataContact: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts a contact to Godata using an external ID",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts a contact to Godata using an external ID\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Upsert contact to godata using an external id to match a specific record.\n * @public\n * @example\n *  upsertContact(\"4dce-3eedce3-rd33\", 'visualId',\n *    {\n *      firstName: 'Luca',\n *      gender: 'male',\n *      'age:years': '20'\n *      ...\n *    }\n *  )\n * @function\n * @param {string} id - Outbreak id\n * @param {string} externalId - External Id to match\n * @param {object} goDataContact - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertContact(id: string, externalId: string, goDataContact: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert contact to godata using an external id to match a specific record.\n * @public\n * @example\n *  upsertContact(\"4dce-3eedce3-rd33\", 'visualId',\n *    {\n *      firstName: 'Luca',\n *      gender: 'male',\n *      'age:years': '20'\n *      ...\n *    }\n *  )\n * @function\n * @param {string} id - Outbreak id\n * @param {string} externalId - External Id to match\n * @param {object} goDataContact - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertContact(id, externalId, goDataContact, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const data = expandReferences(goDataContact)(state);\n\n    const query = { where: {} };\n    query.where[externalId] = data[externalId];\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      baseURL: apiUrl,\n      url: `/outbreaks/${id}/contacts`,\n      method: 'GET',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        if (response.data.length > 1) {\n          console.log('Multiple contacts found. Aborting upsert.');\n          console.log(response.data.length, 'contacts');\n        } else if (response.data.length === 1) {\n          console.log('Contact found. Performing update.');\n          const contactId = response.data[0].id;\n          return axios({\n            method: 'PUT',\n            baseURL: apiUrl,\n            url: `/outbreaks/${id}/contacts/${contactId}`,\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        } else {\n          console.log('No contact found. Performing create.');\n          return axios({\n            method: 'POST',\n            baseURL: apiUrl,\n            url: `/outbreaks/${id}/contacts/`,\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        }\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "listOutbreaks",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch the list of outbreaks\n * @public\n * @example\n *  listOutbreaks(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listOutbreaks(callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/outbreaks',\n      params: {\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Fetch the list of outbreaks\n * @public\n * @example\n *  listOutbreaks(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listOutbreaks(callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that fetches the list of outbreaks.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that fetches the list of outbreaks.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Fetch the list of outbreaks\n * @public\n * @example\n *  listOutbreaks(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listOutbreaks(callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch the list of outbreaks\n * @public\n * @example\n *  listOutbreaks(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listOutbreaks(callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/outbreaks',\n      params: {\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "getOutbreak",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get one or multiple outbreaks from a query filter\n * @public\n * @example\n *  getOutbreak({\"where\":{\"name\": \"Outbreak demo\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getOutbreak(query, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/outbreaks',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Get one or multiple outbreaks from a query filter\n * @public\n * @example\n *  getOutbreak({\"where\":{\"name\": \"Outbreak demo\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getOutbreak(query: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets one or multiple outbreaks from a query filter.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets one or multiple outbreaks from a query filter.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get one or multiple outbreaks from a query filter\n * @public\n * @example\n *  getOutbreak({\"where\":{\"name\": \"Outbreak demo\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getOutbreak(query: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get one or multiple outbreaks from a query filter\n * @public\n * @example\n *  getOutbreak({\"where\":{\"name\": \"Outbreak demo\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getOutbreak(query, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/outbreaks',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "upsertOutbreak",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert outbreak to godata\n * @public\n * @example\n *  upsertOutbreak({externalId: \"3dec33-ede3\", data: {...}})\n * @function\n * @param {object} outbreak - an object with an externalId and some outbreak data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertOutbreak(outbreak, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const { externalId, data } = expandReferences(outbreak)(state);\n\n    const filter = JSON.stringify({ where: { id: externalId } });\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/outbreaks',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        if (response.data.length > 0) {\n          console.log('Outbreak found. Performing update.');\n          const outbreakId = response.data[0].id;\n          return axios({\n            method: 'PUT',\n            baseURL: apiUrl,\n            url: `/outbreaks/${outbreakId}`,\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        } else {\n          console.log('No outbreak found. Performing create.');\n          return axios({\n            method: 'POST',\n            baseURL: apiUrl,\n            url: '/outbreaks',\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        }\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Upsert outbreak to godata\n * @public\n * @example\n *  upsertOutbreak({externalId: \"3dec33-ede3\", data: {...}})\n * @function\n * @param {object} outbreak - an object with an externalId and some outbreak data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertOutbreak(outbreak: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts to godata from an outbreak object.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts to godata from an outbreak object.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Upsert outbreak to godata\n * @public\n * @example\n *  upsertOutbreak({externalId: \"3dec33-ede3\", data: {...}})\n * @function\n * @param {object} outbreak - an object with an externalId and some outbreak data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertOutbreak(outbreak: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert outbreak to godata\n * @public\n * @example\n *  upsertOutbreak({externalId: \"3dec33-ede3\", data: {...}})\n * @function\n * @param {object} outbreak - an object with an externalId and some outbreak data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertOutbreak(outbreak, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const { externalId, data } = expandReferences(outbreak)(state);\n\n    const filter = JSON.stringify({ where: { id: externalId } });\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/outbreaks',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        if (response.data.length > 0) {\n          console.log('Outbreak found. Performing update.');\n          const outbreakId = response.data[0].id;\n          return axios({\n            method: 'PUT',\n            baseURL: apiUrl,\n            url: `/outbreaks/${outbreakId}`,\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        } else {\n          console.log('No outbreak found. Performing create.');\n          return axios({\n            method: 'POST',\n            baseURL: apiUrl,\n            url: '/outbreaks',\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        }\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "listCases",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch the list of cases within a particular outbreak using its ID.\n * @public\n * @example\n *  listCases(\"343d-dc3e\", state => {\n *    console.log(state);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listCases(id, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: `/outbreaks/${id}/cases`,\n      params: {\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Fetch the list of cases within a particular outbreak using its ID.\n * @public\n * @example\n *  listCases(\"343d-dc3e\", state => {\n *    console.log(state);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listCases(id: string, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that fetches the list of cases from a particular outbreak using its",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that fetches the list of cases from a particular outbreak using its\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Fetch the list of cases within a particular outbreak using its ID.\n * @public\n * @example\n *  listCases(\"343d-dc3e\", state => {\n *    console.log(state);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listCases(id: string, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch the list of cases within a particular outbreak using its ID.\n * @public\n * @example\n *  listCases(\"343d-dc3e\", state => {\n *    console.log(state);\n *    return state;\n *  });\n * @function\n * @param {string} id - Outbreak id\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listCases(id, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: `/outbreaks/${id}/cases`,\n      params: {\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "getCase",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get one or multiple cases within an outbreak from a query filter\n * @public\n * @example\n * getCase(\n *    '3b55-cdf4',\n *    { 'where.relationship': { active: true }, where: { firstName: 'Luca'} },\n *    state => {\n *      console.log(state);\n *      return state;\n *    }\n * );\n * @function\n * @param {string} id - Outbreak id\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getCase(id, query, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      baseURL: apiUrl,\n      url: `/outbreaks/${id}/cases`,\n      method: 'GET',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Get one or multiple cases within an outbreak from a query filter\n * @public\n * @example\n * getCase(\n *    '3b55-cdf4',\n *    { 'where.relationship': { active: true }, where: { firstName: 'Luca'} },\n *    state => {\n *      console.log(state);\n *      return state;\n *    }\n * );\n * @function\n * @param {string} id - Outbreak id\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getCase(id: string, query: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets one or multiple cases within an outbreak from a query filter",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets one or multiple cases within an outbreak from a query filter\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get one or multiple cases within an outbreak from a query filter\n * @public\n * @example\n * getCase(\n *    '3b55-cdf4',\n *    { 'where.relationship': { active: true }, where: { firstName: 'Luca'} },\n *    state => {\n *      console.log(state);\n *      return state;\n *    }\n * );\n * @function\n * @param {string} id - Outbreak id\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getCase(id: string, query: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get one or multiple cases within an outbreak from a query filter\n * @public\n * @example\n * getCase(\n *    '3b55-cdf4',\n *    { 'where.relationship': { active: true }, where: { firstName: 'Luca'} },\n *    state => {\n *      console.log(state);\n *      return state;\n *    }\n * );\n * @function\n * @param {string} id - Outbreak id\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getCase(id, query, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      baseURL: apiUrl,\n      url: `/outbreaks/${id}/cases`,\n      method: 'GET',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "upsertCase",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert case to godata using an external id to mach a specific record\n * @public\n * @example\n *  upsertCase(\"4dce-3eedce3-rd33\", 'visualId',\n *    data: state => {\n *      const patient = state.data.body;\n *       return {\n *         firstName: patient.Patient_name.split(' ')[0],\n *         lastName: patient.Patient_name.split(' ')[1],\n *         visualId: patient.Case_ID,\n *         'age:years': patient.Age_in_year,\n *         gender: patient.Sex,\n *       };\n *  })\n * @function\n * @param {string} id - Outbreak id\n * @param {string} externalId - External Id to match\n * @param {object} goDataCase - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertCase(id, externalId, goDataCase, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const data = expandReferences(goDataCase)(state);\n\n    const query = { where: {} };\n    query.where[externalId] = data[externalId];\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      baseURL: apiUrl,\n      url: `/outbreaks/${id}/cases`,\n      method: 'GET',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        if (response.data.length > 1) {\n          console.log(response.data.length, 'cases found; aborting upsert.');\n        } else if (response.data.length === 1) {\n          console.log('Case found. Performing update.');\n          const caseId = response.data[0].id;\n          data['id'] = caseId;\n          delete data.visualId;\n          return axios({\n            method: 'PUT',\n            baseURL: apiUrl,\n            url: `/outbreaks/${id}/cases/${caseId}`,\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        } else {\n          console.log('No case found. Performing create.');\n          return axios({\n            method: 'POST',\n            baseURL: apiUrl,\n            url: `/outbreaks/${id}/cases/`,\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        }\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Upsert case to godata using an external id to mach a specific record\n * @public\n * @example\n *  upsertCase(\"4dce-3eedce3-rd33\", 'visualId',\n *    data: state => {\n *      const patient = state.data.body;\n *       return {\n *         firstName: patient.Patient_name.split(' ')[0],\n *         lastName: patient.Patient_name.split(' ')[1],\n *         visualId: patient.Case_ID,\n *         'age:years': patient.Age_in_year,\n *         gender: patient.Sex,\n *       };\n *  })\n * @function\n * @param {string} id - Outbreak id\n * @param {string} externalId - External Id to match\n * @param {object} goDataCase - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertCase(id: string, externalId: string, goDataCase: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts a case to godata using an external id",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts a case to godata using an external id\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Upsert case to godata using an external id to mach a specific record\n * @public\n * @example\n *  upsertCase(\"4dce-3eedce3-rd33\", 'visualId',\n *    data: state => {\n *      const patient = state.data.body;\n *       return {\n *         firstName: patient.Patient_name.split(' ')[0],\n *         lastName: patient.Patient_name.split(' ')[1],\n *         visualId: patient.Case_ID,\n *         'age:years': patient.Age_in_year,\n *         gender: patient.Sex,\n *       };\n *  })\n * @function\n * @param {string} id - Outbreak id\n * @param {string} externalId - External Id to match\n * @param {object} goDataCase - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertCase(id: string, externalId: string, goDataCase: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert case to godata using an external id to mach a specific record\n * @public\n * @example\n *  upsertCase(\"4dce-3eedce3-rd33\", 'visualId',\n *    data: state => {\n *      const patient = state.data.body;\n *       return {\n *         firstName: patient.Patient_name.split(' ')[0],\n *         lastName: patient.Patient_name.split(' ')[1],\n *         visualId: patient.Case_ID,\n *         'age:years': patient.Age_in_year,\n *         gender: patient.Sex,\n *       };\n *  })\n * @function\n * @param {string} id - Outbreak id\n * @param {string} externalId - External Id to match\n * @param {object} goDataCase - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertCase(id, externalId, goDataCase, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const data = expandReferences(goDataCase)(state);\n\n    const query = { where: {} };\n    query.where[externalId] = data[externalId];\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      baseURL: apiUrl,\n      url: `/outbreaks/${id}/cases`,\n      method: 'GET',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        if (response.data.length > 1) {\n          console.log(response.data.length, 'cases found; aborting upsert.');\n        } else if (response.data.length === 1) {\n          console.log('Case found. Performing update.');\n          const caseId = response.data[0].id;\n          data['id'] = caseId;\n          delete data.visualId;\n          return axios({\n            method: 'PUT',\n            baseURL: apiUrl,\n            url: `/outbreaks/${id}/cases/${caseId}`,\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        } else {\n          console.log('No case found. Performing create.');\n          return axios({\n            method: 'POST',\n            baseURL: apiUrl,\n            url: `/outbreaks/${id}/cases/`,\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        }\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "listLocations",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch the list of locations\n * @public\n * @example\n *  listLocations(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listLocations(callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/locations',\n      params: {\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Fetch the list of locations\n * @public\n * @example\n *  listLocations(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listLocations(callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that fetches the list of locations.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that fetches the list of locations.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Fetch the list of locations\n * @public\n * @example\n *  listLocations(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listLocations(callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch the list of locations\n * @public\n * @example\n *  listLocations(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listLocations(callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/locations',\n      params: {\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "getLocation",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get one or multiple locations from a query filter\n * @public\n * @example\n *  getLocation({\"where\":{\"name\": \"30 DE OCTUBRE\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLocation(query, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/locations',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Get one or multiple locations from a query filter\n * @public\n * @example\n *  getLocation({\"where\":{\"name\": \"30 DE OCTUBRE\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLocation(query: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets one or multiple locations from a query filter.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets one or multiple locations from a query filter.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get one or multiple locations from a query filter\n * @public\n * @example\n *  getLocation({\"where\":{\"name\": \"30 DE OCTUBRE\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLocation(query: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get one or multiple locations from a query filter\n * @public\n * @example\n *  getLocation({\"where\":{\"name\": \"30 DE OCTUBRE\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLocation(query, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/locations',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "upsertLocation",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert location to godata\n * @public\n * @example\n *  upsertLocation('name', {...})\n * @function\n * @param {string} externalId - External Id to match\n * @param {object} goDataLocation - an object with some location data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertLocation(externalId, goDataLocation, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const data = expandReferences(goDataLocation)(state);\n\n    const query = { where: {} };\n    query.where[externalId] = data[externalId];\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/locations',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        if (response.data.length > 1) {\n          console.log(\n            response.data.length,\n            'locations found; aborting upsert.'\n          );\n          return response;\n        } else if (response.data.length === 1) {\n          console.log('Location found. Performing update.');\n          const locationId = response.data[0].id;\n          return axios({\n            method: 'PUT',\n            baseURL: apiUrl,\n            url: `/locations/${locationId}`,\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        } else {\n          console.log('No location found. Performing create.');\n          return axios({\n            method: 'POST',\n            baseURL: apiUrl,\n            url: '/locations',\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        }\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Upsert location to godata\n * @public\n * @example\n *  upsertLocation('name', {...})\n * @function\n * @param {string} externalId - External Id to match\n * @param {object} goDataLocation - an object with some location data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertLocation(externalId: string, goDataLocation: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts a location to godata.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts a location to godata.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Upsert location to godata\n * @public\n * @example\n *  upsertLocation('name', {...})\n * @function\n * @param {string} externalId - External Id to match\n * @param {object} goDataLocation - an object with some location data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertLocation(externalId: string, goDataLocation: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert location to godata\n * @public\n * @example\n *  upsertLocation('name', {...})\n * @function\n * @param {string} externalId - External Id to match\n * @param {object} goDataLocation - an object with some location data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertLocation(externalId, goDataLocation, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const data = expandReferences(goDataLocation)(state);\n\n    const query = { where: {} };\n    query.where[externalId] = data[externalId];\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/locations',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        if (response.data.length > 1) {\n          console.log(\n            response.data.length,\n            'locations found; aborting upsert.'\n          );\n          return response;\n        } else if (response.data.length === 1) {\n          console.log('Location found. Performing update.');\n          const locationId = response.data[0].id;\n          return axios({\n            method: 'PUT',\n            baseURL: apiUrl,\n            url: `/locations/${locationId}`,\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        } else {\n          console.log('No location found. Performing create.');\n          return axios({\n            method: 'POST',\n            baseURL: apiUrl,\n            url: '/locations',\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        }\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "listReferenceData",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch the list of reference data\n * @public\n * @example\n *  listReferenceData(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listReferenceData(callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/reference-data',\n      params: {\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Fetch the list of reference data\n * @public\n * @example\n *  listReferenceData(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listReferenceData(callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that fetches the list of reference data.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that fetches the list of reference data.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Fetch the list of reference data\n * @public\n * @example\n *  listReferenceData(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listReferenceData(callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch the list of reference data\n * @public\n * @example\n *  listReferenceData(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listReferenceData(callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/reference-data',\n      params: {\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "getReferenceData",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get one or multiple reference data from a query filter\n * @public\n * @example\n *  getReferenceData({\"where\":{\"categoryId\": \"LNG_REFERENCE_DATA_CATEGORY_CENTRE_NAME\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getReferenceData(query, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/reference-data',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Get one or multiple reference data from a query filter\n * @public\n * @example\n *  getReferenceData({\"where\":{\"categoryId\": \"LNG_REFERENCE_DATA_CATEGORY_CENTRE_NAME\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getReferenceData(query: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets reference data from a query filter.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets reference data from a query filter.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get one or multiple reference data from a query filter\n * @public\n * @example\n *  getReferenceData({\"where\":{\"categoryId\": \"LNG_REFERENCE_DATA_CATEGORY_CENTRE_NAME\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getReferenceData(query: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get one or multiple reference data from a query filter\n * @public\n * @example\n *  getReferenceData({\"where\":{\"categoryId\": \"LNG_REFERENCE_DATA_CATEGORY_CENTRE_NAME\"}}, state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {object} query - An object with a query filter parameter\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getReferenceData(query, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/reference-data',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "upsertReferenceData",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert reference data to godata\n * @public\n * @example\n *  upsertReferenceData('id', {...})\n * @function\n * @param {string} externalId - External Id to match\n * @param {object} goDataReferenceData - an object with some reference data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertReferenceData(externalId, goDataReferenceData, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const data = expandReferences(goDataReferenceData)(state);\n\n    const query = { where: {} };\n    query.where[externalId] = data[externalId];\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/reference-data',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        if (response.data.length > 1) {\n          console.log(\n            response.data.length,\n            'reference data found; aborting upsert.'\n          );\n          return response;\n        } else if (response.data.length === 1) {\n          console.log('Reference data found. Performing update.');\n          const referenceDataId = response.data[0].id;\n          console.log('referenceDataId', referenceDataId);\n          return axios({\n            method: 'PUT',\n            baseURL: apiUrl,\n            url: `/reference-data/${referenceDataId}`,\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        } else {\n          console.log('No reference data found. Performing create.');\n          return axios({\n            method: 'POST',\n            baseURL: apiUrl,\n            url: '/reference-data',\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        }\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n\n// Note that we expose the entire axios package to the user here.",
    "signature": "/**\n * Upsert reference data to godata\n * @public\n * @example\n *  upsertReferenceData('id', {...})\n * @function\n * @param {string} externalId - External Id to match\n * @param {object} goDataReferenceData - an object with some reference data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertReferenceData(externalId: string, goDataReferenceData: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts reference data to godata.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts reference data to godata.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Upsert reference data to godata\n * @public\n * @example\n *  upsertReferenceData('id', {...})\n * @function\n * @param {string} externalId - External Id to match\n * @param {object} goDataReferenceData - an object with some reference data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertReferenceData(externalId: string, goDataReferenceData: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert reference data to godata\n * @public\n * @example\n *  upsertReferenceData('id', {...})\n * @function\n * @param {string} externalId - External Id to match\n * @param {object} goDataReferenceData - an object with some reference data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertReferenceData(externalId, goDataReferenceData, callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    const data = expandReferences(goDataReferenceData)(state);\n\n    const query = { where: {} };\n    query.where[externalId] = data[externalId];\n\n    const filter = JSON.stringify(query);\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/reference-data',\n      params: {\n        filter,\n        access_token,\n      },\n    })\n      .then(response => {\n        if (response.data.length > 1) {\n          console.log(\n            response.data.length,\n            'reference data found; aborting upsert.'\n          );\n          return response;\n        } else if (response.data.length === 1) {\n          console.log('Reference data found. Performing update.');\n          const referenceDataId = response.data[0].id;\n          console.log('referenceDataId', referenceDataId);\n          return axios({\n            method: 'PUT',\n            baseURL: apiUrl,\n            url: `/reference-data/${referenceDataId}`,\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        } else {\n          console.log('No reference data found. Performing create.');\n          return axios({\n            method: 'POST',\n            baseURL: apiUrl,\n            url: '/reference-data',\n            params: {\n              access_token,\n            },\n            data,\n          })\n            .then(response => {\n              const nextState = composeNextState(state, response.data);\n              if (callback) return callback(nextState);\n              return nextState;\n            })\n            .catch(error => {\n              return error;\n            });\n        }\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n\n// Note that we expose the entire axios package to the user here.\n"
  },
  {
    "name": "execute",
    "implementation": "import { normalizeOauthConfig } from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n      configuration: normalizeOauthConfig(state.configuration),\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport { normalizeOauthConfig } from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n      configuration: normalizeOauthConfig(state.configuration),\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}\n"
  },
  {
    "name": "getForms",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a request to get the list of forms\n * @public\n * @example\n * getForms({}, state => {\n *    console.log(state.data);\n *    return state;\n * });\n * @function\n * @param {object} params - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function to execute after fetching form list\n * @returns {Operation}\n */\nexport function getForms(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { baseURL, apiVersion, username, password } = state.configuration;\n\n    const url = `${baseURL}/api/${apiVersion}/assets/?format=json`;\n    const auth = { username, password };\n\n    const config = {\n      url,\n      params: resolvedParams,\n      auth,\n    };\n\n    return http\n      .get(config)(state)\n      .then(response => {\n        console.log('\u2713', response.data.count, 'forms fetched.');\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}",
    "signature": "/**\n * Make a request to get the list of forms\n * @public\n * @example\n * getForms({}, state => {\n *    console.log(state.data);\n *    return state;\n * });\n * @function\n * @param {object} params - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function to execute after fetching form list\n * @returns {Operation}\n */\nexport function getForms(params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a request to get the list of forms.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a request to get the list of forms.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a request to get the list of forms\n * @public\n * @example\n * getForms({}, state => {\n *    console.log(state.data);\n *    return state;\n * });\n * @function\n * @param {object} params - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function to execute after fetching form list\n * @returns {Operation}\n */\nexport function getForms(params: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a request to get the list of forms\n * @public\n * @example\n * getForms({}, state => {\n *    console.log(state.data);\n *    return state;\n * });\n * @function\n * @param {object} params - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function to execute after fetching form list\n * @returns {Operation}\n */\nexport function getForms(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { baseURL, apiVersion, username, password } = state.configuration;\n\n    const url = `${baseURL}/api/${apiVersion}/assets/?format=json`;\n    const auth = { username, password };\n\n    const config = {\n      url,\n      params: resolvedParams,\n      auth,\n    };\n\n    return http\n      .get(config)(state)\n      .then(response => {\n        console.log('\u2713', response.data.count, 'forms fetched.');\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}\n"
  },
  {
    "name": "getSubmissions",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Get submissions for a specific form\n * @example\n * getSubmissions({formId: 'aXecHjmbATuF6iGFmvBLBX'}, state => {\n *   console.log(state.data);\n *   return state;\n * });\n * @function\n * @param {object} params - Form Id and data to make the fetch or filter\n * @param {function} callback - (Optional) Callback function to execute after fetching form submissions\n * @returns {Operation}\n */\nexport function getSubmissions(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { baseURL, apiVersion, username, password } = state.configuration;\n    const { formId } = resolvedParams;\n\n    const url = `${baseURL}/api/${apiVersion}/assets/${formId}/data/?format=json`;\n    const auth = { username, password };\n\n    const config = {\n      url,\n      params: resolvedParams.query,\n      auth,\n    };\n\n    return http\n      .get(config)(state)\n      .then(response => {\n        console.log('\u2713', response.data.count, 'submissions fetched.');\n\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}",
    "signature": "/**\n * Get submissions for a specific form\n * @example\n * getSubmissions({formId: 'aXecHjmbATuF6iGFmvBLBX'}, state => {\n *   console.log(state.data);\n *   return state;\n * });\n * @function\n * @param {object} params - Form Id and data to make the fetch or filter\n * @param {function} callback - (Optional) Callback function to execute after fetching form submissions\n * @returns {Operation}\n */\nexport function getSubmissions(params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that fetches submissions from a specific form.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that fetches submissions from a specific form.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get submissions for a specific form\n * @example\n * getSubmissions({formId: 'aXecHjmbATuF6iGFmvBLBX'}, state => {\n *   console.log(state.data);\n *   return state;\n * });\n * @function\n * @param {object} params - Form Id and data to make the fetch or filter\n * @param {function} callback - (Optional) Callback function to execute after fetching form submissions\n * @returns {Operation}\n */\nexport function getSubmissions(params: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Get submissions for a specific form\n * @example\n * getSubmissions({formId: 'aXecHjmbATuF6iGFmvBLBX'}, state => {\n *   console.log(state.data);\n *   return state;\n * });\n * @function\n * @param {object} params - Form Id and data to make the fetch or filter\n * @param {function} callback - (Optional) Callback function to execute after fetching form submissions\n * @returns {Operation}\n */\nexport function getSubmissions(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { baseURL, apiVersion, username, password } = state.configuration;\n    const { formId } = resolvedParams;\n\n    const url = `${baseURL}/api/${apiVersion}/assets/${formId}/data/?format=json`;\n    const auth = { username, password };\n\n    const config = {\n      url,\n      params: resolvedParams.query,\n      auth,\n    };\n\n    return http\n      .get(config)(state)\n      .then(response => {\n        console.log('\u2713', response.data.count, 'submissions fetched.');\n\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}\n"
  },
  {
    "name": "getDeploymentInfo",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Get deployment information for a specific form\n * @example\n * getDeploymentInfo({formId: 'aXecHjmbATuF6iGFmvBLBX'}, state => {\n *   console.log(state.data);\n *   return state;\n * });\n * @function\n * @param {object} params - Form Id and data to make the fetch or filter\n * @param {function} callback - (Optional) Callback function to execute after fetching form deployment information\n * @returns {Operation}\n */\nexport function getDeploymentInfo(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { baseURL, apiVersion, username, password } = state.configuration;\n    const { formId } = resolvedParams;\n\n    const url = `${baseURL}/api/${apiVersion}/assets/${formId}/deployment/?format=json`;\n    const auth = { username, password };\n\n    const config = {\n      url,\n      params: resolvedParams.query,\n      auth,\n    };\n\n    return http\n      .get(config)(state)\n      .then(response => {\n        console.log('\u2713', 'deployment information fetched.');\n\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}",
    "signature": "/**\n * Get deployment information for a specific form\n * @example\n * getDeploymentInfo({formId: 'aXecHjmbATuF6iGFmvBLBX'}, state => {\n *   console.log(state.data);\n *   return state;\n * });\n * @function\n * @param {object} params - Form Id and data to make the fetch or filter\n * @param {function} callback - (Optional) Callback function to execute after fetching form deployment information\n * @returns {Operation}\n */\nexport function getDeploymentInfo(params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that fetches deployment information from a specific form.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that fetches deployment information from a specific form.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get deployment information for a specific form\n * @example\n * getDeploymentInfo({formId: 'aXecHjmbATuF6iGFmvBLBX'}, state => {\n *   console.log(state.data);\n *   return state;\n * });\n * @function\n * @param {object} params - Form Id and data to make the fetch or filter\n * @param {function} callback - (Optional) Callback function to execute after fetching form deployment information\n * @returns {Operation}\n */\nexport function getDeploymentInfo(params: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Get deployment information for a specific form\n * @example\n * getDeploymentInfo({formId: 'aXecHjmbATuF6iGFmvBLBX'}, state => {\n *   console.log(state.data);\n *   return state;\n * });\n * @function\n * @param {object} params - Form Id and data to make the fetch or filter\n * @param {function} callback - (Optional) Callback function to execute after fetching form deployment information\n * @returns {Operation}\n */\nexport function getDeploymentInfo(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { baseURL, apiVersion, username, password } = state.configuration;\n    const { formId } = resolvedParams;\n\n    const url = `${baseURL}/api/${apiVersion}/assets/${formId}/deployment/?format=json`;\n    const auth = { username, password };\n\n    const config = {\n      url,\n      params: resolvedParams.query,\n      auth,\n    };\n\n    return http\n      .get(config)(state)\n      .then(response => {\n        console.log('\u2713', 'deployment information fetched.');\n\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    state.configuration.baseUrl = 'https://'.concat(\n      state.configuration.instanceName,\n      '.surveycto.com/api/v1'\n    );\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    state.configuration.baseUrl = 'https://'.concat(\n      state.configuration.instanceName,\n      '.surveycto.com/api/v1'\n    );\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "fetchSubmissions",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a GET request and POST it somewhere else\n * @example\n * execute(\n *   fetch(params)\n * )(state)\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function fetchSubmissions(formId, afterDate, postUrl) {\n  return state => {\n    const { baseUrl, username, password, instanceName } = state.configuration;\n\n    return new Promise((resolve, reject) => {\n      request(\n        {\n          url: `${baseUrl}/forms/data/wide/json/${formId}`,\n          method: 'GET',\n          auth: {\n            username,\n            password,\n            sendImmediately: false,\n          },\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          query: {\n            date: state.lastSubmissionDate || afterDate,\n          },\n        },",
    "signature": "/**\n * Make a GET request and POST it somewhere else\n * @example\n * execute(\n *   fetch(params)\n * )(state)\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function fetchSubmissions(formId: any, afterDate: any, postUrl: any): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a GET request and POSTs it somewhere else.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a GET request and POSTs it somewhere else.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a GET request and POST it somewhere else\n * @example\n * execute(\n *   fetch(params)\n * )(state)\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function fetchSubmissions(formId: any, afterDate: any, postUrl: any): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a GET request and POST it somewhere else\n * @example\n * execute(\n *   fetch(params)\n * )(state)\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function fetchSubmissions(formId, afterDate, postUrl) {\n  return state => {\n    const { baseUrl, username, password, instanceName } = state.configuration;\n\n    return new Promise((resolve, reject) => {\n      request(\n        {\n          url: `${baseUrl}/forms/data/wide/json/${formId}`,\n          method: 'GET',\n          auth: {\n            username,\n            password,\n            sendImmediately: false,\n          },\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          query: {\n            date: state.lastSubmissionDate || afterDate,\n          },\n        },\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for telerivet.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for telerivet.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for telerivet.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for telerivet.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "send",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Send a message\n * @example\n * execute(\n *   send(data)\n * )(state)\n * @function\n * @param {object} sendData - Payload data for the message\n * @returns {Operation}\n */\nexport function send(sendData) {\n  return state => {\n    const body = expandReferences(sendData)(state);\n\n    const { projectId, apiKey } = state.configuration;\n\n    const url = 'https://api.telerivet.com/v1/projects/'.concat(\n      projectId,\n      '/messages/send'\n    );\n\n    console.log(url);\n    console.log('Posting message to send:');\n    console.log(body);\n\n    return post({ apiKey, body, url }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}",
    "signature": "/**\n * Send a message\n * @example\n * execute(\n *   send(data)\n * )(state)\n * @function\n * @param {object} sendData - Payload data for the message\n * @returns {Operation}\n */\nexport function send(sendData: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that sends a message to sendData.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that sends a message to sendData.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Send a message\n * @example\n * execute(\n *   send(data)\n * )(state)\n * @function\n * @param {object} sendData - Payload data for the message\n * @returns {Operation}\n */\nexport function send(sendData: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Send a message\n * @example\n * execute(\n *   send(data)\n * )(state)\n * @function\n * @param {object} sendData - Payload data for the message\n * @returns {Operation}\n */\nexport function send(sendData) {\n  return state => {\n    const body = expandReferences(sendData)(state);\n\n    const { projectId, apiKey } = state.configuration;\n\n    const url = 'https://api.telerivet.com/v1/projects/'.concat(\n      projectId,\n      '/messages/send'\n    );\n\n    console.log(url);\n    console.log('Posting message to send:');\n    console.log(body);\n\n    return post({ apiKey, body, url }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    data: null,\n    references: [],\n    cursor: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    data: null,\n    references: [],\n    cursor: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "fetchSubmissions",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Access form submissions and post them as JSON.\n * @public\n * @example\n * fetchSubmissions(\n *   \"pregnancy\", // formId\n *   { \"last-event-id\": 334 }, // params\n *   \"http://localhost:4000/inbox/abc-123-xyz\" // postUrl\n * );\n * @function\n * @param {string} formId - Query parameters\n * @param {object} params - Starting sequence id\n * @param {string} postUrl - Inbox to post form data\n * @returns {Operation}\n */\nexport function fetchSubmissions(formId, params, postUrl) {\n  return state => {\n    params.include_docs = true;\n    return changesApi(params)(state)\n      .then(state => {\n        return pickFormData(formId)(state);\n      })\n      .then(state => {\n        const submissions = state.data.submissions;\n        for (var i = 0, len = submissions.length; i < len; i++) {\n          request.post({\n            url: postUrl,\n            json: submissions[i],\n          });\n          console.log(\n            `Posted submission ${submissions[i].fields.meta.instanceID} \u2713`\n          );\n        }\n        return state;\n      })\n      .then(state => {\n        // clean state for next run\n        state.data = {};\n        state.references = [];\n        console.log('Fetching submissions succeeded \u2713');\n        return state;\n      });\n  };\n}",
    "signature": "/**\n * Access form submissions and post them as JSON.\n * @public\n * @example\n * fetchSubmissions(\n *   \"pregnancy\", // formId\n *   { \"last-event-id\": 334 }, // params\n *   \"http://localhost:4000/inbox/abc-123-xyz\" // postUrl\n * );\n * @function\n * @param {string} formId - Query parameters\n * @param {object} params - Starting sequence id\n * @param {string} postUrl - Inbox to post form data\n * @returns {Operation}\n */\nexport function fetchSubmissions(formId: string, params: object, postUrl: string): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that posts form submissions as JSON to a given inbox.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that posts form submissions as JSON to a given inbox.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Access form submissions and post them as JSON.\n * @public\n * @example\n * fetchSubmissions(\n *   \"pregnancy\", // formId\n *   { \"last-event-id\": 334 }, // params\n *   \"http://localhost:4000/inbox/abc-123-xyz\" // postUrl\n * );\n * @function\n * @param {string} formId - Query parameters\n * @param {object} params - Starting sequence id\n * @param {string} postUrl - Inbox to post form data\n * @returns {Operation}\n */\nexport function fetchSubmissions(formId: string, params: object, postUrl: string): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Access form submissions and post them as JSON.\n * @public\n * @example\n * fetchSubmissions(\n *   \"pregnancy\", // formId\n *   { \"last-event-id\": 334 }, // params\n *   \"http://localhost:4000/inbox/abc-123-xyz\" // postUrl\n * );\n * @function\n * @param {string} formId - Query parameters\n * @param {object} params - Starting sequence id\n * @param {string} postUrl - Inbox to post form data\n * @returns {Operation}\n */\nexport function fetchSubmissions(formId, params, postUrl) {\n  return state => {\n    params.include_docs = true;\n    return changesApi(params)(state)\n      .then(state => {\n        return pickFormData(formId)(state);\n      })\n      .then(state => {\n        const submissions = state.data.submissions;\n        for (var i = 0, len = submissions.length; i < len; i++) {\n          request.post({\n            url: postUrl,\n            json: submissions[i],\n          });\n          console.log(\n            `Posted submission ${submissions[i].fields.meta.instanceID} \u2713`\n          );\n        }\n        return state;\n      })\n      .then(state => {\n        // clean state for next run\n        state.data = {};\n        state.references = [];\n        console.log('Fetching submissions succeeded \u2713');\n        return state;\n      });\n  };\n}\n"
  },
  {
    "name": "changesApi",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Access the CouchDB Changes API\n * @public\n * @example\n * changesApi(params, callback)\n * @function\n * @param {object} params - Query parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function changesApi(params, callback) {",
    "signature": "/**\n * Access the CouchDB Changes API\n * @public\n * @example\n * changesApi(params, callback)\n * @function\n * @param {object} params - Query parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function changesApi(params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that accesses the CouchDB Changes API.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that accesses the CouchDB Changes API.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Access the CouchDB Changes API\n * @public\n * @example\n * changesApi(params, callback)\n * @function\n * @param {object} params - Query parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function changesApi(params: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Access the CouchDB Changes API\n * @public\n * @example\n * changesApi(params, callback)\n * @function\n * @param {object} params - Query parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function changesApi(params, callback) {\n"
  },
  {
    "name": "pickFormData",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Select submissions for a specific form\n * @public\n * @example\n * pickFormData(formId)\n * @function\n * @param {string} formId - The form ID.\n * @returns {Operation}\n */\nexport function pickFormData(formId) {\n  return state => {\n    var myFormData = [];\n    if (state.data.response.results) {\n      myFormData = state.data.response.results\n        .filter(item => {\n          if (item.doc.form) return item.doc.form == formId;\n        })\n        .map(item => {\n          const { _id, fields, form, type, reported_date, contact } = item.doc;\n          return {\n            _id,\n            form,\n            type,\n            reported_date,\n            contact,\n            fields,\n          };\n        });\n    }\n\n    return {\n      ...state,\n      data: { submissions: myFormData },\n      references: [...state.references, state.data],\n    };\n  };\n}",
    "signature": "/**\n * Select submissions for a specific form\n * @public\n * @example\n * pickFormData(formId)\n * @function\n * @param {string} formId - The form ID.\n * @returns {Operation}\n */\nexport function pickFormData(formId: string): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that selects submissions for a specific form.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that selects submissions for a specific form.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Select submissions for a specific form\n * @public\n * @example\n * pickFormData(formId)\n * @function\n * @param {string} formId - The form ID.\n * @returns {Operation}\n */\nexport function pickFormData(formId: string): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Select submissions for a specific form\n * @public\n * @example\n * pickFormData(formId)\n * @function\n * @param {string} formId - The form ID.\n * @returns {Operation}\n */\nexport function pickFormData(formId) {\n  return state => {\n    var myFormData = [];\n    if (state.data.response.results) {\n      myFormData = state.data.response.results\n        .filter(item => {\n          if (item.doc.form) return item.doc.form == formId;\n        })\n        .map(item => {\n          const { _id, fields, form, type, reported_date, contact } = item.doc;\n          return {\n            _id,\n            form,\n            type,\n            reported_date,\n            contact,\n            fields,\n          };\n        });\n    }\n\n    return {\n      ...state,\n      data: { submissions: myFormData },\n      references: [...state.references, state.data],\n    };\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for zoho.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for zoho.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for zoho.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for zoho.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "addRow",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * To add a row data to a database table\n * @example\n * addRow(\n * 'testing_openfn',\n * 'Customers',\n * fields(field('Subject', dataValue('formId')), field('Status', 'Closed'))\n * );\n * @function\n * @param {string} db - Database\n * @param {string} table - Database table\n * @param {object} rowData - row data to be added into the database\n * @returns {Operation}\n */\nexport function addRow(db, table, rowData) {\n  return state => {\n    const action = 'ADDROW';\n    const body = expandReferences(rowData)(state);\n\n    const { account, authToken, apiVersion } = state.configuration;\n\n    const url = `https://reportsapi.zoho.com/api/`.concat(\n      account,\n      '/',\n      db,\n      '/',\n      table\n    );\n\n    console.log('POST URL:');\n    console.log(url);\n    console.log('POST Parameters:');\n    console.log(body);\n\n    return post({ url, body, authToken, apiVersion, action }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}",
    "signature": "/**\n * To add a row data to a database table\n * @example\n * addRow(\n * 'testing_openfn',\n * 'Customers',\n * fields(field('Subject', dataValue('formId')), field('Status', 'Closed'))\n * );\n * @function\n * @param {string} db - Database\n * @param {string} table - Database table\n * @param {object} rowData - row data to be added into the database\n * @returns {Operation}\n */\nexport function addRow(db: string, table: string, rowData: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that adds row data to a database table.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that adds row data to a database table.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * To add a row data to a database table\n * @example\n * addRow(\n * 'testing_openfn',\n * 'Customers',\n * fields(field('Subject', dataValue('formId')), field('Status', 'Closed'))\n * );\n * @function\n * @param {string} db - Database\n * @param {string} table - Database table\n * @param {object} rowData - row data to be added into the database\n * @returns {Operation}\n */\nexport function addRow(db: string, table: string, rowData: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * To add a row data to a database table\n * @example\n * addRow(\n * 'testing_openfn',\n * 'Customers',\n * fields(field('Subject', dataValue('formId')), field('Status', 'Closed'))\n * );\n * @function\n * @param {string} db - Database\n * @param {string} table - Database table\n * @param {object} rowData - row data to be added into the database\n * @returns {Operation}\n */\nexport function addRow(db, table, rowData) {\n  return state => {\n    const action = 'ADDROW';\n    const body = expandReferences(rowData)(state);\n\n    const { account, authToken, apiVersion } = state.configuration;\n\n    const url = `https://reportsapi.zoho.com/api/`.concat(\n      account,\n      '/',\n      db,\n      '/',\n      table\n    );\n\n    console.log('POST URL:');\n    console.log(url);\n    console.log('POST Parameters:');\n    console.log(body);\n\n    return post({ url, body, authToken, apiVersion, action }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}\n"
  },
  {
    "name": "postData",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a POST request with a certificate\n * @public\n * @example\n * postData({\n *  url: urlDTP,\n *  body: obj,\n *  headers: {\n *    'Ocp-Apim-Subscription-Key': configuration['Ocp-Apim-Subscription-Key'],\n *  },\n *  agentOptions: {\n *    key,\n *    cert,\n *  },\n * }, callback)(state)\n * @function\n * @param {object} params - Url, Headers and Body parameters\n * @param {function} callback - (Optional) A callback function\n * @returns {Operation}\n */\nexport function postData(params, callback) {\n  return state => {\n    const { url, body, headers, agentOptions } = expandReferences(params)(\n      state\n    );\n\n    return http\n      .post({\n        method: 'post',\n        url,\n        data: body,\n        headers,\n        agentOptions,\n      })(state)\n      .then(response => {\n        console.log('POST succeeded.');\n\n        const nextState = composeNextState(state, response);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        console.log(error);\n        return error;\n      });\n  };\n}\n\n// What",
    "signature": "/**\n * Make a POST request with a certificate\n * @public\n * @example\n * postData({\n *  url: urlDTP,\n *  body: obj,\n *  headers: {\n *    'Ocp-Apim-Subscription-Key': configuration['Ocp-Apim-Subscription-Key'],\n *  },\n *  agentOptions: {\n *    key,\n *    cert,\n *  },\n * }, callback)(state)\n * @function\n * @param {object} params - Url, Headers and Body parameters\n * @param {function} callback - (Optional) A callback function\n * @returns {Operation}\n */\nexport function postData(params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a POST request with a certificate to/on/from",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a POST request with a certificate to/on/from\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a POST request with a certificate\n * @public\n * @example\n * postData({\n *  url: urlDTP,\n *  body: obj,\n *  headers: {\n *    'Ocp-Apim-Subscription-Key': configuration['Ocp-Apim-Subscription-Key'],\n *  },\n *  agentOptions: {\n *    key,\n *    cert,\n *  },\n * }, callback)(state)\n * @function\n * @param {object} params - Url, Headers and Body parameters\n * @param {function} callback - (Optional) A callback function\n * @returns {Operation}\n */\nexport function postData(params: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a POST request with a certificate\n * @public\n * @example\n * postData({\n *  url: urlDTP,\n *  body: obj,\n *  headers: {\n *    'Ocp-Apim-Subscription-Key': configuration['Ocp-Apim-Subscription-Key'],\n *  },\n *  agentOptions: {\n *    key,\n *    cert,\n *  },\n * }, callback)(state)\n * @function\n * @param {object} params - Url, Headers and Body parameters\n * @param {function} callback - (Optional) A callback function\n * @returns {Operation}\n */\nexport function postData(params, callback) {\n  return state => {\n    const { url, body, headers, agentOptions } = expandReferences(params)(\n      state\n    );\n\n    return http\n      .post({\n        method: 'post',\n        url,\n        data: body,\n        headers,\n        agentOptions,\n      })(state)\n      .then(response => {\n        console.log('POST succeeded.');\n\n        const nextState = composeNextState(state, response);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        console.log(error);\n        return error;\n      });\n  };\n}\n\n// What\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  // TODO: Add session-based authentication here if your API needs it.\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "describe('execute', () => {\n  it('executes each operation in sequence', done => {\n    const state = {};\n    const operations = [\n      state => {\n        return { counter: 1 };\n      },\n      state => {\n        return { counter: 2 };\n      },\n      state => {\n        return { counter: 3 };\n      },\n    ];\n\n    execute(...operations)(state)\n      .then(finalState => {\n        expect(finalState).to.eql({ counter: 3 });",
    "instruction": "Create an OpenFn function that executes a sequence of operations.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  // TODO: Add session-based authentication here if your API needs it.\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}\n"
  },
  {
    "name": "create",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Create some resource in some system\n * @public\n * @example\n * create(\"patient\", {\"name\": \"Bukayo\"})\n * @function\n * @param {string} resource - The type of entity that will be created\n * @param {object} data - The data to create the new resource\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function create(resource, data, callback) {\n  return state => {\n    const [resolvedResource, resolvedData] = expandReferences(state, resource, data); \n\n    const { baseUrl, username, password } = state.configuration;\n\n    const url = `${baseUrl}/api/${resolvedResource}`;\n    const auth = { username, password };\n\n    const options = {\n      auth,\n      body: resolvedData,\n      method: 'POST',\n    };\n\n    return request(url, options).then(response => {\n      const nextState = {\n        ...composeNextState(state, response.data),\n        response,\n      };\n      if (callback) return callback(nextState);\n      return nextState;\n    });\n  };\n}",
    "signature": "/**\n * Create some resource in some system\n * @public\n * @example\n * create(\"patient\", {\"name\": \"Bukayo\"})\n * @function\n * @param {string} resource - The type of entity that will be created\n * @param {object} data - The data to create the new resource\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function create(resource: string, data: object, callback: Function): Operation;",
    "test": "describe('create', () => {\n  it('makes a post request to the right endpoint', async () => {\n    const state = {\n      configuration: {\n        baseUrl: 'https://fake.server.com',\n        username: 'hello',\n        password: 'there',\n      },\n      data: {\n        fullName: 'Mamadou',\n        gender: 'M',\n      },\n    };\n\n    const finalState = await execute(\n      create('patients', {\n        name: dataValue('fullName')(state),\n        gender: dataValue('gender')(state),\n      })",
    "instruction": "create an OpenFn function that creates a resource in some system.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\ncreate an OpenFn function that creates a resource in some system.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create some resource in some system\n * @public\n * @example\n * create(\"patient\", {\"name\": \"Bukayo\"})\n * @function\n * @param {string} resource - The type of entity that will be created\n * @param {object} data - The data to create the new resource\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function create(resource: string, data: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Create some resource in some system\n * @public\n * @example\n * create(\"patient\", {\"name\": \"Bukayo\"})\n * @function\n * @param {string} resource - The type of entity that will be created\n * @param {object} data - The data to create the new resource\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function create(resource, data, callback) {\n  return state => {\n    const [resolvedResource, resolvedData] = expandReferences(state, resource, data); \n\n    const { baseUrl, username, password } = state.configuration;\n\n    const url = `${baseUrl}/api/${resolvedResource}`;\n    const auth = { username, password };\n\n    const options = {\n      auth,\n      body: resolvedData,\n      method: 'POST',\n    };\n\n    return request(url, options).then(response => {\n      const nextState = {\n        ...composeNextState(state, response.data),\n        response,\n      };\n      if (callback) return callback(nextState);\n      return nextState;\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      challenge,\n      login,\n      ...flatten(operations)\n    )({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      challenge,\n      login,\n      ...flatten(operations)\n    )({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state =>\n    commonExecute(\n      connect,\n      ...operations,\n      disconnect\n    )({ ...initialState, ...state }).catch(e => {\n      disconnect(state);\n      throw e;\n    });\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state =>\n    commonExecute(\n      connect,\n      ...operations,\n      disconnect\n    )({ ...initialState, ...state }).catch(e => {\n      disconnect(state);\n      throw e;\n    });\n}\n"
  },
  {
    "name": "list",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * List files present in a directory\n * @public\n * @example\n * <caption>basic files listing</caption>\n * list('/some/path/')\n * @example\n * <caption>list files with filters</caption>\n * list('/some/path/', file=> {\n *  return /foo.\\.txt/.test(file.name);\n * })\n * @example\n * <caption>list files with filters and use callback</caption>\n * list(\n *   \"/some/path/\",\n *   (file) => /foo.\\.txt/.test(file.name),\n *   (state) => {\n *     const latestFile = state.data.filter(\n *       (file) => file.modifyTime <= new Date()\n *     );\n *     return { ...state, latestFile };\n *   }\n * );\n * @function\n * @param {string} dirPath - Path to remote directory\n * @param {function} filter - a filter function used to select return entries\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function list(dirPath, filter, callback) {\n  return state => {\n    return sftp\n      .list(dirPath, filter)\n      .then(files => handleResponse(files, state, callback));\n  };\n}",
    "signature": "/**\n * List files present in a directory\n * @public\n * @example\n * <caption>basic files listing</caption>\n * list('/some/path/')\n * @example\n * <caption>list files with filters</caption>\n * list('/some/path/', file=> {\n *  return /foo.\\.txt/.test(file.name);\n * })\n * @example\n * <caption>list files with filters and use callback</caption>\n * list(\n *   \"/some/path/\",\n *   (file) => /foo.\\.txt/.test(file.name),\n *   (state) => {\n *     const latestFile = state.data.filter(\n *       (file) => file.modifyTime <= new Date()\n *     );\n *     return { ...state, latestFile };\n *   }\n * );\n * @function\n * @param {string} dirPath - Path to remote directory\n * @param {function} filter - a filter function used to select return entries\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function list(dirPath: string, filter: Function, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that lists files present in a directory.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that lists files present in a directory.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * List files present in a directory\n * @public\n * @example\n * <caption>basic files listing</caption>\n * list('/some/path/')\n * @example\n * <caption>list files with filters</caption>\n * list('/some/path/', file=> {\n *  return /foo.\\.txt/.test(file.name);\n * })\n * @example\n * <caption>list files with filters and use callback</caption>\n * list(\n *   \"/some/path/\",\n *   (file) => /foo.\\.txt/.test(file.name),\n *   (state) => {\n *     const latestFile = state.data.filter(\n *       (file) => file.modifyTime <= new Date()\n *     );\n *     return { ...state, latestFile };\n *   }\n * );\n * @function\n * @param {string} dirPath - Path to remote directory\n * @param {function} filter - a filter function used to select return entries\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function list(dirPath: string, filter: Function, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * List files present in a directory\n * @public\n * @example\n * <caption>basic files listing</caption>\n * list('/some/path/')\n * @example\n * <caption>list files with filters</caption>\n * list('/some/path/', file=> {\n *  return /foo.\\.txt/.test(file.name);\n * })\n * @example\n * <caption>list files with filters and use callback</caption>\n * list(\n *   \"/some/path/\",\n *   (file) => /foo.\\.txt/.test(file.name),\n *   (state) => {\n *     const latestFile = state.data.filter(\n *       (file) => file.modifyTime <= new Date()\n *     );\n *     return { ...state, latestFile };\n *   }\n * );\n * @function\n * @param {string} dirPath - Path to remote directory\n * @param {function} filter - a filter function used to select return entries\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function list(dirPath, filter, callback) {\n  return state => {\n    return sftp\n      .list(dirPath, filter)\n      .then(files => handleResponse(files, state, callback));\n  };\n}\n"
  },
  {
    "name": "getCSV",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * Get a CSV and return a JSON array of strings for each item separated by the delimiter\n * @public\n * @example\n * getCSV(\n *   '/some/path/to_file.csv',\n *   {delimiter: \";\", flatKeys: true }\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {{readStreamOptions: object,delimiter: string,noheader: boolean, quote: string, trim: boolean, flatKeys: boolean, output: string}} [parsingOptions] - Optional. `parsingOptions` Parsing options which can be passed to convert csv to json See more {@link https://github.com/Keyang/node-csvtojson#parameters on csvtojson docs}\n * @returns {Operation}\n */\nexport function getCSV(filePath, parsingOptions = {}) {\n  const defaultOptions = {\n    readStreamOptions: {\n      encoding: null,\n      autoClose: false,\n    },\n    columns: true,\n  };\n\n  return state => {\n    let results = [];\n\n    const { readStreamOptions, ...csvDefaultOptions } = defaultOptions;\n    const useParser = !isObjectEmpty(parsingOptions);\n\n    if (useParser) {\n      const stream = sftp.createReadStream(filePath, readStreamOptions);\n      return parseCsv(stream, { ...csvDefaultOptions, ...parsingOptions })(\n        state\n      );\n    } else {\n      return sftp\n        .get(filePath)\n        .then(chunk => {\n          results.push(chunk);\n        })\n        .then(() => {\n          console.debug('Parsing rows to JSON.\\n');\n          console.time('Stream finished');\n          return new Promise((resolve, reject) => {\n            const content = Buffer.concat(results).toString('utf8');\n            resolve(content.split('\\r\\n'));\n          }).then(json => {\n            const nextState = composeNextState(state, json);\n            return nextState;\n          });\n        })\n        .then(state => {\n          console.timeEnd('Stream finished');\n          return state;\n        });\n    }\n  };\n}",
    "signature": "/**\n * Get a CSV and return a JSON array of strings for each item separated by the delimiter\n * @public\n * @example\n * getCSV(\n *   '/some/path/to_file.csv',\n *   {delimiter: \";\", flatKeys: true }\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {{readStreamOptions: object,delimiter: string,noheader: boolean, quote: string, trim: boolean, flatKeys: boolean, output: string}} [parsingOptions] - Optional. `parsingOptions` Parsing options which can be passed to convert csv to json See more {@link https://github.com/Keyang/node-csvtojson#parameters on csvtojson docs}\n * @returns {Operation}\n */\nexport function getCSV(filePath: string, parsingOptions?: {\n    readStreamOptions: object;\n    delimiter: string;\n    noheader: boolean;\n    quote: string;\n    trim: boolean;\n    flatKeys: boolean;\n    output: string;\n}): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets a CSV and returns a JSON array of strings for each",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets a CSV and returns a JSON array of strings for each\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get a CSV and return a JSON array of strings for each item separated by the delimiter\n * @public\n * @example\n * getCSV(\n *   '/some/path/to_file.csv',\n *   {delimiter: \";\", flatKeys: true }\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {{readStreamOptions: object,delimiter: string,noheader: boolean, quote: string, trim: boolean, flatKeys: boolean, output: string}} [parsingOptions] - Optional. `parsingOptions` Parsing options which can be passed to convert csv to json See more {@link https://github.com/Keyang/node-csvtojson#parameters on csvtojson docs}\n * @returns {Operation}\n */\nexport function getCSV(filePath: string, parsingOptions?: {\n    readStreamOptions: object;\n    delimiter: string;\n    noheader: boolean;\n    quote: string;\n    trim: boolean;\n    flatKeys: boolean;\n    output: string;\n}): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * Get a CSV and return a JSON array of strings for each item separated by the delimiter\n * @public\n * @example\n * getCSV(\n *   '/some/path/to_file.csv',\n *   {delimiter: \";\", flatKeys: true }\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {{readStreamOptions: object,delimiter: string,noheader: boolean, quote: string, trim: boolean, flatKeys: boolean, output: string}} [parsingOptions] - Optional. `parsingOptions` Parsing options which can be passed to convert csv to json See more {@link https://github.com/Keyang/node-csvtojson#parameters on csvtojson docs}\n * @returns {Operation}\n */\nexport function getCSV(filePath, parsingOptions = {}) {\n  const defaultOptions = {\n    readStreamOptions: {\n      encoding: null,\n      autoClose: false,\n    },\n    columns: true,\n  };\n\n  return state => {\n    let results = [];\n\n    const { readStreamOptions, ...csvDefaultOptions } = defaultOptions;\n    const useParser = !isObjectEmpty(parsingOptions);\n\n    if (useParser) {\n      const stream = sftp.createReadStream(filePath, readStreamOptions);\n      return parseCsv(stream, { ...csvDefaultOptions, ...parsingOptions })(\n        state\n      );\n    } else {\n      return sftp\n        .get(filePath)\n        .then(chunk => {\n          results.push(chunk);\n        })\n        .then(() => {\n          console.debug('Parsing rows to JSON.\\n');\n          console.time('Stream finished');\n          return new Promise((resolve, reject) => {\n            const content = Buffer.concat(results).toString('utf8');\n            resolve(content.split('\\r\\n'));\n          }).then(json => {\n            const nextState = composeNextState(state, json);\n            return nextState;\n          });\n        })\n        .then(state => {\n          console.timeEnd('Stream finished');\n          return state;\n        });\n    }\n  };\n}\n"
  },
  {
    "name": "putCSV",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * Convert JSON to CSV and upload to an FTP server\n * @public\n * @example\n * putCSV(\n *   '/some/path/to_local_file.csv',\n *   '/some/path/to_remove_file.csv',\n *   { delimiter: ';', noheader: true }\n * );\n * @function\n * @param {string} localFilePath -  Data source for data to copy to the remote server.\n * @param {string} remoteFilePath - Path to the remote file to be created on the server.\n * @param {object} parsingOptions - Options which can be passed to adjust the read and write stream used in sending the data to the remote server\n * @returns {Operation}\n */\nexport function putCSV(localFilePath, remoteFilePath, parsingOptions) {\n  return state => {\n    console.time('Upload finished');\n    return sftp\n      .put(localFilePath, remoteFilePath, parsingOptions)\n      .then(response => handleResponse(response, state))\n      .then(state => {\n        console.timeEnd('Upload finished');\n        return state;\n      });\n  };\n}",
    "signature": "/**\n * Convert JSON to CSV and upload to an FTP server\n * @public\n * @example\n * putCSV(\n *   '/some/path/to_local_file.csv',\n *   '/some/path/to_remove_file.csv',\n *   { delimiter: ';', noheader: true }\n * );\n * @function\n * @param {string} localFilePath -  Data source for data to copy to the remote server.\n * @param {string} remoteFilePath - Path to the remote file to be created on the server.\n * @param {object} parsingOptions - Options which can be passed to adjust the read and write stream used in sending the data to the remote server\n * @returns {Operation}\n */\nexport function putCSV(localFilePath: string, remoteFilePath: string, parsingOptions: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that converts JSON to CSV and uploads it to an FTP server",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that converts JSON to CSV and uploads it to an FTP server\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Convert JSON to CSV and upload to an FTP server\n * @public\n * @example\n * putCSV(\n *   '/some/path/to_local_file.csv',\n *   '/some/path/to_remove_file.csv',\n *   { delimiter: ';', noheader: true }\n * );\n * @function\n * @param {string} localFilePath -  Data source for data to copy to the remote server.\n * @param {string} remoteFilePath - Path to the remote file to be created on the server.\n * @param {object} parsingOptions - Options which can be passed to adjust the read and write stream used in sending the data to the remote server\n * @returns {Operation}\n */\nexport function putCSV(localFilePath: string, remoteFilePath: string, parsingOptions: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * Convert JSON to CSV and upload to an FTP server\n * @public\n * @example\n * putCSV(\n *   '/some/path/to_local_file.csv',\n *   '/some/path/to_remove_file.csv',\n *   { delimiter: ';', noheader: true }\n * );\n * @function\n * @param {string} localFilePath -  Data source for data to copy to the remote server.\n * @param {string} remoteFilePath - Path to the remote file to be created on the server.\n * @param {object} parsingOptions - Options which can be passed to adjust the read and write stream used in sending the data to the remote server\n * @returns {Operation}\n */\nexport function putCSV(localFilePath, remoteFilePath, parsingOptions) {\n  return state => {\n    console.time('Upload finished');\n    return sftp\n      .put(localFilePath, remoteFilePath, parsingOptions)\n      .then(response => handleResponse(response, state))\n      .then(state => {\n        console.timeEnd('Upload finished');\n        return state;\n      });\n  };\n}\n"
  },
  {
    "name": "getJSON",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * Fetch a json file from an FTP server\n * @public\n * @example\n * getJSON(\n *   '/path/To/File',\n *   'utf8',\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {string} encoding - Character encoding for the json\n * @returns {Operation}\n */\nexport function getJSON(filePath, encoding) {\n  return state => {\n    let results = [];\n\n    return sftp\n      .get(filePath)\n      .then(chunk => {\n        results.push(chunk);\n      })\n      .then(() => {\n        console.debug('Receiving stream.\\n');\n        console.time('Stream finished');\n\n        return new Promise((resolve, reject) => {\n          const content = Buffer.concat(results).toString('utf8');\n          resolve(content.split('\\r\\n'));\n        }).then(json => {\n          const nextState = composeNextState(state, json);\n          return nextState;\n        });\n      })\n      .then(state => {\n        console.timeEnd('Stream finished');\n        return state;\n      });\n  };\n}",
    "signature": "/**\n * Fetch a json file from an FTP server\n * @public\n * @example\n * getJSON(\n *   '/path/To/File',\n *   'utf8',\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {string} encoding - Character encoding for the json\n * @returns {Operation}\n */\nexport function getJSON(filePath: string, encoding: string): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that fetches a json file from an FTP server.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that fetches a json file from an FTP server.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Fetch a json file from an FTP server\n * @public\n * @example\n * getJSON(\n *   '/path/To/File',\n *   'utf8',\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {string} encoding - Character encoding for the json\n * @returns {Operation}\n */\nexport function getJSON(filePath: string, encoding: string): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * Fetch a json file from an FTP server\n * @public\n * @example\n * getJSON(\n *   '/path/To/File',\n *   'utf8',\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {string} encoding - Character encoding for the json\n * @returns {Operation}\n */\nexport function getJSON(filePath, encoding) {\n  return state => {\n    let results = [];\n\n    return sftp\n      .get(filePath)\n      .then(chunk => {\n        results.push(chunk);\n      })\n      .then(() => {\n        console.debug('Receiving stream.\\n');\n        console.time('Stream finished');\n\n        return new Promise((resolve, reject) => {\n          const content = Buffer.concat(results).toString('utf8');\n          resolve(content.split('\\r\\n'));\n        }).then(json => {\n          const nextState = composeNextState(state, json);\n          return nextState;\n        });\n      })\n      .then(state => {\n        console.timeEnd('Stream finished');\n        return state;\n      });\n  };\n}\n"
  },
  {
    "name": "normalizeCSVarray",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * Convert JSON array of strings into a normalized object\n * @public\n * @example\n * normalizeCSVarray({ delimiter: ';', noheader: true });\n * @function\n * @param {options} options - Options passed to csvtojson parser\n * @param {callback} callback - Options passed to csvtojson parser\n * @returns {Operation}\n */\nexport function normalizeCSVarray(options, callback) {\n  return state => {\n    let results = [];\n\n    state.data.map(data => {\n      const [keys, ...rest] = data\n        .shift()\n        .split('\\n')\n        .map(h => h.replace(/\"/g, ''));\n\n      results.push(keys);\n    });\n\n    const headers = results[0]\n      .trim()\n      .split('\\n')\n      .map(item => item.split(','))\n      .flat();\n\n    const values = results[1]\n      .trim()\n      .split('\\n')\n      .map(item => item.split(','))\n      .flat();\n\n    const normalizedArray = values.map(item => {\n      const object = {};\n      headers.forEach((key, index) => (object[key] = item.at(index)));\n      return object;\n    });\n\n    return { ...state, normalizedArray };\n  };\n}",
    "signature": "/**\n * Convert JSON array of strings into a normalized object\n * @public\n * @example\n * normalizeCSVarray({ delimiter: ';', noheader: true });\n * @function\n * @param {options} options - Options passed to csvtojson parser\n * @param {callback} callback - Options passed to csvtojson parser\n * @returns {Operation}\n */\nexport function normalizeCSVarray(options: any, callback: any): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that normalizes a JSON array of strings into a normalized object.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that normalizes a JSON array of strings into a normalized object.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Convert JSON array of strings into a normalized object\n * @public\n * @example\n * normalizeCSVarray({ delimiter: ';', noheader: true });\n * @function\n * @param {options} options - Options passed to csvtojson parser\n * @param {callback} callback - Options passed to csvtojson parser\n * @returns {Operation}\n */\nexport function normalizeCSVarray(options: any, callback: any): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * Convert JSON array of strings into a normalized object\n * @public\n * @example\n * normalizeCSVarray({ delimiter: ';', noheader: true });\n * @function\n * @param {options} options - Options passed to csvtojson parser\n * @param {callback} callback - Options passed to csvtojson parser\n * @returns {Operation}\n */\nexport function normalizeCSVarray(options, callback) {\n  return state => {\n    let results = [];\n\n    state.data.map(data => {\n      const [keys, ...rest] = data\n        .shift()\n        .split('\\n')\n        .map(h => h.replace(/\"/g, ''));\n\n      results.push(keys);\n    });\n\n    const headers = results[0]\n      .trim()\n      .split('\\n')\n      .map(item => item.split(','))\n      .flat();\n\n    const values = results[1]\n      .trim()\n      .split('\\n')\n      .map(item => item.split(','))\n      .flat();\n\n    const normalizedArray = values.map(item => {\n      const object = {};\n      headers.forEach((key, index) => (object[key] = item.at(index)));\n      return object;\n    });\n\n    return { ...state, normalizedArray };\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import { normalizeOauthConfig } from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  // why not here?\n\n  return state => {\n    // Note: we no longer need `steps` anymore since `commonExecute`\n    // takes each operation as an argument.\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n      configuration: normalizeOauthConfig(state.configuration),\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport { normalizeOauthConfig } from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  // why not here?\n\n  return state => {\n    // Note: we no longer need `steps` anymore since `commonExecute`\n    // takes each operation as an argument.\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n      configuration: normalizeOauthConfig(state.configuration),\n    });\n  };\n}\n"
  },
  {
    "name": "appendValues",
    "implementation": "import { normalizeOauthConfig } from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Add an array of rows to the spreadsheet.\n * https://developers.google.com/sheets/api/samples/writing#append_values\n * @public\n * @example\n * appendValues({\n *   spreadsheetId: '1O-a4_RgPF_p8W3I6b5M9wobA3-CBW8hLClZfUik5sos',\n *   range: 'Sheet1!A1:E1',\n *   values: [\n *     ['From expression', '$15', '2', '3/15/2016'],\n *     ['Really now!', '$100', '1', '3/20/2016'],\n *   ],\n * })\n * @function\n * @param {Object} params - Data object to add to the spreadsheet.\n * @returns {Operation}\n */\nexport function appendValues(params) {\n  return state => {\n    const { accessToken } = state.configuration;\n\n    const oauth2Client = new google.auth.OAuth2();\n    oauth2Client.credentials = { access_token: accessToken };\n\n    const { spreadsheetId, range, values } = expandReferences(params)(state);\n\n    var sheets = google.sheets('v4');\n\n    return new Promise((resolve, reject) => {\n      sheets.spreadsheets.values.append(\n        {\n          auth: oauth2Client,\n          spreadsheetId,\n          range,\n          valueInputOption: 'USER_ENTERED',\n          resource: {\n            range,\n            majorDimension: 'ROWS',\n            values: values,\n          },\n        },",
    "signature": "/**\n * Add an array of rows to the spreadsheet.\n * https://developers.google.com/sheets/api/samples/writing#append_values\n * @public\n * @example\n * appendValues({\n *   spreadsheetId: '1O-a4_RgPF_p8W3I6b5M9wobA3-CBW8hLClZfUik5sos',\n *   range: 'Sheet1!A1:E1',\n *   values: [\n *     ['From expression', '$15', '2', '3/15/2016'],\n *     ['Really now!', '$100', '1', '3/20/2016'],\n *   ],\n * })\n * @function\n * @param {Object} params - Data object to add to the spreadsheet.\n * @returns {Operation}\n */\nexport function appendValues(params: any): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that appends values to a spreadsheet.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that appends values to a spreadsheet.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Add an array of rows to the spreadsheet.\n * https://developers.google.com/sheets/api/samples/writing#append_values\n * @public\n * @example\n * appendValues({\n *   spreadsheetId: '1O-a4_RgPF_p8W3I6b5M9wobA3-CBW8hLClZfUik5sos',\n *   range: 'Sheet1!A1:E1',\n *   values: [\n *     ['From expression', '$15', '2', '3/15/2016'],\n *     ['Really now!', '$100', '1', '3/20/2016'],\n *   ],\n * })\n * @function\n * @param {Object} params - Data object to add to the spreadsheet.\n * @returns {Operation}\n */\nexport function appendValues(params: any): Operation;\n\n### Implementation:\nimport { normalizeOauthConfig } from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Add an array of rows to the spreadsheet.\n * https://developers.google.com/sheets/api/samples/writing#append_values\n * @public\n * @example\n * appendValues({\n *   spreadsheetId: '1O-a4_RgPF_p8W3I6b5M9wobA3-CBW8hLClZfUik5sos',\n *   range: 'Sheet1!A1:E1',\n *   values: [\n *     ['From expression', '$15', '2', '3/15/2016'],\n *     ['Really now!', '$100', '1', '3/20/2016'],\n *   ],\n * })\n * @function\n * @param {Object} params - Data object to add to the spreadsheet.\n * @returns {Operation}\n */\nexport function appendValues(params) {\n  return state => {\n    const { accessToken } = state.configuration;\n\n    const oauth2Client = new google.auth.OAuth2();\n    oauth2Client.credentials = { access_token: accessToken };\n\n    const { spreadsheetId, range, values } = expandReferences(params)(state);\n\n    var sheets = google.sheets('v4');\n\n    return new Promise((resolve, reject) => {\n      sheets.spreadsheets.values.append(\n        {\n          auth: oauth2Client,\n          spreadsheetId,\n          range,\n          valueInputOption: 'USER_ENTERED',\n          resource: {\n            range,\n            majorDimension: 'ROWS',\n            values: values,\n          },\n        },\n"
  },
  {
    "name": "execute",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      createClient,\n      ...operations,\n      cleanupState\n    )({\n      ...initialState,\n      ...state,\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      createClient,\n      ...operations,\n      cleanupState\n    )({\n      ...initialState,\n      ...state,\n    });\n  };\n}\n"
  },
  {
    "name": "tagMembers",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Add or update a list members\n * @example\n * upsertMembers((state) => ({\n *   listId: \"someId\",\n *   users: state.response.body.rows.map((u) => ({\n *     email: u.email,\n *     status: u.allow_other_emails ? \"subscribed\" : \"unsubscribed\",\n *     mergeFields: { FNAME: u.first_name, LNAME: u.last_name },\n *   })),\n * }));\n * @function\n * @param {object} params - a listId, users, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\n// TODO: Add jsdoc for params ={ path, query, body}\n// TODO: Add examples\nexport function upsertMembers(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n    // TODO: Add support for options\n    // TODO: rename users to members\n    const defaultOptions = {\n      update_existing: true,\n      sync_tags: false,\n    };\n    const { listId, users, options } = resolvedParams;\n    const opts = { ...defaultOptions, ...options };\n\n    const membersList = users.map(member => ({\n      email_address: member.email,\n      status: member.status,\n      merge_fields: member.mergeFields,\n      tags: member.tags,\n    }));\n\n    return state.client.lists\n      .batchListMembers(listId, {\n        ...opts,\n        members: membersList,\n      })\n      .then(response => handleResponse(response, state, callback));\n  };\n}\n\n/**\n * Tag members with a particular tag\n * @example\n * tagMembers((state) => ({\n *   listId: \"someId\", // All Subscribers list\n *   tagId: \"someTag\", // User tag\n *   members: state.response.body.rows.map((u) => u.email),\n * }));\n * @example\n * tagMembers((state) => ({\n *   listId: \"someId\",\n *   tagId: \"someTag\",\n *   members: state.response.body.rows\n *     .filter((u) => u.allow_other_emails)\n *     .map((u) => u.email),\n * }));\n * @function\n * @param {object} params - a tagId, members, and a list\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function tagMembers(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n    const { listId, tagId, members } = resolvedParams;\n\n    return state.client.lists\n      .batchSegmentMembers({ members_to_add: members }, listId, tagId)\n      .then(response => handleResponse(response, state, callback));\n  };\n}",
    "signature": "/**\n * Tag members with a particular tag\n * @example\n * tagMembers((state) => ({\n *   listId: \"someId\", // All Subscribers list\n *   tagId: \"someTag\", // User tag\n *   members: state.response.body.rows.map((u) => u.email),\n * }));\n * @example\n * tagMembers((state) => ({\n *   listId: \"someId\",\n *   tagId: \"someTag\",\n *   members: state.response.body.rows\n *     .filter((u) => u.allow_other_emails)\n *     .map((u) => u.email),\n * }));\n * @function\n * @param {object} params - a tagId, members, and a list\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function tagMembers(params: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that tags members to/on/from a list.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that tags members to/on/from a list.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Tag members with a particular tag\n * @example\n * tagMembers((state) => ({\n *   listId: \"someId\", // All Subscribers list\n *   tagId: \"someTag\", // User tag\n *   members: state.response.body.rows.map((u) => u.email),\n * }));\n * @example\n * tagMembers((state) => ({\n *   listId: \"someId\",\n *   tagId: \"someTag\",\n *   members: state.response.body.rows\n *     .filter((u) => u.allow_other_emails)\n *     .map((u) => u.email),\n * }));\n * @function\n * @param {object} params - a tagId, members, and a list\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function tagMembers(params: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Add or update a list members\n * @example\n * upsertMembers((state) => ({\n *   listId: \"someId\",\n *   users: state.response.body.rows.map((u) => ({\n *     email: u.email,\n *     status: u.allow_other_emails ? \"subscribed\" : \"unsubscribed\",\n *     mergeFields: { FNAME: u.first_name, LNAME: u.last_name },\n *   })),\n * }));\n * @function\n * @param {object} params - a listId, users, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\n// TODO: Add jsdoc for params ={ path, query, body}\n// TODO: Add examples\nexport function upsertMembers(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n    // TODO: Add support for options\n    // TODO: rename users to members\n    const defaultOptions = {\n      update_existing: true,\n      sync_tags: false,\n    };\n    const { listId, users, options } = resolvedParams;\n    const opts = { ...defaultOptions, ...options };\n\n    const membersList = users.map(member => ({\n      email_address: member.email,\n      status: member.status,\n      merge_fields: member.mergeFields,\n      tags: member.tags,\n    }));\n\n    return state.client.lists\n      .batchListMembers(listId, {\n        ...opts,\n        members: membersList,\n      })\n      .then(response => handleResponse(response, state, callback));\n  };\n}\n\n/**\n * Tag members with a particular tag\n * @example\n * tagMembers((state) => ({\n *   listId: \"someId\", // All Subscribers list\n *   tagId: \"someTag\", // User tag\n *   members: state.response.body.rows.map((u) => u.email),\n * }));\n * @example\n * tagMembers((state) => ({\n *   listId: \"someId\",\n *   tagId: \"someTag\",\n *   members: state.response.body.rows\n *     .filter((u) => u.allow_other_emails)\n *     .map((u) => u.email),\n * }));\n * @function\n * @param {object} params - a tagId, members, and a list\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function tagMembers(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n    const { listId, tagId, members } = resolvedParams;\n\n    return state.client.lists\n      .batchSegmentMembers({ members_to_add: members }, listId, tagId)\n      .then(response => handleResponse(response, state, callback));\n  };\n}\n"
  },
  {
    "name": "startBatch",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Start a batch with a list of operations.\n * @example\n * startBatch(params)\n * @function\n * @param {object} params - operations batch job\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function startBatch(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n    const { operations } = resolvedParams;\n\n    return state.client.batches\n      .start({ operations: [...operations] })\n      .then(response => handleResponse(response, state, callback));\n  };\n}",
    "signature": "/**\n * Start a batch with a list of operations.\n * @example\n * startBatch(params)\n * @function\n * @param {object} params - operations batch job\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function startBatch(params: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that starts a batch with a list of operations.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that starts a batch with a list of operations.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Start a batch with a list of operations.\n * @example\n * startBatch(params)\n * @function\n * @param {object} params - operations batch job\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function startBatch(params: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Start a batch with a list of operations.\n * @example\n * startBatch(params)\n * @function\n * @param {object} params - operations batch job\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function startBatch(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n    const { operations } = resolvedParams;\n\n    return state.client.batches\n      .start({ operations: [...operations] })\n      .then(response => handleResponse(response, state, callback));\n  };\n}\n"
  },
  {
    "name": "listBatches",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * listBatches\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listBatches(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n\n    return state.client.batches\n      .list(resolvedParams)\n      .then(response => handleResponse(response, state, callback));\n  };\n}",
    "signature": "/**\n * listBatches\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listBatches(params: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that lists batches from a listId.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that lists batches from a listId.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * listBatches\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listBatches(params: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * listBatches\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listBatches(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n\n    return state.client.batches\n      .list(resolvedParams)\n      .then(response => handleResponse(response, state, callback));\n  };\n}\n"
  },
  {
    "name": "listMembers",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * listMembers\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listMembers(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n\n    const { listId, ...otherParams } = resolvedParams;\n    return state.client.lists\n      .getListMembersInfo(listId, otherParams)\n      .then(response => handleResponse(response, state, callback));\n  };\n}",
    "signature": "/**\n * listMembers\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listMembers(params: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "create an OpenFn function that lists members from a listId",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\ncreate an OpenFn function that lists members from a listId\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * listMembers\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listMembers(params: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * listMembers\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listMembers(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n\n    const { listId, ...otherParams } = resolvedParams;\n    return state.client.lists\n      .getListMembersInfo(listId, otherParams)\n      .then(response => handleResponse(response, state, callback));\n  };\n}\n"
  },
  {
    "name": "addMember",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * addMember to a list\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function addMember(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n\n    const { listId, member } = resolvedParams;\n    return state.client.lists\n      .addListMember(listId, ...member)\n      .then(response => handleResponse(response, state, callback));\n  };\n}",
    "signature": "/**\n * addMember to a list\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function addMember(params: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that adds a member to a list.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that adds a member to a list.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * addMember to a list\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function addMember(params: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * addMember to a list\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function addMember(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n\n    const { listId, member } = resolvedParams;\n    return state.client.lists\n      .addListMember(listId, ...member)\n      .then(response => handleResponse(response, state, callback));\n  };\n}\n"
  },
  {
    "name": "updateMember",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * updateMember\n * @function\n * @param {object} params - a listId,subscriberHash and member\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function updateMember(\n  params = { listId, subscriberHash, member },\n  callback = s => s\n) {\n  return state => {\n    const requiredParams = ['listId', 'subscriberHash'];\n    const [resolvedParams] = expandReferences(state, params);\n    assertKeys(resolvedParams, requiredParams);\n\n    const { listId, subscriberHash, member } = resolvedParams;\n\n    return state.client.lists\n      .updateListMember(listId, subscriberHash, member)\n      .then(response => handleResponse(response, state, callback));\n  };\n}",
    "signature": "/**\n * updateMember\n * @function\n * @param {object} params - a listId,subscriberHash and member\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function updateMember(params?: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that updates a member to/on/from a listId and",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that updates a member to/on/from a listId and\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * updateMember\n * @function\n * @param {object} params - a listId,subscriberHash and member\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function updateMember(params?: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * updateMember\n * @function\n * @param {object} params - a listId,subscriberHash and member\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function updateMember(\n  params = { listId, subscriberHash, member },\n  callback = s => s\n) {\n  return state => {\n    const requiredParams = ['listId', 'subscriberHash'];\n    const [resolvedParams] = expandReferences(state, params);\n    assertKeys(resolvedParams, requiredParams);\n\n    const { listId, subscriberHash, member } = resolvedParams;\n\n    return state.client.lists\n      .updateListMember(listId, subscriberHash, member)\n      .then(response => handleResponse(response, state, callback));\n  };\n}\n"
  },
  {
    "name": "updateMemberTags",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * updateMemberTags\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function updateMemberTags(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n\n    const { listId, subscriberHash, tags } = resolvedParams;\n    return state.client.lists\n      .updateListMemberTags(listId, subscriberHash, { tags: tags })\n      .then(response => handleResponse(response, state, callback));\n  };\n}",
    "signature": "/**\n * updateMemberTags\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function updateMemberTags(params: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "create an OpenFn function that updates member tags to/on/from a listId.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\ncreate an OpenFn function that updates member tags to/on/from a listId.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * updateMemberTags\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function updateMemberTags(params: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * updateMemberTags\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function updateMemberTags(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n\n    const { listId, subscriberHash, tags } = resolvedParams;\n    return state.client.lists\n      .updateListMemberTags(listId, subscriberHash, { tags: tags })\n      .then(response => handleResponse(response, state, callback));\n  };\n}\n"
  },
  {
    "name": "archiveMember",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * archiveMember in a list\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function archiveMember(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n\n    const { listId, subscriberHash } = resolvedParams;\n    return state.client.lists\n      .deleteListMember(listId, subscriberHash)\n      .then(response => handleResponse(response, state, callback));\n  };\n}",
    "signature": "/**\n * archiveMember in a list\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function archiveMember(params: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that archives a member from a list.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that archives a member from a list.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * archiveMember in a list\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function archiveMember(params: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * archiveMember in a list\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function archiveMember(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n\n    const { listId, subscriberHash } = resolvedParams;\n    return state.client.lists\n      .deleteListMember(listId, subscriberHash)\n      .then(response => handleResponse(response, state, callback));\n  };\n}\n"
  },
  {
    "name": "deleteMember",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Permanently delete a member from a list\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function deleteMember(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n\n    const { listId, subscriberHash } = resolvedParams;\n    return state.client.lists\n      .deleteListMemberPermanent(listId, subscriberHash)\n      .then(response => handleResponse(response, state, callback));\n  };\n}",
    "signature": "/**\n * Permanently delete a member from a list\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function deleteMember(params: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that deletes a member from a list.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that deletes a member from a list.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Permanently delete a member from a list\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function deleteMember(params: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Permanently delete a member from a list\n * @function\n * @param {object} params - a listId, and options\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function deleteMember(params, callback = s => s) {\n  return state => {\n    const [resolvedParams] = expandReferences(state, params);\n\n    const { listId, subscriberHash } = resolvedParams;\n    return state.client.lists\n      .deleteListMemberPermanent(listId, subscriberHash)\n      .then(response => handleResponse(response, state, callback));\n  };\n}\n"
  },
  {
    "name": "listAudiences",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Get information about all lists in the account.\n * @function\n * @param {object} query - Query parameters\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listAudiences(query, callback = s => s) {\n  return state => {\n    const [resolvedQuery] = expandReferences(state, query);\n\n    return state.client.lists\n      .getAllLists(resolvedQuery)\n      .then(response => handleResponse(response, state, callback));\n  };\n}",
    "signature": "/**\n * Get information about all lists in the account.\n * @function\n * @param {object} query - Query parameters\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listAudiences(query: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets information from all lists in the account.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets information from all lists in the account.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get information about all lists in the account.\n * @function\n * @param {object} query - Query parameters\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listAudiences(query: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Get information about all lists in the account.\n * @function\n * @param {object} query - Query parameters\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listAudiences(query, callback = s => s) {\n  return state => {\n    const [resolvedQuery] = expandReferences(state, query);\n\n    return state.client.lists\n      .getAllLists(resolvedQuery)\n      .then(response => handleResponse(response, state, callback));\n  };\n}\n"
  },
  {
    "name": "listAudienceInfo",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Get information about a specific list in your Mailchimp account.\n * Results include list members who have signed up but haven't confirmed their subscription yet and unsubscribed or cleaned.\n * @function\n * @param {object} query - listId and query parameters\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listAudienceInfo(query, callback = s => s) {\n  return state => {\n    const [resolvedQuery] = expandReferences(state, query);\n    const { listId, ...queries } = resolvedQuery;\n    return state.client.lists\n      .getList(listId, queries)\n      .then(response => handleResponse(response, state, callback));\n  };\n}\n\n// Default options for request()\nconst defaultOptions = {\n  query: {},\n  body: undefined,\n};\n\n// Assert response\nconst assertOK = (response, fullUrl) => {\n  if (response.status >= 400) {\n    const defaultErrorMesssage = `Request to ${fullUrl} failed with status: ${response.status}`;\n\n    const error = new Error(defaultErrorMesssage);\n\n    error.url = fullUrl;\n    error.type = response.type;\n    error.title = response.title;\n    error.status = response.status;\n    error.detail = response.detail;\n    error.instance = response.instance;\n    error.errors = response.errors;\n\n    throw error;\n  }\n};",
    "signature": "/**\n * Get information about a specific list in your Mailchimp account.\n * Results include list members who have signed up but haven't confirmed their subscription yet and unsubscribed or cleaned.\n * @function\n * @param {object} query - listId and query parameters\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listAudienceInfo(query: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "create an OpenFn function that gets information from a specific list in your Mailchimp account",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\ncreate an OpenFn function that gets information from a specific list in your Mailchimp account\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get information about a specific list in your Mailchimp account.\n * Results include list members who have signed up but haven't confirmed their subscription yet and unsubscribed or cleaned.\n * @function\n * @param {object} query - listId and query parameters\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listAudienceInfo(query: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Get information about a specific list in your Mailchimp account.\n * Results include list members who have signed up but haven't confirmed their subscription yet and unsubscribed or cleaned.\n * @function\n * @param {object} query - listId and query parameters\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function listAudienceInfo(query, callback = s => s) {\n  return state => {\n    const [resolvedQuery] = expandReferences(state, query);\n    const { listId, ...queries } = resolvedQuery;\n    return state.client.lists\n      .getList(listId, queries)\n      .then(response => handleResponse(response, state, callback));\n  };\n}\n\n// Default options for request()\nconst defaultOptions = {\n  query: {},\n  body: undefined,\n};\n\n// Assert response\nconst assertOK = (response, fullUrl) => {\n  if (response.status >= 400) {\n    const defaultErrorMesssage = `Request to ${fullUrl} failed with status: ${response.status}`;\n\n    const error = new Error(defaultErrorMesssage);\n\n    error.url = fullUrl;\n    error.type = response.type;\n    error.title = response.title;\n    error.status = response.status;\n    error.detail = response.detail;\n    error.instance = response.instance;\n    error.errors = response.errors;\n\n    throw error;\n  }\n};\n"
  },
  {
    "name": "request",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Make an HTTP request to Mailchimp API\n * @example <caption>Get list to all other resources available in the API</caption>\n * request('GET','/');\n * @example <caption>Create a new account export in your Mailchimp account</caption>\n * request('POST','/accounts-export', {include_stages:[]});\n * @function\n * @param {string} method - The HTTP method for the request (e.g., 'GET', 'POST', 'PUT', 'DELETE').\n * @param {string} path - The endpoint of the api to which the request should be made.\n * @param {Object} options - Additional options for the request (query, body only).\n * @param {function} [callback] - (Optional) callback function to handle the response.\n * @returns {Operation}\n */\nexport function request(method, path, options, callback) {\n  return async state => {\n    const apiVersion = '3.0';\n    const { apiKey, server } = state.configuration;\n\n    const [resolvedMethod, resolvedPath, resolvedOptions] = expandReferences(\n      state,\n      method,\n      path,\n      options\n    );\n    const { query, body } = { ...defaultOptions, ...resolvedOptions };\n\n    const apiToken = Buffer.from(`openfn:${apiKey}`, 'utf-8').toString(\n      'base64'\n    );\n\n    const headers = {\n      'Content-Type': 'application/json',\n      Authorization: `Basic ${apiToken}`,\n    };\n\n    const urlPath = `/${apiVersion}${resolvedPath}`;\n    const response = await state.apiClient.request({\n      method: resolvedMethod,\n      path: urlPath,\n      headers,\n      query,\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    console.log('Mailchimp says', response.statusCode);\n\n    const responseBody = await response.body.json();\n    assertOK(responseBody, `https://${server}.api.mailchimp.com${urlPath}`);\n\n    const nextState = {\n      ...state,\n      data: responseBody,\n      response: responseBody,\n    };\n    if (callback) return callback(nextState);\n\n    return nextState;\n  };\n}",
    "signature": "/**\n * Make an HTTP request to Mailchimp API\n * @example <caption>Get list to all other resources available in the API</caption>\n * request('GET','/');\n * @example <caption>Create a new account export in your Mailchimp account</caption>\n * request('POST','/accounts-export', {include_stages:[]});\n * @function\n * @param {string} method - The HTTP method for the request (e.g., 'GET', 'POST', 'PUT', 'DELETE').\n * @param {string} path - The endpoint of the api to which the request should be made.\n * @param {Object} options - Additional options for the request (query, body only).\n * @param {function} [callback] - (Optional) callback function to handle the response.\n * @returns {Operation}\n */\nexport function request(method: string, path: string, options: any, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes an HTTP request to the Mailchimp API.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes an HTTP request to the Mailchimp API.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make an HTTP request to Mailchimp API\n * @example <caption>Get list to all other resources available in the API</caption>\n * request('GET','/');\n * @example <caption>Create a new account export in your Mailchimp account</caption>\n * request('POST','/accounts-export', {include_stages:[]});\n * @function\n * @param {string} method - The HTTP method for the request (e.g., 'GET', 'POST', 'PUT', 'DELETE').\n * @param {string} path - The endpoint of the api to which the request should be made.\n * @param {Object} options - Additional options for the request (query, body only).\n * @param {function} [callback] - (Optional) callback function to handle the response.\n * @returns {Operation}\n */\nexport function request(method: string, path: string, options: any, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Make an HTTP request to Mailchimp API\n * @example <caption>Get list to all other resources available in the API</caption>\n * request('GET','/');\n * @example <caption>Create a new account export in your Mailchimp account</caption>\n * request('POST','/accounts-export', {include_stages:[]});\n * @function\n * @param {string} method - The HTTP method for the request (e.g., 'GET', 'POST', 'PUT', 'DELETE').\n * @param {string} path - The endpoint of the api to which the request should be made.\n * @param {Object} options - Additional options for the request (query, body only).\n * @param {function} [callback] - (Optional) callback function to handle the response.\n * @returns {Operation}\n */\nexport function request(method, path, options, callback) {\n  return async state => {\n    const apiVersion = '3.0';\n    const { apiKey, server } = state.configuration;\n\n    const [resolvedMethod, resolvedPath, resolvedOptions] = expandReferences(\n      state,\n      method,\n      path,\n      options\n    );\n    const { query, body } = { ...defaultOptions, ...resolvedOptions };\n\n    const apiToken = Buffer.from(`openfn:${apiKey}`, 'utf-8').toString(\n      'base64'\n    );\n\n    const headers = {\n      'Content-Type': 'application/json',\n      Authorization: `Basic ${apiToken}`,\n    };\n\n    const urlPath = `/${apiVersion}${resolvedPath}`;\n    const response = await state.apiClient.request({\n      method: resolvedMethod,\n      path: urlPath,\n      headers,\n      query,\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    console.log('Mailchimp says', response.statusCode);\n\n    const responseBody = await response.body.json();\n    assertOK(responseBody, `https://${server}.api.mailchimp.com${urlPath}`);\n\n    const nextState = {\n      ...state,\n      data: responseBody,\n      response: responseBody,\n    };\n    if (callback) return callback(nextState);\n\n    return nextState;\n  };\n}\n"
  },
  {
    "name": "get",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * The get function is used to make a GET request to the Mailchimp API.\n * @example <caption>Get a list of account exports for a given account</caption>\n * get('/account-exports');\n * @function\n * @param {string} path - The endpoint of the api to which the request should be made\n * @param {object} query - An object containing query parameters to be included in the request\n * @param {function} [callback] - (Optional) callback to handle the response\n * @returns {Operation}\n */\nexport function get(path, query, callback) {\n  return request('GET', path, { query }, callback);\n}",
    "signature": "/**\n * The get function is used to make a GET request to the Mailchimp API.\n * @example <caption>Get a list of account exports for a given account</caption>\n * get('/account-exports');\n * @function\n * @param {string} path - The endpoint of the api to which the request should be made\n * @param {object} query - An object containing query parameters to be included in the request\n * @param {function} [callback] - (Optional) callback to handle the response\n * @returns {Operation}\n */\nexport function get(path: string, query: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a GET request to the Mailchimp API.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a GET request to the Mailchimp API.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * The get function is used to make a GET request to the Mailchimp API.\n * @example <caption>Get a list of account exports for a given account</caption>\n * get('/account-exports');\n * @function\n * @param {string} path - The endpoint of the api to which the request should be made\n * @param {object} query - An object containing query parameters to be included in the request\n * @param {function} [callback] - (Optional) callback to handle the response\n * @returns {Operation}\n */\nexport function get(path: string, query: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * The get function is used to make a GET request to the Mailchimp API.\n * @example <caption>Get a list of account exports for a given account</caption>\n * get('/account-exports');\n * @function\n * @param {string} path - The endpoint of the api to which the request should be made\n * @param {object} query - An object containing query parameters to be included in the request\n * @param {function} [callback] - (Optional) callback to handle the response\n * @returns {Operation}\n */\nexport function get(path, query, callback) {\n  return request('GET', path, { query }, callback);\n}\n"
  },
  {
    "name": "post",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * The post function is used to make a POST request to the Mailchimp API.\n *\n * @example <caption>Create a new account export in your Mailchimp account</caption>\n * post('/accounts-export', {include_stages:[]});\n * @function\n * @param {string} path - The endpoint of the api to which the request should be made.\n * @param {object} body - The data to be sent in the body of the request\n * @param {object} query - An object containing query parameters to be included in the request\n * @param {function} [callback] - (Optional) callback to handle the response\n * @returns {Operation}\n */\nexport function post(path, body, query, callback) {\n  return request('POST', path, { body, query }, callback);\n}\n\n// TODO Remove axios",
    "signature": "/**\n * The post function is used to make a POST request to the Mailchimp API.\n *\n * @example <caption>Create a new account export in your Mailchimp account</caption>\n * post('/accounts-export', {include_stages:[]});\n * @function\n * @param {string} path - The endpoint of the api to which the request should be made.\n * @param {object} body - The data to be sent in the body of the request\n * @param {object} query - An object containing query parameters to be included in the request\n * @param {function} [callback] - (Optional) callback to handle the response\n * @returns {Operation}\n */\nexport function post(path: string, body: object, query: object, callback?: Function): Operation;\nimport axios from \"axios\";",
    "test": "",
    "instruction": "Create an OpenFn function that makes a POST request to the Mailchimp API.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a POST request to the Mailchimp API.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * The post function is used to make a POST request to the Mailchimp API.\n *\n * @example <caption>Create a new account export in your Mailchimp account</caption>\n * post('/accounts-export', {include_stages:[]});\n * @function\n * @param {string} path - The endpoint of the api to which the request should be made.\n * @param {object} body - The data to be sent in the body of the request\n * @param {object} query - An object containing query parameters to be included in the request\n * @param {function} [callback] - (Optional) callback to handle the response\n * @returns {Operation}\n */\nexport function post(path: string, body: object, query: object, callback?: Function): Operation;\nimport axios from \"axios\";\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * The post function is used to make a POST request to the Mailchimp API.\n *\n * @example <caption>Create a new account export in your Mailchimp account</caption>\n * post('/accounts-export', {include_stages:[]});\n * @function\n * @param {string} path - The endpoint of the api to which the request should be made.\n * @param {object} body - The data to be sent in the body of the request\n * @param {object} query - An object containing query parameters to be included in the request\n * @param {function} [callback] - (Optional) callback to handle the response\n * @returns {Operation}\n */\nexport function post(path, body, query, callback) {\n  return request('POST', path, { body, query }, callback);\n}\n\n// TODO Remove axios\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  expandReferences,\n  normalizeOauthConfig,\n} from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n      configuration: normalizeOauthConfig(state.configuration),\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "describe('execute', () => {\n  it('executes each operation in sequence', done => {\n    const state = {\n      configuration: { accessToken: 'aGVsbG86dGhlcmU' },\n      data: {},\n      references: [],\n    };\n    const operations = [\n      state => {\n        return { ...state, counter: 1 };\n      },\n      state => {\n        return { ...state, counter: 2 };\n      },\n      state => {\n        return { ...state, counter: 3 };\n      },\n    ];\n\n    execute(...operations)(state)\n      .then(finalState => {\n        expect(finalState).to.eql({ ...state, counter: 3 });",
    "instruction": "Create an OpenFn function that executes a sequence of operations.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  expandReferences,\n  normalizeOauthConfig,\n} from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n      configuration: normalizeOauthConfig(state.configuration),\n    });\n  };\n}\n"
  },
  {
    "name": "createFhirResource",
    "implementation": "import {\n  expandReferences,\n  normalizeOauthConfig,\n} from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Create some resource in Google Cloud Healthcare\n * @public\n * @example\n * createFhirResource(\n *   {\n *     cloudRegion: \"us-central1\",\n *     projectId: \"adjective-noun-123\",\n *     datasetId: \"my-dataset\",\n *     fhirStoreId: \"my-fhir-store\",\n *   },\n *   {\n *     resourceType: \"Patient\",\n *     name: [{ use: \"official\", family: \"Smith\", given: [\"Darcy\"] }],\n *     gender: \"female\",\n *     birthDate: \"1970-01-01\",\n *   }\n * );\n * @example\n * createFhirResource(\n *   {\n *     cloudRegion: \"us-central1\",\n *     projectId: \"adjective-noun-123\",\n *     datasetId: \"my-dataset\",\n *     fhirStoreId: \"my-fhir-store\",\n *   },\n *   (state) => ({\n *     resourceType: \"Encounter\",\n *     status: \"finished\",\n *     class: {\n *       system: \"http://hl7.org/fhir/v3/ActCode\",\n *       code: \"IMP\",\n *       display: \"inpatient encounter\",\n *     },\n *     reasonCode: [\n *       {\n *         text: \"The patient had an abnormal heart rate. She was concerned about this.\",\n *       },\n *     ],\n *     subject: {\n *       reference: `Patient/${state.data.id}`,\n *     },\n *   })\n * );\n *\n * @function\n * @param {{cloudRegion: string, projectId: string, datasetId: string, fhirStoreId: string}} [fhirStore] - The FHIR store information.\n *    - `cloudRegion` (string): The cloud region where the FHIR store is located.\n *    - `projectId` (string): The ID of the project that contains the FHIR store.\n *    - `datasetId` (string): The ID of the dataset that contains the FHIR store.\n *    - `fhirStoreId` (string): The ID of the FHIR store.\n * @param {object} resource - The FHIR resource data to be created\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createFhirResource(fhirStore, resource, callback) {\n  return async state => {\n    const { apiVersion, accessToken } = state.configuration;\n\n    const [resolvedFhirStore, resolvedResource] = expandReferences(\n      state,\n      fhirStore,\n      resource\n    );\n    const { resourceType } = resolvedResource;\n    const { cloudRegion, projectId, datasetId, fhirStoreId } =\n      resolvedFhirStore;\n\n    const requiredKeys = [\n      'cloudRegion',\n      'projectId',\n      'datasetId',\n      'fhirStoreId',\n    ];\n\n    const missingKeys = requiredKeys.filter(key => !(key in resolvedFhirStore));\n\n    if (missingKeys.length > 0) {\n      throw new Error(`Missing key(s) in fhirStore: ${missingKeys.join(', ')}`);\n    }\n\n    const url = buildUrl({\n      apiVersion,\n      projectId,\n      cloudRegion,\n      datasetId,\n      fhirStoreId,\n      resourceType,\n    });\n\n    const payload = {\n      auth: { accessToken },\n      ...resolvedResource,\n    };\n\n    return request(url, payload, 'POST').then(response => {\n      console.log(\n        `Created FHIR ${resourceType} resource with ID ${response.id}`\n      );\n      const nextState = {\n        ...composeNextState(state, response),\n        response,\n      };\n      if (callback) return callback(nextState);\n      return nextState;\n    });\n  };\n}",
    "signature": "/**\n * Create some resource in Google Cloud Healthcare\n * @public\n * @example\n * createFhirResource(\n *   {\n *     cloudRegion: \"us-central1\",\n *     projectId: \"adjective-noun-123\",\n *     datasetId: \"my-dataset\",\n *     fhirStoreId: \"my-fhir-store\",\n *   },\n *   {\n *     resourceType: \"Patient\",\n *     name: [{ use: \"official\", family: \"Smith\", given: [\"Darcy\"] }],\n *     gender: \"female\",\n *     birthDate: \"1970-01-01\",\n *   }\n * );\n * @example\n * createFhirResource(\n *   {\n *     cloudRegion: \"us-central1\",\n *     projectId: \"adjective-noun-123\",\n *     datasetId: \"my-dataset\",\n *     fhirStoreId: \"my-fhir-store\",\n *   },\n *   (state) => ({\n *     resourceType: \"Encounter\",\n *     status: \"finished\",\n *     class: {\n *       system: \"http://hl7.org/fhir/v3/ActCode\",\n *       code: \"IMP\",\n *       display: \"inpatient encounter\",\n *     },\n *     reasonCode: [\n *       {\n *         text: \"The patient had an abnormal heart rate. She was concerned about this.\",\n *       },\n *     ],\n *     subject: {\n *       reference: `Patient/${state.data.id}`,\n *     },\n *   })\n * );\n *\n * @function\n * @param {{cloudRegion: string, projectId: string, datasetId: string, fhirStoreId: string}} [fhirStore] - The FHIR store information.\n *    - `cloudRegion` (string): The cloud region where the FHIR store is located.\n *    - `projectId` (string): The ID of the project that contains the FHIR store.\n *    - `datasetId` (string): The ID of the dataset that contains the FHIR store.\n *    - `fhirStoreId` (string): The ID of the FHIR store.\n * @param {object} resource - The FHIR resource data to be created\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createFhirResource(fhirStore?: {\n    cloudRegion: string;\n    projectId: string;\n    datasetId: string;\n    fhirStoreId: string;\n}, resource: object, callback: Function): Operation;",
    "test": "describe('createFhirResource', () => {\n  it('creates a patient resource to google cloud healthcare', async () => {\n    const state = {\n      configuration: {\n        accessToken: 'aGVsbG86dGhlcmU=',\n      },\n      data: {\n        fhirStore: {\n          cloudRegion: 'us-east7',\n          projectId: 'test-007',\n          datasetId: 'fhir-007',\n          fhirStoreId: 'testing-fhir-007',\n        },\n        resource: {\n          resourceType: 'Patient',\n          name: [{ use: 'official', family: 'Smith', given: ['Darcy'] }],\n          gender: 'female',\n          birthDate: '1970-01-01',\n        },\n      },\n    };\n\n    const finalState = await execute(\n      createFhirResource(\n        state => state.data.fhirStore,\n        state => state.data.resource\n      )\n    )(state);\n\n    expect(finalState.data).to.eql({\n      data: {\n        birthDate: '1970-01-01',\n        gender: 'female',\n        id: '08ab7dd6-4271-45b2-a6a7-0ecd5ddce29d',\n        meta: {\n          lastUpdated: '2023-06-23T16:40:46.202757+00:00',\n          versionId: 'MTY4NzUzODQ0NjIwMjc1NzAwMA',\n        },\n        name: [\n          {\n            family: 'Smith',\n            given: ['Darcy'],\n            use: 'official',\n          },\n        ],\n        resourceType: 'Patient',\n      },\n    });",
    "instruction": "Create an OpenFn function that creates a resource in Google Cloud Healthcare.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates a resource in Google Cloud Healthcare.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create some resource in Google Cloud Healthcare\n * @public\n * @example\n * createFhirResource(\n *   {\n *     cloudRegion: \"us-central1\",\n *     projectId: \"adjective-noun-123\",\n *     datasetId: \"my-dataset\",\n *     fhirStoreId: \"my-fhir-store\",\n *   },\n *   {\n *     resourceType: \"Patient\",\n *     name: [{ use: \"official\", family: \"Smith\", given: [\"Darcy\"] }],\n *     gender: \"female\",\n *     birthDate: \"1970-01-01\",\n *   }\n * );\n * @example\n * createFhirResource(\n *   {\n *     cloudRegion: \"us-central1\",\n *     projectId: \"adjective-noun-123\",\n *     datasetId: \"my-dataset\",\n *     fhirStoreId: \"my-fhir-store\",\n *   },\n *   (state) => ({\n *     resourceType: \"Encounter\",\n *     status: \"finished\",\n *     class: {\n *       system: \"http://hl7.org/fhir/v3/ActCode\",\n *       code: \"IMP\",\n *       display: \"inpatient encounter\",\n *     },\n *     reasonCode: [\n *       {\n *         text: \"The patient had an abnormal heart rate. She was concerned about this.\",\n *       },\n *     ],\n *     subject: {\n *       reference: `Patient/${state.data.id}`,\n *     },\n *   })\n * );\n *\n * @function\n * @param {{cloudRegion: string, projectId: string, datasetId: string, fhirStoreId: string}} [fhirStore] - The FHIR store information.\n *    - `cloudRegion` (string): The cloud region where the FHIR store is located.\n *    - `projectId` (string): The ID of the project that contains the FHIR store.\n *    - `datasetId` (string): The ID of the dataset that contains the FHIR store.\n *    - `fhirStoreId` (string): The ID of the FHIR store.\n * @param {object} resource - The FHIR resource data to be created\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createFhirResource(fhirStore?: {\n    cloudRegion: string;\n    projectId: string;\n    datasetId: string;\n    fhirStoreId: string;\n}, resource: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  expandReferences,\n  normalizeOauthConfig,\n} from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Create some resource in Google Cloud Healthcare\n * @public\n * @example\n * createFhirResource(\n *   {\n *     cloudRegion: \"us-central1\",\n *     projectId: \"adjective-noun-123\",\n *     datasetId: \"my-dataset\",\n *     fhirStoreId: \"my-fhir-store\",\n *   },\n *   {\n *     resourceType: \"Patient\",\n *     name: [{ use: \"official\", family: \"Smith\", given: [\"Darcy\"] }],\n *     gender: \"female\",\n *     birthDate: \"1970-01-01\",\n *   }\n * );\n * @example\n * createFhirResource(\n *   {\n *     cloudRegion: \"us-central1\",\n *     projectId: \"adjective-noun-123\",\n *     datasetId: \"my-dataset\",\n *     fhirStoreId: \"my-fhir-store\",\n *   },\n *   (state) => ({\n *     resourceType: \"Encounter\",\n *     status: \"finished\",\n *     class: {\n *       system: \"http://hl7.org/fhir/v3/ActCode\",\n *       code: \"IMP\",\n *       display: \"inpatient encounter\",\n *     },\n *     reasonCode: [\n *       {\n *         text: \"The patient had an abnormal heart rate. She was concerned about this.\",\n *       },\n *     ],\n *     subject: {\n *       reference: `Patient/${state.data.id}`,\n *     },\n *   })\n * );\n *\n * @function\n * @param {{cloudRegion: string, projectId: string, datasetId: string, fhirStoreId: string}} [fhirStore] - The FHIR store information.\n *    - `cloudRegion` (string): The cloud region where the FHIR store is located.\n *    - `projectId` (string): The ID of the project that contains the FHIR store.\n *    - `datasetId` (string): The ID of the dataset that contains the FHIR store.\n *    - `fhirStoreId` (string): The ID of the FHIR store.\n * @param {object} resource - The FHIR resource data to be created\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createFhirResource(fhirStore, resource, callback) {\n  return async state => {\n    const { apiVersion, accessToken } = state.configuration;\n\n    const [resolvedFhirStore, resolvedResource] = expandReferences(\n      state,\n      fhirStore,\n      resource\n    );\n    const { resourceType } = resolvedResource;\n    const { cloudRegion, projectId, datasetId, fhirStoreId } =\n      resolvedFhirStore;\n\n    const requiredKeys = [\n      'cloudRegion',\n      'projectId',\n      'datasetId',\n      'fhirStoreId',\n    ];\n\n    const missingKeys = requiredKeys.filter(key => !(key in resolvedFhirStore));\n\n    if (missingKeys.length > 0) {\n      throw new Error(`Missing key(s) in fhirStore: ${missingKeys.join(', ')}`);\n    }\n\n    const url = buildUrl({\n      apiVersion,\n      projectId,\n      cloudRegion,\n      datasetId,\n      fhirStoreId,\n      resourceType,\n    });\n\n    const payload = {\n      auth: { accessToken },\n      ...resolvedResource,\n    };\n\n    return request(url, payload, 'POST').then(response => {\n      console.log(\n        `Created FHIR ${resourceType} resource with ID ${response.id}`\n      );\n      const nextState = {\n        ...composeNextState(state, response),\n        response,\n      };\n      if (callback) return callback(nextState);\n      return nextState;\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import 'regenerator-runtime/runtime.js';\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport 'regenerator-runtime/runtime.js';\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "load",
    "implementation": "import 'regenerator-runtime/runtime.js';\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Load files to BigQuery\n * @public\n * @example\n * load(\n *   './tmp/files',\n *   'my-bg-project',\n *   'test01',\n *   'product-codes',\n *   {\n *     schema: 'FREQ:STRING,DATATYPE:STRING,PRODUCTCODE:STRING,PARTNER:STRING',\n *     writeDisposition: 'WRITE_APPEND',\n *     skipLeadingRows: 1,\n *     schemaUpdateOptions: ['ALLOW_FIELD_ADDITION'],\n *     createDisposition: 'CREATE_IF_NEEDED',\n *   }\n * )\n * @function\n * @param {string} dirPath - the path to your local directory\n * @param {string} projectId - your bigquery project id\n * @param {string} datasetId - your bigquery dataset id\n * @param {string} tableId - the name of the table you'd like to load\n * @param {object} loadOptions - options to pass to the bigquery.load() API\n * @param {function} callback - and optional callback\n * @returns {Operation}\n */\nexport function load(\n  dirPath,\n  projectId,\n  datasetId,\n  tableId,\n  loadOptions,\n  callback\n) {\n  // something that loads data (from a CSV?) to BigQuery\n  return state => {\n    const bigquery = new BigQuery({\n      credentials: state.configuration,\n      projectId,\n    });\n    // In this example, the existing table contains only the 'Name', 'Age',\n    // & 'Weight' columns. 'REQUIRED' fields cannot  be added to an existing\n    // schema, so the additional column must be 'NULLABLE'.\n    async",
    "signature": "/**\n * Load files to BigQuery\n * @public\n * @example\n * load(\n *   './tmp/files',\n *   'my-bg-project',\n *   'test01',\n *   'product-codes',\n *   {\n *     schema: 'FREQ:STRING,DATATYPE:STRING,PRODUCTCODE:STRING,PARTNER:STRING',\n *     writeDisposition: 'WRITE_APPEND',\n *     skipLeadingRows: 1,\n *     schemaUpdateOptions: ['ALLOW_FIELD_ADDITION'],\n *     createDisposition: 'CREATE_IF_NEEDED',\n *   }\n * )\n * @function\n * @param {string} dirPath - the path to your local directory\n * @param {string} projectId - your bigquery project id\n * @param {string} datasetId - your bigquery dataset id\n * @param {string} tableId - the name of the table you'd like to load\n * @param {object} loadOptions - options to pass to the bigquery.load() API\n * @param {function} callback - and optional callback\n * @returns {Operation}\n */\nexport function load(dirPath: string, projectId: string, datasetId: string, tableId: string, loadOptions: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that loads files to BigQuery.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that loads files to BigQuery.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Load files to BigQuery\n * @public\n * @example\n * load(\n *   './tmp/files',\n *   'my-bg-project',\n *   'test01',\n *   'product-codes',\n *   {\n *     schema: 'FREQ:STRING,DATATYPE:STRING,PRODUCTCODE:STRING,PARTNER:STRING',\n *     writeDisposition: 'WRITE_APPEND',\n *     skipLeadingRows: 1,\n *     schemaUpdateOptions: ['ALLOW_FIELD_ADDITION'],\n *     createDisposition: 'CREATE_IF_NEEDED',\n *   }\n * )\n * @function\n * @param {string} dirPath - the path to your local directory\n * @param {string} projectId - your bigquery project id\n * @param {string} datasetId - your bigquery dataset id\n * @param {string} tableId - the name of the table you'd like to load\n * @param {object} loadOptions - options to pass to the bigquery.load() API\n * @param {function} callback - and optional callback\n * @returns {Operation}\n */\nexport function load(dirPath: string, projectId: string, datasetId: string, tableId: string, loadOptions: object, callback: Function): Operation;\n\n### Implementation:\nimport 'regenerator-runtime/runtime.js';\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Load files to BigQuery\n * @public\n * @example\n * load(\n *   './tmp/files',\n *   'my-bg-project',\n *   'test01',\n *   'product-codes',\n *   {\n *     schema: 'FREQ:STRING,DATATYPE:STRING,PRODUCTCODE:STRING,PARTNER:STRING',\n *     writeDisposition: 'WRITE_APPEND',\n *     skipLeadingRows: 1,\n *     schemaUpdateOptions: ['ALLOW_FIELD_ADDITION'],\n *     createDisposition: 'CREATE_IF_NEEDED',\n *   }\n * )\n * @function\n * @param {string} dirPath - the path to your local directory\n * @param {string} projectId - your bigquery project id\n * @param {string} datasetId - your bigquery dataset id\n * @param {string} tableId - the name of the table you'd like to load\n * @param {object} loadOptions - options to pass to the bigquery.load() API\n * @param {function} callback - and optional callback\n * @returns {Operation}\n */\nexport function load(\n  dirPath,\n  projectId,\n  datasetId,\n  tableId,\n  loadOptions,\n  callback\n) {\n  // something that loads data (from a CSV?) to BigQuery\n  return state => {\n    const bigquery = new BigQuery({\n      credentials: state.configuration,\n      projectId,\n    });\n    // In this example, the existing table contains only the 'Name', 'Age',\n    // & 'Weight' columns. 'REQUIRED' fields cannot  be added to an existing\n    // schema, so the additional column must be 'NULLABLE'.\n    async\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for magpi.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for magpi.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for magpi.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for magpi.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "fetchSurveyData",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a POST request to fetch Magpi data and POST it somewhere else\n * @public\n * @example\n * fetchSurveyData({\n *  \"surveyId\": \"37479\",\n *  \"afterDate\": \"2017-09-27\",\n *  \"postUrl\": \"https://www.openfn.org/inbox/your-inbox-url\"\n * })\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function fetchSurveyData(params) {\n  return state => {",
    "signature": "/**\n * Make a POST request to fetch Magpi data and POST it somewhere else\n * @public\n * @example\n * fetchSurveyData({\n *  \"surveyId\": \"37479\",\n *  \"afterDate\": \"2017-09-27\",\n *  \"postUrl\": \"https://www.openfn.org/inbox/your-inbox-url\"\n * })\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function fetchSurveyData(params: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a POST request to fetch Magpi data and POST it",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a POST request to fetch Magpi data and POST it\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a POST request to fetch Magpi data and POST it somewhere else\n * @public\n * @example\n * fetchSurveyData({\n *  \"surveyId\": \"37479\",\n *  \"afterDate\": \"2017-09-27\",\n *  \"postUrl\": \"https://www.openfn.org/inbox/your-inbox-url\"\n * })\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function fetchSurveyData(params: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a POST request to fetch Magpi data and POST it somewhere else\n * @public\n * @example\n * fetchSurveyData({\n *  \"surveyId\": \"37479\",\n *  \"afterDate\": \"2017-09-27\",\n *  \"postUrl\": \"https://www.openfn.org/inbox/your-inbox-url\"\n * })\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function fetchSurveyData(params) {\n  return state => {\n"
  },
  {
    "name": "submitRecord",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Submit a record for a form/survey which already exists in a Magpi user account\n * @public\n * @example\n * submitRecord(jsonData)\n * @function\n * @param {object} jsonData - Payload data for the record\n * @returns {Operation}\n */\nexport function submitRecord(jsonData) {\n  return state => {\n    const jsonBody = expandReferences(data)(state);\n    const body = js2xmlparser('form', jsonBody);\n\n    const { username, password, apiUrl } = state.configuration;\n\n    const url = resolveUrl(apiUrl + '/', 'mobileApi/uploadData');\n    //const url = 'https://www.magpi.com/mobileApi/uploadData'\n\n    console.log('Posting to url: '.concat(url));\n    console.log('Raw JSON body: '.concat(JSON.stringify(jsonBody)));\n    console.log('X-form submission: '.concat(body));\n\n    // return post({ url, body })\n    // .then((result) => {\n    //   console.log(\"Success:\", result);\n    //   return { ...state, references: [ result, ...state.references ] }\n    // })\n  };\n}",
    "signature": "/**\n * Submit a record for a form/survey which already exists in a Magpi user account\n * @public\n * @example\n * submitRecord(jsonData)\n * @function\n * @param {object} jsonData - Payload data for the record\n * @returns {Operation}\n */\nexport function submitRecord(jsonData: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that submits a record to a Magpi user account.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that submits a record to a Magpi user account.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Submit a record for a form/survey which already exists in a Magpi user account\n * @public\n * @example\n * submitRecord(jsonData)\n * @function\n * @param {object} jsonData - Payload data for the record\n * @returns {Operation}\n */\nexport function submitRecord(jsonData: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Submit a record for a form/survey which already exists in a Magpi user account\n * @public\n * @example\n * submitRecord(jsonData)\n * @function\n * @param {object} jsonData - Payload data for the record\n * @returns {Operation}\n */\nexport function submitRecord(jsonData) {\n  return state => {\n    const jsonBody = expandReferences(data)(state);\n    const body = js2xmlparser('form', jsonBody);\n\n    const { username, password, apiUrl } = state.configuration;\n\n    const url = resolveUrl(apiUrl + '/', 'mobileApi/uploadData');\n    //const url = 'https://www.magpi.com/mobileApi/uploadData'\n\n    console.log('Posting to url: '.concat(url));\n    console.log('Raw JSON body: '.concat(JSON.stringify(jsonBody)));\n    console.log('X-form submission: '.concat(body));\n\n    // return post({ url, body })\n    // .then((result) => {\n    //   console.log(\"Success:\", result);\n    //   return { ...state, references: [ result, ...state.references ] }\n    // })\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      generateAuthString,\n      ...operations,\n      cleanupState\n    )({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      generateAuthString,\n      ...operations,\n      cleanupState\n    )({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "getCases",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Generate an auth string to support multiple types of auth credentials.\n * @example\n * generateAuthString(state)\n * @function\n * @param {State} state\n * @returns {string}\n */\nfunction generateAuthString(state) {\n  const { configuration } = state;\n  if (configuration.basicAuth) {\n    const { user, password } = configuration;\n    const auth = {\n      token: 'Basic ' + Buffer.from(`${user}:${password}`).toString('base64'),\n    };\n    return { ...state, auth };\n  }\n  return login(state);\n}\n\n/**\n * Execute custom query\n * @param {State} state\n * @param {object} params\n * @param {function} callback\n * @returns {State}\n */\nfunction queryHandler(state, params, callback) {\n  return new Promise((resolve, reject) => {\n    request(params, function (err, resp, body) {\n      const response = scrubResponse(resp);\n      const error = assembleError({ error: err, response, params });\n      if (error) {\n        reject(error);\n      } else {\n        console.log(\n          `Primero says: '${response.statusCode} ${response.statusMessage}'`\n        );\n        const resp = tryJson(body);\n        if (params.method === 'GET') {\n          console.log(\n            `${\n              resp.data.length\n            } referrals retrieved from request: ${JSON.stringify(\n              response.request,\n              null,\n              2\n            )}`\n          );\n        } else if (params.method === 'PATCH') {\n          console.log('Referral updated.');\n        }\n        const nextState = composeNextState(state, resp.data || resp);\n        if (callback) resolve(callback(nextState));\n        resolve(nextState);\n      }\n    });\n  });\n}\n\n/**\n * Logs in to Primero.\n * @example\n * login(state)\n * @function\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nfunction login(state) {\n  const { url, user, password } = state.configuration;\n  const body = JSON.stringify({\n    user: {\n      user_name: user,\n      password,\n    },\n  });\n\n  const params = {\n    method: 'POST',\n    url: `${url}/api/v2/tokens`,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body,\n  };\n\n  return new Promise((resolve, reject) => {\n    request(params, function (err, resp, body) {\n      const response = scrubResponse(resp);\n      const error = assembleError({ error: err, response, params });\n      if (error) {\n        reject(error);\n      } else {\n        const resp = tryJson(body);\n        resp.token = `Bearer ${resp.token}`;\n        resolve({ ...state, auth: resp });\n      }\n    });\n  });\n}\n\n/**\n * Removes unserializable keys from the state.\n * @example\n * cleanupState(state)\n * @function\n * @param {State} state\n * @returns {State}\n */\nfunction cleanupState(state) {\n  delete state.auth;\n  return state;\n}\n\n/**\n * Get cases from Primero\n *\n * Use this function to get cases from Primero based on a set of query parameters.\n * Note that in many implementations, the `remote` attribute should be set to `true` to ensure that only cases marked for remote access will be retrieved.\n * You can specify a `case_id` value to fetch a unique case and a query string to filter result.\n * @public\n * @example <caption> Get cases from Primero with query parameters</caption>\n * getCases({\n *   remote: true,\n *   query: \"sex=male\",\n * });\n * @example <caption>Get case from Primero for a specific case id</caption>\n * getCases({\n *   remote: true,\n *   case_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} query - an object with a query param at minimum, option to getReferrals\n * @param {object} options - (Optional) an object with a getReferrals key to fetch referrals\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getCases(query, options, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const expandedQuery = expandReferences(query)(state);\n    const expandedOptions = expandReferences(options)(state);\n\n    const params = {\n      method: 'GET',\n      url: `${url}/api/v2/cases`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs: expandedQuery,\n    };\n\n    return new Promise((resolve, reject) => {\n      request(params, async",
    "signature": "/**\n * Get cases from Primero\n *\n * Use this function to get cases from Primero based on a set of query parameters.\n * Note that in many implementations, the `remote` attribute should be set to `true` to ensure that only cases marked for remote access will be retrieved.\n * You can specify a `case_id` value to fetch a unique case and a query string to filter result.\n * @public\n * @example <caption> Get cases from Primero with query parameters</caption>\n * getCases({\n *   remote: true,\n *   query: \"sex=male\",\n * });\n * @example <caption>Get case from Primero for a specific case id</caption>\n * getCases({\n *   remote: true,\n *   case_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} query - an object with a query param at minimum, option to getReferrals\n * @param {object} options - (Optional) an object with a getReferrals key to fetch referrals\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getCases(query: object, options: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets cases from Primero.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets cases from Primero.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get cases from Primero\n *\n * Use this function to get cases from Primero based on a set of query parameters.\n * Note that in many implementations, the `remote` attribute should be set to `true` to ensure that only cases marked for remote access will be retrieved.\n * You can specify a `case_id` value to fetch a unique case and a query string to filter result.\n * @public\n * @example <caption> Get cases from Primero with query parameters</caption>\n * getCases({\n *   remote: true,\n *   query: \"sex=male\",\n * });\n * @example <caption>Get case from Primero for a specific case id</caption>\n * getCases({\n *   remote: true,\n *   case_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} query - an object with a query param at minimum, option to getReferrals\n * @param {object} options - (Optional) an object with a getReferrals key to fetch referrals\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getCases(query: object, options: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Generate an auth string to support multiple types of auth credentials.\n * @example\n * generateAuthString(state)\n * @function\n * @param {State} state\n * @returns {string}\n */\nfunction generateAuthString(state) {\n  const { configuration } = state;\n  if (configuration.basicAuth) {\n    const { user, password } = configuration;\n    const auth = {\n      token: 'Basic ' + Buffer.from(`${user}:${password}`).toString('base64'),\n    };\n    return { ...state, auth };\n  }\n  return login(state);\n}\n\n/**\n * Execute custom query\n * @param {State} state\n * @param {object} params\n * @param {function} callback\n * @returns {State}\n */\nfunction queryHandler(state, params, callback) {\n  return new Promise((resolve, reject) => {\n    request(params, function (err, resp, body) {\n      const response = scrubResponse(resp);\n      const error = assembleError({ error: err, response, params });\n      if (error) {\n        reject(error);\n      } else {\n        console.log(\n          `Primero says: '${response.statusCode} ${response.statusMessage}'`\n        );\n        const resp = tryJson(body);\n        if (params.method === 'GET') {\n          console.log(\n            `${\n              resp.data.length\n            } referrals retrieved from request: ${JSON.stringify(\n              response.request,\n              null,\n              2\n            )}`\n          );\n        } else if (params.method === 'PATCH') {\n          console.log('Referral updated.');\n        }\n        const nextState = composeNextState(state, resp.data || resp);\n        if (callback) resolve(callback(nextState));\n        resolve(nextState);\n      }\n    });\n  });\n}\n\n/**\n * Logs in to Primero.\n * @example\n * login(state)\n * @function\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nfunction login(state) {\n  const { url, user, password } = state.configuration;\n  const body = JSON.stringify({\n    user: {\n      user_name: user,\n      password,\n    },\n  });\n\n  const params = {\n    method: 'POST',\n    url: `${url}/api/v2/tokens`,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body,\n  };\n\n  return new Promise((resolve, reject) => {\n    request(params, function (err, resp, body) {\n      const response = scrubResponse(resp);\n      const error = assembleError({ error: err, response, params });\n      if (error) {\n        reject(error);\n      } else {\n        const resp = tryJson(body);\n        resp.token = `Bearer ${resp.token}`;\n        resolve({ ...state, auth: resp });\n      }\n    });\n  });\n}\n\n/**\n * Removes unserializable keys from the state.\n * @example\n * cleanupState(state)\n * @function\n * @param {State} state\n * @returns {State}\n */\nfunction cleanupState(state) {\n  delete state.auth;\n  return state;\n}\n\n/**\n * Get cases from Primero\n *\n * Use this function to get cases from Primero based on a set of query parameters.\n * Note that in many implementations, the `remote` attribute should be set to `true` to ensure that only cases marked for remote access will be retrieved.\n * You can specify a `case_id` value to fetch a unique case and a query string to filter result.\n * @public\n * @example <caption> Get cases from Primero with query parameters</caption>\n * getCases({\n *   remote: true,\n *   query: \"sex=male\",\n * });\n * @example <caption>Get case from Primero for a specific case id</caption>\n * getCases({\n *   remote: true,\n *   case_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} query - an object with a query param at minimum, option to getReferrals\n * @param {object} options - (Optional) an object with a getReferrals key to fetch referrals\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getCases(query, options, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const expandedQuery = expandReferences(query)(state);\n    const expandedOptions = expandReferences(options)(state);\n\n    const params = {\n      method: 'GET',\n      url: `${url}/api/v2/cases`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs: expandedQuery,\n    };\n\n    return new Promise((resolve, reject) => {\n      request(params, async\n"
  },
  {
    "name": "createCase",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create a new case in Primero\n *\n * Use this function to create a new case in Primero based on a set of Data.\n * @public\n * @example <caption>Create a new case in Primero based on a set of Data</caption>\n * createCase({\n *   data: {\n *     age: 16,\n *     sex: \"female\",\n *     name: \"Edwine Edgemont\",\n *   },\n * });\n * @function\n * @param {object} params - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function createCase(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const { data } = expandReferences(params)(state);\n\n    const requestParams = {\n      method: 'POST',\n      url: `${url}/api/v2/cases`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n        options: {\n          successCodes: [200, 201, 202, 203, 204],\n        },\n      },\n      json: { data: data },\n    };\n\n    return new Promise((resolve, reject) => {\n      request(requestParams, (err, resp, body) => {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          const resp = tryJson(body);\n          console.log(\n            `Post succeeded: ${response.statusCode} ${response.statusMessage}`\n          );\n          const nextState = composeNextState(state, resp.body?.data);\n          if (callback) resolve(callback(nextState));\n          resolve(nextState);\n        }\n      });\n    });\n  };\n}",
    "signature": "/**\n * Create a new case in Primero\n *\n * Use this function to create a new case in Primero based on a set of Data.\n * @public\n * @example <caption>Create a new case in Primero based on a set of Data</caption>\n * createCase({\n *   data: {\n *     age: 16,\n *     sex: \"female\",\n *     name: \"Edwine Edgemont\",\n *   },\n * });\n * @function\n * @param {object} params - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function createCase(params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that creates a new case in Primero.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates a new case in Primero.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create a new case in Primero\n *\n * Use this function to create a new case in Primero based on a set of Data.\n * @public\n * @example <caption>Create a new case in Primero based on a set of Data</caption>\n * createCase({\n *   data: {\n *     age: 16,\n *     sex: \"female\",\n *     name: \"Edwine Edgemont\",\n *   },\n * });\n * @function\n * @param {object} params - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function createCase(params: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create a new case in Primero\n *\n * Use this function to create a new case in Primero based on a set of Data.\n * @public\n * @example <caption>Create a new case in Primero based on a set of Data</caption>\n * createCase({\n *   data: {\n *     age: 16,\n *     sex: \"female\",\n *     name: \"Edwine Edgemont\",\n *   },\n * });\n * @function\n * @param {object} params - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function createCase(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const { data } = expandReferences(params)(state);\n\n    const requestParams = {\n      method: 'POST',\n      url: `${url}/api/v2/cases`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n        options: {\n          successCodes: [200, 201, 202, 203, 204],\n        },\n      },\n      json: { data: data },\n    };\n\n    return new Promise((resolve, reject) => {\n      request(requestParams, (err, resp, body) => {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          const resp = tryJson(body);\n          console.log(\n            `Post succeeded: ${response.statusCode} ${response.statusMessage}`\n          );\n          const nextState = composeNextState(state, resp.body?.data);\n          if (callback) resolve(callback(nextState));\n          resolve(nextState);\n        }\n      });\n    });\n  };\n}\n"
  },
  {
    "name": "updateCase",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Update an existing case in Primero\n *\n * Use this function to update an existing case from Primero.\n * In this implementation, the function uses a case ID to check for the case to update,\n * Then merge the values submitted in this call into an existing case.\n * Fields not specified in this request will not be modified.\n * For nested subform fields, the subform arrays will be recursively merged,\n * keeping both the existing values and appending the new\n * @public\n * @example <caption>Update case for a specific case id</caption>\n * updateCase(\"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\", {\n *   data: {\n *     age: 16,\n *     sex: \"female\",\n *     name: \"Fiona Edgemont\",\n *   },\n * });\n * @function\n * @param {string} id - A case ID to use for the update.\n * @param {object} params - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function updateCase(id, params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n    const { data } = expandReferences(params)(state);\n\n    const requestParams = {\n      method: 'PATCH',\n      url: `${url}/api/v2/cases/${id}`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      json: { data: data },\n    };\n\n    return new Promise((resolve, reject) => {\n      request(requestParams, (err, resp, body) => {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          const resp = tryJson(body);\n          console.log(\n            `PATCH succeeded: ${response.statusCode} ${response.statusMessage}`\n          );\n          const nextState = composeNextState(state, resp.body?.data);\n          if (callback) resolve(callback(nextState));\n          resolve(nextState);\n        }\n      });\n    });\n  };\n}",
    "signature": "/**\n * Update an existing case in Primero\n *\n * Use this function to update an existing case from Primero.\n * In this implementation, the function uses a case ID to check for the case to update,\n * Then merge the values submitted in this call into an existing case.\n * Fields not specified in this request will not be modified.\n * For nested subform fields, the subform arrays will be recursively merged,\n * keeping both the existing values and appending the new\n * @public\n * @example <caption>Update case for a specific case id</caption>\n * updateCase(\"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\", {\n *   data: {\n *     age: 16,\n *     sex: \"female\",\n *     name: \"Fiona Edgemont\",\n *   },\n * });\n * @function\n * @param {string} id - A case ID to use for the update.\n * @param {object} params - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function updateCase(id: string, params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that updates an existing case from Primero.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that updates an existing case from Primero.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Update an existing case in Primero\n *\n * Use this function to update an existing case from Primero.\n * In this implementation, the function uses a case ID to check for the case to update,\n * Then merge the values submitted in this call into an existing case.\n * Fields not specified in this request will not be modified.\n * For nested subform fields, the subform arrays will be recursively merged,\n * keeping both the existing values and appending the new\n * @public\n * @example <caption>Update case for a specific case id</caption>\n * updateCase(\"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\", {\n *   data: {\n *     age: 16,\n *     sex: \"female\",\n *     name: \"Fiona Edgemont\",\n *   },\n * });\n * @function\n * @param {string} id - A case ID to use for the update.\n * @param {object} params - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function updateCase(id: string, params: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Update an existing case in Primero\n *\n * Use this function to update an existing case from Primero.\n * In this implementation, the function uses a case ID to check for the case to update,\n * Then merge the values submitted in this call into an existing case.\n * Fields not specified in this request will not be modified.\n * For nested subform fields, the subform arrays will be recursively merged,\n * keeping both the existing values and appending the new\n * @public\n * @example <caption>Update case for a specific case id</caption>\n * updateCase(\"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\", {\n *   data: {\n *     age: 16,\n *     sex: \"female\",\n *     name: \"Fiona Edgemont\",\n *   },\n * });\n * @function\n * @param {string} id - A case ID to use for the update.\n * @param {object} params - an object with some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function updateCase(id, params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n    const { data } = expandReferences(params)(state);\n\n    const requestParams = {\n      method: 'PATCH',\n      url: `${url}/api/v2/cases/${id}`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      json: { data: data },\n    };\n\n    return new Promise((resolve, reject) => {\n      request(requestParams, (err, resp, body) => {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          const resp = tryJson(body);\n          console.log(\n            `PATCH succeeded: ${response.statusCode} ${response.statusMessage}`\n          );\n          const nextState = composeNextState(state, resp.body?.data);\n          if (callback) resolve(callback(nextState));\n          resolve(nextState);\n        }\n      });\n    });\n  };\n}\n"
  },
  {
    "name": "upsertCase",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert case to Primero\n *\n * Use this function to update an existing case from Primero or to create it otherwise.\n * In this implementation, we first fetch the list of cases,\n * then we check if the case exist before choosing the right operation to do.\n * @public\n * @example <caption>Upsert case for a specific case id</caption>\n * upsertCase({\n *   externalIds: [\"case_id\"],\n *   data: state => ({\n *     age: 20,\n *     sex: \"male\",\n *     name: \"Alex\",\n *     status: \"open\",\n *     case_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n *   }),\n * });\n * @function\n * @param {object} params - an object with an externalIds and some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertCase(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n    const { data, externalIds } = expandReferences(params)(state);\n\n    const qs = {\n      remote: true,\n      scope: {},\n    };\n\n    externalIds\n      .filter(x => data[x])\n      .forEach(x => {\n        // For every externalId field that is provided, add a key to the\n        // scope object in our qs (queryString) and set the value for that key to\n        // whatever value is found IN THE DATA for the given externalId.\n        return (qs[x] = `${data[x]}`);\n      });\n\n    const requestParams = {\n      method: 'GET',\n      url: `${url}/api/v2/cases`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs,\n    };\n\n    // NOTE: while record_id is used in the GET, it must be dropped before -----\n    // subsequent create or update calls are made as it's not valid in Primero.\n    delete data['record_id'];\n    // -------------------------------------------------------------------------\n\n    return new Promise((resolve, reject) => {\n      request(requestParams, (err, resp, body) => {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          const resp = tryJson(body);\n          if (resp.data.length == 0) {\n            console.log('No case found. Performing create.');\n            resolve(createCase({ data }, callback)(state));\n          } else if (resp.data.length > 0) {\n            console.log('Case found. Performing update.');\n            resolve(updateCase(resp.data[0].id, { data }, callback)(state));\n          }\n        }\n      });\n    });\n  };\n}",
    "signature": "/**\n * Upsert case to Primero\n *\n * Use this function to update an existing case from Primero or to create it otherwise.\n * In this implementation, we first fetch the list of cases,\n * then we check if the case exist before choosing the right operation to do.\n * @public\n * @example <caption>Upsert case for a specific case id</caption>\n * upsertCase({\n *   externalIds: [\"case_id\"],\n *   data: state => ({\n *     age: 20,\n *     sex: \"male\",\n *     name: \"Alex\",\n *     status: \"open\",\n *     case_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n *   }),\n * });\n * @function\n * @param {object} params - an object with an externalIds and some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertCase(params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts a case to Primero.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts a case to Primero.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Upsert case to Primero\n *\n * Use this function to update an existing case from Primero or to create it otherwise.\n * In this implementation, we first fetch the list of cases,\n * then we check if the case exist before choosing the right operation to do.\n * @public\n * @example <caption>Upsert case for a specific case id</caption>\n * upsertCase({\n *   externalIds: [\"case_id\"],\n *   data: state => ({\n *     age: 20,\n *     sex: \"male\",\n *     name: \"Alex\",\n *     status: \"open\",\n *     case_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n *   }),\n * });\n * @function\n * @param {object} params - an object with an externalIds and some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertCase(params: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert case to Primero\n *\n * Use this function to update an existing case from Primero or to create it otherwise.\n * In this implementation, we first fetch the list of cases,\n * then we check if the case exist before choosing the right operation to do.\n * @public\n * @example <caption>Upsert case for a specific case id</caption>\n * upsertCase({\n *   externalIds: [\"case_id\"],\n *   data: state => ({\n *     age: 20,\n *     sex: \"male\",\n *     name: \"Alex\",\n *     status: \"open\",\n *     case_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n *   }),\n * });\n * @function\n * @param {object} params - an object with an externalIds and some case data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function upsertCase(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n    const { data, externalIds } = expandReferences(params)(state);\n\n    const qs = {\n      remote: true,\n      scope: {},\n    };\n\n    externalIds\n      .filter(x => data[x])\n      .forEach(x => {\n        // For every externalId field that is provided, add a key to the\n        // scope object in our qs (queryString) and set the value for that key to\n        // whatever value is found IN THE DATA for the given externalId.\n        return (qs[x] = `${data[x]}`);\n      });\n\n    const requestParams = {\n      method: 'GET',\n      url: `${url}/api/v2/cases`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs,\n    };\n\n    // NOTE: while record_id is used in the GET, it must be dropped before -----\n    // subsequent create or update calls are made as it's not valid in Primero.\n    delete data['record_id'];\n    // -------------------------------------------------------------------------\n\n    return new Promise((resolve, reject) => {\n      request(requestParams, (err, resp, body) => {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          const resp = tryJson(body);\n          if (resp.data.length == 0) {\n            console.log('No case found. Performing create.');\n            resolve(createCase({ data }, callback)(state));\n          } else if (resp.data.length > 0) {\n            console.log('Case found. Performing update.');\n            resolve(updateCase(resp.data[0].id, { data }, callback)(state));\n          }\n        }\n      });\n    });\n  };\n}\n"
  },
  {
    "name": "getReferrals",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get referrals for a specific case in Primero\n *\n * Use this function to get the list of referrals of one case from Primero.\n * The search can be done using either `record id` or `case id`.\n * @public\n * @example <caption>Get referrals for a case in Primero by record id</caption>\n * getReferrals({\n *   externalId: \"record_id\",\n *   id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @example <caption>Get referrals for a case in Primero by case id</caption>\n *  getReferrals({\n *   id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} params - an object with an externalId field to select the attribute to use for matching on case and an externalId value for that case.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getReferrals(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const { externalId, id } = expandReferences(params)(state);\n\n    let requestParams = {};\n\n    if (externalId === 'record_id') {\n      console.log('Fetching by record id...');\n      requestParams = {\n        method: 'GET',\n        url: `${url}/api/v2/cases/${id}/referrals`,\n        headers: {\n          Authorization: auth.token,\n          'Content-Type': 'application/json',\n        },\n      };\n      return queryHandler(state, requestParams, callback);\n    } else {\n      console.log('Fetching by case id...');\n      const qs = {\n        case_id: `${id}`,\n      };\n      requestParams = {\n        method: 'GET',\n        url: `${url}/api/v2/cases`,\n        headers: {\n          Authorization: auth.token,\n          'Content-Type': 'application/json',\n        },\n        qs,\n      };\n      return new Promise((resolve, reject) => {\n        request(requestParams, (err, resp, body) => {\n          const response = scrubResponse(resp);\n          const error = assembleError({ error: err, response, params });\n          if (error) {\n            reject(error);\n          } else {\n            const resp = tryJson(body);\n            if (resp.data.length == 0) {\n              reject('No case found');\n              return state;\n            } else if (resp.data.length === 1) {\n              console.log('Case found. Fetching referrals.');\n              const id = resp.data[0].id;\n              requestParams = {\n                method: 'GET',\n                url: `${url}/api/v2/cases/${id}/referrals`,\n                headers: {\n                  Authorization: auth.token,\n                  'Content-Type': 'application/json',\n                },\n              };\n              resolve(queryHandler(state, requestParams, callback));\n            } else {\n              reject(\n                'Multiple cases found. Try using another externalId and ensure that it is unique.'\n              );\n            }\n          }\n        });\n      });\n    }\n  };\n}",
    "signature": "/**\n * Get referrals for a specific case in Primero\n *\n * Use this function to get the list of referrals of one case from Primero.\n * The search can be done using either `record id` or `case id`.\n * @public\n * @example <caption>Get referrals for a case in Primero by record id</caption>\n * getReferrals({\n *   externalId: \"record_id\",\n *   id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @example <caption>Get referrals for a case in Primero by case id</caption>\n *  getReferrals({\n *   id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} params - an object with an externalId field to select the attribute to use for matching on case and an externalId value for that case.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getReferrals(params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets referrals from Primero.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets referrals from Primero.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get referrals for a specific case in Primero\n *\n * Use this function to get the list of referrals of one case from Primero.\n * The search can be done using either `record id` or `case id`.\n * @public\n * @example <caption>Get referrals for a case in Primero by record id</caption>\n * getReferrals({\n *   externalId: \"record_id\",\n *   id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @example <caption>Get referrals for a case in Primero by case id</caption>\n *  getReferrals({\n *   id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} params - an object with an externalId field to select the attribute to use for matching on case and an externalId value for that case.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getReferrals(params: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get referrals for a specific case in Primero\n *\n * Use this function to get the list of referrals of one case from Primero.\n * The search can be done using either `record id` or `case id`.\n * @public\n * @example <caption>Get referrals for a case in Primero by record id</caption>\n * getReferrals({\n *   externalId: \"record_id\",\n *   id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @example <caption>Get referrals for a case in Primero by case id</caption>\n *  getReferrals({\n *   id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} params - an object with an externalId field to select the attribute to use for matching on case and an externalId value for that case.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getReferrals(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const { externalId, id } = expandReferences(params)(state);\n\n    let requestParams = {};\n\n    if (externalId === 'record_id') {\n      console.log('Fetching by record id...');\n      requestParams = {\n        method: 'GET',\n        url: `${url}/api/v2/cases/${id}/referrals`,\n        headers: {\n          Authorization: auth.token,\n          'Content-Type': 'application/json',\n        },\n      };\n      return queryHandler(state, requestParams, callback);\n    } else {\n      console.log('Fetching by case id...');\n      const qs = {\n        case_id: `${id}`,\n      };\n      requestParams = {\n        method: 'GET',\n        url: `${url}/api/v2/cases`,\n        headers: {\n          Authorization: auth.token,\n          'Content-Type': 'application/json',\n        },\n        qs,\n      };\n      return new Promise((resolve, reject) => {\n        request(requestParams, (err, resp, body) => {\n          const response = scrubResponse(resp);\n          const error = assembleError({ error: err, response, params });\n          if (error) {\n            reject(error);\n          } else {\n            const resp = tryJson(body);\n            if (resp.data.length == 0) {\n              reject('No case found');\n              return state;\n            } else if (resp.data.length === 1) {\n              console.log('Case found. Fetching referrals.');\n              const id = resp.data[0].id;\n              requestParams = {\n                method: 'GET',\n                url: `${url}/api/v2/cases/${id}/referrals`,\n                headers: {\n                  Authorization: auth.token,\n                  'Content-Type': 'application/json',\n                },\n              };\n              resolve(queryHandler(state, requestParams, callback));\n            } else {\n              reject(\n                'Multiple cases found. Try using another externalId and ensure that it is unique.'\n              );\n            }\n          }\n        });\n      });\n    }\n  };\n}\n"
  },
  {
    "name": "createReferrals",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create referrals in Primero\n *\n * Use this function to bulk refer to one or multiple cases from Primero to a single user\n * @public\n * @example <caption>Create referrals for multiple cases in Primero</caption>\n * createReferrals({\n *   data: {\n *     ids: [\n *       \"749e9c6e-60db-45ec-8f5a-69da7c223a79\",\n *       \"dcea6052-07d9-4cfa-9abf-9a36987cdd25\",\n *     ],\n *     transitioned_to: \"primero_cp\",\n *     notes: \"This is a bulk referral\",\n *   },\n * });\n * @function\n * @param {object} params - an object with referral data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function createReferrals(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const { data } = expandReferences(params)(state);\n\n    const requestParams = {\n      method: 'POST',\n      url: `${url}/api/v2/cases/referrals`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n        options: {\n          successCodes: [200, 201, 202, 203, 204],\n        },\n      },\n      json: { data: data },\n    };\n\n    return new Promise((resolve, reject) => {\n      request(requestParams, (err, resp, body) => {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          const resp = tryJson(body);\n          console.log(\n            `Post succeeded: ${response.statusCode} ${response.statusMessage}`\n          );\n          const nextState = composeNextState(state, resp.data.body);\n          if (callback) resolve(callback(nextState));\n          resolve(nextState);\n        }\n      });\n    });\n  };\n}\n\n// TODO: We need to deprecate this.",
    "signature": "/**\n * Create referrals in Primero\n *\n * Use this function to bulk refer to one or multiple cases from Primero to a single user\n * @public\n * @example <caption>Create referrals for multiple cases in Primero</caption>\n * createReferrals({\n *   data: {\n *     ids: [\n *       \"749e9c6e-60db-45ec-8f5a-69da7c223a79\",\n *       \"dcea6052-07d9-4cfa-9abf-9a36987cdd25\",\n *     ],\n *     transitioned_to: \"primero_cp\",\n *     notes: \"This is a bulk referral\",\n *   },\n * });\n * @function\n * @param {object} params - an object with referral data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function createReferrals(params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that bulk refers to one or multiple cases from Primero to a",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that bulk refers to one or multiple cases from Primero to a\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create referrals in Primero\n *\n * Use this function to bulk refer to one or multiple cases from Primero to a single user\n * @public\n * @example <caption>Create referrals for multiple cases in Primero</caption>\n * createReferrals({\n *   data: {\n *     ids: [\n *       \"749e9c6e-60db-45ec-8f5a-69da7c223a79\",\n *       \"dcea6052-07d9-4cfa-9abf-9a36987cdd25\",\n *     ],\n *     transitioned_to: \"primero_cp\",\n *     notes: \"This is a bulk referral\",\n *   },\n * });\n * @function\n * @param {object} params - an object with referral data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function createReferrals(params: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create referrals in Primero\n *\n * Use this function to bulk refer to one or multiple cases from Primero to a single user\n * @public\n * @example <caption>Create referrals for multiple cases in Primero</caption>\n * createReferrals({\n *   data: {\n *     ids: [\n *       \"749e9c6e-60db-45ec-8f5a-69da7c223a79\",\n *       \"dcea6052-07d9-4cfa-9abf-9a36987cdd25\",\n *     ],\n *     transitioned_to: \"primero_cp\",\n *     notes: \"This is a bulk referral\",\n *   },\n * });\n * @function\n * @param {object} params - an object with referral data.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function createReferrals(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const { data } = expandReferences(params)(state);\n\n    const requestParams = {\n      method: 'POST',\n      url: `${url}/api/v2/cases/referrals`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n        options: {\n          successCodes: [200, 201, 202, 203, 204],\n        },\n      },\n      json: { data: data },\n    };\n\n    return new Promise((resolve, reject) => {\n      request(requestParams, (err, resp, body) => {\n        const response = scrubResponse(resp);\n        const error = assembleError({ error: err, response, params });\n        if (error) {\n          reject(error);\n        } else {\n          const resp = tryJson(body);\n          console.log(\n            `Post succeeded: ${response.statusCode} ${response.statusMessage}`\n          );\n          const nextState = composeNextState(state, resp.data.body);\n          if (callback) resolve(callback(nextState));\n          resolve(nextState);\n        }\n      });\n    });\n  };\n}\n\n// TODO: We need to deprecate this.\n"
  },
  {
    "name": "updateReferral",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Update a single referral for a specific case in Primero\n * @public\n * @example <caption>Update referral by record id</caption>\n * updateReferral({\n *   caseExternalId: \"record_id\",\n *   id: \"749e9c6e-60db-45ec-8f5a-69da7c223a79\",\n *   caseId: \"dcea6052-07d9-4cfa-9abf-9a36987cdd25\",\n *   data: (state) => state.data,\n * });\n * @function\n * @param {object} params - an object with an caseExternalId value to use, the id and the referral id to update.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function updateReferral(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const { caseExternalId, caseId, id, data } =\n      expandReferences(params)(state);\n\n    let requestParams = {};\n\n    if (caseExternalId === 'record_id') {\n      console.log('Updating referral by record id...');\n      requestParams = {\n        method: 'PATCH',\n        url: `${url}/api/v2/cases/${caseId}/referrals/${id}`,\n        headers: {\n          Authorization: auth.token,\n          'Content-Type': 'application/json',\n        },\n        json: { data: data },\n      };\n      return queryHandler(state, requestParams, callback);\n    } else {\n      console.log('Updating referral by case id...');\n      const qs = {\n        case_id: `${caseId}`,\n      };\n      requestParams = {\n        method: 'GET',\n        url: `${url}/api/v2/cases`,\n        headers: {\n          Authorization: auth.token,\n          'Content-Type': 'application/json',\n        },\n        qs,\n      };\n      return new Promise((resolve, reject) => {\n        request(requestParams, (err, resp, body) => {\n          const response = scrubResponse(resp);\n          const error = assembleError({ error: err, response, params });\n          if (error) {\n            reject(error);\n          } else {\n            const resp = tryJson(body);\n            if (resp.data.length == 0) {\n              console.log('No case found.');\n              resolve(state);\n              return state;\n            } else if (resp.data.length === 1) {\n              console.log('Case found. Fetching referrals.');\n\n              const caseRecordId = resp.data[0].id;\n              requestParams = {\n                method: 'PATCH',\n                url: `${url}/api/v2/cases/${caseRecordId}/referrals/${id}`,\n\n                headers: {\n                  Authorization: auth.token,\n                  'Content-Type': 'application/json',\n                },\n                json: { data: data },\n              };\n              resolve(queryHandler(state, requestParams, callback));\n            } else {\n              reject(\n                'Multiple cases found. Try using another externalId and ensure that it is unique.'\n              );\n            }\n          }\n        });\n      });\n    }\n  };\n}",
    "signature": "/**\n * Update a single referral for a specific case in Primero\n * @public\n * @example <caption>Update referral by record id</caption>\n * updateReferral({\n *   caseExternalId: \"record_id\",\n *   id: \"749e9c6e-60db-45ec-8f5a-69da7c223a79\",\n *   caseId: \"dcea6052-07d9-4cfa-9abf-9a36987cdd25\",\n *   data: (state) => state.data,\n * });\n * @function\n * @param {object} params - an object with an caseExternalId value to use, the id and the referral id to update.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function updateReferral(params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that updates a referral from Primero.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that updates a referral from Primero.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Update a single referral for a specific case in Primero\n * @public\n * @example <caption>Update referral by record id</caption>\n * updateReferral({\n *   caseExternalId: \"record_id\",\n *   id: \"749e9c6e-60db-45ec-8f5a-69da7c223a79\",\n *   caseId: \"dcea6052-07d9-4cfa-9abf-9a36987cdd25\",\n *   data: (state) => state.data,\n * });\n * @function\n * @param {object} params - an object with an caseExternalId value to use, the id and the referral id to update.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function updateReferral(params: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Update a single referral for a specific case in Primero\n * @public\n * @example <caption>Update referral by record id</caption>\n * updateReferral({\n *   caseExternalId: \"record_id\",\n *   id: \"749e9c6e-60db-45ec-8f5a-69da7c223a79\",\n *   caseId: \"dcea6052-07d9-4cfa-9abf-9a36987cdd25\",\n *   data: (state) => state.data,\n * });\n * @function\n * @param {object} params - an object with an caseExternalId value to use, the id and the referral id to update.\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function updateReferral(params, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const { caseExternalId, caseId, id, data } =\n      expandReferences(params)(state);\n\n    let requestParams = {};\n\n    if (caseExternalId === 'record_id') {\n      console.log('Updating referral by record id...');\n      requestParams = {\n        method: 'PATCH',\n        url: `${url}/api/v2/cases/${caseId}/referrals/${id}`,\n        headers: {\n          Authorization: auth.token,\n          'Content-Type': 'application/json',\n        },\n        json: { data: data },\n      };\n      return queryHandler(state, requestParams, callback);\n    } else {\n      console.log('Updating referral by case id...');\n      const qs = {\n        case_id: `${caseId}`,\n      };\n      requestParams = {\n        method: 'GET',\n        url: `${url}/api/v2/cases`,\n        headers: {\n          Authorization: auth.token,\n          'Content-Type': 'application/json',\n        },\n        qs,\n      };\n      return new Promise((resolve, reject) => {\n        request(requestParams, (err, resp, body) => {\n          const response = scrubResponse(resp);\n          const error = assembleError({ error: err, response, params });\n          if (error) {\n            reject(error);\n          } else {\n            const resp = tryJson(body);\n            if (resp.data.length == 0) {\n              console.log('No case found.');\n              resolve(state);\n              return state;\n            } else if (resp.data.length === 1) {\n              console.log('Case found. Fetching referrals.');\n\n              const caseRecordId = resp.data[0].id;\n              requestParams = {\n                method: 'PATCH',\n                url: `${url}/api/v2/cases/${caseRecordId}/referrals/${id}`,\n\n                headers: {\n                  Authorization: auth.token,\n                  'Content-Type': 'application/json',\n                },\n                json: { data: data },\n              };\n              resolve(queryHandler(state, requestParams, callback));\n            } else {\n              reject(\n                'Multiple cases found. Try using another externalId and ensure that it is unique.'\n              );\n            }\n          }\n        });\n      });\n    }\n  };\n}\n"
  },
  {
    "name": "getForms",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get forms from Primero\n *\n * Use this function to get forms from Primero that are accessible to this user based on a set of query parameters.\n * The user can filter the form list by record type and module.\n * @public\n * @example <caption>Get the list of all forms</caption>\n * getForms();\n *\n * @example <caption>Get the list of all forms for a specific module</caption>\n * getForms({\n *   module_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getForms(query, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const expandedQuery = expandReferences(query)(state);\n\n    const params = {\n      method: 'GET',\n      url: `${url}/api/v2/forms`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs: expandedQuery,\n    };\n\n    return new Promise((resolve, reject) => {\n      request(params, async",
    "signature": "/**\n * Get forms from Primero\n *\n * Use this function to get forms from Primero that are accessible to this user based on a set of query parameters.\n * The user can filter the form list by record type and module.\n * @public\n * @example <caption>Get the list of all forms</caption>\n * getForms();\n *\n * @example <caption>Get the list of all forms for a specific module</caption>\n * getForms({\n *   module_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getForms(query: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets forms from Primero.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets forms from Primero.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get forms from Primero\n *\n * Use this function to get forms from Primero that are accessible to this user based on a set of query parameters.\n * The user can filter the form list by record type and module.\n * @public\n * @example <caption>Get the list of all forms</caption>\n * getForms();\n *\n * @example <caption>Get the list of all forms for a specific module</caption>\n * getForms({\n *   module_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getForms(query: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get forms from Primero\n *\n * Use this function to get forms from Primero that are accessible to this user based on a set of query parameters.\n * The user can filter the form list by record type and module.\n * @public\n * @example <caption>Get the list of all forms</caption>\n * getForms();\n *\n * @example <caption>Get the list of all forms for a specific module</caption>\n * getForms({\n *   module_id: \"6aeaa66a-5a92-4ff5-bf7a-e59cde07eaaz\",\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getForms(query, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const expandedQuery = expandReferences(query)(state);\n\n    const params = {\n      method: 'GET',\n      url: `${url}/api/v2/forms`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs: expandedQuery,\n    };\n\n    return new Promise((resolve, reject) => {\n      request(params, async\n"
  },
  {
    "name": "getLookups",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get lookups from Primero\n *\n * Use this function to get a paginated list of all lookups that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1)\n * @public\n * @example <caption>Get lookups from Primero with query parameters</caption>\n * getLookups({\n *   per: 10000,\n *   page: 5\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLookups(query, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const expandedQuery = expandReferences(query)(state);\n\n    const params = {\n      method: 'GET',\n      url: `${url}/api/v2/lookups`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs: expandedQuery,\n    };\n\n    return new Promise((resolve, reject) => {\n      request(params, async",
    "signature": "/**\n * Get lookups from Primero\n *\n * Use this function to get a paginated list of all lookups that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1)\n * @public\n * @example <caption>Get lookups from Primero with query parameters</caption>\n * getLookups({\n *   per: 10000,\n *   page: 5\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLookups(query: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets lookups from Primero.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets lookups from Primero.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get lookups from Primero\n *\n * Use this function to get a paginated list of all lookups that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1)\n * @public\n * @example <caption>Get lookups from Primero with query parameters</caption>\n * getLookups({\n *   per: 10000,\n *   page: 5\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLookups(query: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get lookups from Primero\n *\n * Use this function to get a paginated list of all lookups that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1)\n * @public\n * @example <caption>Get lookups from Primero with query parameters</caption>\n * getLookups({\n *   per: 10000,\n *   page: 5\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLookups(query, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const expandedQuery = expandReferences(query)(state);\n\n    const params = {\n      method: 'GET',\n      url: `${url}/api/v2/lookups`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs: expandedQuery,\n    };\n\n    return new Promise((resolve, reject) => {\n      request(params, async\n"
  },
  {
    "name": "getLocations",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get locations from Primero\n *\n * Use this function to get a paginated list of all locations that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1).\n * Another parameter is `hierarchy: true` (Defaults to false)\n * @public\n * @example <caption>Get loocations from Primero with query parameters</caption>\n * getLocations({\n *   page: 1,\n *   per: 20\n * })\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLocations(query, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const expandedQuery = expandReferences(query)(state);\n\n    const params = {\n      method: 'GET',\n      url: `${url}/api/v2/locations`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs: expandedQuery,\n    };\n\n    return new Promise((resolve, reject) => {\n      request(params, async",
    "signature": "/**\n * Get locations from Primero\n *\n * Use this function to get a paginated list of all locations that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1).\n * Another parameter is `hierarchy: true` (Defaults to false)\n * @public\n * @example <caption>Get loocations from Primero with query parameters</caption>\n * getLocations({\n *   page: 1,\n *   per: 20\n * })\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLocations(query: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets locations from Primero with query parameters.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets locations from Primero with query parameters.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get locations from Primero\n *\n * Use this function to get a paginated list of all locations that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1).\n * Another parameter is `hierarchy: true` (Defaults to false)\n * @public\n * @example <caption>Get loocations from Primero with query parameters</caption>\n * getLocations({\n *   page: 1,\n *   per: 20\n * })\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLocations(query: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get locations from Primero\n *\n * Use this function to get a paginated list of all locations that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1).\n * Another parameter is `hierarchy: true` (Defaults to false)\n * @public\n * @example <caption>Get loocations from Primero with query parameters</caption>\n * getLocations({\n *   page: 1,\n *   per: 20\n * })\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLocations(query, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const expandedQuery = expandReferences(query)(state);\n\n    const params = {\n      method: 'GET',\n      url: `${url}/api/v2/locations`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs: expandedQuery,\n    };\n\n    return new Promise((resolve, reject) => {\n      request(params, async\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for openhim.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for openhim.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for openhim.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for openhim.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "encounter",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create an encounter\n * @example\n * execute(\n *   encounter(data)\n * )(state)\n * @function\n * @param {object} encounterData - Payload data for the encounter\n * @returns {Operation}\n */\nexport function encounter(encounterData) {\n  return state => {\n    const body = expandReferences(encounterData)(state);\n\n    const { username, password, apiUrl } = state.configuration;\n\n    const url = resolveUrl(apiUrl + '/', 'chw/encounter');\n\n    console.log('Posting encounter:');\n    console.log(JSON.stringify(body, null, 2));\n\n    return post({ username, password, body, url }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}",
    "signature": "/**\n * Create an encounter\n * @example\n * execute(\n *   encounter(data)\n * )(state)\n * @function\n * @param {object} encounterData - Payload data for the encounter\n * @returns {Operation}\n */\nexport function encounter(encounterData: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes an encounter on the payload data.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes an encounter on the payload data.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create an encounter\n * @example\n * execute(\n *   encounter(data)\n * )(state)\n * @function\n * @param {object} encounterData - Payload data for the encounter\n * @returns {Operation}\n */\nexport function encounter(encounterData: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create an encounter\n * @example\n * execute(\n *   encounter(data)\n * )(state)\n * @function\n * @param {object} encounterData - Payload data for the encounter\n * @returns {Operation}\n */\nexport function encounter(encounterData) {\n  return state => {\n    const body = expandReferences(encounterData)(state);\n\n    const { username, password, apiUrl } = state.configuration;\n\n    const url = resolveUrl(apiUrl + '/', 'chw/encounter');\n\n    console.log('Posting encounter:');\n    console.log(JSON.stringify(body, null, 2));\n\n    return post({ username, password, body, url }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   insertDocuments(params),\n *   findDocuments(params)\n * )(state)\n * @function\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      connect,\n      ...operations,\n      disconnect\n    )({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   insertDocuments(params),\n *   findDocuments(params)\n * )(state)\n * @function\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   insertDocuments(params),\n *   findDocuments(params)\n * )(state)\n * @function\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   insertDocuments(params),\n *   findDocuments(params)\n * )(state)\n * @function\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      connect,\n      ...operations,\n      disconnect\n    )({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "insertDocuments",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Connects to a mongoDb instance\n * @example\n *  connect(state)\n * @function\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nfunction connect(state) {\n  const { clusterHostname, username, password } = state.configuration;\n\n  const uri = `mongodb+srv://${encodeURIComponent(\n    username\n  )}:${encodeURIComponent(\n    password\n  )}@${clusterHostname}/test?retryWrites=true&w=majority`;\n\n  const client = new MongoClient(uri, { useNewUrlParser: true });\n\n  return new Promise((resolve, reject) => {\n    client.connect(err => {\n      if (err) {\n        reject(err);\n      } else {\n        console.log('Connected successfully to server');\n        resolve({ ...state, client });\n      }\n    });\n  });\n}\n\n/**\n * Removes connection from the state.\n * @example\n *  disconnect(state)\n * @function\n * @param {State} state\n * @returns {State}\n */\nfunction disconnect(state) {\n  state.client.close();\n  delete state.client;\n  return state;\n}\n\n/**\n * Inserts documents into a mongoDb collection\n * @example\n *  insertDocuments({\n *    database: 'str',\n *    collection: 'kids',\n *    documents: [1,2,3]\n *   });\n * @function\n * @param {object} params - Configuration for mongo\n * @returns {State}\n */\nexport function insertDocuments(params) {\n  return state => {\n    const { client } = state;\n\n    try {\n      const { database, collection, documents, callback } =\n        expandReferences(params)(state);\n\n      const db = client.db(database);\n      const mCollection = db.collection(collection);\n\n      return new Promise((resolve, reject) => {\n        mCollection.insertMany(documents, (err, result) => {\n          if (err) {\n            reject(err);\n            state.client.close();\n          } else {\n            console.log(\n              `Inserted ${documents.length} documents into the collection`\n            );\n            console.log(JSON.stringify(result, null, 2));\n            const nextState = composeNextState(state, result);\n            if (callback) resolve(callback(nextState));\n            resolve(nextState);\n          }\n        });\n      });\n    } catch (error) {\n      state.client.close();\n      throw error;\n    }\n  };\n}",
    "signature": "/**\n * Inserts documents into a mongoDb collection\n * @example\n *  insertDocuments({\n *    database: 'str',\n *    collection: 'kids',\n *    documents: [1,2,3]\n *   });\n * @function\n * @param {object} params - Configuration for mongo\n * @returns {State}\n */\nexport function insertDocuments(params: object): State;",
    "test": "",
    "instruction": "Create an OpenFn function that inserts documents to/on/from a mongoDb collection",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that inserts documents to/on/from a mongoDb collection\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Inserts documents into a mongoDb collection\n * @example\n *  insertDocuments({\n *    database: 'str',\n *    collection: 'kids',\n *    documents: [1,2,3]\n *   });\n * @function\n * @param {object} params - Configuration for mongo\n * @returns {State}\n */\nexport function insertDocuments(params: object): State;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Connects to a mongoDb instance\n * @example\n *  connect(state)\n * @function\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nfunction connect(state) {\n  const { clusterHostname, username, password } = state.configuration;\n\n  const uri = `mongodb+srv://${encodeURIComponent(\n    username\n  )}:${encodeURIComponent(\n    password\n  )}@${clusterHostname}/test?retryWrites=true&w=majority`;\n\n  const client = new MongoClient(uri, { useNewUrlParser: true });\n\n  return new Promise((resolve, reject) => {\n    client.connect(err => {\n      if (err) {\n        reject(err);\n      } else {\n        console.log('Connected successfully to server');\n        resolve({ ...state, client });\n      }\n    });\n  });\n}\n\n/**\n * Removes connection from the state.\n * @example\n *  disconnect(state)\n * @function\n * @param {State} state\n * @returns {State}\n */\nfunction disconnect(state) {\n  state.client.close();\n  delete state.client;\n  return state;\n}\n\n/**\n * Inserts documents into a mongoDb collection\n * @example\n *  insertDocuments({\n *    database: 'str',\n *    collection: 'kids',\n *    documents: [1,2,3]\n *   });\n * @function\n * @param {object} params - Configuration for mongo\n * @returns {State}\n */\nexport function insertDocuments(params) {\n  return state => {\n    const { client } = state;\n\n    try {\n      const { database, collection, documents, callback } =\n        expandReferences(params)(state);\n\n      const db = client.db(database);\n      const mCollection = db.collection(collection);\n\n      return new Promise((resolve, reject) => {\n        mCollection.insertMany(documents, (err, result) => {\n          if (err) {\n            reject(err);\n            state.client.close();\n          } else {\n            console.log(\n              `Inserted ${documents.length} documents into the collection`\n            );\n            console.log(JSON.stringify(result, null, 2));\n            const nextState = composeNextState(state, result);\n            if (callback) resolve(callback(nextState));\n            resolve(nextState);\n          }\n        });\n      });\n    } catch (error) {\n      state.client.close();\n      throw error;\n    }\n  };\n}\n"
  },
  {
    "name": "findDocuments",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Find documents in a mongoDb collection\n * @example\n *  findDocuments({\n *    database: 'str',\n *    collection: 'cases',\n *    query: {a:3}\n *   });\n * @function\n * @param {object} params - Configuration for mongo\n * @returns {State}\n */\nexport function findDocuments(params) {\n  return state => {\n    const { client } = state;\n\n    try {\n      const { database, collection, query, callback } =\n        expandReferences(params)(state);\n\n      const db = client.db(database);\n      const mCollection = db.collection(collection);\n\n      return new Promise((resolve, reject) => {\n        mCollection.find(query).toArray((err, docs) => {\n          if (err) {\n            reject(err);\n            state.client.close();\n          } else {\n            console.log(`Found ${docs.length} documents in the collection`);\n            console.log(JSON.stringify(result, null, 2));\n            const nextState = composeNextState(state, docs);\n            if (callback) resolve(callback(nextState));\n            resolve(nextState);\n          }\n        });\n      });\n    } catch (error) {\n      state.client.close();\n      throw error;\n    }\n  };\n}",
    "signature": "/**\n * Find documents in a mongoDb collection\n * @example\n *  findDocuments({\n *    database: 'str',\n *    collection: 'cases',\n *    query: {a:3}\n *   });\n * @function\n * @param {object} params - Configuration for mongo\n * @returns {State}\n */\nexport function findDocuments(params: object): State;",
    "test": "",
    "instruction": "Create an OpenFn function that finds documents in a mongoDb collection.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that finds documents in a mongoDb collection.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Find documents in a mongoDb collection\n * @example\n *  findDocuments({\n *    database: 'str',\n *    collection: 'cases',\n *    query: {a:3}\n *   });\n * @function\n * @param {object} params - Configuration for mongo\n * @returns {State}\n */\nexport function findDocuments(params: object): State;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Find documents in a mongoDb collection\n * @example\n *  findDocuments({\n *    database: 'str',\n *    collection: 'cases',\n *    query: {a:3}\n *   });\n * @function\n * @param {object} params - Configuration for mongo\n * @returns {State}\n */\nexport function findDocuments(params) {\n  return state => {\n    const { client } = state;\n\n    try {\n      const { database, collection, query, callback } =\n        expandReferences(params)(state);\n\n      const db = client.db(database);\n      const mCollection = db.collection(collection);\n\n      return new Promise((resolve, reject) => {\n        mCollection.find(query).toArray((err, docs) => {\n          if (err) {\n            reject(err);\n            state.client.close();\n          } else {\n            console.log(`Found ${docs.length} documents in the collection`);\n            console.log(JSON.stringify(result, null, 2));\n            const nextState = composeNextState(state, docs);\n            if (callback) resolve(callback(nextState));\n            resolve(nextState);\n          }\n        });\n      });\n    } catch (error) {\n      state.client.close();\n      throw error;\n    }\n  };\n}\n"
  },
  {
    "name": "updateDocument",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Updates document (optionally upserting) into a mongoDb collection\n * @example\n *  updateDocuments({\n *    database: 'str',\n *    collection: 'animals',\n *    filter: { type: 'fuzzy' },\n *    changes: { kind: 'soft' },\n *    options: { upsert: true }\n *   });\n * @function\n * @param {object} params - Configuration for mongo\n * @returns {State}\n */\nexport function updateDocument(params) {\n  return state => {\n    const { client } = state;\n    try {\n      const { database, collection, filter, changes, options, callback } =\n        expandReferences(params)(state);\n\n      const db = client.db(database);\n      const mCollection = db.collection(collection);\n\n      return new Promise((resolve, reject) => {\n        mCollection.updateMany(\n          filter,\n          { $set: changes },\n          options,\n          (err, result) => {\n            if (err) {\n              reject(err);\n              state.client.close();\n            } else {\n              console.log(\n                `Updated a document matching ${JSON.stringify(\n                  filter\n                )} in the collection.`\n              );\n              console.log(JSON.stringify(result, null, 2));\n              const nextState = composeNextState(state, result);\n              if (callback) resolve(callback(nextState));\n              resolve(nextState);\n            }\n          }\n        );\n      });\n    } catch (error) {\n      state.client.close();\n      throw error;\n    }\n  };\n}",
    "signature": "/**\n * Updates document (optionally upserting) into a mongoDb collection\n * @example\n *  updateDocuments({\n *    database: 'str',\n *    collection: 'animals',\n *    filter: { type: 'fuzzy' },\n *    changes: { kind: 'soft' },\n *    options: { upsert: true }\n *   });\n * @function\n * @param {object} params - Configuration for mongo\n * @returns {State}\n */\nexport function updateDocument(params: object): State;",
    "test": "",
    "instruction": "Create an OpenFn function that updates documents to/on/from a mongoDb collection",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that updates documents to/on/from a mongoDb collection\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Updates document (optionally upserting) into a mongoDb collection\n * @example\n *  updateDocuments({\n *    database: 'str',\n *    collection: 'animals',\n *    filter: { type: 'fuzzy' },\n *    changes: { kind: 'soft' },\n *    options: { upsert: true }\n *   });\n * @function\n * @param {object} params - Configuration for mongo\n * @returns {State}\n */\nexport function updateDocument(params: object): State;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Updates document (optionally upserting) into a mongoDb collection\n * @example\n *  updateDocuments({\n *    database: 'str',\n *    collection: 'animals',\n *    filter: { type: 'fuzzy' },\n *    changes: { kind: 'soft' },\n *    options: { upsert: true }\n *   });\n * @function\n * @param {object} params - Configuration for mongo\n * @returns {State}\n */\nexport function updateDocument(params) {\n  return state => {\n    const { client } = state;\n    try {\n      const { database, collection, filter, changes, options, callback } =\n        expandReferences(params)(state);\n\n      const db = client.db(database);\n      const mCollection = db.collection(collection);\n\n      return new Promise((resolve, reject) => {\n        mCollection.updateMany(\n          filter,\n          { $set: changes },\n          options,\n          (err, result) => {\n            if (err) {\n              reject(err);\n              state.client.close();\n            } else {\n              console.log(\n                `Updated a document matching ${JSON.stringify(\n                  filter\n                )} in the collection.`\n              );\n              console.log(JSON.stringify(result, null, 2));\n              const nextState = composeNextState(state, result);\n              if (callback) resolve(callback(nextState));\n              resolve(nextState);\n            }\n          }\n        );\n      });\n    } catch (error) {\n      state.client.close();\n      throw error;\n    }\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n    drives: {},\n  };\n\n  const cleanup = finalState => {\n    if (finalState?.buffer) {\n      delete finalState.buffer;\n    }\n    if (finalState?.drives) {\n      delete finalState.drives;\n    }\n\n    return finalState;\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    })\n      .then(cleanup)\n      .catch(error => {\n        cleanup(state);\n        throw error;\n      });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "describe('execute', () => {\n  it('executes each operation in sequence', done => {\n    const state = {};\n    const operations = [\n      state => {\n        return { counter: 1 };\n      },\n      state => {\n        return { counter: 2 };\n      },\n      state => {\n        return { counter: 3 };\n      },\n    ];\n\n    execute(...operations)(state)\n      .then(finalState => {\n        expect(finalState).to.eql({ counter: 3 });",
    "instruction": "Create an OpenFn function that executes a sequence of operations.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n    drives: {},\n  };\n\n  const cleanup = finalState => {\n    if (finalState?.buffer) {\n      delete finalState.buffer;\n    }\n    if (finalState?.drives) {\n      delete finalState.drives;\n    }\n\n    return finalState;\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    })\n      .then(cleanup)\n      .catch(error => {\n        cleanup(state);\n        throw error;\n      });\n  };\n}\n"
  },
  {
    "name": "create",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Create some resource in msgraph\n * @public\n * @example\n * create(\"applications\", {\"displayName\": \"My App\"})\n * @function\n * @param {string} resource - The type of entity that will be created\n * @param {object} data - The data to create the new resource\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function create(resource, data, callback) {\n  return state => {\n    const [resolvedResource, resolvedData] = expandReferences(\n      state,\n      resource,\n      data\n    );\n\n    const { accessToken, apiVersion } = state.configuration;\n\n    const url = setUrl({ apiVersion, resolvedResource });\n\n    const options = {\n      accessToken,\n      body: JSON.stringify(resolvedData),\n      method: 'POST',\n    };\n\n    return request(url, options).then(response =>\n      handleResponse(response, state, callback)\n    );\n  };\n}",
    "signature": "/**\n * Create some resource in msgraph\n * @public\n * @example\n * create(\"applications\", {\"displayName\": \"My App\"})\n * @function\n * @param {string} resource - The type of entity that will be created\n * @param {object} data - The data to create the new resource\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function create(resource: string, data: object, callback: Function): Operation;",
    "instruction": "Create an OpenFn function that creates a resource in msgraph.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates a resource in msgraph.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create some resource in msgraph\n * @public\n * @example\n * create(\"applications\", {\"displayName\": \"My App\"})\n * @function\n * @param {string} resource - The type of entity that will be created\n * @param {object} data - The data to create the new resource\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function create(resource: string, data: object, callback: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Create some resource in msgraph\n * @public\n * @example\n * create(\"applications\", {\"displayName\": \"My App\"})\n * @function\n * @param {string} resource - The type of entity that will be created\n * @param {object} data - The data to create the new resource\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function create(resource, data, callback) {\n  return state => {\n    const [resolvedResource, resolvedData] = expandReferences(\n      state,\n      resource,\n      data\n    );\n\n    const { accessToken, apiVersion } = state.configuration;\n\n    const url = setUrl({ apiVersion, resolvedResource });\n\n    const options = {\n      accessToken,\n      body: JSON.stringify(resolvedData),\n      method: 'POST',\n    };\n\n    return request(url, options).then(response =>\n      handleResponse(response, state, callback)\n    );\n  };\n}\n"
  },
  {
    "name": "get",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Make a GET request to msgraph resource\n * @public\n * @example\n *  get('sites/root/lists')\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function get(path, query, callback = false) {\n  return state => {\n    const { accessToken, apiVersion } = state.configuration;\n    const [resolvedPath, resolvedQuery] = expandReferences(state, path, query);\n\n    const url = setUrl(resolvedPath, apiVersion);\n\n    return request(url, { query: resolvedQuery, accessToken }).then(response =>\n      handleResponse(response, state, callback)\n    );\n  };\n}",
    "signature": "/**\n * Make a GET request to msgraph resource\n * @public\n * @example\n *  get('sites/root/lists')\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function get(path: string, query: object, callback?: Function): Operation;",
    "instruction": "Create an OpenFn function that makes a GET request to a msgraph resource.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a GET request to a msgraph resource.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a GET request to msgraph resource\n * @public\n * @example\n *  get('sites/root/lists')\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function get(path: string, query: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Make a GET request to msgraph resource\n * @public\n * @example\n *  get('sites/root/lists')\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function get(path, query, callback = false) {\n  return state => {\n    const { accessToken, apiVersion } = state.configuration;\n    const [resolvedPath, resolvedQuery] = expandReferences(state, path, query);\n\n    const url = setUrl(resolvedPath, apiVersion);\n\n    return request(url, { query: resolvedQuery, accessToken }).then(response =>\n      handleResponse(response, state, callback)\n    );\n  };\n}\n"
  },
  {
    "name": "getDrive",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Get a Drive or SharePoint document library. The drive metadata will be written\n * to state.drives, where it can be used by other adaptor functions.\n * Pass { id } to get a drive by id or { id, owner } to get default drive for\n * some parent resource, like a group\n * @public\n * @example <caption>Get a drive by ID</caption>\n * getDrive({ id: \"YXzpkoLwR06bxC8tNdg71m\" })\n * @example <caption>Get the default drive for a site</caption>\n * getDrive({ id: \"openfn.sharepoint.com\", owner: \"sites\" })\n * @param specifier {Object} - A definition of the drive to retrieve\n *    - id {string} - The ID of the resource or owner.\n *    - owner {string} - The type of drive owner (e.g. sites, groups).\n * @param {string} name - The local name of the drive used to write to state.drives, ie, state.drives[name]\n * @param {function} [callback = s => s] (Optional) Callback function\n * @return {Operation}\n */\nexport function getDrive(specifier, name = 'default', callback = s => s) {\n  return state => {\n    const { accessToken, apiVersion } = state.configuration;\n    const [resolvedSpecifier, resolvedName] = expandReferences(\n      state,\n      specifier,\n      name\n    );\n\n    const { id, owner = 'drive' } = resolvedSpecifier;\n\n    let resource;\n    if (owner === 'drive') {\n      resource = `drives/${id}`;\n    } else {\n      resource = `${owner}/${id}/drive`;\n    }\n\n    const url = setUrl(resource, apiVersion);\n\n    return request(url, { accessToken }).then(response => {\n      state.drives[resolvedName] = response;\n      return callback(state);\n    });\n  };\n}",
    "signature": "/**\n * Get a Drive or SharePoint document library. The drive metadata will be written\n * to state.drives, where it can be used by other adaptor functions.\n * Pass { id } to get a drive by id or { id, owner } to get default drive for\n * some parent resource, like a group\n * @public\n * @example <caption>Get a drive by ID</caption>\n * getDrive({ id: \"YXzpkoLwR06bxC8tNdg71m\" })\n * @example <caption>Get the default drive for a site</caption>\n * getDrive({ id: \"openfn.sharepoint.com\", owner: \"sites\" })\n * @param specifier {Object} - A definition of the drive to retrieve\n *    - id {string} - The ID of the resource or owner.\n *    - owner {string} - The type of drive owner (e.g. sites, groups).\n * @param {string} name - The local name of the drive used to write to state.drives, ie, state.drives[name]\n * @param {function} [callback = s => s] (Optional) Callback function\n * @return {Operation}\n */\nexport function getDrive(specifier: any, name?: string, callback?: Function): Operation;",
    "test": "describe('getDrive', () => {\n  it('should get a drive by id and set it to state', async () => {\n    const state = {\n      configuration: {\n        accessToken: fixtures.accessToken,\n      },\n    };\n\n    const finalState = await execute(\n      getDrive({ id: 'b!YXzpkoLwR06bxC8tNdg71m_' }, undefined, state => {\n        // write the drives object back to state before it gets cleaned up\n        state.result = state.drives;\n        return state;\n      })",
    "instruction": "Create an OpenFn function that gets a Drive or SharePoint document library from a specifier",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets a Drive or SharePoint document library from a specifier\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get a Drive or SharePoint document library. The drive metadata will be written\n * to state.drives, where it can be used by other adaptor functions.\n * Pass { id } to get a drive by id or { id, owner } to get default drive for\n * some parent resource, like a group\n * @public\n * @example <caption>Get a drive by ID</caption>\n * getDrive({ id: \"YXzpkoLwR06bxC8tNdg71m\" })\n * @example <caption>Get the default drive for a site</caption>\n * getDrive({ id: \"openfn.sharepoint.com\", owner: \"sites\" })\n * @param specifier {Object} - A definition of the drive to retrieve\n *    - id {string} - The ID of the resource or owner.\n *    - owner {string} - The type of drive owner (e.g. sites, groups).\n * @param {string} name - The local name of the drive used to write to state.drives, ie, state.drives[name]\n * @param {function} [callback = s => s] (Optional) Callback function\n * @return {Operation}\n */\nexport function getDrive(specifier: any, name?: string, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Get a Drive or SharePoint document library. The drive metadata will be written\n * to state.drives, where it can be used by other adaptor functions.\n * Pass { id } to get a drive by id or { id, owner } to get default drive for\n * some parent resource, like a group\n * @public\n * @example <caption>Get a drive by ID</caption>\n * getDrive({ id: \"YXzpkoLwR06bxC8tNdg71m\" })\n * @example <caption>Get the default drive for a site</caption>\n * getDrive({ id: \"openfn.sharepoint.com\", owner: \"sites\" })\n * @param specifier {Object} - A definition of the drive to retrieve\n *    - id {string} - The ID of the resource or owner.\n *    - owner {string} - The type of drive owner (e.g. sites, groups).\n * @param {string} name - The local name of the drive used to write to state.drives, ie, state.drives[name]\n * @param {function} [callback = s => s] (Optional) Callback function\n * @return {Operation}\n */\nexport function getDrive(specifier, name = 'default', callback = s => s) {\n  return state => {\n    const { accessToken, apiVersion } = state.configuration;\n    const [resolvedSpecifier, resolvedName] = expandReferences(\n      state,\n      specifier,\n      name\n    );\n\n    const { id, owner = 'drive' } = resolvedSpecifier;\n\n    let resource;\n    if (owner === 'drive') {\n      resource = `drives/${id}`;\n    } else {\n      resource = `${owner}/${id}/drive`;\n    }\n\n    const url = setUrl(resource, apiVersion);\n\n    return request(url, { accessToken }).then(response => {\n      state.drives[resolvedName] = response;\n      return callback(state);\n    });\n  };\n}\n"
  },
  {
    "name": "getFolder",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Get the contents or metadata of a folder.\n * @public\n * @example <caption>Get a folder by ID</caption>\n * getFolder('01LUM6XOCKDTZKQC7AVZF2VMHE2I3O6OY3')\n * @example <caption>Get a folder for a named drive by id</caption>\n * getFolder(\"01LUM6XOCKDTZKQC7AVZF2VMHE2I3O6OY3\",{ driveName: \"mydrive\"})\n * @param {string} pathOrId - A path to a folder or folder id\n * @param {object} options - (Optional) Query parameters\n * @param {function} [callback = s => s] (Optional) Callback function\n * @return {Operation}\n */\nexport function getFolder(pathOrId, options, callback = s => s) {\n  return async state => {\n    const defaultOptions = {\n      driveName: 'default', // Named drive in state.drives\n      metadata: false, // If false return folder files if true return folder metadata\n      // $filter: '', // Eg: \"file/mimeType eq \\'application/vnd.ms-excel\\'\"\n    };\n    const { accessToken, apiVersion } = state.configuration;\n    const [resolvedPathOrId, resolvedOptions] = expandReferences(\n      state,\n      pathOrId,\n      options\n    );\n\n    const { driveName, metadata } = { ...defaultOptions, ...resolvedOptions };\n\n    assertDrive(state, driveName);\n\n    const { id: driveId } = state.drives[driveName];\n\n    let resource;\n\n    if (resolvedPathOrId.startsWith('/')) {\n      resource = `drives/${driveId}/root:/${encodeURIComponent(\n        resolvedPathOrId\n      )}`;\n    } else {\n      resource = `drives/${driveId}/items/${resolvedPathOrId}`;\n    }\n\n    if (!metadata) {\n      resource += resolvedPathOrId.startsWith('/') ? ':/children' : '/children';\n    }\n\n    const url = setUrl(resource, apiVersion);\n\n    return request(url, { accessToken }).then(response =>\n      handleResponse(response, state, callback)\n    );\n  };\n}",
    "signature": "/**\n * Get the contents or metadata of a folder.\n * @public\n * @example <caption>Get a folder by ID</caption>\n * getFolder('01LUM6XOCKDTZKQC7AVZF2VMHE2I3O6OY3')\n * @example <caption>Get a folder for a named drive by id</caption>\n * getFolder(\"01LUM6XOCKDTZKQC7AVZF2VMHE2I3O6OY3\",{ driveName: \"mydrive\"})\n * @param {string} pathOrId - A path to a folder or folder id\n * @param {object} options - (Optional) Query parameters\n * @param {function} [callback = s => s] (Optional) Callback function\n * @return {Operation}\n */\nexport function getFolder(pathOrId: string, options: object, callback?: Function): Operation;",
    "test": "describe('getFolder', () => {\n  it('should get a folder metadata by id', async () => {\n    const state = {\n      configuration: {\n        accessToken: fixtures.accessToken,\n      },\n      drives: {\n        default: {\n          id: 'b!YXzpkoLwR06bxC8tNdg71m_',\n        },\n      },\n    };\n\n    const finalState = await execute(\n      getFolder('01LUM6XOCKDTZKQC7AVZF2VMHE2I3O6OY3', { metadata: true })",
    "instruction": "Create an OpenFn function that gets the contents or metadata of a folder.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets the contents or metadata of a folder.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get the contents or metadata of a folder.\n * @public\n * @example <caption>Get a folder by ID</caption>\n * getFolder('01LUM6XOCKDTZKQC7AVZF2VMHE2I3O6OY3')\n * @example <caption>Get a folder for a named drive by id</caption>\n * getFolder(\"01LUM6XOCKDTZKQC7AVZF2VMHE2I3O6OY3\",{ driveName: \"mydrive\"})\n * @param {string} pathOrId - A path to a folder or folder id\n * @param {object} options - (Optional) Query parameters\n * @param {function} [callback = s => s] (Optional) Callback function\n * @return {Operation}\n */\nexport function getFolder(pathOrId: string, options: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Get the contents or metadata of a folder.\n * @public\n * @example <caption>Get a folder by ID</caption>\n * getFolder('01LUM6XOCKDTZKQC7AVZF2VMHE2I3O6OY3')\n * @example <caption>Get a folder for a named drive by id</caption>\n * getFolder(\"01LUM6XOCKDTZKQC7AVZF2VMHE2I3O6OY3\",{ driveName: \"mydrive\"})\n * @param {string} pathOrId - A path to a folder or folder id\n * @param {object} options - (Optional) Query parameters\n * @param {function} [callback = s => s] (Optional) Callback function\n * @return {Operation}\n */\nexport function getFolder(pathOrId, options, callback = s => s) {\n  return async state => {\n    const defaultOptions = {\n      driveName: 'default', // Named drive in state.drives\n      metadata: false, // If false return folder files if true return folder metadata\n      // $filter: '', // Eg: \"file/mimeType eq \\'application/vnd.ms-excel\\'\"\n    };\n    const { accessToken, apiVersion } = state.configuration;\n    const [resolvedPathOrId, resolvedOptions] = expandReferences(\n      state,\n      pathOrId,\n      options\n    );\n\n    const { driveName, metadata } = { ...defaultOptions, ...resolvedOptions };\n\n    assertDrive(state, driveName);\n\n    const { id: driveId } = state.drives[driveName];\n\n    let resource;\n\n    if (resolvedPathOrId.startsWith('/')) {\n      resource = `drives/${driveId}/root:/${encodeURIComponent(\n        resolvedPathOrId\n      )}`;\n    } else {\n      resource = `drives/${driveId}/items/${resolvedPathOrId}`;\n    }\n\n    if (!metadata) {\n      resource += resolvedPathOrId.startsWith('/') ? ':/children' : '/children';\n    }\n\n    const url = setUrl(resource, apiVersion);\n\n    return request(url, { accessToken }).then(response =>\n      handleResponse(response, state, callback)\n    );\n  };\n}\n"
  },
  {
    "name": "getFile",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Get file metadata or file content.\n * @public\n * @example <caption>Get a file by ID</caption>\n * getFile('01LUM6XOGRONYNTZ26DBBJPTN5IFTQPBIW')\n * @example <caption>Get a file for a named drive by id</caption>\n * getFile(\"01LUM6XOGRONYNTZ26DBBJPTN5IFTQPBIW\",{ driveName: \"mydrive\"})\n * @param {string} pathOrId - A path to a file or file id\n * @param {object} options - (Optional) Query parameters\n * @param {function} [callback = s => s] (Optional) Callback function\n * @return {Operation}\n */\nexport function getFile(pathOrId, options, callback = s => s) {\n  const defaultOptions = {\n    driveName: 'default', // named drive in state.drives\n    metadata: false, // Returns file msgraph metadata\n    // $filter: '', // Eg: \"file/mimeType eq \\'application/vnd.ms-excel\\'\"\n    // select: '', // Eg: id,@microsoft.graph.downloadUrl\n  };\n  return async state => {\n    const { accessToken, apiVersion } = state.configuration;\n    const [resolvedPathOrId, resolvedOptions] = expandReferences(\n      state,\n      pathOrId,\n      options\n    );\n\n    const { driveName, metadata } = {\n      ...defaultOptions,\n      ...resolvedOptions,\n    };\n\n    assertDrive(state, driveName);\n\n    const { id: driveId } = state.drives[driveName];\n\n    let resource;\n\n    if (resolvedPathOrId.startsWith('/')) {\n      resource = `drives/${driveId}/root:/${encodeURIComponent(\n        resolvedPathOrId\n      )}`;\n    } else {\n      resource = `drives/${driveId}/items/${resolvedPathOrId}`;\n    }\n\n    if (!metadata) {\n      resource += resolvedPathOrId.startsWith('/') ? ':/content' : '/content';\n    }\n\n    const url = setUrl(resource, apiVersion);\n\n    const response = await request(url, {\n      accessToken,\n      parseAs: metadata ? 'json' : 'text',\n    });\n\n    return handleResponse(response, state, callback);\n  };\n}\n\nconst defaultResource = {\n  contentType: 'application/octet-stream',\n  driveId: '',\n  folderId: '',\n  fileName: 'sheet.xls',\n  onConflict: 'replace',\n};",
    "signature": "/**\n * Get file metadata or file content.\n * @public\n * @example <caption>Get a file by ID</caption>\n * getFile('01LUM6XOGRONYNTZ26DBBJPTN5IFTQPBIW')\n * @example <caption>Get a file for a named drive by id</caption>\n * getFile(\"01LUM6XOGRONYNTZ26DBBJPTN5IFTQPBIW\",{ driveName: \"mydrive\"})\n * @param {string} pathOrId - A path to a file or file id\n * @param {object} options - (Optional) Query parameters\n * @param {function} [callback = s => s] (Optional) Callback function\n * @return {Operation}\n */\nexport function getFile(pathOrId: string, options: object, callback?: Function): Operation;",
    "test": "describe('getFile', () => {\n  it('should get a file by id', async () => {\n    const state = {\n      configuration: {\n        accessToken: fixtures.accessToken,\n      },\n      drives: {\n        default: {\n          id: 'b!YXzpkoLwR06bxC8tNdg71m_',\n        },\n      },\n    };\n\n    const finalState = await execute(\n      getFile('01LUM6XOGRONYNTZ26DBBJPTN5IFTQPBIW')\n    )(state);\n\n    expect(finalState.data).to.eql(fixtures.itemContent);\n  });",
    "instruction": "Create an OpenFn function that gets a file by ID or for a named drive by ID",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets a file by ID or for a named drive by ID\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get file metadata or file content.\n * @public\n * @example <caption>Get a file by ID</caption>\n * getFile('01LUM6XOGRONYNTZ26DBBJPTN5IFTQPBIW')\n * @example <caption>Get a file for a named drive by id</caption>\n * getFile(\"01LUM6XOGRONYNTZ26DBBJPTN5IFTQPBIW\",{ driveName: \"mydrive\"})\n * @param {string} pathOrId - A path to a file or file id\n * @param {object} options - (Optional) Query parameters\n * @param {function} [callback = s => s] (Optional) Callback function\n * @return {Operation}\n */\nexport function getFile(pathOrId: string, options: object, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Get file metadata or file content.\n * @public\n * @example <caption>Get a file by ID</caption>\n * getFile('01LUM6XOGRONYNTZ26DBBJPTN5IFTQPBIW')\n * @example <caption>Get a file for a named drive by id</caption>\n * getFile(\"01LUM6XOGRONYNTZ26DBBJPTN5IFTQPBIW\",{ driveName: \"mydrive\"})\n * @param {string} pathOrId - A path to a file or file id\n * @param {object} options - (Optional) Query parameters\n * @param {function} [callback = s => s] (Optional) Callback function\n * @return {Operation}\n */\nexport function getFile(pathOrId, options, callback = s => s) {\n  const defaultOptions = {\n    driveName: 'default', // named drive in state.drives\n    metadata: false, // Returns file msgraph metadata\n    // $filter: '', // Eg: \"file/mimeType eq \\'application/vnd.ms-excel\\'\"\n    // select: '', // Eg: id,@microsoft.graph.downloadUrl\n  };\n  return async state => {\n    const { accessToken, apiVersion } = state.configuration;\n    const [resolvedPathOrId, resolvedOptions] = expandReferences(\n      state,\n      pathOrId,\n      options\n    );\n\n    const { driveName, metadata } = {\n      ...defaultOptions,\n      ...resolvedOptions,\n    };\n\n    assertDrive(state, driveName);\n\n    const { id: driveId } = state.drives[driveName];\n\n    let resource;\n\n    if (resolvedPathOrId.startsWith('/')) {\n      resource = `drives/${driveId}/root:/${encodeURIComponent(\n        resolvedPathOrId\n      )}`;\n    } else {\n      resource = `drives/${driveId}/items/${resolvedPathOrId}`;\n    }\n\n    if (!metadata) {\n      resource += resolvedPathOrId.startsWith('/') ? ':/content' : '/content';\n    }\n\n    const url = setUrl(resource, apiVersion);\n\n    const response = await request(url, {\n      accessToken,\n      parseAs: metadata ? 'json' : 'text',\n    });\n\n    return handleResponse(response, state, callback);\n  };\n}\n\nconst defaultResource = {\n  contentType: 'application/octet-stream',\n  driveId: '',\n  folderId: '',\n  fileName: 'sheet.xls',\n  onConflict: 'replace',\n};\n"
  },
  {
    "name": "uploadFile",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Upload a file to a drive\n * @public\n * @example\n * <caption>Upload Excel file to a drive using `driveId` and `parantItemId`</caption>\n * uploadFile(\n *   state => ({\n *     driveId: state.driveId,\n *     folderId: state.folderId,\n *     fileName: `Tracker.xlsx`,\n *   }),\n *   state => state.buffer\n * );\n * @example\n * <caption>Upload Excel file to a SharePoint drive using `siteId` and `parantItemId`</caption>\n * uploadFile(\n *   state => ({\n *     siteId: state.siteId,\n *     folderId: state.folderId,\n *     fileName: `Report.xlsx`,\n *   }),\n *   state => state.buffer\n * );\n * @function\n * @param {Object} resource - Resource Object\n * @param {String} [resource.driveId] - Drive Id\n * @param {String} [resource.driveId] - Site Id\n * @param {String} [resource.folderId] - Parent folder id\n * @param {String} [resource.contentType] - Resource content-type\n * @param {String} [resource.onConflict] - Specify conflict behavior if file with the same name exists. Can be \"rename | fail | replace\"\n * @param {Object} data - A buffer containing the file.\n * @param {Function} callback - Optional callback function\n * @returns {Operation}\n */\nexport function uploadFile(resource, data, callback) {\n  return async state => {\n    const { accessToken, apiVersion } = state.configuration;\n\n    const [resolvedResource, resolvedData] = expandReferences(\n      state,\n      resource,\n      data\n    );\n\n    const { contentType, driveId, siteId, folderId, onConflict, fileName } = {\n      ...defaultResource,\n      ...resolvedResource,\n    };\n\n    assertResources({ driveId, siteId, folderId });\n\n    const path =\n      (driveId &&\n        `drives/${driveId}/items/${folderId}:/${fileName}:/createUploadSession`) ||\n      (siteId &&\n        `sites/${siteId}/drive/items/${folderId}:/${fileName}:/createUploadSession`);\n\n    const uploadSession = await request(setUrl(path, apiVersion), {\n      method: 'POST',\n      accessToken,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        '@microsoft.graph.conflictBehavior': onConflict,\n        name: fileName,\n      }),\n    });\n\n    const uploadUrl = uploadSession.uploadUrl;\n\n    console.log(`Uploading file...`);\n\n    return request(uploadUrl, {\n      method: 'PUT',\n      accessToken,\n      headers: {\n        'Content-Type': contentType,\n        'Content-Length': `${resolvedData.length}`,\n        'Content-Range': `bytes 0-${resolvedData.length - 1}/${\n          resolvedData.length\n        }`,\n      },\n\n      body: resolvedData,\n    }).then(response => handleResponse(response, state, callback));\n  };\n}",
    "signature": "/**\n * Upload a file to a drive\n * @public\n * @example\n * <caption>Upload Excel file to a drive using `driveId` and `parantItemId`</caption>\n * uploadFile(\n *   state => ({\n *     driveId: state.driveId,\n *     folderId: state.folderId,\n *     fileName: `Tracker.xlsx`,\n *   }),\n *   state => state.buffer\n * );\n * @example\n * <caption>Upload Excel file to a SharePoint drive using `siteId` and `parantItemId`</caption>\n * uploadFile(\n *   state => ({\n *     siteId: state.siteId,\n *     folderId: state.folderId,\n *     fileName: `Report.xlsx`,\n *   }),\n *   state => state.buffer\n * );\n * @function\n * @param {Object} resource - Resource Object\n * @param {String} [resource.driveId] - Drive Id\n * @param {String} [resource.driveId] - Site Id\n * @param {String} [resource.folderId] - Parent folder id\n * @param {String} [resource.contentType] - Resource content-type\n * @param {String} [resource.onConflict] - Specify conflict behavior if file with the same name exists. Can be \"rename | fail | replace\"\n * @param {Object} data - A buffer containing the file.\n * @param {Function} callback - Optional callback function\n * @returns {Operation}\n */\nexport function uploadFile(resource: {\n    driveId?: string;\n    driveId?: string;\n    folderId?: string;\n    contentType?: string;\n    onConflict?: string;\n}, data: any, callback: Function): Operation;",
    "test": "describe('uploadFile', () => {\n  it.skip('should convert array of object to excel and post to specified path', async () => {\n    const state = {\n      configuration: {\n        accessToken: fixtures.accessToken,\n      },\n      siteId: 'openfn.sharepoint.com',\n      folderId: '01LUM6XOGVJ2OK2Z5RJRAKU3WAK2MTC5XD',\n      drives: {},\n      rows: [\n        [\n          {\n            name: 'Mtuchi',\n            birthday: '1/1/1973',\n          },\n          {\n            name: 'Aleksa',\n            birthday: '1/1/2023',\n          },\n        ],\n      ],\n    };\n\n    const finalState = await uploadFile(\n      state => ({\n        siteId: state.siteId,\n        parentItemId: state.folderId,\n        fileName: `invalidGrantCodeRows_${new Date()\n          .toISOString()\n          .replace(/[-:.]/g, '_')}.csv`,\n      })",
    "instruction": "Create an OpenFn function that uploads a file to a drive.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that uploads a file to a drive.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Upload a file to a drive\n * @public\n * @example\n * <caption>Upload Excel file to a drive using `driveId` and `parantItemId`</caption>\n * uploadFile(\n *   state => ({\n *     driveId: state.driveId,\n *     folderId: state.folderId,\n *     fileName: `Tracker.xlsx`,\n *   }),\n *   state => state.buffer\n * );\n * @example\n * <caption>Upload Excel file to a SharePoint drive using `siteId` and `parantItemId`</caption>\n * uploadFile(\n *   state => ({\n *     siteId: state.siteId,\n *     folderId: state.folderId,\n *     fileName: `Report.xlsx`,\n *   }),\n *   state => state.buffer\n * );\n * @function\n * @param {Object} resource - Resource Object\n * @param {String} [resource.driveId] - Drive Id\n * @param {String} [resource.driveId] - Site Id\n * @param {String} [resource.folderId] - Parent folder id\n * @param {String} [resource.contentType] - Resource content-type\n * @param {String} [resource.onConflict] - Specify conflict behavior if file with the same name exists. Can be \"rename | fail | replace\"\n * @param {Object} data - A buffer containing the file.\n * @param {Function} callback - Optional callback function\n * @returns {Operation}\n */\nexport function uploadFile(resource: {\n    driveId?: string;\n    driveId?: string;\n    folderId?: string;\n    contentType?: string;\n    onConflict?: string;\n}, data: any, callback: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Upload a file to a drive\n * @public\n * @example\n * <caption>Upload Excel file to a drive using `driveId` and `parantItemId`</caption>\n * uploadFile(\n *   state => ({\n *     driveId: state.driveId,\n *     folderId: state.folderId,\n *     fileName: `Tracker.xlsx`,\n *   }),\n *   state => state.buffer\n * );\n * @example\n * <caption>Upload Excel file to a SharePoint drive using `siteId` and `parantItemId`</caption>\n * uploadFile(\n *   state => ({\n *     siteId: state.siteId,\n *     folderId: state.folderId,\n *     fileName: `Report.xlsx`,\n *   }),\n *   state => state.buffer\n * );\n * @function\n * @param {Object} resource - Resource Object\n * @param {String} [resource.driveId] - Drive Id\n * @param {String} [resource.driveId] - Site Id\n * @param {String} [resource.folderId] - Parent folder id\n * @param {String} [resource.contentType] - Resource content-type\n * @param {String} [resource.onConflict] - Specify conflict behavior if file with the same name exists. Can be \"rename | fail | replace\"\n * @param {Object} data - A buffer containing the file.\n * @param {Function} callback - Optional callback function\n * @returns {Operation}\n */\nexport function uploadFile(resource, data, callback) {\n  return async state => {\n    const { accessToken, apiVersion } = state.configuration;\n\n    const [resolvedResource, resolvedData] = expandReferences(\n      state,\n      resource,\n      data\n    );\n\n    const { contentType, driveId, siteId, folderId, onConflict, fileName } = {\n      ...defaultResource,\n      ...resolvedResource,\n    };\n\n    assertResources({ driveId, siteId, folderId });\n\n    const path =\n      (driveId &&\n        `drives/${driveId}/items/${folderId}:/${fileName}:/createUploadSession`) ||\n      (siteId &&\n        `sites/${siteId}/drive/items/${folderId}:/${fileName}:/createUploadSession`);\n\n    const uploadSession = await request(setUrl(path, apiVersion), {\n      method: 'POST',\n      accessToken,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        '@microsoft.graph.conflictBehavior': onConflict,\n        name: fileName,\n      }),\n    });\n\n    const uploadUrl = uploadSession.uploadUrl;\n\n    console.log(`Uploading file...`);\n\n    return request(uploadUrl, {\n      method: 'PUT',\n      accessToken,\n      headers: {\n        'Content-Type': contentType,\n        'Content-Length': `${resolvedData.length}`,\n        'Content-Range': `bytes 0-${resolvedData.length - 1}/${\n          resolvedData.length\n        }`,\n      },\n\n      body: resolvedData,\n    }).then(response => handleResponse(response, state, callback));\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for DHIS2.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      configMigrationHelper,\n      ...operations\n    )({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for DHIS2.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on DHIS2.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on DHIS2.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for DHIS2.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for DHIS2.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      configMigrationHelper,\n      ...operations\n    )({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "create",
    "implementation": "import axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Migrates `apiUrl` to `hostUrl` if `hostUrl` is `blank`.\n * For `OpenFn.org` users with the `old-style configuration`.\n * @example\n * configMigrationHelper(state)\n * @function\n * @param {object} state - the runtime state\n * @returns {object}\n */\nfunction configMigrationHelper(state) {\n  const { hostUrl, apiUrl } = state.configuration;\n  if (!hostUrl) {\n    console.warn(\n      'DEPRECATION WARNING: Please migrate instance address from `apiUrl` to `hostUrl`.'\n    );\n    state.configuration.hostUrl = apiUrl;\n    return state;\n  }\n  return state;\n}\n\n// NOTE: In order to prevent unintended exposure of authentication information\n// in the logs, we make use of an axios interceptor.\naxios.interceptors.response.use(\n  function (response) {\n    const contentType = response.headers['content-type']?.split(';')[0];\n\n    const acceptHeaders = response.config.headers['Accept']\n      .split(';')[0]\n      .split(',');\n\n    if (response.config.method === 'get') {\n      if (indexOf(acceptHeaders, contentType) === -1) {\n        const newError = {\n          status: 404,\n          message: 'Unexpected content returned',\n          responseData: response.data,\n        };\n\n        console.error(newError.message);\n\n        return Promise.reject(newError);\n      }\n    }\n\n    if (\n      typeof response?.data === 'string' &&\n      contentType === CONTENT_TYPES?.json\n    ) {\n      try {\n        // eslint-disable-next-line no-param-reassign\n        response = { ...response, data: JSON.parse(response.data) };\n      } catch (error) {\n        console.warn('Non-JSON response detected, unable to parse.');\n      }\n    }\n    return response;\n  },\n  function (error) {\n    if (error.config?.auth) error.config.auth = '--REDACTED--';\n    if (error.config?.data) error.config.data = '--REDACTED--';\n\n    const details = error.response?.data;\n\n    console.error(error.message || \"That didn't work.\");\n\n    if (details) console.log(JSON.stringify(details, null, 2));\n\n    return Promise.reject({\n      request: error.config,\n      message: error.message,\n      response: error.response?.data,\n    });\n  }\n);\n\n/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `trackedEntityInstances`, `programs`, `events`, ...\n * @magic resourceType $.children.resourceTypes[*]\n * @param {Dhis2Data} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * create('programs', {\n *   name: 'name 20',\n *   shortName: 'n20',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * create('events', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'DiszpKrYNg8',\n *   status: 'COMPLETED',\n * });\n * @example <caption>a trackedEntityInstance</caption>\n * create('trackedEntityInstances', {\n *   orgUnit: 'TSyzvBiovKh',\n *   trackedEntityType: 'nEenWmSyUEp',\n *   attributes: [\n *     {\n *       attribute: 'w75KJ2mc4zz',\n *       value: 'Gigiwe',\n *     },\n *   ]\n * });\n * @example <caption>a dataSet</caption>\n * create('dataSets', { name: 'OpenFn Data Set', periodType: 'Monthly' });\n * @example <caption>a dataSetNotification</caption>\n * create('dataSetNotificationTemplates', {\n *   dataSetNotificationTrigger: 'DATA_SET_COMPLETION',\n *   notificationRecipient: 'ORGANISATION_UNIT_CONTACT',\n *   name: 'Notification',\n *   messageTemplate: 'Hello',\n *   deliveryChannels: ['SMS'],\n *   dataSets: [],\n * });\n * @example <caption>a dataElement</caption>\n * create('dataElements', {\n *   aggregationType: 'SUM',\n *   domainType: 'AGGREGATE',\n *   valueType: 'NUMBER',\n *   name: 'Paracetamol',\n *   shortName: 'Para',\n * });\n * @example <caption>a dataElementGroup</caption>\n * create('dataElementGroups', {\n *   name: 'Data Element Group 1',\n *   dataElements: [],\n * });\n * @example <caption>a dataElementGroupSet</caption>\n * create('dataElementGroupSets', {\n *   name: 'Data Element Group Set 4',\n *   dataDimension: true,\n *   shortName: 'DEGS4',\n *   dataElementGroups: [],\n * });\n * @example <caption>a dataValueSet</caption>\n * create('dataValueSets', {\n *   dataElement: 'f7n9E0hX8qk',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   value: '12',\n * });\n * @example <caption>a dataValueSet with related dataValues</caption>\n * create('dataValueSets', {\n *   dataSet: 'pBOMPrpg1QX',\n *   completeDate: '2014-02-03',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   dataValues: [\n *     {\n *       dataElement: 'f7n9E0hX8qk',\n *       value: '1',\n *     },\n *     {\n *       dataElement: 'Ix2HsbDMLea',\n *       value: '2',\n *     },\n *     {\n *       dataElement: 'eY5ehpbEsB7',\n *       value: '3',\n *     },\n *   ],\n * });\n * @example <caption>an enrollment</caption>\n * create('enrollments', {\n *   trackedEntityInstance: 'bmshzEacgxa',\n *   orgUnit: 'TSyzvBiovKh',\n *   program: 'gZBxv9Ujxg0',\n *   enrollmentDate: '2013-09-17',\n *   incidentDate: '2013-09-17',\n * });\n */\nexport function create(resourceType, data, options = {}, callback = false) {\n  return state => {\n    console.log(`Preparing create operation...`);\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedData = expandReferences(data)(state);\n    const resolvedOptions = expandReferences(options)(state);\n\n    const { params, requestConfig } = resolvedOptions;\n    const { configuration } = state;\n\n    return request(configuration, {\n      method: 'post',\n      url: generateUrl(configuration, resolvedOptions, resolvedResourceType),\n      params,\n      data: nestArray(resolvedData, resolvedResourceType),\n      ...requestConfig,\n    }).then(result => {\n      const details = `with response ${JSON.stringify(result.data, null, 2)}`;\n      console.log(`Created ${resolvedResourceType} ${details}`);\n\n      const { location } = result.headers;\n      if (location) console.log(`Record available @ ${location}`);\n\n      return handleResponse(result, state, callback);\n    });\n  };\n}",
    "signature": "/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `trackedEntityInstances`, `programs`, `events`, ...\n * @magic resourceType $.children.resourceTypes[*]\n * @param {Dhis2Data} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * create('programs', {\n *   name: 'name 20',\n *   shortName: 'n20',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * create('events', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'DiszpKrYNg8',\n *   status: 'COMPLETED',\n * });\n * @example <caption>a trackedEntityInstance</caption>\n * create('trackedEntityInstances', {\n *   orgUnit: 'TSyzvBiovKh',\n *   trackedEntityType: 'nEenWmSyUEp',\n *   attributes: [\n *     {\n *       attribute: 'w75KJ2mc4zz',\n *       value: 'Gigiwe',\n *     },\n *   ]\n * });\n * @example <caption>a dataSet</caption>\n * create('dataSets', { name: 'OpenFn Data Set', periodType: 'Monthly' });\n * @example <caption>a dataSetNotification</caption>\n * create('dataSetNotificationTemplates', {\n *   dataSetNotificationTrigger: 'DATA_SET_COMPLETION',\n *   notificationRecipient: 'ORGANISATION_UNIT_CONTACT',\n *   name: 'Notification',\n *   messageTemplate: 'Hello',\n *   deliveryChannels: ['SMS'],\n *   dataSets: [],\n * });\n * @example <caption>a dataElement</caption>\n * create('dataElements', {\n *   aggregationType: 'SUM',\n *   domainType: 'AGGREGATE',\n *   valueType: 'NUMBER',\n *   name: 'Paracetamol',\n *   shortName: 'Para',\n * });\n * @example <caption>a dataElementGroup</caption>\n * create('dataElementGroups', {\n *   name: 'Data Element Group 1',\n *   dataElements: [],\n * });\n * @example <caption>a dataElementGroupSet</caption>\n * create('dataElementGroupSets', {\n *   name: 'Data Element Group Set 4',\n *   dataDimension: true,\n *   shortName: 'DEGS4',\n *   dataElementGroups: [],\n * });\n * @example <caption>a dataValueSet</caption>\n * create('dataValueSets', {\n *   dataElement: 'f7n9E0hX8qk',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   value: '12',\n * });\n * @example <caption>a dataValueSet with related dataValues</caption>\n * create('dataValueSets', {\n *   dataSet: 'pBOMPrpg1QX',\n *   completeDate: '2014-02-03',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   dataValues: [\n *     {\n *       dataElement: 'f7n9E0hX8qk',\n *       value: '1',\n *     },\n *     {\n *       dataElement: 'Ix2HsbDMLea',\n *       value: '2',\n *     },\n *     {\n *       dataElement: 'eY5ehpbEsB7',\n *       value: '3',\n *     },\n *   ],\n * });\n * @example <caption>an enrollment</caption>\n * create('enrollments', {\n *   trackedEntityInstance: 'bmshzEacgxa',\n *   orgUnit: 'TSyzvBiovKh',\n *   program: 'gZBxv9Ujxg0',\n *   enrollmentDate: '2013-09-17',\n *   incidentDate: '2013-09-17',\n * });\n */\nexport function create(resourceType: string, data: Dhis2Data, options?: any, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that creates a record to/on/from resourceType.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates a record to/on/from resourceType.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `trackedEntityInstances`, `programs`, `events`, ...\n * @magic resourceType $.children.resourceTypes[*]\n * @param {Dhis2Data} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * create('programs', {\n *   name: 'name 20',\n *   shortName: 'n20',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * create('events', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'DiszpKrYNg8',\n *   status: 'COMPLETED',\n * });\n * @example <caption>a trackedEntityInstance</caption>\n * create('trackedEntityInstances', {\n *   orgUnit: 'TSyzvBiovKh',\n *   trackedEntityType: 'nEenWmSyUEp',\n *   attributes: [\n *     {\n *       attribute: 'w75KJ2mc4zz',\n *       value: 'Gigiwe',\n *     },\n *   ]\n * });\n * @example <caption>a dataSet</caption>\n * create('dataSets', { name: 'OpenFn Data Set', periodType: 'Monthly' });\n * @example <caption>a dataSetNotification</caption>\n * create('dataSetNotificationTemplates', {\n *   dataSetNotificationTrigger: 'DATA_SET_COMPLETION',\n *   notificationRecipient: 'ORGANISATION_UNIT_CONTACT',\n *   name: 'Notification',\n *   messageTemplate: 'Hello',\n *   deliveryChannels: ['SMS'],\n *   dataSets: [],\n * });\n * @example <caption>a dataElement</caption>\n * create('dataElements', {\n *   aggregationType: 'SUM',\n *   domainType: 'AGGREGATE',\n *   valueType: 'NUMBER',\n *   name: 'Paracetamol',\n *   shortName: 'Para',\n * });\n * @example <caption>a dataElementGroup</caption>\n * create('dataElementGroups', {\n *   name: 'Data Element Group 1',\n *   dataElements: [],\n * });\n * @example <caption>a dataElementGroupSet</caption>\n * create('dataElementGroupSets', {\n *   name: 'Data Element Group Set 4',\n *   dataDimension: true,\n *   shortName: 'DEGS4',\n *   dataElementGroups: [],\n * });\n * @example <caption>a dataValueSet</caption>\n * create('dataValueSets', {\n *   dataElement: 'f7n9E0hX8qk',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   value: '12',\n * });\n * @example <caption>a dataValueSet with related dataValues</caption>\n * create('dataValueSets', {\n *   dataSet: 'pBOMPrpg1QX',\n *   completeDate: '2014-02-03',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   dataValues: [\n *     {\n *       dataElement: 'f7n9E0hX8qk',\n *       value: '1',\n *     },\n *     {\n *       dataElement: 'Ix2HsbDMLea',\n *       value: '2',\n *     },\n *     {\n *       dataElement: 'eY5ehpbEsB7',\n *       value: '3',\n *     },\n *   ],\n * });\n * @example <caption>an enrollment</caption>\n * create('enrollments', {\n *   trackedEntityInstance: 'bmshzEacgxa',\n *   orgUnit: 'TSyzvBiovKh',\n *   program: 'gZBxv9Ujxg0',\n *   enrollmentDate: '2013-09-17',\n *   incidentDate: '2013-09-17',\n * });\n */\nexport function create(resourceType: string, data: Dhis2Data, options?: any, callback?: Function): Operation;\n\n### Implementation:\nimport axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Migrates `apiUrl` to `hostUrl` if `hostUrl` is `blank`.\n * For `OpenFn.org` users with the `old-style configuration`.\n * @example\n * configMigrationHelper(state)\n * @function\n * @param {object} state - the runtime state\n * @returns {object}\n */\nfunction configMigrationHelper(state) {\n  const { hostUrl, apiUrl } = state.configuration;\n  if (!hostUrl) {\n    console.warn(\n      'DEPRECATION WARNING: Please migrate instance address from `apiUrl` to `hostUrl`.'\n    );\n    state.configuration.hostUrl = apiUrl;\n    return state;\n  }\n  return state;\n}\n\n// NOTE: In order to prevent unintended exposure of authentication information\n// in the logs, we make use of an axios interceptor.\naxios.interceptors.response.use(\n  function (response) {\n    const contentType = response.headers['content-type']?.split(';')[0];\n\n    const acceptHeaders = response.config.headers['Accept']\n      .split(';')[0]\n      .split(',');\n\n    if (response.config.method === 'get') {\n      if (indexOf(acceptHeaders, contentType) === -1) {\n        const newError = {\n          status: 404,\n          message: 'Unexpected content returned',\n          responseData: response.data,\n        };\n\n        console.error(newError.message);\n\n        return Promise.reject(newError);\n      }\n    }\n\n    if (\n      typeof response?.data === 'string' &&\n      contentType === CONTENT_TYPES?.json\n    ) {\n      try {\n        // eslint-disable-next-line no-param-reassign\n        response = { ...response, data: JSON.parse(response.data) };\n      } catch (error) {\n        console.warn('Non-JSON response detected, unable to parse.');\n      }\n    }\n    return response;\n  },\n  function (error) {\n    if (error.config?.auth) error.config.auth = '--REDACTED--';\n    if (error.config?.data) error.config.data = '--REDACTED--';\n\n    const details = error.response?.data;\n\n    console.error(error.message || \"That didn't work.\");\n\n    if (details) console.log(JSON.stringify(details, null, 2));\n\n    return Promise.reject({\n      request: error.config,\n      message: error.message,\n      response: error.response?.data,\n    });\n  }\n);\n\n/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `trackedEntityInstances`, `programs`, `events`, ...\n * @magic resourceType $.children.resourceTypes[*]\n * @param {Dhis2Data} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * create('programs', {\n *   name: 'name 20',\n *   shortName: 'n20',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * create('events', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'DiszpKrYNg8',\n *   status: 'COMPLETED',\n * });\n * @example <caption>a trackedEntityInstance</caption>\n * create('trackedEntityInstances', {\n *   orgUnit: 'TSyzvBiovKh',\n *   trackedEntityType: 'nEenWmSyUEp',\n *   attributes: [\n *     {\n *       attribute: 'w75KJ2mc4zz',\n *       value: 'Gigiwe',\n *     },\n *   ]\n * });\n * @example <caption>a dataSet</caption>\n * create('dataSets', { name: 'OpenFn Data Set', periodType: 'Monthly' });\n * @example <caption>a dataSetNotification</caption>\n * create('dataSetNotificationTemplates', {\n *   dataSetNotificationTrigger: 'DATA_SET_COMPLETION',\n *   notificationRecipient: 'ORGANISATION_UNIT_CONTACT',\n *   name: 'Notification',\n *   messageTemplate: 'Hello',\n *   deliveryChannels: ['SMS'],\n *   dataSets: [],\n * });\n * @example <caption>a dataElement</caption>\n * create('dataElements', {\n *   aggregationType: 'SUM',\n *   domainType: 'AGGREGATE',\n *   valueType: 'NUMBER',\n *   name: 'Paracetamol',\n *   shortName: 'Para',\n * });\n * @example <caption>a dataElementGroup</caption>\n * create('dataElementGroups', {\n *   name: 'Data Element Group 1',\n *   dataElements: [],\n * });\n * @example <caption>a dataElementGroupSet</caption>\n * create('dataElementGroupSets', {\n *   name: 'Data Element Group Set 4',\n *   dataDimension: true,\n *   shortName: 'DEGS4',\n *   dataElementGroups: [],\n * });\n * @example <caption>a dataValueSet</caption>\n * create('dataValueSets', {\n *   dataElement: 'f7n9E0hX8qk',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   value: '12',\n * });\n * @example <caption>a dataValueSet with related dataValues</caption>\n * create('dataValueSets', {\n *   dataSet: 'pBOMPrpg1QX',\n *   completeDate: '2014-02-03',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   dataValues: [\n *     {\n *       dataElement: 'f7n9E0hX8qk',\n *       value: '1',\n *     },\n *     {\n *       dataElement: 'Ix2HsbDMLea',\n *       value: '2',\n *     },\n *     {\n *       dataElement: 'eY5ehpbEsB7',\n *       value: '3',\n *     },\n *   ],\n * });\n * @example <caption>an enrollment</caption>\n * create('enrollments', {\n *   trackedEntityInstance: 'bmshzEacgxa',\n *   orgUnit: 'TSyzvBiovKh',\n *   program: 'gZBxv9Ujxg0',\n *   enrollmentDate: '2013-09-17',\n *   incidentDate: '2013-09-17',\n * });\n */\nexport function create(resourceType, data, options = {}, callback = false) {\n  return state => {\n    console.log(`Preparing create operation...`);\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedData = expandReferences(data)(state);\n    const resolvedOptions = expandReferences(options)(state);\n\n    const { params, requestConfig } = resolvedOptions;\n    const { configuration } = state;\n\n    return request(configuration, {\n      method: 'post',\n      url: generateUrl(configuration, resolvedOptions, resolvedResourceType),\n      params,\n      data: nestArray(resolvedData, resolvedResourceType),\n      ...requestConfig,\n    }).then(result => {\n      const details = `with response ${JSON.stringify(result.data, null, 2)}`;\n      console.log(`Created ${resolvedResourceType} ${details}`);\n\n      const { location } = result.headers;\n      if (location) console.log(`Record available @ ${location}`);\n\n      return handleResponse(result, state, callback);\n    });\n  };\n}\n"
  },
  {
    "name": "update",
    "implementation": "import axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Update data. A generic helper function to update a resource object of any type.\n * Updating an object requires to send `all required fields` or the `full body`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be updated. E.g. `dataElements`, `organisationUnits`, etc.\n * @param {string} path - The `id` or `path` to the `object` to be updated. E.g. `FTRrcoaog83` or `FTRrcoaog83/{collection-name}/{object-id}`\n * @param {Object} data - Data to update. It requires to send `all required fields` or the `full body`. If you want `partial updates`, use `patch` operation.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * update('programs', 'qAZJCrNJK8H', {\n *   name: '14e1aa02c3f0a31618e096f2c6d03bed',\n *   shortName: '14e1aa02',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * update('events', 'PVqUD2hvU4E', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'Ngelehun CHC',\n *   status: 'COMPLETED',\n *   storedBy: 'admin',\n *   dataValues: [],\n * });\n * @example <caption>a trackedEntityInstance</caption>\n * update('trackedEntityInstances', 'IeQfgUtGPq2', {\n *   created: '2015-08-06T21:12:37.256',\n *   orgUnit: 'TSyzvBiovKh',\n *   createdAtClient: '2015-08-06T21:12:37.256',\n *   trackedEntityInstance: 'IeQfgUtGPq2',\n *   lastUpdated: '2015-08-06T21:12:37.257',\n *   trackedEntityType: 'nEenWmSyUEp',\n *   inactive: false,\n *   deleted: false,\n *   featureType: 'NONE',\n *   programOwners: [\n *     {\n *       ownerOrgUnit: 'TSyzvBiovKh',\n *       program: 'IpHINAT79UW',\n *       trackedEntityInstance: 'IeQfgUtGPq2',\n *     },\n *   ],\n *   enrollments: [],\n *   relationships: [],\n *   attributes: [\n *     {\n *       lastUpdated: '2016-01-12T00:00:00.000',\n *       displayName: 'Last name',\n *       created: '2016-01-12T00:00:00.000',\n *       valueType: 'TEXT',\n *       attribute: 'zDhUuAYrxNC',\n *       value: 'Russell',\n *     },\n *     {\n *       lastUpdated: '2016-01-12T00:00:00.000',\n *       code: 'MMD_PER_NAM',\n *       displayName: 'First name',\n *       created: '2016-01-12T00:00:00.000',\n *       valueType: 'TEXT',\n *       attribute: 'w75KJ2mc4zz',\n *       value: 'Catherine',\n *     },\n *   ],\n * });\n * @example <caption>a dataSet</caption>\n * update('dataSets', 'lyLU2wR22tC', { name: 'OpenFN Data Set', periodType: 'Weekly' });\n * @example <caption>a dataSetNotification</caption>\n * update('dataSetNotificationTemplates', 'VbQBwdm1wVP', {\n *   dataSetNotificationTrigger: 'DATA_SET_COMPLETION',\n *   notificationRecipient: 'ORGANISATION_UNIT_CONTACT',\n *   name: 'Notification',\n *   messageTemplate: 'Hello Updated,\n *   deliveryChannels: ['SMS'],\n *   dataSets: [],\n * });\n * @example <caption>a dataElement</caption>\n * update('dataElements', 'FTRrcoaog83', {\n *   aggregationType: 'SUM',\n *   domainType: 'AGGREGATE',\n *   valueType: 'NUMBER',\n *   name: 'Paracetamol',\n *   shortName: 'Para',\n * });\n * @example <caption>a dataElementGroup</caption>\n * update('dataElementGroups', 'QrprHT61XFk', {\n *   name: 'Data Element Group 1',\n *   dataElements: [],\n * });\n * @example <caption>a dataElementGroupSet</caption>\n * update('dataElementGroupSets', 'VxWloRvAze8', {\n *   name: 'Data Element Group Set 4',\n *   dataDimension: true,\n *   shortName: 'DEGS4',\n *   dataElementGroups: [],\n * });\n * @example <caption>a dataValueSet</caption>\n * update('dataValueSets', 'AsQj6cDsUq4', {\n *   dataElement: 'f7n9E0hX8qk',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   value: '12',\n * });\n * @example <caption>a dataValueSet with related dataValues</caption>\n * update('dataValueSets', 'Ix2HsbDMLea', {\n *   dataSet: 'pBOMPrpg1QX',\n *   completeDate: '2014-02-03',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   dataValues: [\n *     {\n *       dataElement: 'f7n9E0hX8qk',\n *       value: '1',\n *     },\n *     {\n *       dataElement: 'Ix2HsbDMLea',\n *       value: '2',\n *     },\n *     {\n *       dataElement: 'eY5ehpbEsB7',\n *       value: '3',\n *     },\n *   ],\n * });\n * @example <caption>a single enrollment</caption>\n * update('enrollments', 'CmsHzercTBa' {\n *   trackedEntityInstance: 'bmshzEacgxa',\n *   orgUnit: 'TSyzvBiovKh',\n *   program: 'gZBxv9Ujxg0',\n *   enrollmentDate: '2013-10-17',\n *   incidentDate: '2013-10-17',\n * });\n */\nexport function update(\n  resourceType,\n  path,\n  data,\n  options = {},\n  callback = false\n) {\n  return state => {\n    console.log(`Preparing update operation...`);\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedData = expandReferences(data)(state);\n    const resolvedOptions = expandReferences(options)(state);\n\n    const { params, requestConfig } = resolvedOptions;\n    const { configuration } = state;\n\n    return request(configuration, {\n      method: 'put',\n      url: generateUrl(\n        configuration,\n        resolvedOptions,\n        resolvedResourceType,\n        path\n      ),\n      params,\n      data: resolvedData,\n      ...requestConfig,\n    }).then(result => {\n      console.log(`Updated ${resolvedResourceType} at ${resolvedPath}`);\n      return handleResponse(result, state, callback);\n    });\n  };\n}",
    "signature": "/**\n * Update data. A generic helper function to update a resource object of any type.\n * Updating an object requires to send `all required fields` or the `full body`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be updated. E.g. `dataElements`, `organisationUnits`, etc.\n * @param {string} path - The `id` or `path` to the `object` to be updated. E.g. `FTRrcoaog83` or `FTRrcoaog83/{collection-name}/{object-id}`\n * @param {Object} data - Data to update. It requires to send `all required fields` or the `full body`. If you want `partial updates`, use `patch` operation.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * update('programs', 'qAZJCrNJK8H', {\n *   name: '14e1aa02c3f0a31618e096f2c6d03bed',\n *   shortName: '14e1aa02',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * update('events', 'PVqUD2hvU4E', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'Ngelehun CHC',\n *   status: 'COMPLETED',\n *   storedBy: 'admin',\n *   dataValues: [],\n * });\n * @example <caption>a trackedEntityInstance</caption>\n * update('trackedEntityInstances', 'IeQfgUtGPq2', {\n *   created: '2015-08-06T21:12:37.256',\n *   orgUnit: 'TSyzvBiovKh',\n *   createdAtClient: '2015-08-06T21:12:37.256',\n *   trackedEntityInstance: 'IeQfgUtGPq2',\n *   lastUpdated: '2015-08-06T21:12:37.257',\n *   trackedEntityType: 'nEenWmSyUEp',\n *   inactive: false,\n *   deleted: false,\n *   featureType: 'NONE',\n *   programOwners: [\n *     {\n *       ownerOrgUnit: 'TSyzvBiovKh',\n *       program: 'IpHINAT79UW',\n *       trackedEntityInstance: 'IeQfgUtGPq2',\n *     },\n *   ],\n *   enrollments: [],\n *   relationships: [],\n *   attributes: [\n *     {\n *       lastUpdated: '2016-01-12T00:00:00.000',\n *       displayName: 'Last name',\n *       created: '2016-01-12T00:00:00.000',\n *       valueType: 'TEXT',\n *       attribute: 'zDhUuAYrxNC',\n *       value: 'Russell',\n *     },\n *     {\n *       lastUpdated: '2016-01-12T00:00:00.000',\n *       code: 'MMD_PER_NAM',\n *       displayName: 'First name',\n *       created: '2016-01-12T00:00:00.000',\n *       valueType: 'TEXT',\n *       attribute: 'w75KJ2mc4zz',\n *       value: 'Catherine',\n *     },\n *   ],\n * });\n * @example <caption>a dataSet</caption>\n * update('dataSets', 'lyLU2wR22tC', { name: 'OpenFN Data Set', periodType: 'Weekly' });\n * @example <caption>a dataSetNotification</caption>\n * update('dataSetNotificationTemplates', 'VbQBwdm1wVP', {\n *   dataSetNotificationTrigger: 'DATA_SET_COMPLETION',\n *   notificationRecipient: 'ORGANISATION_UNIT_CONTACT',\n *   name: 'Notification',\n *   messageTemplate: 'Hello Updated,\n *   deliveryChannels: ['SMS'],\n *   dataSets: [],\n * });\n * @example <caption>a dataElement</caption>\n * update('dataElements', 'FTRrcoaog83', {\n *   aggregationType: 'SUM',\n *   domainType: 'AGGREGATE',\n *   valueType: 'NUMBER',\n *   name: 'Paracetamol',\n *   shortName: 'Para',\n * });\n * @example <caption>a dataElementGroup</caption>\n * update('dataElementGroups', 'QrprHT61XFk', {\n *   name: 'Data Element Group 1',\n *   dataElements: [],\n * });\n * @example <caption>a dataElementGroupSet</caption>\n * update('dataElementGroupSets', 'VxWloRvAze8', {\n *   name: 'Data Element Group Set 4',\n *   dataDimension: true,\n *   shortName: 'DEGS4',\n *   dataElementGroups: [],\n * });\n * @example <caption>a dataValueSet</caption>\n * update('dataValueSets', 'AsQj6cDsUq4', {\n *   dataElement: 'f7n9E0hX8qk',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   value: '12',\n * });\n * @example <caption>a dataValueSet with related dataValues</caption>\n * update('dataValueSets', 'Ix2HsbDMLea', {\n *   dataSet: 'pBOMPrpg1QX',\n *   completeDate: '2014-02-03',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   dataValues: [\n *     {\n *       dataElement: 'f7n9E0hX8qk',\n *       value: '1',\n *     },\n *     {\n *       dataElement: 'Ix2HsbDMLea',\n *       value: '2',\n *     },\n *     {\n *       dataElement: 'eY5ehpbEsB7',\n *       value: '3',\n *     },\n *   ],\n * });\n * @example <caption>a single enrollment</caption>\n * update('enrollments', 'CmsHzercTBa' {\n *   trackedEntityInstance: 'bmshzEacgxa',\n *   orgUnit: 'TSyzvBiovKh',\n *   program: 'gZBxv9Ujxg0',\n *   enrollmentDate: '2013-10-17',\n *   incidentDate: '2013-10-17',\n * });\n */\nexport function update(resourceType: string, path: string, data: any, options?: any, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that updates data to/on/from a resource object.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that updates data to/on/from a resource object.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Update data. A generic helper function to update a resource object of any type.\n * Updating an object requires to send `all required fields` or the `full body`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be updated. E.g. `dataElements`, `organisationUnits`, etc.\n * @param {string} path - The `id` or `path` to the `object` to be updated. E.g. `FTRrcoaog83` or `FTRrcoaog83/{collection-name}/{object-id}`\n * @param {Object} data - Data to update. It requires to send `all required fields` or the `full body`. If you want `partial updates`, use `patch` operation.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * update('programs', 'qAZJCrNJK8H', {\n *   name: '14e1aa02c3f0a31618e096f2c6d03bed',\n *   shortName: '14e1aa02',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * update('events', 'PVqUD2hvU4E', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'Ngelehun CHC',\n *   status: 'COMPLETED',\n *   storedBy: 'admin',\n *   dataValues: [],\n * });\n * @example <caption>a trackedEntityInstance</caption>\n * update('trackedEntityInstances', 'IeQfgUtGPq2', {\n *   created: '2015-08-06T21:12:37.256',\n *   orgUnit: 'TSyzvBiovKh',\n *   createdAtClient: '2015-08-06T21:12:37.256',\n *   trackedEntityInstance: 'IeQfgUtGPq2',\n *   lastUpdated: '2015-08-06T21:12:37.257',\n *   trackedEntityType: 'nEenWmSyUEp',\n *   inactive: false,\n *   deleted: false,\n *   featureType: 'NONE',\n *   programOwners: [\n *     {\n *       ownerOrgUnit: 'TSyzvBiovKh',\n *       program: 'IpHINAT79UW',\n *       trackedEntityInstance: 'IeQfgUtGPq2',\n *     },\n *   ],\n *   enrollments: [],\n *   relationships: [],\n *   attributes: [\n *     {\n *       lastUpdated: '2016-01-12T00:00:00.000',\n *       displayName: 'Last name',\n *       created: '2016-01-12T00:00:00.000',\n *       valueType: 'TEXT',\n *       attribute: 'zDhUuAYrxNC',\n *       value: 'Russell',\n *     },\n *     {\n *       lastUpdated: '2016-01-12T00:00:00.000',\n *       code: 'MMD_PER_NAM',\n *       displayName: 'First name',\n *       created: '2016-01-12T00:00:00.000',\n *       valueType: 'TEXT',\n *       attribute: 'w75KJ2mc4zz',\n *       value: 'Catherine',\n *     },\n *   ],\n * });\n * @example <caption>a dataSet</caption>\n * update('dataSets', 'lyLU2wR22tC', { name: 'OpenFN Data Set', periodType: 'Weekly' });\n * @example <caption>a dataSetNotification</caption>\n * update('dataSetNotificationTemplates', 'VbQBwdm1wVP', {\n *   dataSetNotificationTrigger: 'DATA_SET_COMPLETION',\n *   notificationRecipient: 'ORGANISATION_UNIT_CONTACT',\n *   name: 'Notification',\n *   messageTemplate: 'Hello Updated,\n *   deliveryChannels: ['SMS'],\n *   dataSets: [],\n * });\n * @example <caption>a dataElement</caption>\n * update('dataElements', 'FTRrcoaog83', {\n *   aggregationType: 'SUM',\n *   domainType: 'AGGREGATE',\n *   valueType: 'NUMBER',\n *   name: 'Paracetamol',\n *   shortName: 'Para',\n * });\n * @example <caption>a dataElementGroup</caption>\n * update('dataElementGroups', 'QrprHT61XFk', {\n *   name: 'Data Element Group 1',\n *   dataElements: [],\n * });\n * @example <caption>a dataElementGroupSet</caption>\n * update('dataElementGroupSets', 'VxWloRvAze8', {\n *   name: 'Data Element Group Set 4',\n *   dataDimension: true,\n *   shortName: 'DEGS4',\n *   dataElementGroups: [],\n * });\n * @example <caption>a dataValueSet</caption>\n * update('dataValueSets', 'AsQj6cDsUq4', {\n *   dataElement: 'f7n9E0hX8qk',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   value: '12',\n * });\n * @example <caption>a dataValueSet with related dataValues</caption>\n * update('dataValueSets', 'Ix2HsbDMLea', {\n *   dataSet: 'pBOMPrpg1QX',\n *   completeDate: '2014-02-03',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   dataValues: [\n *     {\n *       dataElement: 'f7n9E0hX8qk',\n *       value: '1',\n *     },\n *     {\n *       dataElement: 'Ix2HsbDMLea',\n *       value: '2',\n *     },\n *     {\n *       dataElement: 'eY5ehpbEsB7',\n *       value: '3',\n *     },\n *   ],\n * });\n * @example <caption>a single enrollment</caption>\n * update('enrollments', 'CmsHzercTBa' {\n *   trackedEntityInstance: 'bmshzEacgxa',\n *   orgUnit: 'TSyzvBiovKh',\n *   program: 'gZBxv9Ujxg0',\n *   enrollmentDate: '2013-10-17',\n *   incidentDate: '2013-10-17',\n * });\n */\nexport function update(resourceType: string, path: string, data: any, options?: any, callback?: Function): Operation;\n\n### Implementation:\nimport axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Update data. A generic helper function to update a resource object of any type.\n * Updating an object requires to send `all required fields` or the `full body`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be updated. E.g. `dataElements`, `organisationUnits`, etc.\n * @param {string} path - The `id` or `path` to the `object` to be updated. E.g. `FTRrcoaog83` or `FTRrcoaog83/{collection-name}/{object-id}`\n * @param {Object} data - Data to update. It requires to send `all required fields` or the `full body`. If you want `partial updates`, use `patch` operation.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * update('programs', 'qAZJCrNJK8H', {\n *   name: '14e1aa02c3f0a31618e096f2c6d03bed',\n *   shortName: '14e1aa02',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * update('events', 'PVqUD2hvU4E', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'Ngelehun CHC',\n *   status: 'COMPLETED',\n *   storedBy: 'admin',\n *   dataValues: [],\n * });\n * @example <caption>a trackedEntityInstance</caption>\n * update('trackedEntityInstances', 'IeQfgUtGPq2', {\n *   created: '2015-08-06T21:12:37.256',\n *   orgUnit: 'TSyzvBiovKh',\n *   createdAtClient: '2015-08-06T21:12:37.256',\n *   trackedEntityInstance: 'IeQfgUtGPq2',\n *   lastUpdated: '2015-08-06T21:12:37.257',\n *   trackedEntityType: 'nEenWmSyUEp',\n *   inactive: false,\n *   deleted: false,\n *   featureType: 'NONE',\n *   programOwners: [\n *     {\n *       ownerOrgUnit: 'TSyzvBiovKh',\n *       program: 'IpHINAT79UW',\n *       trackedEntityInstance: 'IeQfgUtGPq2',\n *     },\n *   ],\n *   enrollments: [],\n *   relationships: [],\n *   attributes: [\n *     {\n *       lastUpdated: '2016-01-12T00:00:00.000',\n *       displayName: 'Last name',\n *       created: '2016-01-12T00:00:00.000',\n *       valueType: 'TEXT',\n *       attribute: 'zDhUuAYrxNC',\n *       value: 'Russell',\n *     },\n *     {\n *       lastUpdated: '2016-01-12T00:00:00.000',\n *       code: 'MMD_PER_NAM',\n *       displayName: 'First name',\n *       created: '2016-01-12T00:00:00.000',\n *       valueType: 'TEXT',\n *       attribute: 'w75KJ2mc4zz',\n *       value: 'Catherine',\n *     },\n *   ],\n * });\n * @example <caption>a dataSet</caption>\n * update('dataSets', 'lyLU2wR22tC', { name: 'OpenFN Data Set', periodType: 'Weekly' });\n * @example <caption>a dataSetNotification</caption>\n * update('dataSetNotificationTemplates', 'VbQBwdm1wVP', {\n *   dataSetNotificationTrigger: 'DATA_SET_COMPLETION',\n *   notificationRecipient: 'ORGANISATION_UNIT_CONTACT',\n *   name: 'Notification',\n *   messageTemplate: 'Hello Updated,\n *   deliveryChannels: ['SMS'],\n *   dataSets: [],\n * });\n * @example <caption>a dataElement</caption>\n * update('dataElements', 'FTRrcoaog83', {\n *   aggregationType: 'SUM',\n *   domainType: 'AGGREGATE',\n *   valueType: 'NUMBER',\n *   name: 'Paracetamol',\n *   shortName: 'Para',\n * });\n * @example <caption>a dataElementGroup</caption>\n * update('dataElementGroups', 'QrprHT61XFk', {\n *   name: 'Data Element Group 1',\n *   dataElements: [],\n * });\n * @example <caption>a dataElementGroupSet</caption>\n * update('dataElementGroupSets', 'VxWloRvAze8', {\n *   name: 'Data Element Group Set 4',\n *   dataDimension: true,\n *   shortName: 'DEGS4',\n *   dataElementGroups: [],\n * });\n * @example <caption>a dataValueSet</caption>\n * update('dataValueSets', 'AsQj6cDsUq4', {\n *   dataElement: 'f7n9E0hX8qk',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   value: '12',\n * });\n * @example <caption>a dataValueSet with related dataValues</caption>\n * update('dataValueSets', 'Ix2HsbDMLea', {\n *   dataSet: 'pBOMPrpg1QX',\n *   completeDate: '2014-02-03',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   dataValues: [\n *     {\n *       dataElement: 'f7n9E0hX8qk',\n *       value: '1',\n *     },\n *     {\n *       dataElement: 'Ix2HsbDMLea',\n *       value: '2',\n *     },\n *     {\n *       dataElement: 'eY5ehpbEsB7',\n *       value: '3',\n *     },\n *   ],\n * });\n * @example <caption>a single enrollment</caption>\n * update('enrollments', 'CmsHzercTBa' {\n *   trackedEntityInstance: 'bmshzEacgxa',\n *   orgUnit: 'TSyzvBiovKh',\n *   program: 'gZBxv9Ujxg0',\n *   enrollmentDate: '2013-10-17',\n *   incidentDate: '2013-10-17',\n * });\n */\nexport function update(\n  resourceType,\n  path,\n  data,\n  options = {},\n  callback = false\n) {\n  return state => {\n    console.log(`Preparing update operation...`);\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedData = expandReferences(data)(state);\n    const resolvedOptions = expandReferences(options)(state);\n\n    const { params, requestConfig } = resolvedOptions;\n    const { configuration } = state;\n\n    return request(configuration, {\n      method: 'put',\n      url: generateUrl(\n        configuration,\n        resolvedOptions,\n        resolvedResourceType,\n        path\n      ),\n      params,\n      data: resolvedData,\n      ...requestConfig,\n    }).then(result => {\n      console.log(`Updated ${resolvedResourceType} at ${resolvedPath}`);\n      return handleResponse(result, state, callback);\n    });\n  };\n}\n"
  },
  {
    "name": "get",
    "implementation": "import axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get data. Generic helper method for getting data of any kind from DHIS2.\n * - This can be used to get `DataValueSets`,`events`,`trackedEntityInstances`,`etc.`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to get(use its `plural` name). E.g. `dataElements`, `trackedEntityInstances`,`organisationUnits`, etc.\n * @param {Object} query - A query object that will limit what resources are retrieved when converted into request params.\n * @param {Object} [options] - Optional `options` to define URL parameters via params beyond filters, request configuration (e.g. `auth`) and DHIS2 api version to use.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation} state\n * @example <caption>all data values for the 'pBOMPrpg1QX' dataset</caption>\n * get('dataValueSets', {\n *   dataSet: 'pBOMPrpg1QX',\n *   orgUnit: 'DiszpKrYNg8',\n *   period: '201401',\n *   fields: '*',\n * });\n * @example <caption>all programs for an organization unit</caption>\n * get('programs', { orgUnit: 'TSyzvBiovKh', fields: '*' });\n * @example <caption>a single tracked entity instance by a unique external ID</caption>\n * get('trackedEntityInstances', {\n *   ou: 'DiszpKrYNg8',\n *   filter: ['flGbXLXCrEo:Eq:124', 'w75KJ2mc4zz:Eq:John'],\n * });\n */\nexport function get(resourceType, query, options = {}, callback = false) {\n  return state => {\n    console.log('Preparing get operation...');\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedQuery = expandReferences(query)(state);\n    const resolvedOptions = expandReferences(options)(state);\n\n    const { params, requestConfig } = resolvedOptions;\n    const { configuration } = state;\n\n    return request(configuration, {\n      method: 'get',\n      url: generateUrl(configuration, resolvedOptions, resolvedResourceType),\n      params: { ...resolvedQuery, ...params },\n      responseType: 'json',\n      ...requestConfig,\n    }).then(result => {\n      console.log(`Retrieved ${resolvedResourceType}`);\n      return handleResponse(result, state, callback);\n    });\n  };\n}",
    "signature": "/**\n * Get data. Generic helper method for getting data of any kind from DHIS2.\n * - This can be used to get `DataValueSets`,`events`,`trackedEntityInstances`,`etc.`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to get(use its `plural` name). E.g. `dataElements`, `trackedEntityInstances`,`organisationUnits`, etc.\n * @param {Object} query - A query object that will limit what resources are retrieved when converted into request params.\n * @param {Object} [options] - Optional `options` to define URL parameters via params beyond filters, request configuration (e.g. `auth`) and DHIS2 api version to use.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation} state\n * @example <caption>all data values for the 'pBOMPrpg1QX' dataset</caption>\n * get('dataValueSets', {\n *   dataSet: 'pBOMPrpg1QX',\n *   orgUnit: 'DiszpKrYNg8',\n *   period: '201401',\n *   fields: '*',\n * });\n * @example <caption>all programs for an organization unit</caption>\n * get('programs', { orgUnit: 'TSyzvBiovKh', fields: '*' });\n * @example <caption>a single tracked entity instance by a unique external ID</caption>\n * get('trackedEntityInstances', {\n *   ou: 'DiszpKrYNg8',\n *   filter: ['flGbXLXCrEo:Eq:124', 'w75KJ2mc4zz:Eq:John'],\n * });\n */\nexport function get(resourceType: string, query: any, options?: any, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets data from DHIS2.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets data from DHIS2.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get data. Generic helper method for getting data of any kind from DHIS2.\n * - This can be used to get `DataValueSets`,`events`,`trackedEntityInstances`,`etc.`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to get(use its `plural` name). E.g. `dataElements`, `trackedEntityInstances`,`organisationUnits`, etc.\n * @param {Object} query - A query object that will limit what resources are retrieved when converted into request params.\n * @param {Object} [options] - Optional `options` to define URL parameters via params beyond filters, request configuration (e.g. `auth`) and DHIS2 api version to use.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation} state\n * @example <caption>all data values for the 'pBOMPrpg1QX' dataset</caption>\n * get('dataValueSets', {\n *   dataSet: 'pBOMPrpg1QX',\n *   orgUnit: 'DiszpKrYNg8',\n *   period: '201401',\n *   fields: '*',\n * });\n * @example <caption>all programs for an organization unit</caption>\n * get('programs', { orgUnit: 'TSyzvBiovKh', fields: '*' });\n * @example <caption>a single tracked entity instance by a unique external ID</caption>\n * get('trackedEntityInstances', {\n *   ou: 'DiszpKrYNg8',\n *   filter: ['flGbXLXCrEo:Eq:124', 'w75KJ2mc4zz:Eq:John'],\n * });\n */\nexport function get(resourceType: string, query: any, options?: any, callback?: Function): Operation;\n\n### Implementation:\nimport axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get data. Generic helper method for getting data of any kind from DHIS2.\n * - This can be used to get `DataValueSets`,`events`,`trackedEntityInstances`,`etc.`\n * @public\n * @function\n * @param {string} resourceType - The type of resource to get(use its `plural` name). E.g. `dataElements`, `trackedEntityInstances`,`organisationUnits`, etc.\n * @param {Object} query - A query object that will limit what resources are retrieved when converted into request params.\n * @param {Object} [options] - Optional `options` to define URL parameters via params beyond filters, request configuration (e.g. `auth`) and DHIS2 api version to use.\n * @param {function} [callback]  - Optional callback to handle the response\n * @returns {Operation} state\n * @example <caption>all data values for the 'pBOMPrpg1QX' dataset</caption>\n * get('dataValueSets', {\n *   dataSet: 'pBOMPrpg1QX',\n *   orgUnit: 'DiszpKrYNg8',\n *   period: '201401',\n *   fields: '*',\n * });\n * @example <caption>all programs for an organization unit</caption>\n * get('programs', { orgUnit: 'TSyzvBiovKh', fields: '*' });\n * @example <caption>a single tracked entity instance by a unique external ID</caption>\n * get('trackedEntityInstances', {\n *   ou: 'DiszpKrYNg8',\n *   filter: ['flGbXLXCrEo:Eq:124', 'w75KJ2mc4zz:Eq:John'],\n * });\n */\nexport function get(resourceType, query, options = {}, callback = false) {\n  return state => {\n    console.log('Preparing get operation...');\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedQuery = expandReferences(query)(state);\n    const resolvedOptions = expandReferences(options)(state);\n\n    const { params, requestConfig } = resolvedOptions;\n    const { configuration } = state;\n\n    return request(configuration, {\n      method: 'get',\n      url: generateUrl(configuration, resolvedOptions, resolvedResourceType),\n      params: { ...resolvedQuery, ...params },\n      responseType: 'json',\n      ...requestConfig,\n    }).then(result => {\n      console.log(`Retrieved ${resolvedResourceType}`);\n      return handleResponse(result, state, callback);\n    });\n  };\n}\n"
  },
  {
    "name": "upsert",
    "implementation": "import axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert a record. A generic helper function used to atomically either insert a row, or on the basis of the row already existing, UPDATE that existing row instead.\n * @public\n * @function\n * @param {string} resourceType - The type of a resource to `upsert`. E.g. `trackedEntityInstances`\n * @param {Object} query - A query object that allows to uniquely identify the resource to update. If no matches found, then the resource will be created.\n * @param {Object} data - The data to use for update or create depending on the result of the query.\n * @param {{ apiVersion: object, requestConfig: object, params: object }} [options] - Optional configuration that will be applied to both the `get` and the `create` or `update` operations.\n * @param {function} [callback] - Optional callback to handle the response\n * @throws {RangeError} - Throws range error\n * @returns {Operation}\n * @example <caption>Example `expression.js` of upsert</caption>\n * upsert('trackedEntityInstances', {\n *  ou: 'TSyzvBiovKh',\n *  filter: ['w75KJ2mc4zz:Eq:Qassim'],\n * }, {\n *  orgUnit: 'TSyzvBiovKh',\n *  trackedEntityType: 'nEenWmSyUEp',\n *  attributes: [\n *    {\n *      attribute: 'w75KJ2mc4zz',\n *      value: 'Qassim',\n *    },\n *  ],\n * });\n */\nexport function upsert(\n  resourceType, // resourceType supplied to both the `get` and the `create/update`\n  query, // query supplied to the `get`\n  data, // data supplied to the `create/update`\n  options = {}, // options supplied to both the `get` and the `create/update`\n  callback = false // callback for the upsert itself.\n) {\n  return state => {\n    console.log(`Preparing upsert via 'get' then 'create' OR 'update'...`);\n\n    // NOTE: that these parameters are all expanded by the `get`, `create`, and\n    // `update`",
    "signature": "/**\n * Upsert a record. A generic helper function used to atomically either insert a row, or on the basis of the row already existing, UPDATE that existing row instead.\n * @public\n * @function\n * @param {string} resourceType - The type of a resource to `upsert`. E.g. `trackedEntityInstances`\n * @param {Object} query - A query object that allows to uniquely identify the resource to update. If no matches found, then the resource will be created.\n * @param {Object} data - The data to use for update or create depending on the result of the query.\n * @param {{ apiVersion: object, requestConfig: object, params: object }} [options] - Optional configuration that will be applied to both the `get` and the `create` or `update` operations.\n * @param {function} [callback] - Optional callback to handle the response\n * @throws {RangeError} - Throws range error\n * @returns {Operation}\n * @example <caption>Example `expression.js` of upsert</caption>\n * upsert('trackedEntityInstances', {\n *  ou: 'TSyzvBiovKh',\n *  filter: ['w75KJ2mc4zz:Eq:Qassim'],\n * }, {\n *  orgUnit: 'TSyzvBiovKh',\n *  trackedEntityType: 'nEenWmSyUEp',\n *  attributes: [\n *    {\n *      attribute: 'w75KJ2mc4zz',\n *      value: 'Qassim',\n *    },\n *  ],\n * });\n */\nexport function upsert(resourceType: string, query: any, data: any, options?: {\n    apiVersion: object;\n    requestConfig: object;\n    params: object;\n}, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts to/on/from a resource type.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts to/on/from a resource type.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Upsert a record. A generic helper function used to atomically either insert a row, or on the basis of the row already existing, UPDATE that existing row instead.\n * @public\n * @function\n * @param {string} resourceType - The type of a resource to `upsert`. E.g. `trackedEntityInstances`\n * @param {Object} query - A query object that allows to uniquely identify the resource to update. If no matches found, then the resource will be created.\n * @param {Object} data - The data to use for update or create depending on the result of the query.\n * @param {{ apiVersion: object, requestConfig: object, params: object }} [options] - Optional configuration that will be applied to both the `get` and the `create` or `update` operations.\n * @param {function} [callback] - Optional callback to handle the response\n * @throws {RangeError} - Throws range error\n * @returns {Operation}\n * @example <caption>Example `expression.js` of upsert</caption>\n * upsert('trackedEntityInstances', {\n *  ou: 'TSyzvBiovKh',\n *  filter: ['w75KJ2mc4zz:Eq:Qassim'],\n * }, {\n *  orgUnit: 'TSyzvBiovKh',\n *  trackedEntityType: 'nEenWmSyUEp',\n *  attributes: [\n *    {\n *      attribute: 'w75KJ2mc4zz',\n *      value: 'Qassim',\n *    },\n *  ],\n * });\n */\nexport function upsert(resourceType: string, query: any, data: any, options?: {\n    apiVersion: object;\n    requestConfig: object;\n    params: object;\n}, callback?: Function): Operation;\n\n### Implementation:\nimport axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Upsert a record. A generic helper function used to atomically either insert a row, or on the basis of the row already existing, UPDATE that existing row instead.\n * @public\n * @function\n * @param {string} resourceType - The type of a resource to `upsert`. E.g. `trackedEntityInstances`\n * @param {Object} query - A query object that allows to uniquely identify the resource to update. If no matches found, then the resource will be created.\n * @param {Object} data - The data to use for update or create depending on the result of the query.\n * @param {{ apiVersion: object, requestConfig: object, params: object }} [options] - Optional configuration that will be applied to both the `get` and the `create` or `update` operations.\n * @param {function} [callback] - Optional callback to handle the response\n * @throws {RangeError} - Throws range error\n * @returns {Operation}\n * @example <caption>Example `expression.js` of upsert</caption>\n * upsert('trackedEntityInstances', {\n *  ou: 'TSyzvBiovKh',\n *  filter: ['w75KJ2mc4zz:Eq:Qassim'],\n * }, {\n *  orgUnit: 'TSyzvBiovKh',\n *  trackedEntityType: 'nEenWmSyUEp',\n *  attributes: [\n *    {\n *      attribute: 'w75KJ2mc4zz',\n *      value: 'Qassim',\n *    },\n *  ],\n * });\n */\nexport function upsert(\n  resourceType, // resourceType supplied to both the `get` and the `create/update`\n  query, // query supplied to the `get`\n  data, // data supplied to the `create/update`\n  options = {}, // options supplied to both the `get` and the `create/update`\n  callback = false // callback for the upsert itself.\n) {\n  return state => {\n    console.log(`Preparing upsert via 'get' then 'create' OR 'update'...`);\n\n    // NOTE: that these parameters are all expanded by the `get`, `create`, and\n    // `update`\n"
  },
  {
    "name": "discover",
    "implementation": "import axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Discover `DHIS2` `api` `endpoint` `query parameters` and allowed `operators` for a given resource's endpoint.\n * @public\n * @function\n * @param {string} httpMethod - The HTTP to inspect parameter usage for a given endpoint, e.g., `get`, `post`,`put`,`patch`,`delete`\n * @param {string} endpoint - The path for a given endpoint. E.g. `/trackedEntityInstances` or `/dataValueSets`\n * @returns {Operation}\n * @example <caption>a list of parameters allowed on a given endpoint for specific http method</caption>\n * discover('post', '/trackedEntityInstances')\n */\nexport function discover(httpMethod, endpoint) {\n  return state => {\n    console.log(\n      `Discovering query/import parameters for ${httpMethod} on ${endpoint}`\n    );\n    return axios\n      .get(\n        'https://dhis2.github.io/dhis2-api-specification/spec/metadata_openapi.json',\n        {\n          transformResponse: [\n            data => {\n              let tempData = JSON.parse(data);\n              let filteredData = tempData.paths[endpoint][httpMethod];\n              return {\n                ...filteredData,\n                parameters: filteredData.parameters.reduce(\n                  (acc, currentValue) => {\n                    let index = currentValue['$ref'].lastIndexOf('/') + 1;\n                    let paramRef = currentValue['$ref'].slice(index);\n                    let param = tempData.components.parameters[paramRef];\n\n                    if (param.schema['$ref']) {\n                      let schemaRefIndex =\n                        param.schema['$ref'].lastIndexOf('/') + 1;\n                      let schemaRef =\n                        param.schema['$ref'].slice(schemaRefIndex);\n                      param.schema = tempData.components.schemas[schemaRef];\n                    }\n\n                    param.schema = JSON.stringify(param.schema);\n\n                    let descIndex;\n                    if (\n                      indexOf(param.description, ',') === -1 &&\n                      indexOf(param.description, '.') > -1\n                    )\n                      descIndex = indexOf(param.description, '.');\n                    else if (\n                      indexOf(param.description, ',') > -1 &&\n                      indexOf(param.description, '.') > -1\n                    ) {\n                      descIndex =\n                        indexOf(param.description, '.') <\n                        indexOf(param.description, ',')\n                          ? indexOf(param.description, '.')\n                          : indexOf(param.description, ',');\n                    } else {\n                      descIndex = param.description.length;\n                    }\n\n                    param.description = param.description.slice(0, descIndex);\n\n                    acc[paramRef] = param;\n                    return acc;\n                  },\n                  {}\n                ),\n              };\n            },\n          ],\n        }\n      )\n      .then(result => {\n        console.log(\n          `\\t=======================================================================================\\n\\tQuery Parameters for ${httpMethod} on ${endpoint} [${\n            result.data.description ?? '<description_missing>'\n          }]\\n\\t=======================================================================================`\n        );\n        console.table(result.data.parameters, [\n          'in',\n          'required',\n          'description',\n        ]);\n        console.table(result.data.parameters, ['schema']);\n        console.log(\n          `=========================================Responses===============================\\n${prettyJson(\n            result.data.responses\n          )}\\n=======================================================================================`\n        );\n        return { ...state, data: result.data };\n      });\n  };\n}",
    "signature": "/**\n * Discover `DHIS2` `api` `endpoint` `query parameters` and allowed `operators` for a given resource's endpoint.\n * @public\n * @function\n * @param {string} httpMethod - The HTTP to inspect parameter usage for a given endpoint, e.g., `get`, `post`,`put`,`patch`,`delete`\n * @param {string} endpoint - The path for a given endpoint. E.g. `/trackedEntityInstances` or `/dataValueSets`\n * @returns {Operation}\n * @example <caption>a list of parameters allowed on a given endpoint for specific http method</caption>\n * discover('post', '/trackedEntityInstances')\n */\nexport function discover(httpMethod: string, endpoint: string): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that discovers query parameters and allowed operators for a given DHIS2",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that discovers query parameters and allowed operators for a given DHIS2\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Discover `DHIS2` `api` `endpoint` `query parameters` and allowed `operators` for a given resource's endpoint.\n * @public\n * @function\n * @param {string} httpMethod - The HTTP to inspect parameter usage for a given endpoint, e.g., `get`, `post`,`put`,`patch`,`delete`\n * @param {string} endpoint - The path for a given endpoint. E.g. `/trackedEntityInstances` or `/dataValueSets`\n * @returns {Operation}\n * @example <caption>a list of parameters allowed on a given endpoint for specific http method</caption>\n * discover('post', '/trackedEntityInstances')\n */\nexport function discover(httpMethod: string, endpoint: string): Operation;\n\n### Implementation:\nimport axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Discover `DHIS2` `api` `endpoint` `query parameters` and allowed `operators` for a given resource's endpoint.\n * @public\n * @function\n * @param {string} httpMethod - The HTTP to inspect parameter usage for a given endpoint, e.g., `get`, `post`,`put`,`patch`,`delete`\n * @param {string} endpoint - The path for a given endpoint. E.g. `/trackedEntityInstances` or `/dataValueSets`\n * @returns {Operation}\n * @example <caption>a list of parameters allowed on a given endpoint for specific http method</caption>\n * discover('post', '/trackedEntityInstances')\n */\nexport function discover(httpMethod, endpoint) {\n  return state => {\n    console.log(\n      `Discovering query/import parameters for ${httpMethod} on ${endpoint}`\n    );\n    return axios\n      .get(\n        'https://dhis2.github.io/dhis2-api-specification/spec/metadata_openapi.json',\n        {\n          transformResponse: [\n            data => {\n              let tempData = JSON.parse(data);\n              let filteredData = tempData.paths[endpoint][httpMethod];\n              return {\n                ...filteredData,\n                parameters: filteredData.parameters.reduce(\n                  (acc, currentValue) => {\n                    let index = currentValue['$ref'].lastIndexOf('/') + 1;\n                    let paramRef = currentValue['$ref'].slice(index);\n                    let param = tempData.components.parameters[paramRef];\n\n                    if (param.schema['$ref']) {\n                      let schemaRefIndex =\n                        param.schema['$ref'].lastIndexOf('/') + 1;\n                      let schemaRef =\n                        param.schema['$ref'].slice(schemaRefIndex);\n                      param.schema = tempData.components.schemas[schemaRef];\n                    }\n\n                    param.schema = JSON.stringify(param.schema);\n\n                    let descIndex;\n                    if (\n                      indexOf(param.description, ',') === -1 &&\n                      indexOf(param.description, '.') > -1\n                    )\n                      descIndex = indexOf(param.description, '.');\n                    else if (\n                      indexOf(param.description, ',') > -1 &&\n                      indexOf(param.description, '.') > -1\n                    ) {\n                      descIndex =\n                        indexOf(param.description, '.') <\n                        indexOf(param.description, ',')\n                          ? indexOf(param.description, '.')\n                          : indexOf(param.description, ',');\n                    } else {\n                      descIndex = param.description.length;\n                    }\n\n                    param.description = param.description.slice(0, descIndex);\n\n                    acc[paramRef] = param;\n                    return acc;\n                  },\n                  {}\n                ),\n              };\n            },\n          ],\n        }\n      )\n      .then(result => {\n        console.log(\n          `\\t=======================================================================================\\n\\tQuery Parameters for ${httpMethod} on ${endpoint} [${\n            result.data.description ?? '<description_missing>'\n          }]\\n\\t=======================================================================================`\n        );\n        console.table(result.data.parameters, [\n          'in',\n          'required',\n          'description',\n        ]);\n        console.table(result.data.parameters, ['schema']);\n        console.log(\n          `=========================================Responses===============================\\n${prettyJson(\n            result.data.responses\n          )}\\n=======================================================================================`\n        );\n        return { ...state, data: result.data };\n      });\n  };\n}\n"
  },
  {
    "name": "destroy",
    "implementation": "import axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Patch a record. A generic helper function to send partial updates on one or more object properties.\n * - You are not required to send the full body of object properties.\n * - This is useful for cases where you don't want or need to update all properties on a object.\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be updated. E.g. `dataElements`, `organisationUnits`, etc.\n * @param {string} path - The `id` or `path` to the `object` to be updated. E.g. `FTRrcoaog83` or `FTRrcoaog83/{collection-name}/{object-id}`\n * @param {Object} data - Data to update. Include only the fields you want to update. E.g. `{name: \"New Name\"}`\n * @param {Object} [options] - Optional configuration, including params for the update ({preheatCache: true, strategy: 'UPDATE', mergeMode: 'REPLACE'}). Defaults to `{operationName: 'patch', apiVersion: state.configuration.apiVersion, responseType: 'json'}`\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a dataElement</caption>\n * patch('dataElements', 'FTRrcoaog83', { name: 'New Name' });\n */\n// TODO: @Elias, can this be deleted in favor of update? How does DHIS2 handle PATCH vs PUT?\n// I need to investigate on this. But I think DHIS2 forces to send all properties back when we do an update. If that's confirmed then this may be needed.\nexport function patch(\n  resourceType,\n  path,\n  data,\n  options = {},\n  callback = false\n) {\n  return state => {\n    console.log('Preparing patch operation...');\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedData = expandReferences(data)(state);\n    const resolvedOptions = expandReferences(options)(state);\n\n    const { params, requestConfig } = resolvedOptions;\n    const { configuration } = state;\n\n    return request(configuration, {\n      method: 'patch',\n      url: generateUrl(\n        configuration,\n        resolvedOptions,\n        resolvedResourceType,\n        resolvedPath\n      ),\n      params,\n      data: resolvedData,\n      ...requestConfig,\n    }).then(result => {\n      console.log(`Patched ${resolvedResourceType} at ${resolvedPath}`);\n      return handleResponse(result, state, callback);\n    });\n  };\n}\n\n/**\n * Delete a record. A generic helper function to delete an object\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be deleted. E.g. `trackedEntityInstances`, `organisationUnits`, etc.\n * @param {string} path - Can be an `id` of an `object` or `path` to the `nested object` to `delete`.\n * @param {Object} [data] - Optional. This is useful when you want to remove multiple objects from a collection in one request. You can send `data` as, for example, `{\"identifiableObjects\": [{\"id\": \"IDA\"}, {\"id\": \"IDB\"}, {\"id\": \"IDC\"}]}`. See more {@link https://docs.dhis2.org/2.34/en/dhis2_developer_manual/web-api.html#deleting-objects on DHIS2 API docs}\n * @param {{apiVersion: number,operationName: string,resourceType: string}} [options] - Optional `options` for `del` operation including params e.g. `{preheatCache: true, strategy: 'UPDATE', mergeMode: 'REPLACE'}`. Run `discover` or see {@link https://docs.dhis2.org/2.34/en/dhis2_developer_manual/web-api.html#create-update-parameters DHIS2 documentation}. Defaults to `{operationName: 'delete', apiVersion: state.configuration.apiVersion, responseType: 'json'}`\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a tracked entity instance</caption>\n * destroy('trackedEntityInstances', 'LcRd6Nyaq7T');\n */\nexport function destroy(\n  resourceType,\n  path,\n  data = null,\n  options = {},\n  callback = false\n) {\n  return state => {\n    console.log('Preparing destroy operation...');\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedData = expandReferences(data)(state);\n    const resolvedOptions = expandReferences(options)(state);\n\n    const { params, requestConfig } = resolvedOptions;\n    const { configuration } = state;\n\n    return request({\n      method: 'delete',\n      url: generateUrl(\n        configuration,\n        resolvedOptions,\n        resolvedResourceType,\n        resolvedPath\n      ),\n      params,\n      resolvedData,\n      ...requestConfig,\n    }).then(result => {\n      console.log(`Deleted ${resolvedResourceType} at ${resolvedPath}`);\n      return handleResponse(result, state, callback);\n    });\n  };\n}",
    "signature": "/**\n * Delete a record. A generic helper function to delete an object\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be deleted. E.g. `trackedEntityInstances`, `organisationUnits`, etc.\n * @param {string} path - Can be an `id` of an `object` or `path` to the `nested object` to `delete`.\n * @param {Object} [data] - Optional. This is useful when you want to remove multiple objects from a collection in one request. You can send `data` as, for example, `{\"identifiableObjects\": [{\"id\": \"IDA\"}, {\"id\": \"IDB\"}, {\"id\": \"IDC\"}]}`. See more {@link https://docs.dhis2.org/2.34/en/dhis2_developer_manual/web-api.html#deleting-objects on DHIS2 API docs}\n * @param {{apiVersion: number,operationName: string,resourceType: string}} [options] - Optional `options` for `del` operation including params e.g. `{preheatCache: true, strategy: 'UPDATE', mergeMode: 'REPLACE'}`. Run `discover` or see {@link https://docs.dhis2.org/2.34/en/dhis2_developer_manual/web-api.html#create-update-parameters DHIS2 documentation}. Defaults to `{operationName: 'delete', apiVersion: state.configuration.apiVersion, responseType: 'json'}`\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a tracked entity instance</caption>\n * destroy('trackedEntityInstances', 'LcRd6Nyaq7T');\n */\nexport function destroy(resourceType: string, path: string, data?: any, options?: {\n    apiVersion: number;\n    operationName: string;\n    resourceType: string;\n}, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that deletes a record from a resource type.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that deletes a record from a resource type.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Delete a record. A generic helper function to delete an object\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be deleted. E.g. `trackedEntityInstances`, `organisationUnits`, etc.\n * @param {string} path - Can be an `id` of an `object` or `path` to the `nested object` to `delete`.\n * @param {Object} [data] - Optional. This is useful when you want to remove multiple objects from a collection in one request. You can send `data` as, for example, `{\"identifiableObjects\": [{\"id\": \"IDA\"}, {\"id\": \"IDB\"}, {\"id\": \"IDC\"}]}`. See more {@link https://docs.dhis2.org/2.34/en/dhis2_developer_manual/web-api.html#deleting-objects on DHIS2 API docs}\n * @param {{apiVersion: number,operationName: string,resourceType: string}} [options] - Optional `options` for `del` operation including params e.g. `{preheatCache: true, strategy: 'UPDATE', mergeMode: 'REPLACE'}`. Run `discover` or see {@link https://docs.dhis2.org/2.34/en/dhis2_developer_manual/web-api.html#create-update-parameters DHIS2 documentation}. Defaults to `{operationName: 'delete', apiVersion: state.configuration.apiVersion, responseType: 'json'}`\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a tracked entity instance</caption>\n * destroy('trackedEntityInstances', 'LcRd6Nyaq7T');\n */\nexport function destroy(resourceType: string, path: string, data?: any, options?: {\n    apiVersion: number;\n    operationName: string;\n    resourceType: string;\n}, callback?: Function): Operation;\n\n### Implementation:\nimport axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Patch a record. A generic helper function to send partial updates on one or more object properties.\n * - You are not required to send the full body of object properties.\n * - This is useful for cases where you don't want or need to update all properties on a object.\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be updated. E.g. `dataElements`, `organisationUnits`, etc.\n * @param {string} path - The `id` or `path` to the `object` to be updated. E.g. `FTRrcoaog83` or `FTRrcoaog83/{collection-name}/{object-id}`\n * @param {Object} data - Data to update. Include only the fields you want to update. E.g. `{name: \"New Name\"}`\n * @param {Object} [options] - Optional configuration, including params for the update ({preheatCache: true, strategy: 'UPDATE', mergeMode: 'REPLACE'}). Defaults to `{operationName: 'patch', apiVersion: state.configuration.apiVersion, responseType: 'json'}`\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a dataElement</caption>\n * patch('dataElements', 'FTRrcoaog83', { name: 'New Name' });\n */\n// TODO: @Elias, can this be deleted in favor of update? How does DHIS2 handle PATCH vs PUT?\n// I need to investigate on this. But I think DHIS2 forces to send all properties back when we do an update. If that's confirmed then this may be needed.\nexport function patch(\n  resourceType,\n  path,\n  data,\n  options = {},\n  callback = false\n) {\n  return state => {\n    console.log('Preparing patch operation...');\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedData = expandReferences(data)(state);\n    const resolvedOptions = expandReferences(options)(state);\n\n    const { params, requestConfig } = resolvedOptions;\n    const { configuration } = state;\n\n    return request(configuration, {\n      method: 'patch',\n      url: generateUrl(\n        configuration,\n        resolvedOptions,\n        resolvedResourceType,\n        resolvedPath\n      ),\n      params,\n      data: resolvedData,\n      ...requestConfig,\n    }).then(result => {\n      console.log(`Patched ${resolvedResourceType} at ${resolvedPath}`);\n      return handleResponse(result, state, callback);\n    });\n  };\n}\n\n/**\n * Delete a record. A generic helper function to delete an object\n * @public\n * @function\n * @param {string} resourceType - The type of resource to be deleted. E.g. `trackedEntityInstances`, `organisationUnits`, etc.\n * @param {string} path - Can be an `id` of an `object` or `path` to the `nested object` to `delete`.\n * @param {Object} [data] - Optional. This is useful when you want to remove multiple objects from a collection in one request. You can send `data` as, for example, `{\"identifiableObjects\": [{\"id\": \"IDA\"}, {\"id\": \"IDB\"}, {\"id\": \"IDC\"}]}`. See more {@link https://docs.dhis2.org/2.34/en/dhis2_developer_manual/web-api.html#deleting-objects on DHIS2 API docs}\n * @param {{apiVersion: number,operationName: string,resourceType: string}} [options] - Optional `options` for `del` operation including params e.g. `{preheatCache: true, strategy: 'UPDATE', mergeMode: 'REPLACE'}`. Run `discover` or see {@link https://docs.dhis2.org/2.34/en/dhis2_developer_manual/web-api.html#create-update-parameters DHIS2 documentation}. Defaults to `{operationName: 'delete', apiVersion: state.configuration.apiVersion, responseType: 'json'}`\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a tracked entity instance</caption>\n * destroy('trackedEntityInstances', 'LcRd6Nyaq7T');\n */\nexport function destroy(\n  resourceType,\n  path,\n  data = null,\n  options = {},\n  callback = false\n) {\n  return state => {\n    console.log('Preparing destroy operation...');\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedData = expandReferences(data)(state);\n    const resolvedOptions = expandReferences(options)(state);\n\n    const { params, requestConfig } = resolvedOptions;\n    const { configuration } = state;\n\n    return request({\n      method: 'delete',\n      url: generateUrl(\n        configuration,\n        resolvedOptions,\n        resolvedResourceType,\n        resolvedPath\n      ),\n      params,\n      resolvedData,\n      ...requestConfig,\n    }).then(result => {\n      console.log(`Deleted ${resolvedResourceType} at ${resolvedPath}`);\n      return handleResponse(result, state, callback);\n    });\n  };\n}\n"
  },
  {
    "name": "findAttributeValue",
    "implementation": "import axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Gets an attribute value by its case-insensitive display name\n * @public\n * @example\n * findAttributeValue(state.data.trackedEntityInstances[0], 'first name')\n * @function\n * @param {Object} trackedEntityInstance - A tracked entity instance (TEI) object\n * @param {string} attributeDisplayName - The 'displayName' to search for in the TEI's attributes\n * @returns {string}\n */\nexport function findAttributeValue(\n  trackedEntityInstance,\n  attributeDisplayName\n) {\n  return trackedEntityInstance?.attributes?.find(\n    a => a?.displayName.toLowerCase() == attributeDisplayName.toLowerCase()\n  )?.value;\n}",
    "signature": "/**\n * Gets an attribute value by its case-insensitive display name\n * @public\n * @example\n * findAttributeValue(state.data.trackedEntityInstances[0], 'first name')\n * @function\n * @param {Object} trackedEntityInstance - A tracked entity instance (TEI) object\n * @param {string} attributeDisplayName - The 'displayName' to search for in the TEI's attributes\n * @returns {string}\n */\nexport function findAttributeValue(trackedEntityInstance: any, attributeDisplayName: string): string;",
    "test": "",
    "instruction": "Create an OpenFn function that finds an attribute value from a tracked entity instance object by its",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that finds an attribute value from a tracked entity instance object by its\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Gets an attribute value by its case-insensitive display name\n * @public\n * @example\n * findAttributeValue(state.data.trackedEntityInstances[0], 'first name')\n * @function\n * @param {Object} trackedEntityInstance - A tracked entity instance (TEI) object\n * @param {string} attributeDisplayName - The 'displayName' to search for in the TEI's attributes\n * @returns {string}\n */\nexport function findAttributeValue(trackedEntityInstance: any, attributeDisplayName: string): string;\n\n### Implementation:\nimport axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Gets an attribute value by its case-insensitive display name\n * @public\n * @example\n * findAttributeValue(state.data.trackedEntityInstances[0], 'first name')\n * @function\n * @param {Object} trackedEntityInstance - A tracked entity instance (TEI) object\n * @param {string} attributeDisplayName - The 'displayName' to search for in the TEI's attributes\n * @returns {string}\n */\nexport function findAttributeValue(\n  trackedEntityInstance,\n  attributeDisplayName\n) {\n  return trackedEntityInstance?.attributes?.find(\n    a => a?.displayName.toLowerCase() == attributeDisplayName.toLowerCase()\n  )?.value;\n}\n"
  },
  {
    "name": "attr",
    "implementation": "import axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Converts an attribute ID and value into a DSHI2 attribute object\n * @public\n * @example\n * attr('w75KJ2mc4zz', 'Elias')\n * @function\n * @param {string} attribute - A tracked entity instance (TEI) attribute ID.\n * @param {string} value - The value for that attribute.\n * @returns {object}\n */\nexport function attr(attribute, value) {\n  return { attribute, value };\n}",
    "signature": "/**\n * Converts an attribute ID and value into a DSHI2 attribute object\n * @public\n * @example\n * attr('w75KJ2mc4zz', 'Elias')\n * @function\n * @param {string} attribute - A tracked entity instance (TEI) attribute ID.\n * @param {string} value - The value for that attribute.\n * @returns {object}\n */\nexport function attr(attribute: string, value: string): object;",
    "test": "",
    "instruction": "Create an OpenFn function that converts an attribute ID and value into a DSHI2",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that converts an attribute ID and value into a DSHI2\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Converts an attribute ID and value into a DSHI2 attribute object\n * @public\n * @example\n * attr('w75KJ2mc4zz', 'Elias')\n * @function\n * @param {string} attribute - A tracked entity instance (TEI) attribute ID.\n * @param {string} value - The value for that attribute.\n * @returns {object}\n */\nexport function attr(attribute: string, value: string): object;\n\n### Implementation:\nimport axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Converts an attribute ID and value into a DSHI2 attribute object\n * @public\n * @example\n * attr('w75KJ2mc4zz', 'Elias')\n * @function\n * @param {string} attribute - A tracked entity instance (TEI) attribute ID.\n * @param {string} value - The value for that attribute.\n * @returns {object}\n */\nexport function attr(attribute, value) {\n  return { attribute, value };\n}\n"
  },
  {
    "name": "dv",
    "implementation": "import axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Converts a dataElement and value into a DSHI2 dataValue object\n * @public\n * @example\n * dv('f7n9E0hX8qk', 12)\n * @function\n * @param {string} dataElement - A data element ID.\n * @param {string} value - The value for that data element.\n * @returns {object}\n */\nexport function dv(dataElement, value) {\n  return { dataElement, value };\n}",
    "signature": "/**\n * Converts a dataElement and value into a DSHI2 dataValue object\n * @public\n * @example\n * dv('f7n9E0hX8qk', 12)\n * @function\n * @param {string} dataElement - A data element ID.\n * @param {string} value - The value for that data element.\n * @returns {object}\n */\nexport function dv(dataElement: string, value: string): object;",
    "test": "",
    "instruction": "Create an OpenFn function that converts a dataElement and value into a DSHI2",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that converts a dataElement and value into a DSHI2\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Converts a dataElement and value into a DSHI2 dataValue object\n * @public\n * @example\n * dv('f7n9E0hX8qk', 12)\n * @function\n * @param {string} dataElement - A data element ID.\n * @param {string} value - The value for that data element.\n * @returns {object}\n */\nexport function dv(dataElement: string, value: string): object;\n\n### Implementation:\nimport axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Converts a dataElement and value into a DSHI2 dataValue object\n * @public\n * @example\n * dv('f7n9E0hX8qk', 12)\n * @function\n * @param {string} dataElement - A data element ID.\n * @param {string} value - The value for that data element.\n * @returns {object}\n */\nexport function dv(dataElement, value) {\n  return { dataElement, value };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "\n/**\n * Execute a sequence of operations.\n * Main outer API for executing expressions.\n * @public\n * @example\n *  execute(\n *    create('foo'),\n *    delete('bar')\n *  )\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Promise}\n */\nexport function execute(...operations) {\n  return state => {\n    const start = Promise.resolve(state);\n\n    return operations.reduce((acc, operation) => {\n      return acc.then(operation);\n    }, start);\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Main outer API for executing expressions.\n * @public\n * @example\n *  execute(\n *    create('foo'),\n *    delete('bar')\n *  )\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Promise}\n */\nexport function execute(...operations: Operations): Promise<any>;",
    "test": "",
    "instruction": "Create an OpenFn function that executes operations to/on/from Operations.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes operations to/on/from Operations.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Main outer API for executing expressions.\n * @public\n * @example\n *  execute(\n *    create('foo'),\n *    delete('bar')\n *  )\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Promise}\n */\nexport function execute(...operations: Operations): Promise<any>;\n\n### Implementation:\n\n/**\n * Execute a sequence of operations.\n * Main outer API for executing expressions.\n * @public\n * @example\n *  execute(\n *    create('foo'),\n *    delete('bar')\n *  )\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Promise}\n */\nexport function execute(...operations) {\n  return state => {\n    const start = Promise.resolve(state);\n\n    return operations.reduce((acc, operation) => {\n      return acc.then(operation);\n    }, start);\n  };\n}\n"
  },
  {
    "name": "alterState",
    "implementation": "\n/**\n * alias for \"fn()\"\n * @function\n * @param {Function} func is the function\n * @returns {Operation}\n */\nexport function alterState(func) {\n  return fn(func);\n}",
    "signature": "/**\n * alias for \"fn()\"\n * @function\n * @param {Function} func is the function\n * @returns {Operation}\n */\nexport function alterState(func: Function): Operation;",
    "test": "",
    "instruction": "create an OpenFn function that alters state from a function.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\ncreate an OpenFn function that alters state from a function.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * alias for \"fn()\"\n * @function\n * @param {Function} func is the function\n * @returns {Operation}\n */\nexport function alterState(func: Function): Operation;\n\n### Implementation:\n\n/**\n * alias for \"fn()\"\n * @function\n * @param {Function} func is the function\n * @returns {Operation}\n */\nexport function alterState(func) {\n  return fn(func);\n}\n"
  },
  {
    "name": "fn",
    "implementation": "\n/**\n * Creates a custom step (or operation) for more flexible job writing.\n * @public\n * @example\n * fn(state => {\n *   // do some things to state\n *   return state;\n * });\n * @function\n * @param {Function} func is the function\n * @returns {Operation}\n */\nexport function fn(func) {\n  return state => {\n    return func(state);\n  };\n}",
    "signature": "/**\n * Creates a custom step (or operation) for more flexible job writing.\n * @public\n * @example\n * fn(state => {\n *   // do some things to state\n *   return state;\n * });\n * @function\n * @param {Function} func is the function\n * @returns {Operation}\n */\nexport function fn(func: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that does some things to state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that does some things to state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Creates a custom step (or operation) for more flexible job writing.\n * @public\n * @example\n * fn(state => {\n *   // do some things to state\n *   return state;\n * });\n * @function\n * @param {Function} func is the function\n * @returns {Operation}\n */\nexport function fn(func: Function): Operation;\n\n### Implementation:\n\n/**\n * Creates a custom step (or operation) for more flexible job writing.\n * @public\n * @example\n * fn(state => {\n *   // do some things to state\n *   return state;\n * });\n * @function\n * @param {Function} func is the function\n * @returns {Operation}\n */\nexport function fn(func) {\n  return state => {\n    return func(state);\n  };\n}\n"
  },
  {
    "name": "jsonValue",
    "implementation": "\n/**\n * Picks out a single value from a JSON object.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * jsonValue({ a:1 }, 'a')\n * @function\n * @param {object} obj - A valid JSON object.\n * @param {String} path - JSONPath referencing a point in given JSON object.\n * @returns {Operation}\n */\nexport function jsonValue(obj, path) {\n  return JSONPath({ path, json: obj })[0];\n}",
    "signature": "/**\n * Picks out a single value from a JSON object.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * jsonValue({ a:1 }, 'a')\n * @function\n * @param {object} obj - A valid JSON object.\n * @param {String} path - JSONPath referencing a point in given JSON object.\n * @returns {Operation}\n */\nexport function jsonValue(obj: object, path: string): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that picks out a single value from a JSON object.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that picks out a single value from a JSON object.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Picks out a single value from a JSON object.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * jsonValue({ a:1 }, 'a')\n * @function\n * @param {object} obj - A valid JSON object.\n * @param {String} path - JSONPath referencing a point in given JSON object.\n * @returns {Operation}\n */\nexport function jsonValue(obj: object, path: string): Operation;\n\n### Implementation:\n\n/**\n * Picks out a single value from a JSON object.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * jsonValue({ a:1 }, 'a')\n * @function\n * @param {object} obj - A valid JSON object.\n * @param {String} path - JSONPath referencing a point in given JSON object.\n * @returns {Operation}\n */\nexport function jsonValue(obj, path) {\n  return JSONPath({ path, json: obj })[0];\n}\n"
  },
  {
    "name": "sourceValue",
    "implementation": "\n/**\n * Picks out a single value from source data.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * sourceValue('$.key')\n * @function\n * @param {String} path - JSONPath referencing a point in `state`.\n * @returns {Operation}\n */\nexport function sourceValue(path) {\n  return state => {\n    return JSONPath({ path, json: state })[0];\n  };\n}",
    "signature": "/**\n * Picks out a single value from source data.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * sourceValue('$.key')\n * @function\n * @param {String} path - JSONPath referencing a point in `state`.\n * @returns {Operation}\n */\nexport function sourceValue(path: string): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that picks out a single value from source data.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that picks out a single value from source data.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Picks out a single value from source data.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * sourceValue('$.key')\n * @function\n * @param {String} path - JSONPath referencing a point in `state`.\n * @returns {Operation}\n */\nexport function sourceValue(path: string): Operation;\n\n### Implementation:\n\n/**\n * Picks out a single value from source data.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * sourceValue('$.key')\n * @function\n * @param {String} path - JSONPath referencing a point in `state`.\n * @returns {Operation}\n */\nexport function sourceValue(path) {\n  return state => {\n    return JSONPath({ path, json: state })[0];\n  };\n}\n"
  },
  {
    "name": "source",
    "implementation": "\n/**\n * Picks out a value from source data.\n * Will return whatever JSONPath returns, which will always be an array.\n * If you need a single value use `sourceValue` instead.\n * @public\n * @example\n * source('$.key')\n * @function\n * @param {String} path - JSONPath referencing a point in `state`.\n * @returns {Array.<String|Object>}\n */\nexport function source(path) {\n  return state => {\n    return JSONPath({ path, json: state });\n  };\n}",
    "signature": "/**\n * Picks out a value from source data.\n * Will return whatever JSONPath returns, which will always be an array.\n * If you need a single value use `sourceValue` instead.\n * @public\n * @example\n * source('$.key')\n * @function\n * @param {String} path - JSONPath referencing a point in `state`.\n * @returns {Array.<String|Object>}\n */\nexport function source(path: string): Array<string | any>;",
    "test": "",
    "instruction": "Create an OpenFn function that picks out a value from source data.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that picks out a value from source data.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Picks out a value from source data.\n * Will return whatever JSONPath returns, which will always be an array.\n * If you need a single value use `sourceValue` instead.\n * @public\n * @example\n * source('$.key')\n * @function\n * @param {String} path - JSONPath referencing a point in `state`.\n * @returns {Array.<String|Object>}\n */\nexport function source(path: string): Array<string | any>;\n\n### Implementation:\n\n/**\n * Picks out a value from source data.\n * Will return whatever JSONPath returns, which will always be an array.\n * If you need a single value use `sourceValue` instead.\n * @public\n * @example\n * source('$.key')\n * @function\n * @param {String} path - JSONPath referencing a point in `state`.\n * @returns {Array.<String|Object>}\n */\nexport function source(path) {\n  return state => {\n    return JSONPath({ path, json: state });\n  };\n}\n"
  },
  {
    "name": "dataPath",
    "implementation": "\n/**\n * Ensures a path points at the data.\n * @public\n * @example\n * dataPath('key')\n * @function\n * @param {string} path - JSONPath referencing a point in `data`.\n * @returns {string}\n */\nexport function dataPath(path) {\n  // Remove prepending `$.`, `$` or `.`, in order to ensure the root of the\n  // path starts with `$.data.`\n  const cleanPath = path.match(/^[\\$\\.]*(.+)/)[1];\n  return '$.data.'.concat(cleanPath);\n}",
    "signature": "/**\n * Ensures a path points at the data.\n * @public\n * @example\n * dataPath('key')\n * @function\n * @param {string} path - JSONPath referencing a point in `data`.\n * @returns {string}\n */\nexport function dataPath(path: string): string;",
    "test": "",
    "instruction": "Create an OpenFn function that references a point in 'data' from a JSONPath.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that references a point in 'data' from a JSONPath.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Ensures a path points at the data.\n * @public\n * @example\n * dataPath('key')\n * @function\n * @param {string} path - JSONPath referencing a point in `data`.\n * @returns {string}\n */\nexport function dataPath(path: string): string;\n\n### Implementation:\n\n/**\n * Ensures a path points at the data.\n * @public\n * @example\n * dataPath('key')\n * @function\n * @param {string} path - JSONPath referencing a point in `data`.\n * @returns {string}\n */\nexport function dataPath(path) {\n  // Remove prepending `$.`, `$` or `.`, in order to ensure the root of the\n  // path starts with `$.data.`\n  const cleanPath = path.match(/^[\\$\\.]*(.+)/)[1];\n  return '$.data.'.concat(cleanPath);\n}\n"
  },
  {
    "name": "dataValue",
    "implementation": "\n/**\n * Picks out a single value from the source data object\u2014usually `state.data`.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * dataValue('key')\n * @function\n * @param {String} path - JSONPath referencing a point in `data`.\n * @returns {Operation}\n */\nexport function dataValue(path) {\n  return sourceValue(dataPath(path));\n}",
    "signature": "/**\n * Picks out a single value from the source data object\u2014usually `state.data`.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * dataValue('key')\n * @function\n * @param {String} path - JSONPath referencing a point in `data`.\n * @returns {Operation}\n */\nexport function dataValue(path: string): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that picks out a single value from the source data object using a",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that picks out a single value from the source data object using a\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Picks out a single value from the source data object\u2014usually `state.data`.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * dataValue('key')\n * @function\n * @param {String} path - JSONPath referencing a point in `data`.\n * @returns {Operation}\n */\nexport function dataValue(path: string): Operation;\n\n### Implementation:\n\n/**\n * Picks out a single value from the source data object\u2014usually `state.data`.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * dataValue('key')\n * @function\n * @param {String} path - JSONPath referencing a point in `data`.\n * @returns {Operation}\n */\nexport function dataValue(path) {\n  return sourceValue(dataPath(path));\n}\n"
  },
  {
    "name": "referencePath",
    "implementation": "\n/**\n * Ensures a path points at references.\n * @public\n * @example\n * referencePath('key')\n * @function\n * @param {string} path - JSONPath referencing a point in `references`.\n * @returns {string}\n */\nexport function referencePath(path) {\n  // Remove prepending `$.`, `$` or `.`, in order to ensure the root of the\n  // path starts with `$.data.`\n  const cleanPath = path.match(/^[\\$\\.]*(.+)/)[1];\n  return '$.references'.concat(cleanPath);\n}",
    "signature": "/**\n * Ensures a path points at references.\n * @public\n * @example\n * referencePath('key')\n * @function\n * @param {string} path - JSONPath referencing a point in `references`.\n * @returns {string}\n */\nexport function referencePath(path: string): string;",
    "test": "",
    "instruction": "Create an OpenFn function that references a path from 'references'.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that references a path from 'references'.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Ensures a path points at references.\n * @public\n * @example\n * referencePath('key')\n * @function\n * @param {string} path - JSONPath referencing a point in `references`.\n * @returns {string}\n */\nexport function referencePath(path: string): string;\n\n### Implementation:\n\n/**\n * Ensures a path points at references.\n * @public\n * @example\n * referencePath('key')\n * @function\n * @param {string} path - JSONPath referencing a point in `references`.\n * @returns {string}\n */\nexport function referencePath(path) {\n  // Remove prepending `$.`, `$` or `.`, in order to ensure the root of the\n  // path starts with `$.data.`\n  const cleanPath = path.match(/^[\\$\\.]*(.+)/)[1];\n  return '$.references'.concat(cleanPath);\n}\n"
  },
  {
    "name": "lastReferenceValue",
    "implementation": "\n/**\n * Picks out the last reference value from source data.\n * @public\n * @example\n * lastReferenceValue('key')\n * @function\n * @param {String} path - JSONPath referencing a point in `references`.\n * @returns {Operation}\n */\nexport function lastReferenceValue(path) {\n  const lastReferencePath = referencePath('[0]'.concat('.', path));\n\n  return sourceValue(lastReferencePath);\n}",
    "signature": "/**\n * Picks out the last reference value from source data.\n * @public\n * @example\n * lastReferenceValue('key')\n * @function\n * @param {String} path - JSONPath referencing a point in `references`.\n * @returns {Operation}\n */\nexport function lastReferenceValue(path: string): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that picks out the last reference value from source data.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that picks out the last reference value from source data.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Picks out the last reference value from source data.\n * @public\n * @example\n * lastReferenceValue('key')\n * @function\n * @param {String} path - JSONPath referencing a point in `references`.\n * @returns {Operation}\n */\nexport function lastReferenceValue(path: string): Operation;\n\n### Implementation:\n\n/**\n * Picks out the last reference value from source data.\n * @public\n * @example\n * lastReferenceValue('key')\n * @function\n * @param {String} path - JSONPath referencing a point in `references`.\n * @returns {Operation}\n */\nexport function lastReferenceValue(path) {\n  const lastReferencePath = referencePath('[0]'.concat('.', path));\n\n  return sourceValue(lastReferencePath);\n}\n"
  },
  {
    "name": "asData",
    "implementation": "\n/**\n * Scopes an array of data based on a JSONPath.\n * Useful when the source data has `n` items you would like to map to\n * an operation.\n * The operation will receive a slice of the data based of each item\n * of the JSONPath provided.\n * @public\n * @example\n * map(\"$.[*]\",\n *   create(\"SObject\",\n *     field(\"FirstName\", sourceValue(\"$.firstName\"))\n *   )\n * )\n * @function\n * @param {string} path - JSONPath referencing a point in `state.data`.\n * @param {function} operation - The operation needed to be repeated.\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nexport const map = curry(function (path, operation, state) {\n  switch (typeof path) {\n    case 'string':\n      source(path)(state).map(function (data) {\n        return operation({ data, references: state.references });\n      });\n      return state;\n\n    case 'object':\n      path.map(function (data) {\n        return operation({ data, references: state.references });\n      });\n      return state;\n  }\n});\n\n/**\n * Simple switcher allowing other expressions to use either a JSONPath or\n * object literals as a data source.\n * - JSONPath referencing a point in `state`\n * - Object Literal of the data itself.\n * - Function to be called with state.\n * @public\n * @example\n * asData('$.key'| key | callback)\n * @function\n * @param {String|object|function} data\n * @param {object} state - The current state.\n * @returns {array}\n */\nexport function asData(data, state) {\n  switch (typeof data) {\n    case 'string':\n      return source(data)(state);\n    case 'object':\n      return data;\n    case '",
    "signature": "/**\n * Simple switcher allowing other expressions to use either a JSONPath or\n * object literals as a data source.\n * - JSONPath referencing a point in `state`\n * - Object Literal of the data itself.\n * - Function to be called with state.\n * @public\n * @example\n * asData('$.key'| key | callback)\n * @function\n * @param {String|object|function} data\n * @param {object} state - The current state.\n * @returns {array}\n */\nexport function asData(data: string | object | Function, state: object): any[];",
    "test": "",
    "instruction": "Create an OpenFn function that uses a JSONPath, object literal, or callback to reference",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that uses a JSONPath, object literal, or callback to reference\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Simple switcher allowing other expressions to use either a JSONPath or\n * object literals as a data source.\n * - JSONPath referencing a point in `state`\n * - Object Literal of the data itself.\n * - Function to be called with state.\n * @public\n * @example\n * asData('$.key'| key | callback)\n * @function\n * @param {String|object|function} data\n * @param {object} state - The current state.\n * @returns {array}\n */\nexport function asData(data: string | object | Function, state: object): any[];\n\n### Implementation:\n\n/**\n * Scopes an array of data based on a JSONPath.\n * Useful when the source data has `n` items you would like to map to\n * an operation.\n * The operation will receive a slice of the data based of each item\n * of the JSONPath provided.\n * @public\n * @example\n * map(\"$.[*]\",\n *   create(\"SObject\",\n *     field(\"FirstName\", sourceValue(\"$.firstName\"))\n *   )\n * )\n * @function\n * @param {string} path - JSONPath referencing a point in `state.data`.\n * @param {function} operation - The operation needed to be repeated.\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nexport const map = curry(function (path, operation, state) {\n  switch (typeof path) {\n    case 'string':\n      source(path)(state).map(function (data) {\n        return operation({ data, references: state.references });\n      });\n      return state;\n\n    case 'object':\n      path.map(function (data) {\n        return operation({ data, references: state.references });\n      });\n      return state;\n  }\n});\n\n/**\n * Simple switcher allowing other expressions to use either a JSONPath or\n * object literals as a data source.\n * - JSONPath referencing a point in `state`\n * - Object Literal of the data itself.\n * - Function to be called with state.\n * @public\n * @example\n * asData('$.key'| key | callback)\n * @function\n * @param {String|object|function} data\n * @param {object} state - The current state.\n * @returns {array}\n */\nexport function asData(data, state) {\n  switch (typeof data) {\n    case 'string':\n      return source(data)(state);\n    case 'object':\n      return data;\n    case '\n"
  },
  {
    "name": "each",
    "implementation": "\n/**\n * Scopes an array of data based on a JSONPath.\n * Useful when the source data has `n` items you would like to map to\n * an operation.\n * The operation will receive a slice of the data based of each item\n * of the JSONPath provided.\n *\n * It also ensures the results of an operation make their way back into\n * the state's references.\n * @public\n * @example\n * each(\"$.[*]\",\n *   create(\"SObject\",\n *     field(\"FirstName\", sourceValue(\"$.firstName\"))\n *   )\n * )\n * @function\n * @param {DataSource} dataSource - JSONPath referencing a point in `state`.\n * @param {Operation} operation - The operation needed to be repeated.\n * @returns {Operation}\n */\nexport function each(dataSource, operation) {\n  if (!dataSource) {\n    throw new TypeError('dataSource argument for each operation is invalid.');\n  }\n\n  return state => {\n    return asData(dataSource, state).reduce((state, data, index) => {\n      if (state.then) {\n        return state.then(state => {\n          return operation({ ...state, data, index });\n        });\n      } else {\n        return operation({ ...state, data, index });\n      }\n    }, state);\n  };\n}",
    "signature": "/**\n * Scopes an array of data based on a JSONPath.\n * Useful when the source data has `n` items you would like to map to\n * an operation.\n * The operation will receive a slice of the data based of each item\n * of the JSONPath provided.\n *\n * It also ensures the results of an operation make their way back into\n * the state's references.\n * @public\n * @example\n * each(\"$.[*]\",\n *   create(\"SObject\",\n *     field(\"FirstName\", sourceValue(\"$.firstName\"))\n *   )\n * )\n * @function\n * @param {DataSource} dataSource - JSONPath referencing a point in `state`.\n * @param {Operation} operation - The operation needed to be repeated.\n * @returns {Operation}\n */\nexport function each(dataSource: DataSource, operation: Operation): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that repeats an operation on an array of data based on a JSON",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that repeats an operation on an array of data based on a JSON\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Scopes an array of data based on a JSONPath.\n * Useful when the source data has `n` items you would like to map to\n * an operation.\n * The operation will receive a slice of the data based of each item\n * of the JSONPath provided.\n *\n * It also ensures the results of an operation make their way back into\n * the state's references.\n * @public\n * @example\n * each(\"$.[*]\",\n *   create(\"SObject\",\n *     field(\"FirstName\", sourceValue(\"$.firstName\"))\n *   )\n * )\n * @function\n * @param {DataSource} dataSource - JSONPath referencing a point in `state`.\n * @param {Operation} operation - The operation needed to be repeated.\n * @returns {Operation}\n */\nexport function each(dataSource: DataSource, operation: Operation): Operation;\n\n### Implementation:\n\n/**\n * Scopes an array of data based on a JSONPath.\n * Useful when the source data has `n` items you would like to map to\n * an operation.\n * The operation will receive a slice of the data based of each item\n * of the JSONPath provided.\n *\n * It also ensures the results of an operation make their way back into\n * the state's references.\n * @public\n * @example\n * each(\"$.[*]\",\n *   create(\"SObject\",\n *     field(\"FirstName\", sourceValue(\"$.firstName\"))\n *   )\n * )\n * @function\n * @param {DataSource} dataSource - JSONPath referencing a point in `state`.\n * @param {Operation} operation - The operation needed to be repeated.\n * @returns {Operation}\n */\nexport function each(dataSource, operation) {\n  if (!dataSource) {\n    throw new TypeError('dataSource argument for each operation is invalid.');\n  }\n\n  return state => {\n    return asData(dataSource, state).reduce((state, data, index) => {\n      if (state.then) {\n        return state.then(state => {\n          return operation({ ...state, data, index });\n        });\n      } else {\n        return operation({ ...state, data, index });\n      }\n    }, state);\n  };\n}\n"
  },
  {
    "name": "combine",
    "implementation": "\n/**\n * Combines two operations into one\n * @public\n * @example\n * combine(\n *   create('foo'),\n *   delete('bar')\n * )\n * @function\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function combine(...operations) {\n  return state => {\n    return operations.reduce((state, operation) => {\n      if (state.then) {\n        return state.then(state => {\n          return { ...state, ...operation(state) };\n        });\n      } else {\n        return { ...state, ...operation(state) };\n      }\n    }, state);\n  };\n}",
    "signature": "/**\n * Combines two operations into one\n * @public\n * @example\n * combine(\n *   create('foo'),\n *   delete('bar')\n * )\n * @function\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function combine(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that combines two operations.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that combines two operations.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Combines two operations into one\n * @public\n * @example\n * combine(\n *   create('foo'),\n *   delete('bar')\n * )\n * @function\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function combine(...operations: Operations): Operation;\n\n### Implementation:\n\n/**\n * Combines two operations into one\n * @public\n * @example\n * combine(\n *   create('foo'),\n *   delete('bar')\n * )\n * @function\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function combine(...operations) {\n  return state => {\n    return operations.reduce((state, operation) => {\n      if (state.then) {\n        return state.then(state => {\n          return { ...state, ...operation(state) };\n        });\n      } else {\n        return { ...state, ...operation(state) };\n      }\n    }, state);\n  };\n}\n"
  },
  {
    "name": "join",
    "implementation": "\n/**\n * Adds data from a target object\n * @public\n * @example\n * join('$.key','$.data','newKey')\n * @function\n * @param {String} targetPath - Target path\n * @param {String} sourcePath - Source path\n * @param {String} targetKey - Target Key\n * @returns {Operation}\n */\nexport function join(targetPath, sourcePath, targetKey) {\n  return state => {\n    return source(targetPath)(state).map(i => {\n      return { [targetKey]: sourceValue(sourcePath)(state), ...i };\n    });\n  };\n}",
    "signature": "/**\n * Adds data from a target object\n * @public\n * @example\n * join('$.key','$.data','newKey')\n * @function\n * @param {String} targetPath - Target path\n * @param {String} sourcePath - Source path\n * @param {String} targetKey - Target Key\n * @returns {Operation}\n */\nexport function join(targetPath: string, sourcePath: string, targetKey: string): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that adds data from a target object.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that adds data from a target object.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Adds data from a target object\n * @public\n * @example\n * join('$.key','$.data','newKey')\n * @function\n * @param {String} targetPath - Target path\n * @param {String} sourcePath - Source path\n * @param {String} targetKey - Target Key\n * @returns {Operation}\n */\nexport function join(targetPath: string, sourcePath: string, targetKey: string): Operation;\n\n### Implementation:\n\n/**\n * Adds data from a target object\n * @public\n * @example\n * join('$.key','$.data','newKey')\n * @function\n * @param {String} targetPath - Target path\n * @param {String} sourcePath - Source path\n * @param {String} targetKey - Target Key\n * @returns {Operation}\n */\nexport function join(targetPath, sourcePath, targetKey) {\n  return state => {\n    return source(targetPath)(state).map(i => {\n      return { [targetKey]: sourceValue(sourcePath)(state), ...i };\n    });\n  };\n}\n"
  },
  {
    "name": "expandReferences",
    "implementation": "\n/**\n * Recursively resolves objects that have resolvable values (functions).\n * @public\n * @function\n * @param {object} value - data\n * @param {Function} [skipFilter] - a function which returns true if a value should be skipped\n * @returns {Operation}\n */\nexport function expandReferences(value, skipFilter) {\n  return state => {\n    if (skipFilter && skipFilter(value)) return value;\n\n    if (Array.isArray(value)) {\n      return value.map(v => expandReferences(v)(state));\n    }\n\n    if (typeof value == 'object' && !!value) {\n      return Object.keys(value).reduce((acc, key) => {\n        return { ...acc, [key]: expandReferences(value[key])(state) };\n      }, {});\n    }\n\n    if (typeof value == '",
    "signature": "/**\n * Recursively resolves objects that have resolvable values (functions).\n * @public\n * @function\n * @param {object} value - data\n * @param {Function} [skipFilter] - a function which returns true if a value should be skipped\n * @returns {Operation}\n */\nexport function expandReferences(value: object, skipFilter?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that expands references from an object.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that expands references from an object.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Recursively resolves objects that have resolvable values (functions).\n * @public\n * @function\n * @param {object} value - data\n * @param {Function} [skipFilter] - a function which returns true if a value should be skipped\n * @returns {Operation}\n */\nexport function expandReferences(value: object, skipFilter?: Function): Operation;\n\n### Implementation:\n\n/**\n * Recursively resolves objects that have resolvable values (functions).\n * @public\n * @function\n * @param {object} value - data\n * @param {Function} [skipFilter] - a function which returns true if a value should be skipped\n * @returns {Operation}\n */\nexport function expandReferences(value, skipFilter) {\n  return state => {\n    if (skipFilter && skipFilter(value)) return value;\n\n    if (Array.isArray(value)) {\n      return value.map(v => expandReferences(v)(state));\n    }\n\n    if (typeof value == 'object' && !!value) {\n      return Object.keys(value).reduce((acc, key) => {\n        return { ...acc, [key]: expandReferences(value[key])(state) };\n      }, {});\n    }\n\n    if (typeof value == '\n"
  },
  {
    "name": "field",
    "implementation": "\n/**\n * Returns a key, value pair in an array.\n * @public\n * @example\n * field('destination_field_name__c', 'value')\n * @function\n * @param {string} key - Name of the field\n * @param {Value} value - The value itself or a sourceable operation.\n * @returns {Field}\n */\nexport function field(key, value) {\n  return [key, value];\n}",
    "signature": "/**\n * Returns a key, value pair in an array.\n * @public\n * @example\n * field('destination_field_name__c', 'value')\n * @function\n * @param {string} key - Name of the field\n * @param {Value} value - The value itself or a sourceable operation.\n * @returns {Field}\n */\nexport function field(key: string, value: Value): Field;",
    "test": "",
    "instruction": "Create an OpenFn function that returns a key, value pair in an array from a field",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that returns a key, value pair in an array from a field\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Returns a key, value pair in an array.\n * @public\n * @example\n * field('destination_field_name__c', 'value')\n * @function\n * @param {string} key - Name of the field\n * @param {Value} value - The value itself or a sourceable operation.\n * @returns {Field}\n */\nexport function field(key: string, value: Value): Field;\n\n### Implementation:\n\n/**\n * Returns a key, value pair in an array.\n * @public\n * @example\n * field('destination_field_name__c', 'value')\n * @function\n * @param {string} key - Name of the field\n * @param {Value} value - The value itself or a sourceable operation.\n * @returns {Field}\n */\nexport function field(key, value) {\n  return [key, value];\n}\n"
  },
  {
    "name": "fields",
    "implementation": "\n/**\n * Zips key value pairs into an object.\n * @public\n * @example\n *  fields(list_of_fields)\n * @function\n * @param {Fields} fields - a list of fields\n * @returns {Object}\n */\nexport function fields(...fields) {\n  return fromPairs(fields);\n}",
    "signature": "/**\n * Zips key value pairs into an object.\n * @public\n * @example\n *  fields(list_of_fields)\n * @function\n * @param {Fields} fields - a list of fields\n * @returns {Object}\n */\nexport function fields(...fields: Fields): any;",
    "test": "",
    "instruction": "Create an OpenFn function that zips key value pairs into an object.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that zips key value pairs into an object.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Zips key value pairs into an object.\n * @public\n * @example\n *  fields(list_of_fields)\n * @function\n * @param {Fields} fields - a list of fields\n * @returns {Object}\n */\nexport function fields(...fields: Fields): any;\n\n### Implementation:\n\n/**\n * Zips key value pairs into an object.\n * @public\n * @example\n *  fields(list_of_fields)\n * @function\n * @param {Fields} fields - a list of fields\n * @returns {Object}\n */\nexport function fields(...fields) {\n  return fromPairs(fields);\n}\n"
  },
  {
    "name": "merge",
    "implementation": "\n/**\n * Merges fields into each item in an array.\n * @public\n * @example\n * merge(\n *   \"$.books[*]\",\n *   fields(\n *     field( \"publisher\", sourceValue(\"$.publisher\") )\n *   )\n * )\n * @function\n * @param {DataSource} dataSource\n * @param {Object} fields - Group of fields to merge in.\n * @returns {DataSource}\n */\nexport function merge(dataSource, fields) {\n  return state => {\n    const initialData = source(dataSource)(state);\n    const additionalData = expandReferences(fields)(state);\n\n    return initialData.reduce((acc, dataItem) => {\n      return [...acc, { ...dataItem, ...additionalData }];\n    }, []);\n  };\n}",
    "signature": "/**\n * Merges fields into each item in an array.\n * @public\n * @example\n * merge(\n *   \"$.books[*]\",\n *   fields(\n *     field( \"publisher\", sourceValue(\"$.publisher\") )\n *   )\n * )\n * @function\n * @param {DataSource} dataSource\n * @param {Object} fields - Group of fields to merge in.\n * @returns {DataSource}\n */\nexport function merge(dataSource: DataSource, fields: any): DataSource;",
    "test": "",
    "instruction": "Create an OpenFn function that merges fields into each item in an array.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that merges fields into each item in an array.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Merges fields into each item in an array.\n * @public\n * @example\n * merge(\n *   \"$.books[*]\",\n *   fields(\n *     field( \"publisher\", sourceValue(\"$.publisher\") )\n *   )\n * )\n * @function\n * @param {DataSource} dataSource\n * @param {Object} fields - Group of fields to merge in.\n * @returns {DataSource}\n */\nexport function merge(dataSource: DataSource, fields: any): DataSource;\n\n### Implementation:\n\n/**\n * Merges fields into each item in an array.\n * @public\n * @example\n * merge(\n *   \"$.books[*]\",\n *   fields(\n *     field( \"publisher\", sourceValue(\"$.publisher\") )\n *   )\n * )\n * @function\n * @param {DataSource} dataSource\n * @param {Object} fields - Group of fields to merge in.\n * @returns {DataSource}\n */\nexport function merge(dataSource, fields) {\n  return state => {\n    const initialData = source(dataSource)(state);\n    const additionalData = expandReferences(fields)(state);\n\n    return initialData.reduce((acc, dataItem) => {\n      return [...acc, { ...dataItem, ...additionalData }];\n    }, []);\n  };\n}\n"
  },
  {
    "name": "index",
    "implementation": "\n/**\n * Returns the index of the current array being iterated.\n * To be used with `each` as a data source.\n * @public\n * @example\n * index()\n * @function\n * @returns {DataSource}\n */\nexport function index() {\n  return state => {\n    return state.index;\n  };\n}",
    "signature": "/**\n * Returns the index of the current array being iterated.\n * To be used with `each` as a data source.\n * @public\n * @example\n * index()\n * @function\n * @returns {DataSource}\n */\nexport function index(): DataSource;",
    "test": "",
    "instruction": "Create an OpenFn function that returns the index of the current array being iterated.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that returns the index of the current array being iterated.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Returns the index of the current array being iterated.\n * To be used with `each` as a data source.\n * @public\n * @example\n * index()\n * @function\n * @returns {DataSource}\n */\nexport function index(): DataSource;\n\n### Implementation:\n\n/**\n * Returns the index of the current array being iterated.\n * To be used with `each` as a data source.\n * @public\n * @example\n * index()\n * @function\n * @returns {DataSource}\n */\nexport function index() {\n  return state => {\n    return state.index;\n  };\n}\n"
  },
  {
    "name": "arrayToString",
    "implementation": "\n/**\n * Turns an array into a string, separated by X.\n * @public\n * @example\n * field(\"destination_string__c\", function(state) {\n *   return arrayToString(dataValue(\"path_of_array\")(state), ', ')\n * })\n * @function\n * @param {array} arr - Array of toString'able primatives.\n * @param {string} separator - Separator string.\n * @returns {string}\n */\nexport function arrayToString(arr, separator) {\n  return Array.apply(null, arr).join(separator);\n}",
    "signature": "/**\n * Turns an array into a string, separated by X.\n * @public\n * @example\n * field(\"destination_string__c\", function(state) {\n *   return arrayToString(dataValue(\"path_of_array\")(state), ', ')\n * })\n * @function\n * @param {array} arr - Array of toString'able primatives.\n * @param {string} separator - Separator string.\n * @returns {string}\n */\nexport function arrayToString(arr: any[], separator: string): string;",
    "test": "",
    "instruction": "Create an OpenFn function that turns an array into a string, separated by X.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that turns an array into a string, separated by X.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Turns an array into a string, separated by X.\n * @public\n * @example\n * field(\"destination_string__c\", function(state) {\n *   return arrayToString(dataValue(\"path_of_array\")(state), ', ')\n * })\n * @function\n * @param {array} arr - Array of toString'able primatives.\n * @param {string} separator - Separator string.\n * @returns {string}\n */\nexport function arrayToString(arr: any[], separator: string): string;\n\n### Implementation:\n\n/**\n * Turns an array into a string, separated by X.\n * @public\n * @example\n * field(\"destination_string__c\", function(state) {\n *   return arrayToString(dataValue(\"path_of_array\")(state), ', ')\n * })\n * @function\n * @param {array} arr - Array of toString'able primatives.\n * @param {string} separator - Separator string.\n * @returns {string}\n */\nexport function arrayToString(arr, separator) {\n  return Array.apply(null, arr).join(separator);\n}\n"
  },
  {
    "name": "toArray",
    "implementation": "\n/**\n * Ensures primitive data types are wrapped in an array.\n * Does not affect array objects.\n * @public\n * @example\n * each(function(state) {\n *   return toArray( dataValue(\"path_of_array\")(state) )\n * }, ...)\n * @function\n * @param {any} arg - Data required to be in an array\n * @returns {array}\n */\nexport function toArray(arg) {\n  return new Array().concat(arg);\n}",
    "signature": "/**\n * Ensures primitive data types are wrapped in an array.\n * Does not affect array objects.\n * @public\n * @example\n * each(function(state) {\n *   return toArray( dataValue(\"path_of_array\")(state) )\n * }, ...)\n * @function\n * @param {any} arg - Data required to be in an array\n * @returns {array}\n */\nexport function toArray(arg: any): any[];",
    "test": "",
    "instruction": "Create an OpenFn function that wraps primitive data types in an array.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that wraps primitive data types in an array.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Ensures primitive data types are wrapped in an array.\n * Does not affect array objects.\n * @public\n * @example\n * each(function(state) {\n *   return toArray( dataValue(\"path_of_array\")(state) )\n * }, ...)\n * @function\n * @param {any} arg - Data required to be in an array\n * @returns {array}\n */\nexport function toArray(arg: any): any[];\n\n### Implementation:\n\n/**\n * Ensures primitive data types are wrapped in an array.\n * Does not affect array objects.\n * @public\n * @example\n * each(function(state) {\n *   return toArray( dataValue(\"path_of_array\")(state) )\n * }, ...)\n * @function\n * @param {any} arg - Data required to be in an array\n * @returns {array}\n */\nexport function toArray(arg) {\n  return new Array().concat(arg);\n}\n"
  },
  {
    "name": "composeNextState",
    "implementation": "\n/**\n * Prepares next state\n * @public\n * @example\n * composeNextState(state, response)\n * @function\n * @param {State} state - state\n * @param {Object} response - Response to be added\n * @returns {State}\n */\nexport function composeNextState(state, response) {\n  return {\n    ...state,\n    data: response,\n    references: [...state.references, state.data],\n  };\n}",
    "signature": "/**\n * Prepares next state\n * @public\n * @example\n * composeNextState(state, response)\n * @function\n * @param {State} state - state\n * @param {Object} response - Response to be added\n * @returns {State}\n */\nexport function composeNextState(state: State, response: any): State;",
    "test": "",
    "instruction": "Create an OpenFn function that composes the next state from the state and response.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that composes the next state from the state and response.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Prepares next state\n * @public\n * @example\n * composeNextState(state, response)\n * @function\n * @param {State} state - state\n * @param {Object} response - Response to be added\n * @returns {State}\n */\nexport function composeNextState(state: State, response: any): State;\n\n### Implementation:\n\n/**\n * Prepares next state\n * @public\n * @example\n * composeNextState(state, response)\n * @function\n * @param {State} state - state\n * @param {Object} response - Response to be added\n * @returns {State}\n */\nexport function composeNextState(state, response) {\n  return {\n    ...state,\n    data: response,\n    references: [...state.references, state.data],\n  };\n}\n"
  },
  {
    "name": "humanProper",
    "implementation": "\n/**\n * Substitutes underscores for spaces and proper-cases a string\n * @public\n * @example\n * field(\"destination_string__c\", humanProper(state.data.path_to_string))\n * @function\n * @param {string} str - String that needs converting\n * @returns {string}\n */\nexport function humanProper(str) {\n  if (typeof str == 'string') {\n    return str.replace(/[_-]/g, ' ').replace(/\\w\\S*/g,",
    "signature": "/**\n * Substitutes underscores for spaces and proper-cases a string\n * @public\n * @example\n * field(\"destination_string__c\", humanProper(state.data.path_to_string))\n * @function\n * @param {string} str - String that needs converting\n * @returns {string}\n */\nexport function humanProper(str: string): string;",
    "test": "",
    "instruction": "Create an OpenFn function that substitutes underscores for spaces and proper-cases a string.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that substitutes underscores for spaces and proper-cases a string.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Substitutes underscores for spaces and proper-cases a string\n * @public\n * @example\n * field(\"destination_string__c\", humanProper(state.data.path_to_string))\n * @function\n * @param {string} str - String that needs converting\n * @returns {string}\n */\nexport function humanProper(str: string): string;\n\n### Implementation:\n\n/**\n * Substitutes underscores for spaces and proper-cases a string\n * @public\n * @example\n * field(\"destination_string__c\", humanProper(state.data.path_to_string))\n * @function\n * @param {string} str - String that needs converting\n * @returns {string}\n */\nexport function humanProper(str) {\n  if (typeof str == 'string') {\n    return str.replace(/[_-]/g, ' ').replace(/\\w\\S*/g,\n"
  },
  {
    "name": "splitKeys",
    "implementation": "\n/**\n * Splits an object into two objects based on a list of keys.\n * The first object contains the keys that are not in the list,\n * and the second contains the keys that are.\n * @public\n * @function\n * @param {Object} obj - The object to split.\n * @param {string[]} keys - List of keys to split on.\n * @returns {Object[]} - Tuple of objects, first object contains keys not in list, second contains keys that are.\n */\nexport function splitKeys(obj, keys) {\n  return Object.keys(obj).reduce(\n    ([keep, split], key) => {\n      const value = obj[key];\n\n      if (keys.includes(key)) {\n        return [keep, { ...split, [key]: value }];\n      }\n\n      return [{ ...keep, [key]: value }, split];\n    },\n    [{}, {}]\n  );\n}",
    "signature": "/**\n * Splits an object into two objects based on a list of keys.\n * The first object contains the keys that are not in the list,\n * and the second contains the keys that are.\n * @public\n * @function\n * @param {Object} obj - The object to split.\n * @param {string[]} keys - List of keys to split on.\n * @returns {Object[]} - Tuple of objects, first object contains keys not in list, second contains keys that are.\n */\nexport function splitKeys(obj: any, keys: string[]): any[];",
    "test": "",
    "instruction": "Create an OpenFn function that splits an object into two objects based on a list of keys",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that splits an object into two objects based on a list of keys\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Splits an object into two objects based on a list of keys.\n * The first object contains the keys that are not in the list,\n * and the second contains the keys that are.\n * @public\n * @function\n * @param {Object} obj - The object to split.\n * @param {string[]} keys - List of keys to split on.\n * @returns {Object[]} - Tuple of objects, first object contains keys not in list, second contains keys that are.\n */\nexport function splitKeys(obj: any, keys: string[]): any[];\n\n### Implementation:\n\n/**\n * Splits an object into two objects based on a list of keys.\n * The first object contains the keys that are not in the list,\n * and the second contains the keys that are.\n * @public\n * @function\n * @param {Object} obj - The object to split.\n * @param {string[]} keys - List of keys to split on.\n * @returns {Object[]} - Tuple of objects, first object contains keys not in list, second contains keys that are.\n */\nexport function splitKeys(obj, keys) {\n  return Object.keys(obj).reduce(\n    ([keep, split], key) => {\n      const value = obj[key];\n\n      if (keys.includes(key)) {\n        return [keep, { ...split, [key]: value }];\n      }\n\n      return [{ ...keep, [key]: value }, split];\n    },\n    [{}, {}]\n  );\n}\n"
  },
  {
    "name": "scrubEmojis",
    "implementation": "\n/**\n * Replaces emojis in a string.\n * @public\n * @example\n * scrubEmojis('Dove\ud83d\udd4a\ufe0f\u2b50 29')\n * @function\n * @param {string} text - String that needs to be cleaned\n * @param {string} replacementChars - Characters that replace the emojis\n * @returns {string}\n */\nexport function scrubEmojis(text, replacementChars) {\n  if (!text) return text;\n\n  if (replacementChars == '') {\n    console.warn(\n      'Removing characters from a string may create injection vulnerabilities;',\n      \"It's better to replace than remove.\",\n      'See https://www.unicode.org/reports/tr36/#Deletion_of_Noncharacters'\n    );\n  }\n\n  const newChars =\n    replacementChars || replacementChars == '' ? replacementChars : '\\uFFFD';\n\n  const emojisPattern =\n    /(\\uFE0F|\\u00a9|\\u00ae|[\\u2000-\\u3300]|\\ud83c[\\ud000-\\udfff]|\\ud83d[\\ud000-\\udfff]|\\ud83e[\\ud000-\\udfff])/g;\n\n  return text.replace(emojisPattern, newChars);\n}",
    "signature": "/**\n * Replaces emojis in a string.\n * @public\n * @example\n * scrubEmojis('Dove\ud83d\udd4a\ufe0f\u2b50 29')\n * @function\n * @param {string} text - String that needs to be cleaned\n * @param {string} replacementChars - Characters that replace the emojis\n * @returns {string}\n */\nexport function scrubEmojis(text: string, replacementChars: string): string;",
    "test": "",
    "instruction": "Create an OpenFn function that replaces emojis in a string.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that replaces emojis in a string.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Replaces emojis in a string.\n * @public\n * @example\n * scrubEmojis('Dove\ud83d\udd4a\ufe0f\u2b50 29')\n * @function\n * @param {string} text - String that needs to be cleaned\n * @param {string} replacementChars - Characters that replace the emojis\n * @returns {string}\n */\nexport function scrubEmojis(text: string, replacementChars: string): string;\n\n### Implementation:\n\n/**\n * Replaces emojis in a string.\n * @public\n * @example\n * scrubEmojis('Dove\ud83d\udd4a\ufe0f\u2b50 29')\n * @function\n * @param {string} text - String that needs to be cleaned\n * @param {string} replacementChars - Characters that replace the emojis\n * @returns {string}\n */\nexport function scrubEmojis(text, replacementChars) {\n  if (!text) return text;\n\n  if (replacementChars == '') {\n    console.warn(\n      'Removing characters from a string may create injection vulnerabilities;',\n      \"It's better to replace than remove.\",\n      'See https://www.unicode.org/reports/tr36/#Deletion_of_Noncharacters'\n    );\n  }\n\n  const newChars =\n    replacementChars || replacementChars == '' ? replacementChars : '\\uFFFD';\n\n  const emojisPattern =\n    /(\\uFE0F|\\u00a9|\\u00ae|[\\u2000-\\u3300]|\\ud83c[\\ud000-\\udfff]|\\ud83d[\\ud000-\\udfff]|\\ud83e[\\ud000-\\udfff])/g;\n\n  return text.replace(emojisPattern, newChars);\n}\n"
  },
  {
    "name": "chunk",
    "implementation": "\n/**\n * Chunks an array into an array of arrays, each with no more than a certain size.\n * @public\n * @example\n * chunk([1,2,3,4,5], 2)\n * @function\n * @param {Object} array - Array to be chunked\n * @param {Integer} chunkSize - The maxiumum size of each chunks\n * @returns {Object}\n */\nexport function chunk(array, chunkSize) {\n  const output = [];\n  for (var i = 0, len = array.length; i < len; i += chunkSize)\n    output.push(array.slice(i, i + chunkSize));\n  return output;\n}\n\nconst getParser = (csvData, options) => {\n  if (typeof csvData === 'string') {\n    return parse(csvData, options);\n  }\n\n  let stream = csvData;\n  if (csvData instanceof ReadableStream) {\n    stream = Readable.from(csvData);\n  }\n  return stream.pipe(parse(options));\n};",
    "signature": "/**\n * Chunks an array into an array of arrays, each with no more than a certain size.\n * @public\n * @example\n * chunk([1,2,3,4,5], 2)\n * @function\n * @param {Object} array - Array to be chunked\n * @param {Integer} chunkSize - The maxiumum size of each chunks\n * @returns {Object}\n */\nexport function chunk(array: any, chunkSize: Integer): any;",
    "test": "",
    "instruction": "Create an OpenFn function that chunks an array into an array of arrays with no more than",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that chunks an array into an array of arrays with no more than\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Chunks an array into an array of arrays, each with no more than a certain size.\n * @public\n * @example\n * chunk([1,2,3,4,5], 2)\n * @function\n * @param {Object} array - Array to be chunked\n * @param {Integer} chunkSize - The maxiumum size of each chunks\n * @returns {Object}\n */\nexport function chunk(array: any, chunkSize: Integer): any;\n\n### Implementation:\n\n/**\n * Chunks an array into an array of arrays, each with no more than a certain size.\n * @public\n * @example\n * chunk([1,2,3,4,5], 2)\n * @function\n * @param {Object} array - Array to be chunked\n * @param {Integer} chunkSize - The maxiumum size of each chunks\n * @returns {Object}\n */\nexport function chunk(array, chunkSize) {\n  const output = [];\n  for (var i = 0, len = array.length; i < len; i += chunkSize)\n    output.push(array.slice(i, i + chunkSize));\n  return output;\n}\n\nconst getParser = (csvData, options) => {\n  if (typeof csvData === 'string') {\n    return parse(csvData, options);\n  }\n\n  let stream = csvData;\n  if (csvData instanceof ReadableStream) {\n    stream = Readable.from(csvData);\n  }\n  return stream.pipe(parse(options));\n};\n"
  },
  {
    "name": "parseCsv",
    "implementation": "\n/**\n * Takes a CSV file string or stream and parsing options as input, and returns a promise that\n * resolves to the parsed CSV data as an array of objects.\n * Options for `parsingOptions` include:\n * - `delimiter` {string/Buffer/[string/Buffer]} - Defines the character(s) used to delineate the fields inside a record. Default: `','`\n * - `quote` {string/Buffer/[string/Buffer]} - Defines the characters used to surround a field. Default: `'\"'`\n * - `escape` {Buffer/string/null/boolean} - Set the escape character as one character/byte only. Default: `\"`\n * - `columns` {boolean / array / function} - Generates record in the form of object literals. Default: `true`\n * - `bom` {boolean} - Strips the {@link https://en.wikipedia.org/wiki/Byte_order_mark byte order mark (BOM)} from the input string or buffer. Default: `true`\n * - `trim` {boolean} - Ignore whitespace characters immediately around the `delimiter`. Default: `true`\n * - `ltrim` {boolean} - Ignore whitespace characters from the left side of a CSV field. Default: `true`\n * - `rtrim` {boolean} - Ignore whitespace characters from the right side of a CSV field. Default: `true`\n * - `chunkSize` {number} - The size of each chunk of CSV data. Default: `Infinity`\n * - `skip_empty_lines` {boolean} - Ignore empty lines in the CSV file. Default: `true`\n * @public\n * @function\n * @param {String | Stream} csvData - A CSV string or a readable stream\n * @param {Object} [parsingOptions] - Optional. Parsing options for converting CSV to JSON.\n * @param {function} [callback] - (Optional) callback function. If used it will be called state and an array of rows.\n * @returns {Operation} The function returns a Promise that resolves to the result of parsing a CSV `stringOrStream`.\n */\nexport function parseCsv(csvData, parsingOptions = {}, callback) {\n  const defaultOptions = {\n    delimiter: ',',\n    quote: '\"',\n    escape: '\"',\n    columns: true,\n    bom: true,\n    trim: true,\n    ltrim: true,\n    rtrim: true,\n    chunkSize: Infinity,\n    skip_empty_lines: true,\n  };\n\n  return async state => {\n    const [resolvedCsvData, resolvedParsingOptions] = newExpandReferences(\n      state,\n      csvData,\n      parsingOptions\n    );\n\n    const filteredOptions = Object.fromEntries(\n      Object.entries(resolvedParsingOptions).filter(\n        ([key]) => key in defaultOptions\n      )\n    );\n\n    const options = { ...defaultOptions, ...filteredOptions };\n\n    if (options.chunkSize < 1) {\n      throw new Error('chunkSize must be at least 1');\n    }\n\n    let buffer = [];\n\n    const parser = getParser(resolvedCsvData, options);\n\n    const flushBuffer = async currentState => {\n      const nextState = callback\n        ? await callback(currentState, buffer)\n        : composeNextState(currentState, buffer);\n\n      buffer = [];\n\n      return [nextState, buffer];\n    };\n\n    let result = state;\n    for await (const record of parser) {\n      buffer.push(record);\n      if (buffer.length === options.chunkSize) {\n        const [nextState, nextBuffer] = await flushBuffer(result);\n        result = nextState;\n        buffer = nextBuffer;\n      }\n    }\n    if (buffer.length) {\n      [result] = await flushBuffer(result);\n    }\n    return result;\n  };\n}\n\n//",
    "signature": "/**\n * Takes a CSV file string or stream and parsing options as input, and returns a promise that\n * resolves to the parsed CSV data as an array of objects.\n * Options for `parsingOptions` include:\n * - `delimiter` {string/Buffer/[string/Buffer]} - Defines the character(s) used to delineate the fields inside a record. Default: `','`\n * - `quote` {string/Buffer/[string/Buffer]} - Defines the characters used to surround a field. Default: `'\"'`\n * - `escape` {Buffer/string/null/boolean} - Set the escape character as one character/byte only. Default: `\"`\n * - `columns` {boolean / array / function} - Generates record in the form of object literals. Default: `true`\n * - `bom` {boolean} - Strips the {@link https://en.wikipedia.org/wiki/Byte_order_mark byte order mark (BOM)} from the input string or buffer. Default: `true`\n * - `trim` {boolean} - Ignore whitespace characters immediately around the `delimiter`. Default: `true`\n * - `ltrim` {boolean} - Ignore whitespace characters from the left side of a CSV field. Default: `true`\n * - `rtrim` {boolean} - Ignore whitespace characters from the right side of a CSV field. Default: `true`\n * - `chunkSize` {number} - The size of each chunk of CSV data. Default: `Infinity`\n * - `skip_empty_lines` {boolean} - Ignore empty lines in the CSV file. Default: `true`\n * @public\n * @function\n * @param {String | Stream} csvData - A CSV string or a readable stream\n * @param {Object} [parsingOptions] - Optional. Parsing options for converting CSV to JSON.\n * @param {function} [callback] - (Optional) callback function. If used it will be called state and an array of rows.\n * @returns {Operation} The function returns a Promise that resolves to the result of parsing a CSV `stringOrStream`.\n */\nexport function parseCsv(csvData: string | Stream, parsingOptions?: any, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that parses a CSV string or stream and returns the parsed CSV",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that parses a CSV string or stream and returns the parsed CSV\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Takes a CSV file string or stream and parsing options as input, and returns a promise that\n * resolves to the parsed CSV data as an array of objects.\n * Options for `parsingOptions` include:\n * - `delimiter` {string/Buffer/[string/Buffer]} - Defines the character(s) used to delineate the fields inside a record. Default: `','`\n * - `quote` {string/Buffer/[string/Buffer]} - Defines the characters used to surround a field. Default: `'\"'`\n * - `escape` {Buffer/string/null/boolean} - Set the escape character as one character/byte only. Default: `\"`\n * - `columns` {boolean / array / function} - Generates record in the form of object literals. Default: `true`\n * - `bom` {boolean} - Strips the {@link https://en.wikipedia.org/wiki/Byte_order_mark byte order mark (BOM)} from the input string or buffer. Default: `true`\n * - `trim` {boolean} - Ignore whitespace characters immediately around the `delimiter`. Default: `true`\n * - `ltrim` {boolean} - Ignore whitespace characters from the left side of a CSV field. Default: `true`\n * - `rtrim` {boolean} - Ignore whitespace characters from the right side of a CSV field. Default: `true`\n * - `chunkSize` {number} - The size of each chunk of CSV data. Default: `Infinity`\n * - `skip_empty_lines` {boolean} - Ignore empty lines in the CSV file. Default: `true`\n * @public\n * @function\n * @param {String | Stream} csvData - A CSV string or a readable stream\n * @param {Object} [parsingOptions] - Optional. Parsing options for converting CSV to JSON.\n * @param {function} [callback] - (Optional) callback function. If used it will be called state and an array of rows.\n * @returns {Operation} The function returns a Promise that resolves to the result of parsing a CSV `stringOrStream`.\n */\nexport function parseCsv(csvData: string | Stream, parsingOptions?: any, callback?: Function): Operation;\n\n### Implementation:\n\n/**\n * Takes a CSV file string or stream and parsing options as input, and returns a promise that\n * resolves to the parsed CSV data as an array of objects.\n * Options for `parsingOptions` include:\n * - `delimiter` {string/Buffer/[string/Buffer]} - Defines the character(s) used to delineate the fields inside a record. Default: `','`\n * - `quote` {string/Buffer/[string/Buffer]} - Defines the characters used to surround a field. Default: `'\"'`\n * - `escape` {Buffer/string/null/boolean} - Set the escape character as one character/byte only. Default: `\"`\n * - `columns` {boolean / array / function} - Generates record in the form of object literals. Default: `true`\n * - `bom` {boolean} - Strips the {@link https://en.wikipedia.org/wiki/Byte_order_mark byte order mark (BOM)} from the input string or buffer. Default: `true`\n * - `trim` {boolean} - Ignore whitespace characters immediately around the `delimiter`. Default: `true`\n * - `ltrim` {boolean} - Ignore whitespace characters from the left side of a CSV field. Default: `true`\n * - `rtrim` {boolean} - Ignore whitespace characters from the right side of a CSV field. Default: `true`\n * - `chunkSize` {number} - The size of each chunk of CSV data. Default: `Infinity`\n * - `skip_empty_lines` {boolean} - Ignore empty lines in the CSV file. Default: `true`\n * @public\n * @function\n * @param {String | Stream} csvData - A CSV string or a readable stream\n * @param {Object} [parsingOptions] - Optional. Parsing options for converting CSV to JSON.\n * @param {function} [callback] - (Optional) callback function. If used it will be called state and an array of rows.\n * @returns {Operation} The function returns a Promise that resolves to the result of parsing a CSV `stringOrStream`.\n */\nexport function parseCsv(csvData, parsingOptions = {}, callback) {\n  const defaultOptions = {\n    delimiter: ',',\n    quote: '\"',\n    escape: '\"',\n    columns: true,\n    bom: true,\n    trim: true,\n    ltrim: true,\n    rtrim: true,\n    chunkSize: Infinity,\n    skip_empty_lines: true,\n  };\n\n  return async state => {\n    const [resolvedCsvData, resolvedParsingOptions] = newExpandReferences(\n      state,\n      csvData,\n      parsingOptions\n    );\n\n    const filteredOptions = Object.fromEntries(\n      Object.entries(resolvedParsingOptions).filter(\n        ([key]) => key in defaultOptions\n      )\n    );\n\n    const options = { ...defaultOptions, ...filteredOptions };\n\n    if (options.chunkSize < 1) {\n      throw new Error('chunkSize must be at least 1');\n    }\n\n    let buffer = [];\n\n    const parser = getParser(resolvedCsvData, options);\n\n    const flushBuffer = async currentState => {\n      const nextState = callback\n        ? await callback(currentState, buffer)\n        : composeNextState(currentState, buffer);\n\n      buffer = [];\n\n      return [nextState, buffer];\n    };\n\n    let result = state;\n    for await (const record of parser) {\n      buffer.push(record);\n      if (buffer.length === options.chunkSize) {\n        const [nextState, nextBuffer] = await flushBuffer(result);\n        result = nextState;\n        buffer = nextBuffer;\n      }\n    }\n    if (buffer.length) {\n      [result] = await flushBuffer(result);\n    }\n    return result;\n  };\n}\n\n//\n"
  },
  {
    "name": "validate",
    "implementation": "\n/**\n//  * Returns a unique array of objects by an attribute in those objects\n//  * @public\n//  * @example\n//  * uniqBy([{a:1}, {b:2}, {a:1, b:2}], 'a')\n//  * @function\n//  * @param {Object} array - Array of objects to be deduplicated\n//  * @param {Integer} uid - The attribute name on which to deduplicate\n//  * @returns {Object}\n//  */\n// export function uniqBy(array, uid) {\n//   return Array.from(new Set(array.map(a => a[uid]))).map(id => {\n//     return array.find(a => a[uid] === id);\n//   });\n// }\n\nconst ajvVersions = {};\n\n// We need to import different versions of AJV depending on the schema\n// version - which is handled by this function\nconst getAjvVersion = async schema => {\n  if (/^https?:\\/\\/json-schema.org\\/draft\\/2019/.test(schema)) {\n    if (!ajvVersions['2019']) {\n      const Ajv = (await import('ajv/dist/2019.js')).default;\n      ajvVersions['2019'] = new Ajv();\n    }\n    return ajvVersions['2019'];\n  }\n  if (/^https?:\\/\\/json-schema.org\\/draft\\/2020/.test(schema)) {\n    if (!ajvVersions['2020']) {\n      const Ajv = (await import('ajv/dist/2020.js')).default;\n      ajvVersions['2020'] = new Ajv();\n    }\n    return ajvVersions['2020'];\n  }\n\n  if (!ajvVersions['default']) {\n    const Ajv = (await import('ajv')).default;\n    ajvVersions['default'] = new Ajv();\n  }\n\n  return ajvVersions['default'];\n};\n\n/**\n * Validate against a JSON schema. Any erors are written to an array at `state.validationErrors`.\n * Schema can be passed directly, loaded as a JSON path from state, or loaded from a URL\n * Data can be passed directly or loaded as a JSON path from state.\n * By default, schema is loaded from `state.schema` and data from `state.data`.\n * @param {string|object} schema - The schema, path or URL to validate against\n * @param {string|object} data - The data or path to validate\n * @example <caption>Validate `state.data` with `state.schema`</caption>\n * validate()\n * @example <caption>Validate form data at `state.form` with a schema from a URL</caption>\n * validate(\"https://www.example.com/schema/record\", \"form\")\n * @example <caption>Validate the each item in `state.records` with a schema from a URL</caption>\n * each(\"records[*]\", validate(\"https://www.example.com/schema/record\"))\n * @returns {Operation}\n */\nexport function validate(schema = 'schema', data = 'data') {\n  return async state => {\n    if (!state.validationErrors) {\n      state.validationErrors = [];\n    }\n\n    const resolvedData = resolveData();\n    const resolvedSchema = await resolveSchema();\n    // TODO: warn if the schema doesn't have an id? Does it matter? Maybe, if you're using multiple id-less schemas\n    const schemaId = resolvedSchema.$id || 'schema';\n    if (!schemaCache[schemaId]) {\n      const ajv = await getAjvVersion(resolvedSchema.$schema);\n      schemaCache[schemaId] = ajv.compile(resolvedSchema);\n    }\n\n    const validate = schemaCache[schemaId];\n\n    if (!validate(resolvedData)) {\n      state.validationErrors.push({\n        data: state.data,\n        errors: validate.errors,\n      });\n    }\n    return state;\n\n    // Schema can be a url, jsonpath or object; or a",
    "signature": "/**\n * Validate against a JSON schema. Any erors are written to an array at `state.validationErrors`.\n * Schema can be passed directly, loaded as a JSON path from state, or loaded from a URL\n * Data can be passed directly or loaded as a JSON path from state.\n * By default, schema is loaded from `state.schema` and data from `state.data`.\n * @param {string|object} schema - The schema, path or URL to validate against\n * @param {string|object} data - The data or path to validate\n * @example <caption>Validate `state.data` with `state.schema`</caption>\n * validate()\n * @example <caption>Validate form data at `state.form` with a schema from a URL</caption>\n * validate(\"https://www.example.com/schema/record\", \"form\")\n * @example <caption>Validate the each item in `state.records` with a schema from a URL</caption>\n * each(\"records[*]\", validate(\"https://www.example.com/schema/record\"))\n * @returns {Operation}\n */\nexport function validate(schema?: string | object, data?: string | object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that validates data from/on state to/on/from",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that validates data from/on state to/on/from\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Validate against a JSON schema. Any erors are written to an array at `state.validationErrors`.\n * Schema can be passed directly, loaded as a JSON path from state, or loaded from a URL\n * Data can be passed directly or loaded as a JSON path from state.\n * By default, schema is loaded from `state.schema` and data from `state.data`.\n * @param {string|object} schema - The schema, path or URL to validate against\n * @param {string|object} data - The data or path to validate\n * @example <caption>Validate `state.data` with `state.schema`</caption>\n * validate()\n * @example <caption>Validate form data at `state.form` with a schema from a URL</caption>\n * validate(\"https://www.example.com/schema/record\", \"form\")\n * @example <caption>Validate the each item in `state.records` with a schema from a URL</caption>\n * each(\"records[*]\", validate(\"https://www.example.com/schema/record\"))\n * @returns {Operation}\n */\nexport function validate(schema?: string | object, data?: string | object): Operation;\n\n### Implementation:\n\n/**\n//  * Returns a unique array of objects by an attribute in those objects\n//  * @public\n//  * @example\n//  * uniqBy([{a:1}, {b:2}, {a:1, b:2}], 'a')\n//  * @function\n//  * @param {Object} array - Array of objects to be deduplicated\n//  * @param {Integer} uid - The attribute name on which to deduplicate\n//  * @returns {Object}\n//  */\n// export function uniqBy(array, uid) {\n//   return Array.from(new Set(array.map(a => a[uid]))).map(id => {\n//     return array.find(a => a[uid] === id);\n//   });\n// }\n\nconst ajvVersions = {};\n\n// We need to import different versions of AJV depending on the schema\n// version - which is handled by this function\nconst getAjvVersion = async schema => {\n  if (/^https?:\\/\\/json-schema.org\\/draft\\/2019/.test(schema)) {\n    if (!ajvVersions['2019']) {\n      const Ajv = (await import('ajv/dist/2019.js')).default;\n      ajvVersions['2019'] = new Ajv();\n    }\n    return ajvVersions['2019'];\n  }\n  if (/^https?:\\/\\/json-schema.org\\/draft\\/2020/.test(schema)) {\n    if (!ajvVersions['2020']) {\n      const Ajv = (await import('ajv/dist/2020.js')).default;\n      ajvVersions['2020'] = new Ajv();\n    }\n    return ajvVersions['2020'];\n  }\n\n  if (!ajvVersions['default']) {\n    const Ajv = (await import('ajv')).default;\n    ajvVersions['default'] = new Ajv();\n  }\n\n  return ajvVersions['default'];\n};\n\n/**\n * Validate against a JSON schema. Any erors are written to an array at `state.validationErrors`.\n * Schema can be passed directly, loaded as a JSON path from state, or loaded from a URL\n * Data can be passed directly or loaded as a JSON path from state.\n * By default, schema is loaded from `state.schema` and data from `state.data`.\n * @param {string|object} schema - The schema, path or URL to validate against\n * @param {string|object} data - The data or path to validate\n * @example <caption>Validate `state.data` with `state.schema`</caption>\n * validate()\n * @example <caption>Validate form data at `state.form` with a schema from a URL</caption>\n * validate(\"https://www.example.com/schema/record\", \"form\")\n * @example <caption>Validate the each item in `state.records` with a schema from a URL</caption>\n * each(\"records[*]\", validate(\"https://www.example.com/schema/record\"))\n * @returns {Operation}\n */\nexport function validate(schema = 'schema', data = 'data') {\n  return async state => {\n    if (!state.validationErrors) {\n      state.validationErrors = [];\n    }\n\n    const resolvedData = resolveData();\n    const resolvedSchema = await resolveSchema();\n    // TODO: warn if the schema doesn't have an id? Does it matter? Maybe, if you're using multiple id-less schemas\n    const schemaId = resolvedSchema.$id || 'schema';\n    if (!schemaCache[schemaId]) {\n      const ajv = await getAjvVersion(resolvedSchema.$schema);\n      schemaCache[schemaId] = ajv.compile(resolvedSchema);\n    }\n\n    const validate = schemaCache[schemaId];\n\n    if (!validate(resolvedData)) {\n      state.validationErrors.push({\n        data: state.data,\n        errors: validate.errors,\n      });\n    }\n    return state;\n\n    // Schema can be a url, jsonpath or object; or a\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      login,\n      ...operations\n      // logout\n    )({ ...initialState, ...state });\n    // .catch(e => {\n    //   console.error(e);\n    //   logout;\n    //   process.exit(1);\n    // });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      login,\n      ...operations\n      // logout\n    )({ ...initialState, ...state });\n    // .catch(e => {\n    //   console.error(e);\n    //   logout;\n    //   process.exit(1);\n    // });\n  };\n}\n"
  },
  {
    "name": "request",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a POST request\n * @public\n * @example\n *  request({method: 'get', path: '/jobs/});\n * @function\n * @param {object} options - Body, Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function request(options, callback) {\n  return state => {\n    const { host, jwt } = state.configuration;\n    const { method, path, params, data } = expandReferences(options)(state);\n\n    return axios({\n      method,\n      headers: {\n        ...defaultHeaders,\n        Authorization: `Bearer ${jwt}`,\n      },\n      url: `${host}/api/${path}`,\n      params,\n      data,\n    }).then(response => {\n      const { data } = response;\n      const nextState = composeNextState(state, data);\n      if (callback) {\n        return callback(nextState);\n      }\n      return nextState;\n    });\n  };\n}",
    "signature": "/**\n * Make a POST request\n * @public\n * @example\n *  request({method: 'get', path: '/jobs/});\n * @function\n * @param {object} options - Body, Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function request(options: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a POST request to/on/from the given options",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a POST request to/on/from the given options\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a POST request\n * @public\n * @example\n *  request({method: 'get', path: '/jobs/});\n * @function\n * @param {object} options - Body, Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function request(options: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a POST request\n * @public\n * @example\n *  request({method: 'get', path: '/jobs/});\n * @function\n * @param {object} options - Body, Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function request(options, callback) {\n  return state => {\n    const { host, jwt } = state.configuration;\n    const { method, path, params, data } = expandReferences(options)(state);\n\n    return axios({\n      method,\n      headers: {\n        ...defaultHeaders,\n        Authorization: `Bearer ${jwt}`,\n      },\n      url: `${host}/api/${path}`,\n      params,\n      data,\n    }).then(response => {\n      const { data } = response;\n      const nextState = composeNextState(state, data);\n      if (callback) {\n        return callback(nextState);\n      }\n      return nextState;\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\nimport { normalizeOauthConfig } from '@openfn/language-common/util';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n      configuration: normalizeOauthConfig(state.configuration),\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\nimport { normalizeOauthConfig } from '@openfn/language-common/util';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n      configuration: normalizeOauthConfig(state.configuration),\n    });\n  };\n}\n"
  },
  {
    "name": "postMessage",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\nimport { normalizeOauthConfig } from '@openfn/language-common/util';\n/**\n * Post a message\n * @public\n * @example\n * postMessage({\n *  \"recipient\": {\n *     \"id\": \"your-psid\"\n *   },\n *   \"message\": {\n *     \"text\": \"your-message\"\n *   }\n * })\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function postMessage(params) {\n  return state => {",
    "signature": "/**\n * Post a message\n * @public\n * @example\n * postMessage({\n *  \"recipient\": {\n *     \"id\": \"your-psid\"\n *   },\n *   \"message\": {\n *     \"text\": \"your-message\"\n *   }\n * })\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function postMessage(params: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that posts a message to your-psid.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that posts a message to your-psid.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Post a message\n * @public\n * @example\n * postMessage({\n *  \"recipient\": {\n *     \"id\": \"your-psid\"\n *   },\n *   \"message\": {\n *     \"text\": \"your-message\"\n *   }\n * })\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function postMessage(params: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\nimport { normalizeOauthConfig } from '@openfn/language-common/util';\n/**\n * Post a message\n * @public\n * @example\n * postMessage({\n *  \"recipient\": {\n *     \"id\": \"your-psid\"\n *   },\n *   \"message\": {\n *     \"text\": \"your-message\"\n *   }\n * })\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function postMessage(params) {\n  return state => {\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for resourcemap.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for resourcemap.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for resourcemap.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for resourcemap.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "submitSite",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create an event\n * @example\n * execute(\n *   event(eventData)\n * )(state)\n * @function\n * @param {object} eventData - Payload data for the event\n * @returns {Operation}\n */\nexport function submitSite(collection_id, submissionData) {",
    "signature": "/**\n * Create an event\n * @example\n * execute(\n *   event(eventData)\n * )(state)\n * @function\n * @param {object} eventData - Payload data for the event\n * @returns {Operation}\n */\nexport function submitSite(collection_id: any, submissionData: any): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that submits a site to a collection.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that submits a site to a collection.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create an event\n * @example\n * execute(\n *   event(eventData)\n * )(state)\n * @function\n * @param {object} eventData - Payload data for the event\n * @returns {Operation}\n */\nexport function submitSite(collection_id: any, submissionData: any): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create an event\n * @example\n * execute(\n *   event(eventData)\n * )(state)\n * @function\n * @param {object} eventData - Payload data for the event\n * @returns {Operation}\n */\nexport function submitSite(collection_id, submissionData) {\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n\nvar cookiejar = new tough.CookieJar();\nvar Cookie = tough.Cookie;\n\naxios.interceptors.request.use(config => {\n  cookiejar?.getCookies(config.url, (err, cookies) => {\n    config.headers.cookie = cookies?.join('; ');\n  });\n  return config;\n});",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n\nvar cookiejar = new tough.CookieJar();\nvar Cookie = tough.Cookie;\n\naxios.interceptors.request.use(config => {\n  cookiejar?.getCookies(config.url, (err, cookies) => {\n    config.headers.cookie = cookies?.join('; ');\n  });\n  return config;\n});\n"
  },
  {
    "name": "get",
    "implementation": "import {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a GET request\n * @public\n * @example\n *  get('/myEndpoint', {\n *    query: {foo: 'bar', a: 1},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function get(path, params, callback) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedParams = http.expandRequestReferences(params)(state);\n\n    const url = setUrl(state.configuration, resolvedPath);\n\n    const auth = setAuth(\n      state.configuration,\n      resolvedParams?.authentication ?? resolvedParams?.auth\n    );\n\n    const config = mapToAxiosConfig({ ...resolvedParams, url, auth });\n\n    return http\n      .get(config)(state)\n      .then(response => handleResponse(state, response))\n      .then(nextState => handleCallback(nextState, callback));\n  };\n}",
    "signature": "/**\n * Make a GET request\n * @public\n * @example\n *  get('/myEndpoint', {\n *    query: {foo: 'bar', a: 1},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function get(path: string, params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a GET request to a resource.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a GET request to a resource.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a GET request\n * @public\n * @example\n *  get('/myEndpoint', {\n *    query: {foo: 'bar', a: 1},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function get(path: string, params: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a GET request\n * @public\n * @example\n *  get('/myEndpoint', {\n *    query: {foo: 'bar', a: 1},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function get(path, params, callback) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedParams = http.expandRequestReferences(params)(state);\n\n    const url = setUrl(state.configuration, resolvedPath);\n\n    const auth = setAuth(\n      state.configuration,\n      resolvedParams?.authentication ?? resolvedParams?.auth\n    );\n\n    const config = mapToAxiosConfig({ ...resolvedParams, url, auth });\n\n    return http\n      .get(config)(state)\n      .then(response => handleResponse(state, response))\n      .then(nextState => handleCallback(nextState, callback));\n  };\n}\n"
  },
  {
    "name": "post",
    "implementation": "import {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a POST request\n * @public\n * @example\n *  post('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {operation}\n */\nexport function post(path, params, callback) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedParams = http.expandRequestReferences(params)(state);\n\n    const url = setUrl(state.configuration, resolvedPath);\n\n    const auth = setAuth(\n      state.configuration,\n      resolvedParams?.authentication ?? resolvedParams?.auth\n    );\n\n    const config = mapToAxiosConfig({ ...resolvedParams, url, auth });\n\n    return http\n      .post(config)(state)\n      .then(response => handleResponse(state, response))\n      .then(nextState => handleCallback(nextState, callback));\n  };\n}",
    "signature": "/**\n * Make a POST request\n * @public\n * @example\n *  post('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {operation}\n */\nexport function post(path: string, params: object, callback: Function): operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a POST request to '/myEndpoint'.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a POST request to '/myEndpoint'.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a POST request\n * @public\n * @example\n *  post('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {operation}\n */\nexport function post(path: string, params: object, callback: Function): operation;\n\n### Implementation:\nimport {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a POST request\n * @public\n * @example\n *  post('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {operation}\n */\nexport function post(path, params, callback) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedParams = http.expandRequestReferences(params)(state);\n\n    const url = setUrl(state.configuration, resolvedPath);\n\n    const auth = setAuth(\n      state.configuration,\n      resolvedParams?.authentication ?? resolvedParams?.auth\n    );\n\n    const config = mapToAxiosConfig({ ...resolvedParams, url, auth });\n\n    return http\n      .post(config)(state)\n      .then(response => handleResponse(state, response))\n      .then(nextState => handleCallback(nextState, callback));\n  };\n}\n"
  },
  {
    "name": "put",
    "implementation": "import {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a PUT request\n * @public\n * @example\n *  put('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Auth parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function put(path, params, callback) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedParams = http.expandRequestReferences(params)(state);\n\n    const url = setUrl(state.configuration, resolvedPath);\n\n    const auth = setAuth(\n      state.configuration,\n      resolvedParams?.authentication ?? resolvedParams?.auth\n    );\n\n    const config = mapToAxiosConfig({ ...resolvedParams, url, auth });\n\n    return http\n      .put(config)(state)\n      .then(response => handleResponse(state, response))\n      .then(nextState => handleCallback(nextState, callback));\n  };\n}",
    "signature": "/**\n * Make a PUT request\n * @public\n * @example\n *  put('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Auth parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function put(path: string, params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a PUT request to a resource.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a PUT request to a resource.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a PUT request\n * @public\n * @example\n *  put('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Auth parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function put(path: string, params: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a PUT request\n * @public\n * @example\n *  put('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Auth parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function put(path, params, callback) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedParams = http.expandRequestReferences(params)(state);\n\n    const url = setUrl(state.configuration, resolvedPath);\n\n    const auth = setAuth(\n      state.configuration,\n      resolvedParams?.authentication ?? resolvedParams?.auth\n    );\n\n    const config = mapToAxiosConfig({ ...resolvedParams, url, auth });\n\n    return http\n      .put(config)(state)\n      .then(response => handleResponse(state, response))\n      .then(nextState => handleCallback(nextState, callback));\n  };\n}\n"
  },
  {
    "name": "patch",
    "implementation": "import {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a PATCH request\n * @public\n * @example\n *  patch('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Auth parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function patch(path, params, callback) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedParams = http.expandRequestReferences(params)(state);\n\n    const url = setUrl(state.configuration, resolvedPath);\n\n    const auth = setAuth(\n      state.configuration,\n      resolvedParams?.authentication ?? resolvedParams?.auth\n    );\n\n    const config = mapToAxiosConfig({ ...resolvedParams, url, auth });\n\n    return http\n      .patch(config)(state)\n      .then(response => handleResponse(state, response))\n      .then(nextState => handleCallback(nextState, callback));\n  };\n}",
    "signature": "/**\n * Make a PATCH request\n * @public\n * @example\n *  patch('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Auth parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function patch(path: string, params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a PATCH request to a resource.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a PATCH request to a resource.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a PATCH request\n * @public\n * @example\n *  patch('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Auth parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function patch(path: string, params: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a PATCH request\n * @public\n * @example\n *  patch('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Auth parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function patch(path, params, callback) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedParams = http.expandRequestReferences(params)(state);\n\n    const url = setUrl(state.configuration, resolvedPath);\n\n    const auth = setAuth(\n      state.configuration,\n      resolvedParams?.authentication ?? resolvedParams?.auth\n    );\n\n    const config = mapToAxiosConfig({ ...resolvedParams, url, auth });\n\n    return http\n      .patch(config)(state)\n      .then(response => handleResponse(state, response))\n      .then(nextState => handleCallback(nextState, callback));\n  };\n}\n"
  },
  {
    "name": "del",
    "implementation": "import {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a DELETE request\n * @public\n * @example\n *  del(`/myendpoint/${state => state.data.id}`, {\n *    headers: {'content-type': 'application/json'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Auth parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function del(path, params, callback) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedParams = http.expandRequestReferences(params)(state);\n\n    const url = setUrl(state.configuration, resolvedPath);\n\n    const auth = setAuth(\n      state.configuration,\n      resolvedParams?.authentication ?? resolvedParams.auth\n    );\n\n    const config = mapToAxiosConfig({ ...resolvedParams, url, auth });\n\n    return http\n      .delete(config)(state)\n      .then(response => handleResponse(state, response))\n      .then(nextState => handleCallback(nextState, callback));\n  };\n}",
    "signature": "/**\n * Make a DELETE request\n * @public\n * @example\n *  del(`/myendpoint/${state => state.data.id}`, {\n *    headers: {'content-type': 'application/json'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Auth parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function del(path: string, params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a DELETE request to a resource.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a DELETE request to a resource.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a DELETE request\n * @public\n * @example\n *  del(`/myendpoint/${state => state.data.id}`, {\n *    headers: {'content-type': 'application/json'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Auth parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function del(path: string, params: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a DELETE request\n * @public\n * @example\n *  del(`/myendpoint/${state => state.data.id}`, {\n *    headers: {'content-type': 'application/json'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Auth parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function del(path, params, callback) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedParams = http.expandRequestReferences(params)(state);\n\n    const url = setUrl(state.configuration, resolvedPath);\n\n    const auth = setAuth(\n      state.configuration,\n      resolvedParams?.authentication ?? resolvedParams.auth\n    );\n\n    const config = mapToAxiosConfig({ ...resolvedParams, url, auth });\n\n    return http\n      .delete(config)(state)\n      .then(response => handleResponse(state, response))\n      .then(nextState => handleCallback(nextState, callback));\n  };\n}\n"
  },
  {
    "name": "parseXML",
    "implementation": "import {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Parse XML with the Cheerio parser\n * @public\n * @example\n *  parseXML(body, function($){\n *    return $(\"table[class=your_table]\").parsetable(true, true, true);\n *  })\n * @function\n * @param {String} body - data string to be parsed\n * @param {function} script - script for extracting data\n * @returns {Operation}\n */\nexport function parseXML(body, script) {\n  return state => {\n    const $ = cheerio.load(body);\n    cheerioTableparser($);\n\n    if (script) {\n      const result = script($);\n      try {\n        const r = JSON.parse(result);\n        return composeNextState(state, r);\n      } catch (e) {\n        return composeNextState(state, { body: result });\n      }\n    } else {\n      return composeNextState(state, { body: body });\n    }\n  };\n}",
    "signature": "/**\n * Parse XML with the Cheerio parser\n * @public\n * @example\n *  parseXML(body, function($){\n *    return $(\"table[class=your_table]\").parsetable(true, true, true);\n *  })\n * @function\n * @param {String} body - data string to be parsed\n * @param {function} script - script for extracting data\n * @returns {Operation}\n */\nexport function parseXML(body: string, script: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that parses XML with the Cheerio parser.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that parses XML with the Cheerio parser.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Parse XML with the Cheerio parser\n * @public\n * @example\n *  parseXML(body, function($){\n *    return $(\"table[class=your_table]\").parsetable(true, true, true);\n *  })\n * @function\n * @param {String} body - data string to be parsed\n * @param {function} script - script for extracting data\n * @returns {Operation}\n */\nexport function parseXML(body: string, script: Function): Operation;\n\n### Implementation:\nimport {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Parse XML with the Cheerio parser\n * @public\n * @example\n *  parseXML(body, function($){\n *    return $(\"table[class=your_table]\").parsetable(true, true, true);\n *  })\n * @function\n * @param {String} body - data string to be parsed\n * @param {function} script - script for extracting data\n * @returns {Operation}\n */\nexport function parseXML(body, script) {\n  return state => {\n    const $ = cheerio.load(body);\n    cheerioTableparser($);\n\n    if (script) {\n      const result = script($);\n      try {\n        const r = JSON.parse(result);\n        return composeNextState(state, r);\n      } catch (e) {\n        return composeNextState(state, { body: result });\n      }\n    } else {\n      return composeNextState(state, { body: body });\n    }\n  };\n}\n"
  },
  {
    "name": "request",
    "implementation": "import {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a request using the 'request' node module. This module is deprecated.\n * @example\n *  request(params);\n * @function\n * @param {object} params - Query, Headers and Authentication parameters\n * @returns {Operation}\n */\nexport function request(params) {\n  return state => {\n    const resolvedParams = http.expandRequestReferences(params)(state);\n\n    return new Promise((resolve, reject) => {\n      nodeRequest(resolvedParams, (err, response, body) => {\n        const error = assembleError({ error: err, response, resolvedParams });\n        error && reject(error);\n\n        console.log(\n          '\u2713 Request succeeded. (The response body available in state.)'\n        );\n        const resp = tryJson(body);\n        resolve(resp);\n      });\n    });\n  };\n}",
    "signature": "/**\n * Make a request using the 'request' node module. This module is deprecated.\n * @example\n *  request(params);\n * @function\n * @param {object} params - Query, Headers and Authentication parameters\n * @returns {Operation}\n */\nexport function request(params: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a request using the 'request' node module.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a request using the 'request' node module.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a request using the 'request' node module. This module is deprecated.\n * @example\n *  request(params);\n * @function\n * @param {object} params - Query, Headers and Authentication parameters\n * @returns {Operation}\n */\nexport function request(params: object): Operation;\n\n### Implementation:\nimport {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a request using the 'request' node module. This module is deprecated.\n * @example\n *  request(params);\n * @function\n * @param {object} params - Query, Headers and Authentication parameters\n * @returns {Operation}\n */\nexport function request(params) {\n  return state => {\n    const resolvedParams = http.expandRequestReferences(params)(state);\n\n    return new Promise((resolve, reject) => {\n      nodeRequest(resolvedParams, (err, response, body) => {\n        const error = assembleError({ error: err, response, resolvedParams });\n        error && reject(error);\n\n        console.log(\n          '\u2713 Request succeeded. (The response body available in state.)'\n        );\n        const resp = tryJson(body);\n        resolve(resp);\n      });\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for beyonic.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for beyonic.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for beyonic.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for beyonic.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "createPayment",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create a payment\n * @example\n * execute(\n *   createPayment(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the payment\n * @returns {Operation}\n */\nexport function createPayment(data) {\n  return state => {\n    const body = expandReferences(data)(state);\n\n    const { apiUrl, apiToken } = state.configuration;\n\n    const url = resolveUrl(apiUrl + '/', 'payments');\n\n    console.log('Posting payment:');\n    console.log(body);\n\n    return post({ apiToken, body, url }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}",
    "signature": "/**\n * Create a payment\n * @example\n * execute(\n *   createPayment(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the payment\n * @returns {Operation}\n */\nexport function createPayment(data: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that creates a payment from data.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates a payment from data.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create a payment\n * @example\n * execute(\n *   createPayment(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the payment\n * @returns {Operation}\n */\nexport function createPayment(data: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create a payment\n * @example\n * execute(\n *   createPayment(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the payment\n * @returns {Operation}\n */\nexport function createPayment(data) {\n  return state => {\n    const body = expandReferences(data)(state);\n\n    const { apiUrl, apiToken } = state.configuration;\n\n    const url = resolveUrl(apiUrl + '/', 'payments');\n\n    console.log('Posting payment:');\n    console.log(body);\n\n    return post({ apiToken, body, url }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}\n"
  },
  {
    "name": "createContact",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create a contact\n * @example\n * execute(\n *   createContact(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the contact\n * @returns {Operation}\n */\nexport function createContact(data) {\n  return state => {\n    const body = expandReferences(data)(state);\n\n    const { apiUrl, apiToken } = state.configuration;\n\n    const url = resolveUrl(apiUrl + '/', 'contacts');\n\n    console.log('Posting contact:');\n    console.log(body);\n\n    return post({ apiToken, body, url }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}",
    "signature": "/**\n * Create a contact\n * @example\n * execute(\n *   createContact(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the contact\n * @returns {Operation}\n */\nexport function createContact(data: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that creates a contact from data.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates a contact from data.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create a contact\n * @example\n * execute(\n *   createContact(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the contact\n * @returns {Operation}\n */\nexport function createContact(data: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create a contact\n * @example\n * execute(\n *   createContact(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the contact\n * @returns {Operation}\n */\nexport function createContact(data) {\n  return state => {\n    const body = expandReferences(data)(state);\n\n    const { apiUrl, apiToken } = state.configuration;\n\n    const url = resolveUrl(apiUrl + '/', 'contacts');\n\n    console.log('Posting contact:');\n    console.log(body);\n\n    return post({ apiToken, body, url }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}\n"
  },
  {
    "name": "createCollectionRequest",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create a collection request\n * @example\n * execute(\n *   createCollectionRequest(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the collection request\n * @returns {Operation}\n */\nexport function createCollectionRequest(data) {\n  return state => {\n    const body = expandReferences(data)(state);\n\n    const { apiUrl, apiToken } = state.configuration;\n\n    const url = resolveUrl(apiUrl + '/', 'collectionrequests');\n\n    console.log('Posting collection request:');\n    console.log(body);\n\n    return post({ apiToken, body, url }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}",
    "signature": "/**\n * Create a collection request\n * @example\n * execute(\n *   createCollectionRequest(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the collection request\n * @returns {Operation}\n */\nexport function createCollectionRequest(data: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that creates a collection request from data.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates a collection request from data.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create a collection request\n * @example\n * execute(\n *   createCollectionRequest(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the collection request\n * @returns {Operation}\n */\nexport function createCollectionRequest(data: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create a collection request\n * @example\n * execute(\n *   createCollectionRequest(data)\n * )(state)\n * @function\n * @param {object} data - Payload data for the collection request\n * @returns {Operation}\n */\nexport function createCollectionRequest(data) {\n  return state => {\n    const body = expandReferences(data)(state);\n\n    const { apiUrl, apiToken } = state.configuration;\n\n    const url = resolveUrl(apiUrl + '/', 'collectionrequests');\n\n    console.log('Posting collection request:');\n    console.log(body);\n\n    return post({ apiToken, body, url }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for mysql.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      connect,\n      ...operations,\n      disconnect,\n      cleanupState\n    )({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for mysql.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for mysql.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for mysql.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      connect,\n      ...operations,\n      disconnect,\n      cleanupState\n    )({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "insert",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert a record\n * @example\n * execute(\n *   insert('table', fields(\n *      field('name', dataValue('name'))\n *   ))\n * )(state)\n * @function\n * @param {string} table - The target table\n * @param {object} fields - A fields object\n * @returns {Operation}\n */\nexport function insert(table, fields) {\n  return state => {\n    let { connection } = state;\n\n    const valuesObj = expandReferences(fields)(state);\n\n    const squelMysql = squel.useFlavour('mysql');\n\n    var sqlParams = squelMysql\n      .insert({\n        autoQuoteFieldNames: true,\n      })\n      .into(table)\n      .setFields(valuesObj)\n      .toParam();\n\n    var sql = sqlParams.text;\n    var inserts = sqlParams.values;\n    sqlString = mysql.format(sql, inserts);\n\n    console.log(`Executing MySQL query: ${sqlString}`);\n\n    return new Promise((resolve, reject) => {\n      // execute a query on our database\n\n      // TODO: figure out how to escape the string.\n\n      connection.query(sqlString,",
    "signature": "/**\n * Insert a record\n * @example\n * execute(\n *   insert('table', fields(\n *      field('name', dataValue('name'))\n *   ))\n * )(state)\n * @function\n * @param {string} table - The target table\n * @param {object} fields - A fields object\n * @returns {Operation}\n */\nexport function insert(table: string, fields: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that inserts a record to the target table.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that inserts a record to the target table.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Insert a record\n * @example\n * execute(\n *   insert('table', fields(\n *      field('name', dataValue('name'))\n *   ))\n * )(state)\n * @function\n * @param {string} table - The target table\n * @param {object} fields - A fields object\n * @returns {Operation}\n */\nexport function insert(table: string, fields: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert a record\n * @example\n * execute(\n *   insert('table', fields(\n *      field('name', dataValue('name'))\n *   ))\n * )(state)\n * @function\n * @param {string} table - The target table\n * @param {object} fields - A fields object\n * @returns {Operation}\n */\nexport function insert(table, fields) {\n  return state => {\n    let { connection } = state;\n\n    const valuesObj = expandReferences(fields)(state);\n\n    const squelMysql = squel.useFlavour('mysql');\n\n    var sqlParams = squelMysql\n      .insert({\n        autoQuoteFieldNames: true,\n      })\n      .into(table)\n      .setFields(valuesObj)\n      .toParam();\n\n    var sql = sqlParams.text;\n    var inserts = sqlParams.values;\n    sqlString = mysql.format(sql, inserts);\n\n    console.log(`Executing MySQL query: ${sqlString}`);\n\n    return new Promise((resolve, reject) => {\n      // execute a query on our database\n\n      // TODO: figure out how to escape the string.\n\n      connection.query(sqlString,\n"
  },
  {
    "name": "upsert",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert or Update a record if matched\n * @example\n * execute(\n *   upsert('table', fields(\n *      field('name', dataValue('name'))\n *   ))\n * )(state)\n * @function\n * @param {string} table - The target table\n * @param {object} fields - A fields object\n * @returns {Operation}\n */\nexport function upsert(table, fields) {\n  return state => {\n    let { connection } = state;\n\n    const valuesObj = expandReferences(fields)(state);\n\n    const squelMysql = squel.useFlavour('mysql');\n\n    var insertParams = squelMysql\n      .insert({\n        autoQuoteFieldNames: true,\n      })\n      .into(table)\n      .setFields(valuesObj)\n      .toParam();\n\n    var sql = insertParams.text;\n    var inserts = insertParams.values;\n    const insertString = mysql.format(sql, inserts);\n\n    var updateParams = squelMysql\n      .update({\n        autoQuoteFieldNames: true,\n      })\n      .table('')\n      .setFields(valuesObj)\n      .toParam();\n\n    var sql = updateParams.text;\n    var inserts = updateParams.values;\n    const updateString = mysql.format(sql, inserts);\n\n    const upsertString =\n      insertString + ` ON DUPLICATE KEY UPDATE ` + updateString.slice(10);\n\n    console.log('Executing MySQL query: ' + upsertString);\n\n    return new Promise((resolve, reject) => {\n      // execute a query on our database\n\n      // TODO: figure out how to escape the string.\n\n      connection.query(upsertString,",
    "signature": "/**\n * Insert or Update a record if matched\n * @example\n * execute(\n *   upsert('table', fields(\n *      field('name', dataValue('name'))\n *   ))\n * )(state)\n * @function\n * @param {string} table - The target table\n * @param {object} fields - A fields object\n * @returns {Operation}\n */\nexport function upsert(table: string, fields: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts to/on/from the target table.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts to/on/from the target table.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Insert or Update a record if matched\n * @example\n * execute(\n *   upsert('table', fields(\n *      field('name', dataValue('name'))\n *   ))\n * )(state)\n * @function\n * @param {string} table - The target table\n * @param {object} fields - A fields object\n * @returns {Operation}\n */\nexport function upsert(table: string, fields: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert or Update a record if matched\n * @example\n * execute(\n *   upsert('table', fields(\n *      field('name', dataValue('name'))\n *   ))\n * )(state)\n * @function\n * @param {string} table - The target table\n * @param {object} fields - A fields object\n * @returns {Operation}\n */\nexport function upsert(table, fields) {\n  return state => {\n    let { connection } = state;\n\n    const valuesObj = expandReferences(fields)(state);\n\n    const squelMysql = squel.useFlavour('mysql');\n\n    var insertParams = squelMysql\n      .insert({\n        autoQuoteFieldNames: true,\n      })\n      .into(table)\n      .setFields(valuesObj)\n      .toParam();\n\n    var sql = insertParams.text;\n    var inserts = insertParams.values;\n    const insertString = mysql.format(sql, inserts);\n\n    var updateParams = squelMysql\n      .update({\n        autoQuoteFieldNames: true,\n      })\n      .table('')\n      .setFields(valuesObj)\n      .toParam();\n\n    var sql = updateParams.text;\n    var inserts = updateParams.values;\n    const updateString = mysql.format(sql, inserts);\n\n    const upsertString =\n      insertString + ` ON DUPLICATE KEY UPDATE ` + updateString.slice(10);\n\n    console.log('Executing MySQL query: ' + upsertString);\n\n    return new Promise((resolve, reject) => {\n      // execute a query on our database\n\n      // TODO: figure out how to escape the string.\n\n      connection.query(upsertString,\n"
  },
  {
    "name": "upsertMany",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert or update multiple records using ON DUPLICATE KEY\n * @public\n * @example\n * upsertMany(\n *   'users', // the DB table\n *   [\n *     { name: 'one', email: 'one@openfn.org' },\n *     { name: 'two', email: 'two@openfn.org' },\n *   ]\n * )\n * @function\n * @param {string} table - The target table\n * @param {array} data - An array of objects or a function that returns an array\n * @returns {Operation}\n */\nexport function upsertMany(table, data) {\n  return",
    "signature": "/**\n * Insert or update multiple records using ON DUPLICATE KEY\n * @public\n * @example\n * upsertMany(\n *   'users', // the DB table\n *   [\n *     { name: 'one', email: 'one@openfn.org' },\n *     { name: 'two', email: 'two@openfn.org' },\n *   ]\n * )\n * @function\n * @param {string} table - The target table\n * @param {array} data - An array of objects or a function that returns an array\n * @returns {Operation}\n */\nexport function upsertMany(table: string, data: any[]): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts many records to/on the 'users'",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts many records to/on the 'users'\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Insert or update multiple records using ON DUPLICATE KEY\n * @public\n * @example\n * upsertMany(\n *   'users', // the DB table\n *   [\n *     { name: 'one', email: 'one@openfn.org' },\n *     { name: 'two', email: 'two@openfn.org' },\n *   ]\n * )\n * @function\n * @param {string} table - The target table\n * @param {array} data - An array of objects or a function that returns an array\n * @returns {Operation}\n */\nexport function upsertMany(table: string, data: any[]): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert or update multiple records using ON DUPLICATE KEY\n * @public\n * @example\n * upsertMany(\n *   'users', // the DB table\n *   [\n *     { name: 'one', email: 'one@openfn.org' },\n *     { name: 'two', email: 'two@openfn.org' },\n *   ]\n * )\n * @function\n * @param {string} table - The target table\n * @param {array} data - An array of objects or a function that returns an array\n * @returns {Operation}\n */\nexport function upsertMany(table, data) {\n  return\n"
  },
  {
    "name": "query",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a SQL statement\n * @example\n * execute(\n *   query({ sql: 'select * from users;' })\n * )(state)\n * @function\n * @param {object} options - Payload data for the message\n * @returns {Operation}\n */\nexport function query(options) {\n  return state => {\n    let { connection } = state;\n\n    const opts = expandReferences(options)(state);\n\n    console.log(\n      'Executing MySQL statement with options: ' + JSON.stringify(opts, 2, null)\n    );\n\n    return new Promise((resolve, reject) => {\n      // execute a query on our database\n      connection.query(opts,",
    "signature": "/**\n * Execute a SQL statement\n * @example\n * execute(\n *   query({ sql: 'select * from users;' })\n * )(state)\n * @function\n * @param {object} options - Payload data for the message\n * @returns {Operation}\n */\nexport function query(options: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a SQL statement.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a SQL statement.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a SQL statement\n * @example\n * execute(\n *   query({ sql: 'select * from users;' })\n * )(state)\n * @function\n * @param {object} options - Payload data for the message\n * @returns {Operation}\n */\nexport function query(options: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a SQL statement\n * @example\n * execute(\n *   query({ sql: 'select * from users;' })\n * )(state)\n * @function\n * @param {object} options - Payload data for the message\n * @returns {Operation}\n */\nexport function query(options) {\n  return state => {\n    let { connection } = state;\n\n    const opts = expandReferences(options)(state);\n\n    console.log(\n      'Executing MySQL statement with options: ' + JSON.stringify(opts, 2, null)\n    );\n\n    return new Promise((resolve, reject) => {\n      // execute a query on our database\n      connection.query(opts,\n"
  },
  {
    "name": "sqlString",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a SQL statement\n * @example\n * execute(\n *   sqlString(state => \"select * from items;\")\n * )(state)\n * @function\n * @param {String} queryString - A query string (or function which takes state and returns a string)\n * @returns {Operation}\n */\nexport function sqlString(queryString) {\n  return state => {\n    return query({ sql: queryString })(state);\n  };\n}",
    "signature": "/**\n * Execute a SQL statement\n * @example\n * execute(\n *   sqlString(state => \"select * from items;\")\n * )(state)\n * @function\n * @param {String} queryString - A query string (or function which takes state and returns a string)\n * @returns {Operation}\n */\nexport function sqlString(queryString: string): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a SQL statement.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a SQL statement.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a SQL statement\n * @example\n * execute(\n *   sqlString(state => \"select * from items;\")\n * )(state)\n * @function\n * @param {String} queryString - A query string (or function which takes state and returns a string)\n * @returns {Operation}\n */\nexport function sqlString(queryString: string): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a SQL statement\n * @example\n * execute(\n *   sqlString(state => \"select * from items;\")\n * )(state)\n * @function\n * @param {String} queryString - A query string (or function which takes state and returns a string)\n * @returns {Operation}\n */\nexport function sqlString(queryString) {\n  return state => {\n    return query({ sql: queryString })(state);\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for khanacademy.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for khanacademy.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for khanacademy.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for khanacademy.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "fetch",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch data from the Khan Academy API\n * @example\n * execute(\n *   fetch(params)\n * )(state)\n * @function\n * @param {object} params - data to make the query\n * @returns {Operation}\n */\nexport function fetch(params) {",
    "signature": "/**\n * Fetch data from the Khan Academy API\n * @example\n * execute(\n *   fetch(params)\n * )(state)\n * @function\n * @param {object} params - data to make the query\n * @returns {Operation}\n */\nexport function fetch(params: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that fetches data from the Khan Academy API.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that fetches data from the Khan Academy API.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Fetch data from the Khan Academy API\n * @example\n * execute(\n *   fetch(params)\n * )(state)\n * @function\n * @param {object} params - data to make the query\n * @returns {Operation}\n */\nexport function fetch(params: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch data from the Khan Academy API\n * @example\n * execute(\n *   fetch(params)\n * )(state)\n * @function\n * @param {object} params - data to make the query\n * @returns {Operation}\n */\nexport function fetch(params) {\n"
  },
  {
    "name": "execute",
    "implementation": "import { expandReferences } from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport { expandReferences } from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}\n"
  },
  {
    "name": "sendSMS",
    "implementation": "import { expandReferences } from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Sends an SMS message to a specific phone number\n * @public\n * @example\n * sendSMS(\"OpenFn\", \"phoneNumber\", \"Hello World!\")\n * @function\n * @param {String} from - Name or number the message should be sent from.\n * @param {String} toNumber - Destination phone number.\n * @param {String} message - Text message\n * @returns {Operation}\n */\nexport function sendSMS(from, toNumber, message) {\n  return state => {\n    const { apiKey, apiSecret } = state.configuration;\n    const [resolvedFrom, resolvedToNumber, resolvedMessage] = expandReferences(\n      state,\n      from,\n      toNumber,\n      message\n    );\n\n    const nexmo = new Nexmo({\n      apiKey: apiKey,\n      apiSecret: apiSecret,\n    });\n\n    return new Promise((resolve, reject) => {\n      nexmo.message.sendSms(\n        resolvedFrom,\n        resolvedToNumber,\n        resolvedMessage,\n        (error, response) => {\n          if (error) {\n            console.error(error);\n            reject(error);\n          } else if (response.messages[0].status != '0') {\n            console.error('Nexmo Error:');\n            console.error(response);\n            reject(response);\n          } else {\n            console.log(response);\n            resolve(response);\n          }\n        }\n      );\n    }).then(response => {\n      const nextState = composeNextState(state, response);\n      return nextState;\n    });\n  };\n}",
    "signature": "/**\n * Sends an SMS message to a specific phone number\n * @public\n * @example\n * sendSMS(\"OpenFn\", \"phoneNumber\", \"Hello World!\")\n * @function\n * @param {String} from - Name or number the message should be sent from.\n * @param {String} toNumber - Destination phone number.\n * @param {String} message - Text message\n * @returns {Operation}\n */\nexport function sendSMS(from: string, toNumber: string, message: string): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that sends an SMS message from to a specific phone number.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that sends an SMS message from to a specific phone number.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Sends an SMS message to a specific phone number\n * @public\n * @example\n * sendSMS(\"OpenFn\", \"phoneNumber\", \"Hello World!\")\n * @function\n * @param {String} from - Name or number the message should be sent from.\n * @param {String} toNumber - Destination phone number.\n * @param {String} message - Text message\n * @returns {Operation}\n */\nexport function sendSMS(from: string, toNumber: string, message: string): Operation;\n\n### Implementation:\nimport { expandReferences } from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Sends an SMS message to a specific phone number\n * @public\n * @example\n * sendSMS(\"OpenFn\", \"phoneNumber\", \"Hello World!\")\n * @function\n * @param {String} from - Name or number the message should be sent from.\n * @param {String} toNumber - Destination phone number.\n * @param {String} message - Text message\n * @returns {Operation}\n */\nexport function sendSMS(from, toNumber, message) {\n  return state => {\n    const { apiKey, apiSecret } = state.configuration;\n    const [resolvedFrom, resolvedToNumber, resolvedMessage] = expandReferences(\n      state,\n      from,\n      toNumber,\n      message\n    );\n\n    const nexmo = new Nexmo({\n      apiKey: apiKey,\n      apiSecret: apiSecret,\n    });\n\n    return new Promise((resolve, reject) => {\n      nexmo.message.sendSms(\n        resolvedFrom,\n        resolvedToNumber,\n        resolvedMessage,\n        (error, response) => {\n          if (error) {\n            console.error(error);\n            reject(error);\n          } else if (response.messages[0].status != '0') {\n            console.error('Nexmo Error:');\n            console.error(response);\n            reject(response);\n          } else {\n            console.log(response);\n            resolve(response);\n          }\n        }\n      );\n    }).then(response => {\n      const nextState = composeNextState(state, response);\n      return nextState;\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import { expandReferences } from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      connect,\n      ...operations,\n      disconnect\n    )({\n      ...initialState,\n      ...state,\n    });\n  };\n}\n\nasync",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "describe('execute', () => {\n  it.skip('executes each operation in sequence', done => {\n    const state = {\n      configuration: {\n        host: 'localhost',\n        username: 'admin',\n        password: 'admin',\n        port: '10000',\n      },\n    };\n    const operations = [\n      state => {\n        return { counter: 1 };\n      },\n      state => {\n        return { counter: 2 };\n      },\n      state => {\n        return { counter: 3 };\n      },\n    ];\n\n    execute(...operations)(state)\n      .then(finalState => {\n        expect(finalState).to.eql({ counter: 3 });",
    "instruction": "Create an OpenFn function that executes a sequence of operations.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport { expandReferences } from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      connect,\n      ...operations,\n      disconnect\n    )({\n      ...initialState,\n      ...state,\n    });\n  };\n}\n\nasync\n"
  },
  {
    "name": "query",
    "implementation": "import { expandReferences } from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute an SQL statement\n * @public\n * @example\n * <caption>Get patient count from hive database</caption>\n * query(\"select count(*) from patient\");\n * @function\n * @param {string} qs - SQL statement\n * @param {object} options - (Optional) options for executing sql statement\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function query(qs, options, callback) {\n  return async state => {\n    const [resolvedQs, resolvedOptions] = expandReferences(state, qs, options);\n\n    console.log(`Executing query: ${resolvedQs}`);\n\n    const result = await execSql(resolvedQs, resolvedOptions);\n\n    console.log('Success... \u2714');\n    console.log('Retrieved', result.length, 'items');\n\n    const nextState = {\n      ...composeNextState(state, result),\n      result,\n    };\n\n    if (callback) callback(nextState);\n    return nextState;\n  };\n}\n\nconst defaultOpts = {\n  runAsync: true,\n};\n\nasync",
    "signature": "/**\n * Execute an SQL statement\n * @public\n * @example\n * <caption>Get patient count from hive database</caption>\n * query(\"select count(*) from patient\");\n * @function\n * @param {string} qs - SQL statement\n * @param {object} options - (Optional) options for executing sql statement\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function query(qs: string, options: object, callback: Function): Operation;",
    "instruction": "Create an OpenFn function that executes an SQL statement to/on/from a hive database",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes an SQL statement to/on/from a hive database\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute an SQL statement\n * @public\n * @example\n * <caption>Get patient count from hive database</caption>\n * query(\"select count(*) from patient\");\n * @function\n * @param {string} qs - SQL statement\n * @param {object} options - (Optional) options for executing sql statement\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function query(qs: string, options: object, callback: Function): Operation;\n\n### Implementation:\nimport { expandReferences } from '@openfn/language-common/util';\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute an SQL statement\n * @public\n * @example\n * <caption>Get patient count from hive database</caption>\n * query(\"select count(*) from patient\");\n * @function\n * @param {string} qs - SQL statement\n * @param {object} options - (Optional) options for executing sql statement\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function query(qs, options, callback) {\n  return async state => {\n    const [resolvedQs, resolvedOptions] = expandReferences(state, qs, options);\n\n    console.log(`Executing query: ${resolvedQs}`);\n\n    const result = await execSql(resolvedQs, resolvedOptions);\n\n    console.log('Success... \u2714');\n    console.log('Retrieved', result.length, 'items');\n\n    const nextState = {\n      ...composeNextState(state, result),\n      result,\n    };\n\n    if (callback) callback(nextState);\n    return nextState;\n  };\n}\n\nconst defaultOpts = {\n  runAsync: true,\n};\n\nasync\n"
  },
  {
    "name": "relationship",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * @typedef {Object} State\n * @property {object} data JSON Data.\n * @property {Array<Reference>} references History of all previous operations.\n * @ignore\n */\n\n/**\n * @typedef {Function} Operation\n * @param {State} state\n * @ignore\n */\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n\nimport jsforce from 'jsforce';\nimport flatten from 'lodash/flatten';\n\n/**\n * Adds a lookup relation or 'dome insert' to a record.\n * @public\n * @example\n * Data Sourced Value:\n *  relationship(\"relationship_name__r\", \"externalID on related object\", dataSource(\"path\"))\n * Fixed Value:\n *  relationship(\"relationship_name__r\", \"externalID on related object\", \"hello world\")\n * @function\n * @param {string} relationshipName - `__r` relationship field on the record.\n * @param {string} externalId - Salesforce ExternalID field.\n * @param {string} dataSource - resolvable source.\n * @returns {object}\n */\nexport function relationship(relationshipName, externalId, dataSource) {\n  return field(relationshipName, state => {\n    if (typeof dataSource == '",
    "signature": "/**\n * Adds a lookup relation or 'dome insert' to a record.\n * @public\n * @example\n * Data Sourced Value:\n *  relationship(\"relationship_name__r\", \"externalID on related object\", dataSource(\"path\"))\n * Fixed Value:\n *  relationship(\"relationship_name__r\", \"externalID on related object\", \"hello world\")\n * @function\n * @param {string} relationshipName - `__r` relationship field on the record.\n * @param {string} externalId - Salesforce ExternalID field.\n * @param {string} dataSource - resolvable source.\n * @returns {object}\n */\nexport function relationship(relationshipName: string, externalId: string, dataSource: string): object;",
    "instruction": "Create an OpenFn function that adds a lookup relation or 'dome insert' to a",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that adds a lookup relation or 'dome insert' to a\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Adds a lookup relation or 'dome insert' to a record.\n * @public\n * @example\n * Data Sourced Value:\n *  relationship(\"relationship_name__r\", \"externalID on related object\", dataSource(\"path\"))\n * Fixed Value:\n *  relationship(\"relationship_name__r\", \"externalID on related object\", \"hello world\")\n * @function\n * @param {string} relationshipName - `__r` relationship field on the record.\n * @param {string} externalId - Salesforce ExternalID field.\n * @param {string} dataSource - resolvable source.\n * @returns {object}\n */\nexport function relationship(relationshipName: string, externalId: string, dataSource: string): object;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * @typedef {Object} State\n * @property {object} data JSON Data.\n * @property {Array<Reference>} references History of all previous operations.\n * @ignore\n */\n\n/**\n * @typedef {Function} Operation\n * @param {State} state\n * @ignore\n */\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n\nimport jsforce from 'jsforce';\nimport flatten from 'lodash/flatten';\n\n/**\n * Adds a lookup relation or 'dome insert' to a record.\n * @public\n * @example\n * Data Sourced Value:\n *  relationship(\"relationship_name__r\", \"externalID on related object\", dataSource(\"path\"))\n * Fixed Value:\n *  relationship(\"relationship_name__r\", \"externalID on related object\", \"hello world\")\n * @function\n * @param {string} relationshipName - `__r` relationship field on the record.\n * @param {string} externalId - Salesforce ExternalID field.\n * @param {string} dataSource - resolvable source.\n * @returns {object}\n */\nexport function relationship(relationshipName, externalId, dataSource) {\n  return field(relationshipName, state => {\n    if (typeof dataSource == '\n"
  },
  {
    "name": "describeAll",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Outputs basic information about available sObjects.\n * @public\n * @example\n * describeAll()\n * @function\n * @returns {Operation}\n */\nexport function describeAll() {\n  return state => {\n    const { connection } = state;\n\n    return connection.describeGlobal().then(result => {\n      const { sobjects } = result;\n      console.log(`Retrieved ${sobjects.length} sObjects`);\n\n      return {\n        ...state,\n        references: [sobjects, ...state.references],\n      };\n    });\n  };\n}",
    "signature": "/**\n * Outputs basic information about available sObjects.\n * @public\n * @example\n * describeAll()\n * @function\n * @returns {Operation}\n */\nexport function describeAll(): Operation;",
    "instruction": "Create an OpenFn function that outputs basic information about available sObjects.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that outputs basic information about available sObjects.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Outputs basic information about available sObjects.\n * @public\n * @example\n * describeAll()\n * @function\n * @returns {Operation}\n */\nexport function describeAll(): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Outputs basic information about available sObjects.\n * @public\n * @example\n * describeAll()\n * @function\n * @returns {Operation}\n */\nexport function describeAll() {\n  return state => {\n    const { connection } = state;\n\n    return connection.describeGlobal().then(result => {\n      const { sobjects } = result;\n      console.log(`Retrieved ${sobjects.length} sObjects`);\n\n      return {\n        ...state,\n        references: [sobjects, ...state.references],\n      };\n    });\n  };\n}\n"
  },
  {
    "name": "describe",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Outputs basic information about an sObject to `STDOUT`.\n * @public\n * @example\n * describe('obj_name')\n * @function\n * @param {String} sObject - API name of the sObject.\n * @returns {Operation}\n */\nexport function describe(sObject) {\n  return state => {\n    const { connection } = state;\n\n    const objectName = expandReferences(sObject)(state);\n\n    return connection\n      .sobject(objectName)\n      .describe()\n      .then(result => {\n        console.log('Label : ' + result.label);\n        console.log('Num of Fields : ' + result.fields.length);\n\n        return {\n          ...state,\n          references: [result, ...state.references],\n        };\n      });\n  };\n}",
    "signature": "/**\n * Outputs basic information about an sObject to `STDOUT`.\n * @public\n * @example\n * describe('obj_name')\n * @function\n * @param {String} sObject - API name of the sObject.\n * @returns {Operation}\n */\nexport function describe(sObject: string): Operation;",
    "instruction": "Create an OpenFn function that describes an sObject.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that describes an sObject.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Outputs basic information about an sObject to `STDOUT`.\n * @public\n * @example\n * describe('obj_name')\n * @function\n * @param {String} sObject - API name of the sObject.\n * @returns {Operation}\n */\nexport function describe(sObject: string): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Outputs basic information about an sObject to `STDOUT`.\n * @public\n * @example\n * describe('obj_name')\n * @function\n * @param {String} sObject - API name of the sObject.\n * @returns {Operation}\n */\nexport function describe(sObject) {\n  return state => {\n    const { connection } = state;\n\n    const objectName = expandReferences(sObject)(state);\n\n    return connection\n      .sobject(objectName)\n      .describe()\n      .then(result => {\n        console.log('Label : ' + result.label);\n        console.log('Num of Fields : ' + result.fields.length);\n\n        return {\n          ...state,\n          references: [result, ...state.references],\n        };\n      });\n  };\n}\n"
  },
  {
    "name": "retrieve",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Retrieves a Salesforce sObject(s).\n * @public\n * @example\n * retrieve('ContentVersion', '0684K0000020Au7QAE/VersionData');\n * @function\n * @param {String} sObject - The sObject to retrieve\n * @param {String} id - The id of the record\n * @param {Function} callback - A callback to execute once the record is retrieved\n * @returns {Operation}\n */\nexport function retrieve(sObject, id, callback) {\n  return state => {\n    const { connection } = state;\n\n    const finalId = expandReferences(id)(state);\n\n    return connection\n      .sobject(sObject)\n      .retrieve(finalId)\n      .then(result => {\n        return {\n          ...state,\n          references: [result, ...state.references],\n        };\n      })\n      .then(state => {\n        if (callback) {\n          return callback(state);\n        }\n        return state;\n      });\n  };\n}",
    "signature": "/**\n * Retrieves a Salesforce sObject(s).\n * @public\n * @example\n * retrieve('ContentVersion', '0684K0000020Au7QAE/VersionData');\n * @function\n * @param {String} sObject - The sObject to retrieve\n * @param {String} id - The id of the record\n * @param {Function} callback - A callback to execute once the record is retrieved\n * @returns {Operation}\n */\nexport function retrieve(sObject: string, id: string, callback: Function): Operation;",
    "instruction": "Create an OpenFn function that retrieves a Salesforce sObject from a given id.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that retrieves a Salesforce sObject from a given id.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Retrieves a Salesforce sObject(s).\n * @public\n * @example\n * retrieve('ContentVersion', '0684K0000020Au7QAE/VersionData');\n * @function\n * @param {String} sObject - The sObject to retrieve\n * @param {String} id - The id of the record\n * @param {Function} callback - A callback to execute once the record is retrieved\n * @returns {Operation}\n */\nexport function retrieve(sObject: string, id: string, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Retrieves a Salesforce sObject(s).\n * @public\n * @example\n * retrieve('ContentVersion', '0684K0000020Au7QAE/VersionData');\n * @function\n * @param {String} sObject - The sObject to retrieve\n * @param {String} id - The id of the record\n * @param {Function} callback - A callback to execute once the record is retrieved\n * @returns {Operation}\n */\nexport function retrieve(sObject, id, callback) {\n  return state => {\n    const { connection } = state;\n\n    const finalId = expandReferences(id)(state);\n\n    return connection\n      .sobject(sObject)\n      .retrieve(finalId)\n      .then(result => {\n        return {\n          ...state,\n          references: [result, ...state.references],\n        };\n      })\n      .then(state => {\n        if (callback) {\n          return callback(state);\n        }\n        return state;\n      });\n  };\n}\n"
  },
  {
    "name": "query",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Execute an SOQL query.\n * Note that in an event of a query error,\n * error logs will be printed but the operation will not throw the error.\n * @public\n * @example\n * query(`SELECT Id FROM Patient__c WHERE Health_ID__c = '${state.data.field1}'`);\n * @function\n * @param {String} qs - A query string.\n * @returns {Operation}\n */\nexport function query(qs) {\n  return state => {\n    const { connection } = state;\n    const resolvedQs = expandReferences(qs)(state);\n    console.log(`Executing query: ${resolvedQs}`);\n\n    return connection.query(resolvedQs,",
    "signature": "/**\n * Execute an SOQL query.\n * Note that in an event of a query error,\n * error logs will be printed but the operation will not throw the error.\n * @public\n * @example\n * query(`SELECT Id FROM Patient__c WHERE Health_ID__c = '${state.data.field1}'`);\n * @function\n * @param {String} qs - A query string.\n * @returns {Operation}\n */\nexport function query(qs: string): Operation;",
    "instruction": "Create an OpenFn function that executes an SOQL query on a query string.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes an SOQL query on a query string.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute an SOQL query.\n * Note that in an event of a query error,\n * error logs will be printed but the operation will not throw the error.\n * @public\n * @example\n * query(`SELECT Id FROM Patient__c WHERE Health_ID__c = '${state.data.field1}'`);\n * @function\n * @param {String} qs - A query string.\n * @returns {Operation}\n */\nexport function query(qs: string): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Execute an SOQL query.\n * Note that in an event of a query error,\n * error logs will be printed but the operation will not throw the error.\n * @public\n * @example\n * query(`SELECT Id FROM Patient__c WHERE Health_ID__c = '${state.data.field1}'`);\n * @function\n * @param {String} qs - A query string.\n * @returns {Operation}\n */\nexport function query(qs) {\n  return state => {\n    const { connection } = state;\n    const resolvedQs = expandReferences(qs)(state);\n    console.log(`Executing query: ${resolvedQs}`);\n\n    return connection.query(resolvedQs,\n"
  },
  {
    "name": "bulkQuery",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Execute an SOQL Bulk Query.\n * This function uses bulk query to efficiently query large data sets and reduce the number of API requests.\n * Note that in an event of a query error,\n * error logs will be printed but the operation will not throw the error.\n * @public\n * @example\n * <caption>The results will be available on `state.data`</caption>\n * bulkQuery(state=> `SELECT Id FROM Patient__c WHERE Health_ID__c = '${state.data.field1}'`);\n * @example\n * bulkQuery(\n *   (state) =>\n *     `SELECT Id FROM Patient__c WHERE Health_ID__c = '${state.data.field1}'`,\n *   { pollTimeout: 10000, pollInterval: 6000 }\n * );\n * @function\n * @param {String} qs - A query string.\n * @param {Object} options - Options passed to the bulk api.\n * @param {integer} [options.pollTimeout] - Polling timeout in milliseconds.\n * @param {integer} [options.pollInterval] - Polling interval in milliseconds.\n * @param {Function} callback - A callback to execute once the record is retrieved\n * @returns {Operation}\n */\nexport function bulkQuery(qs, options, callback) {\n  return async state => {\n    const { connection } = state;\n    const [resolvedQs, resolvedOptions] = newExpandReferences(\n      state,\n      qs,\n      options\n    );\n    const apiVersion = connection.version;\n\n    const { pollTimeout, pollInterval } = {\n      ...defaultOptions,\n      ...resolvedOptions,\n    };\n\n    console.log(`Executing query: ${resolvedQs}`);\n\n    const queryJob = await connection.request({\n      method: 'POST',\n      url: `/services/data/v${apiVersion}/jobs/query`,\n      body: JSON.stringify({\n        operation: 'query',\n        query: resolvedQs,\n      }),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n\n    const result = await pollJobResult(\n      connection,\n      queryJob,\n      pollInterval,\n      pollTimeout\n    );\n\n    const nextState = {\n      ...composeNextState(state, result),\n      result,\n    };\n    if (callback) return callback(nextState);\n\n    return nextState;\n  };\n}",
    "signature": "/**\n * Execute an SOQL Bulk Query.\n * This function uses bulk query to efficiently query large data sets and reduce the number of API requests.\n * Note that in an event of a query error,\n * error logs will be printed but the operation will not throw the error.\n * @public\n * @example\n * <caption>The results will be available on `state.data`</caption>\n * bulkQuery(state=> `SELECT Id FROM Patient__c WHERE Health_ID__c = '${state.data.field1}'`);\n * @example\n * bulkQuery(\n *   (state) =>\n *     `SELECT Id FROM Patient__c WHERE Health_ID__c = '${state.data.field1}'`,\n *   { pollTimeout: 10000, pollInterval: 6000 }\n * );\n * @function\n * @param {String} qs - A query string.\n * @param {Object} options - Options passed to the bulk api.\n * @param {integer} [options.pollTimeout] - Polling timeout in milliseconds.\n * @param {integer} [options.pollInterval] - Polling interval in milliseconds.\n * @param {Function} callback - A callback to execute once the record is retrieved\n * @returns {Operation}\n */\nexport function bulkQuery(qs: string, options: {\n    pollTimeout?: integer;\n    pollInterval?: integer;\n}, callback: Function): Operation;",
    "instruction": "Create an OpenFn function that executes an SOQL Bulk Query.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes an SOQL Bulk Query.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute an SOQL Bulk Query.\n * This function uses bulk query to efficiently query large data sets and reduce the number of API requests.\n * Note that in an event of a query error,\n * error logs will be printed but the operation will not throw the error.\n * @public\n * @example\n * <caption>The results will be available on `state.data`</caption>\n * bulkQuery(state=> `SELECT Id FROM Patient__c WHERE Health_ID__c = '${state.data.field1}'`);\n * @example\n * bulkQuery(\n *   (state) =>\n *     `SELECT Id FROM Patient__c WHERE Health_ID__c = '${state.data.field1}'`,\n *   { pollTimeout: 10000, pollInterval: 6000 }\n * );\n * @function\n * @param {String} qs - A query string.\n * @param {Object} options - Options passed to the bulk api.\n * @param {integer} [options.pollTimeout] - Polling timeout in milliseconds.\n * @param {integer} [options.pollInterval] - Polling interval in milliseconds.\n * @param {Function} callback - A callback to execute once the record is retrieved\n * @returns {Operation}\n */\nexport function bulkQuery(qs: string, options: {\n    pollTimeout?: integer;\n    pollInterval?: integer;\n}, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Execute an SOQL Bulk Query.\n * This function uses bulk query to efficiently query large data sets and reduce the number of API requests.\n * Note that in an event of a query error,\n * error logs will be printed but the operation will not throw the error.\n * @public\n * @example\n * <caption>The results will be available on `state.data`</caption>\n * bulkQuery(state=> `SELECT Id FROM Patient__c WHERE Health_ID__c = '${state.data.field1}'`);\n * @example\n * bulkQuery(\n *   (state) =>\n *     `SELECT Id FROM Patient__c WHERE Health_ID__c = '${state.data.field1}'`,\n *   { pollTimeout: 10000, pollInterval: 6000 }\n * );\n * @function\n * @param {String} qs - A query string.\n * @param {Object} options - Options passed to the bulk api.\n * @param {integer} [options.pollTimeout] - Polling timeout in milliseconds.\n * @param {integer} [options.pollInterval] - Polling interval in milliseconds.\n * @param {Function} callback - A callback to execute once the record is retrieved\n * @returns {Operation}\n */\nexport function bulkQuery(qs, options, callback) {\n  return async state => {\n    const { connection } = state;\n    const [resolvedQs, resolvedOptions] = newExpandReferences(\n      state,\n      qs,\n      options\n    );\n    const apiVersion = connection.version;\n\n    const { pollTimeout, pollInterval } = {\n      ...defaultOptions,\n      ...resolvedOptions,\n    };\n\n    console.log(`Executing query: ${resolvedQs}`);\n\n    const queryJob = await connection.request({\n      method: 'POST',\n      url: `/services/data/v${apiVersion}/jobs/query`,\n      body: JSON.stringify({\n        operation: 'query',\n        query: resolvedQs,\n      }),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n\n    const result = await pollJobResult(\n      connection,\n      queryJob,\n      pollInterval,\n      pollTimeout\n    );\n\n    const nextState = {\n      ...composeNextState(state, result),\n      result,\n    };\n    if (callback) return callback(nextState);\n\n    return nextState;\n  };\n}\n"
  },
  {
    "name": "bulk",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Create and execute a bulk job.\n * @public\n * @example\n * bulk('Patient__c', 'insert', { failOnError: true, pollInterval: 3000, pollTimeout: 240000 }, state => {\n *   return state.data.someArray.map(x => {\n *     return { 'Age__c': x.age, 'Name': x.name }\n *   })\n * });\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {String} operation - The bulk operation to be performed\n * @param {Object} options - Options passed to the bulk api.\n * @param {Function} fun - A function which takes state and returns an array.\n * @returns {Operation}\n */\nexport function bulk(sObject, operation, options, fun) {\n  return state => {\n    const { connection } = state;\n    const { failOnError, allowNoOp, pollTimeout, pollInterval } = options;\n    const finalAttrs = fun(state);\n\n    if (allowNoOp && finalAttrs.length === 0) {\n      console.info(\n        `No items in ${sObject} array. Skipping bulk ${operation} operation.`\n      );\n      return state;\n    }\n\n    if (finalAttrs.length > 10000)\n      console.log('Your batch is bigger than 10,000 records; chunking...');\n\n    const chunkedBatches = chunk(finalAttrs, 10000);\n\n    return Promise.all(\n      chunkedBatches.map(\n        chunkedBatch =>\n          new Promise((resolve, reject) => {\n            const timeout = pollTimeout || 240000;\n            const interval = pollInterval || 6000;\n\n            console.info(\n              `Creating bulk ${operation} job for ${sObject} with ${chunkedBatch.length} records`\n            );\n\n            const job = connection.bulk.createJob(sObject, operation, options);\n\n            job.on('error', err => reject(err));\n\n            console.info('Creating batch for job.');\n            var batch = job.createBatch();\n\n            console.info('Executing batch.');\n            batch.execute(chunkedBatch);\n\n            batch.on('error',",
    "signature": "/**\n * Create and execute a bulk job.\n * @public\n * @example\n * bulk('Patient__c', 'insert', { failOnError: true, pollInterval: 3000, pollTimeout: 240000 }, state => {\n *   return state.data.someArray.map(x => {\n *     return { 'Age__c': x.age, 'Name': x.name }\n *   })\n * });\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {String} operation - The bulk operation to be performed\n * @param {Object} options - Options passed to the bulk api.\n * @param {Function} fun - A function which takes state and returns an array.\n * @returns {Operation}\n */\nexport function bulk(sObject: string, operation: string, options: any, fun: Function): Operation;",
    "instruction": "Create an OpenFn function that performs a bulk job on the sObject specified.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that performs a bulk job on the sObject specified.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create and execute a bulk job.\n * @public\n * @example\n * bulk('Patient__c', 'insert', { failOnError: true, pollInterval: 3000, pollTimeout: 240000 }, state => {\n *   return state.data.someArray.map(x => {\n *     return { 'Age__c': x.age, 'Name': x.name }\n *   })\n * });\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {String} operation - The bulk operation to be performed\n * @param {Object} options - Options passed to the bulk api.\n * @param {Function} fun - A function which takes state and returns an array.\n * @returns {Operation}\n */\nexport function bulk(sObject: string, operation: string, options: any, fun: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Create and execute a bulk job.\n * @public\n * @example\n * bulk('Patient__c', 'insert', { failOnError: true, pollInterval: 3000, pollTimeout: 240000 }, state => {\n *   return state.data.someArray.map(x => {\n *     return { 'Age__c': x.age, 'Name': x.name }\n *   })\n * });\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {String} operation - The bulk operation to be performed\n * @param {Object} options - Options passed to the bulk api.\n * @param {Function} fun - A function which takes state and returns an array.\n * @returns {Operation}\n */\nexport function bulk(sObject, operation, options, fun) {\n  return state => {\n    const { connection } = state;\n    const { failOnError, allowNoOp, pollTimeout, pollInterval } = options;\n    const finalAttrs = fun(state);\n\n    if (allowNoOp && finalAttrs.length === 0) {\n      console.info(\n        `No items in ${sObject} array. Skipping bulk ${operation} operation.`\n      );\n      return state;\n    }\n\n    if (finalAttrs.length > 10000)\n      console.log('Your batch is bigger than 10,000 records; chunking...');\n\n    const chunkedBatches = chunk(finalAttrs, 10000);\n\n    return Promise.all(\n      chunkedBatches.map(\n        chunkedBatch =>\n          new Promise((resolve, reject) => {\n            const timeout = pollTimeout || 240000;\n            const interval = pollInterval || 6000;\n\n            console.info(\n              `Creating bulk ${operation} job for ${sObject} with ${chunkedBatch.length} records`\n            );\n\n            const job = connection.bulk.createJob(sObject, operation, options);\n\n            job.on('error', err => reject(err));\n\n            console.info('Creating batch for job.');\n            var batch = job.createBatch();\n\n            console.info('Executing batch.');\n            batch.execute(chunkedBatch);\n\n            batch.on('error',\n"
  },
  {
    "name": "destroy",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Delete records of an object.\n * @public\n * @example\n * destroy('obj_name', [\n *  '0060n00000JQWHYAA5',\n *  '0090n00000JQEWHYAA5\n * ], { failOnError: true })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Array of IDs of records to delete.\n * @param {Object} options - Options for the destroy delete operation.\n * @returns {Operation}\n */\nexport function destroy(sObject, attrs, options) {\n  return state => {\n    const { connection } = state;\n    const finalAttrs = expandReferences(attrs)(state);\n    const { failOnError } = options;\n    console.info(`Deleting ${sObject} records`);\n\n    return connection\n      .sobject(sObject)\n      .del(finalAttrs)\n      .then(",
    "signature": "/**\n * Delete records of an object.\n * @public\n * @example\n * destroy('obj_name', [\n *  '0060n00000JQWHYAA5',\n *  '0090n00000JQEWHYAA5\n * ], { failOnError: true })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Array of IDs of records to delete.\n * @param {Object} options - Options for the destroy delete operation.\n * @returns {Operation}\n */\nexport function destroy(sObject: string, attrs: any, options: any): Operation;",
    "instruction": "Create an OpenFn function that deletes records from an object.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that deletes records from an object.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Delete records of an object.\n * @public\n * @example\n * destroy('obj_name', [\n *  '0060n00000JQWHYAA5',\n *  '0090n00000JQEWHYAA5\n * ], { failOnError: true })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Array of IDs of records to delete.\n * @param {Object} options - Options for the destroy delete operation.\n * @returns {Operation}\n */\nexport function destroy(sObject: string, attrs: any, options: any): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Delete records of an object.\n * @public\n * @example\n * destroy('obj_name', [\n *  '0060n00000JQWHYAA5',\n *  '0090n00000JQEWHYAA5\n * ], { failOnError: true })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Array of IDs of records to delete.\n * @param {Object} options - Options for the destroy delete operation.\n * @returns {Operation}\n */\nexport function destroy(sObject, attrs, options) {\n  return state => {\n    const { connection } = state;\n    const finalAttrs = expandReferences(attrs)(state);\n    const { failOnError } = options;\n    console.info(`Deleting ${sObject} records`);\n\n    return connection\n      .sobject(sObject)\n      .del(finalAttrs)\n      .then(\n"
  },
  {
    "name": "create",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Create a new object.\n * @public\n * @example\n * create('obj_name', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function create(sObject, attrs) {\n  return state => {\n    let { connection } = state;\n    const finalAttrs = expandReferences(attrs)(state);\n    console.info(`Creating ${sObject}`, finalAttrs);\n\n    return connection.create(sObject, finalAttrs).then(",
    "signature": "/**\n * Create a new object.\n * @public\n * @example\n * create('obj_name', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function create(sObject: string, attrs: any): Operation;",
    "test": "describe('create', () => {\n    it('makes a new sObject', done => {\n      const fakeConnection = {\n        create: function () {\n          return Promise.resolve({ Id: 10 });",
    "instruction": "Create an OpenFn function that creates an object from the given attributes.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates an object from the given attributes.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create a new object.\n * @public\n * @example\n * create('obj_name', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function create(sObject: string, attrs: any): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Create a new object.\n * @public\n * @example\n * create('obj_name', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function create(sObject, attrs) {\n  return state => {\n    let { connection } = state;\n    const finalAttrs = expandReferences(attrs)(state);\n    console.info(`Creating ${sObject}`, finalAttrs);\n\n    return connection.create(sObject, finalAttrs).then(\n"
  },
  {
    "name": "createIf",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Create a new object if conditions are met.\n * @public\n * @example\n * createIf(true, 'obj_name', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {boolean} logical - a logical statement that will be evaluated.\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function createIf(logical, sObject, attrs) {\n  return state => {\n    const resolvedLogical = expandReferences(logical)(state);\n\n    if (resolvedLogical) {\n      const { connection } = state;\n      const finalAttrs = expandReferences(attrs)(state);\n      console.info(`Creating ${sObject}`, finalAttrs);\n      return connection\n        .create(sObject, finalAttrs)\n        .then(",
    "signature": "/**\n * Create a new object if conditions are met.\n * @public\n * @example\n * createIf(true, 'obj_name', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {boolean} logical - a logical statement that will be evaluated.\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function createIf(logical: boolean, sObject: string, attrs: any): Operation;",
    "test": "describe('createIf', () => {\n    it(\"doesn't create a new sObject if a logical is false\", done => {\n      const fakeConnection = {\n        create: function () {\n          return Promise.resolve({ Id: 10 });",
    "instruction": "Create an OpenFn function that creates a new object if conditions are met.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates a new object if conditions are met.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create a new object if conditions are met.\n * @public\n * @example\n * createIf(true, 'obj_name', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {boolean} logical - a logical statement that will be evaluated.\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function createIf(logical: boolean, sObject: string, attrs: any): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Create a new object if conditions are met.\n * @public\n * @example\n * createIf(true, 'obj_name', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {boolean} logical - a logical statement that will be evaluated.\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function createIf(logical, sObject, attrs) {\n  return state => {\n    const resolvedLogical = expandReferences(logical)(state);\n\n    if (resolvedLogical) {\n      const { connection } = state;\n      const finalAttrs = expandReferences(attrs)(state);\n      console.info(`Creating ${sObject}`, finalAttrs);\n      return connection\n        .create(sObject, finalAttrs)\n        .then(\n"
  },
  {
    "name": "upsert",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Upsert an object.\n * @public\n * @example\n * upsert('obj_name', 'ext_id', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @magic sObject - $.children[?(!@.meta.system)].name\n * @param {String} externalId - ID.\n * @magic externalId - $.children[?(@.name==\"{{args.sObject}}\")].children[?(@.meta.externalId)].name\n * @param {Object} attrs - Field attributes for the new object.\n * @magic attrs - $.children[?(@.name==\"{{args.sObject}}\")].children[?(!@.meta.externalId)]\n * @returns {Operation}\n */\nexport function upsert(sObject, externalId, attrs) {\n  return state => {\n    const { connection } = state;\n    const finalAttrs = expandReferences(attrs)(state);\n    console.info(\n      `Upserting ${sObject} with externalId`,\n      externalId,\n      ':',\n      finalAttrs\n    );\n\n    return connection\n      .upsert(sObject, finalAttrs, externalId)\n      .then(",
    "signature": "/**\n * Upsert an object.\n * @public\n * @example\n * upsert('obj_name', 'ext_id', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @magic sObject - $.children[?(!@.meta.system)].name\n * @param {String} externalId - ID.\n * @magic externalId - $.children[?(@.name==\"{{args.sObject}}\")].children[?(@.meta.externalId)].name\n * @param {Object} attrs - Field attributes for the new object.\n * @magic attrs - $.children[?(@.name==\"{{args.sObject}}\")].children[?(!@.meta.externalId)]\n * @returns {Operation}\n */\nexport function upsert(sObject: string, externalId: string, attrs: any): Operation;",
    "test": "describe('upsert', () => {\n    it('is expected to call `upsert` on the connection', done => {\n      const connection = {\n        upsert: function () {\n          return Promise.resolve({ Id: 10 });",
    "instruction": "Create an OpenFn function that upserts an object to/on/from sObject",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts an object to/on/from sObject\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Upsert an object.\n * @public\n * @example\n * upsert('obj_name', 'ext_id', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @magic sObject - $.children[?(!@.meta.system)].name\n * @param {String} externalId - ID.\n * @magic externalId - $.children[?(@.name==\"{{args.sObject}}\")].children[?(@.meta.externalId)].name\n * @param {Object} attrs - Field attributes for the new object.\n * @magic attrs - $.children[?(@.name==\"{{args.sObject}}\")].children[?(!@.meta.externalId)]\n * @returns {Operation}\n */\nexport function upsert(sObject: string, externalId: string, attrs: any): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Upsert an object.\n * @public\n * @example\n * upsert('obj_name', 'ext_id', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @magic sObject - $.children[?(!@.meta.system)].name\n * @param {String} externalId - ID.\n * @magic externalId - $.children[?(@.name==\"{{args.sObject}}\")].children[?(@.meta.externalId)].name\n * @param {Object} attrs - Field attributes for the new object.\n * @magic attrs - $.children[?(@.name==\"{{args.sObject}}\")].children[?(!@.meta.externalId)]\n * @returns {Operation}\n */\nexport function upsert(sObject, externalId, attrs) {\n  return state => {\n    const { connection } = state;\n    const finalAttrs = expandReferences(attrs)(state);\n    console.info(\n      `Upserting ${sObject} with externalId`,\n      externalId,\n      ':',\n      finalAttrs\n    );\n\n    return connection\n      .upsert(sObject, finalAttrs, externalId)\n      .then(\n"
  },
  {
    "name": "upsertIf",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Upsert if conditions are met.\n * @public\n * @example\n * upsertIf(true, 'obj_name', 'ext_id', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {boolean} logical - a logical statement that will be evaluated.\n * @param {String} sObject - API name of the sObject.\n * @param {String} externalId - ID.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function upsertIf(logical, sObject, externalId, attrs) {\n  return state => {\n    const resolvedLogical = expandReferences(logical)(state);\n\n    if (resolvedLogical) {\n      const { connection } = state;\n      const finalAttrs = expandReferences(attrs)(state);\n      console.info(\n        `Upserting ${sObject} with externalId`,\n        externalId,\n        ':',\n        finalAttrs\n      );\n\n      return connection\n        .upsert(sObject, finalAttrs, externalId)\n        .then(",
    "signature": "/**\n * Upsert if conditions are met.\n * @public\n * @example\n * upsertIf(true, 'obj_name', 'ext_id', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {boolean} logical - a logical statement that will be evaluated.\n * @param {String} sObject - API name of the sObject.\n * @param {String} externalId - ID.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function upsertIf(logical: boolean, sObject: string, externalId: string, attrs: any): Operation;",
    "test": "describe('upsertIf', () => {\n    it('upserts if a logical is true', done => {\n      const fakeConnection = {\n        upsert: function () {\n          return Promise.resolve({ Id: 10 });",
    "instruction": "Create an OpenFn function that upserts to/on/from an object with field",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts to/on/from an object with field\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Upsert if conditions are met.\n * @public\n * @example\n * upsertIf(true, 'obj_name', 'ext_id', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {boolean} logical - a logical statement that will be evaluated.\n * @param {String} sObject - API name of the sObject.\n * @param {String} externalId - ID.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function upsertIf(logical: boolean, sObject: string, externalId: string, attrs: any): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Upsert if conditions are met.\n * @public\n * @example\n * upsertIf(true, 'obj_name', 'ext_id', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {boolean} logical - a logical statement that will be evaluated.\n * @param {String} sObject - API name of the sObject.\n * @param {String} externalId - ID.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function upsertIf(logical, sObject, externalId, attrs) {\n  return state => {\n    const resolvedLogical = expandReferences(logical)(state);\n\n    if (resolvedLogical) {\n      const { connection } = state;\n      const finalAttrs = expandReferences(attrs)(state);\n      console.info(\n        `Upserting ${sObject} with externalId`,\n        externalId,\n        ':',\n        finalAttrs\n      );\n\n      return connection\n        .upsert(sObject, finalAttrs, externalId)\n        .then(\n"
  },
  {
    "name": "update",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Update an object.\n * @public\n * @example\n * update('obj_name', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function update(sObject, attrs) {\n  return state => {\n    let { connection } = state;\n    const finalAttrs = expandReferences(attrs)(state);\n    console.info(`Updating ${sObject}`, finalAttrs);\n\n    return connection.update(sObject, finalAttrs).then(",
    "signature": "/**\n * Update an object.\n * @public\n * @example\n * update('obj_name', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function update(sObject: string, attrs: any): Operation;",
    "instruction": "Create an OpenFn function that updates an object from sObject.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that updates an object from sObject.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Update an object.\n * @public\n * @example\n * update('obj_name', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function update(sObject: string, attrs: any): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Update an object.\n * @public\n * @example\n * update('obj_name', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {String} sObject - API name of the sObject.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function update(sObject, attrs) {\n  return state => {\n    let { connection } = state;\n    const finalAttrs = expandReferences(attrs)(state);\n    console.info(`Updating ${sObject}`, finalAttrs);\n\n    return connection.update(sObject, finalAttrs).then(\n"
  },
  {
    "name": "reference",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Get a reference ID by an index.\n * @public\n * @example\n * reference(0)\n * @function\n * @param {number} position - Position for references array.\n * @returns {State}\n */\nexport function reference(position) {\n  return state => state.references[position].id;\n}",
    "signature": "/**\n * Get a reference ID by an index.\n * @public\n * @example\n * reference(0)\n * @function\n * @param {number} position - Position for references array.\n * @returns {State}\n */\nexport function reference(position: number): State;",
    "instruction": "Create an OpenFn function that gets a reference ID from an index.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets a reference ID from an index.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get a reference ID by an index.\n * @public\n * @example\n * reference(0)\n * @function\n * @param {number} position - Position for references array.\n * @returns {State}\n */\nexport function reference(position: number): State;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Get a reference ID by an index.\n * @public\n * @example\n * reference(0)\n * @function\n * @param {number} position - Position for references array.\n * @returns {State}\n */\nexport function reference(position) {\n  return state => state.references[position].id;\n}\n"
  },
  {
    "name": "execute",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Creates a connection.\n * @example\n * createConnection(state)\n * @function\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nfunction createConnection(state) {\n  const { loginUrl, apiVersion } = state.configuration;\n\n  if (!loginUrl) {\n    throw new Error('loginUrl missing from configuration.');\n  }\n\n  return {\n    ...state,\n    connection: apiVersion\n      ? new jsforce.Connection({\n          loginUrl,\n          version: setApiVersion(apiVersion),\n        })\n      : new jsforce.Connection({ loginUrl }),\n  };\n}\n\n/**\n * Performs a login.\n * @example\n * login(state)\n * @function\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nfunction login(state) {\n  const { username, password, securityToken } = state.configuration;\n  let { connection } = state;\n  console.info(`Logging in as ${username}.`);\n\n  return (\n    connection\n      .login(username, password + securityToken)\n      // NOTE: Uncomment this to debug connection issues.\n      // .then(response => {\n      //   console.log(connection);\n      //   console.log(response);\n      //   return state;\n      // })\n      .then(() => state)\n  );\n}\n\n/**\n * Executes an operation.\n * @function\n * @param {Operation} operations - Operations\n * @returns {State}\n */\nexport function execute(...operations) {\n  const initialState = {\n    logger: {\n      info: console.info.bind(console),\n      debug: console.log.bind(console),\n    },\n    references: [],\n    data: null,\n    configuration: {},\n  };\n\n  return state => {\n    // Note: we no longer need `steps` anymore since `commonExecute`\n    // takes each operation as an argument.\n    return commonExecute(\n      createConnection,\n      login,\n      ...flatten(operations),\n      cleanupState\n    )({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Executes an operation.\n * @function\n * @param {Operation} operations - Operations\n * @returns {State}\n */\nexport function execute(...operations: Operation): State;",
    "instruction": "Create an OpenFn function that executes operations on State.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes operations on State.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Executes an operation.\n * @function\n * @param {Operation} operations - Operations\n * @returns {State}\n */\nexport function execute(...operations: Operation): State;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Creates a connection.\n * @example\n * createConnection(state)\n * @function\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nfunction createConnection(state) {\n  const { loginUrl, apiVersion } = state.configuration;\n\n  if (!loginUrl) {\n    throw new Error('loginUrl missing from configuration.');\n  }\n\n  return {\n    ...state,\n    connection: apiVersion\n      ? new jsforce.Connection({\n          loginUrl,\n          version: setApiVersion(apiVersion),\n        })\n      : new jsforce.Connection({ loginUrl }),\n  };\n}\n\n/**\n * Performs a login.\n * @example\n * login(state)\n * @function\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nfunction login(state) {\n  const { username, password, securityToken } = state.configuration;\n  let { connection } = state;\n  console.info(`Logging in as ${username}.`);\n\n  return (\n    connection\n      .login(username, password + securityToken)\n      // NOTE: Uncomment this to debug connection issues.\n      // .then(response => {\n      //   console.log(connection);\n      //   console.log(response);\n      //   return state;\n      // })\n      .then(() => state)\n  );\n}\n\n/**\n * Executes an operation.\n * @function\n * @param {Operation} operations - Operations\n * @returns {State}\n */\nexport function execute(...operations) {\n  const initialState = {\n    logger: {\n      info: console.info.bind(console),\n      debug: console.log.bind(console),\n    },\n    references: [],\n    data: null,\n    configuration: {},\n  };\n\n  return state => {\n    // Note: we no longer need `steps` anymore since `commonExecute`\n    // takes each operation as an argument.\n    return commonExecute(\n      createConnection,\n      login,\n      ...flatten(operations),\n      cleanupState\n    )({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "steps",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Removes unserializable keys from the state.\n * @example\n * cleanupState(state)\n * @function\n * @param {State} state\n * @returns {State}\n */\nfunction cleanupState(state) {\n  delete state.connection;\n  return state;\n}\n\n/**\n * Flattens an array of operations.\n * @example\n * steps(\n *   createIf(params),\n *   update(params)\n * )\n * @function\n * @returns {Array}\n */\nexport function steps(...operations) {\n  return flatten(operations);\n}\n\n// Note that we expose the entire axios package to the user here.\nimport axios from 'axios';",
    "signature": "/**\n * Flattens an array of operations.\n * @example\n * steps(\n *   createIf(params),\n *   update(params)\n * )\n * @function\n * @returns {Array}\n */\nexport function steps(...operations: any[]): any[];",
    "instruction": "Create an OpenFn function that flattens an array of operations.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that flattens an array of operations.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Flattens an array of operations.\n * @example\n * steps(\n *   createIf(params),\n *   update(params)\n * )\n * @function\n * @returns {Array}\n */\nexport function steps(...operations: any[]): any[];\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Removes unserializable keys from the state.\n * @example\n * cleanupState(state)\n * @function\n * @param {State} state\n * @returns {State}\n */\nfunction cleanupState(state) {\n  delete state.connection;\n  return state;\n}\n\n/**\n * Flattens an array of operations.\n * @example\n * steps(\n *   createIf(params),\n *   update(params)\n * )\n * @function\n * @returns {Array}\n */\nexport function steps(...operations) {\n  return flatten(operations);\n}\n\n// Note that we expose the entire axios package to the user here.\nimport axios from 'axios';\n"
  },
  {
    "name": "execute",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}\n"
  },
  {
    "name": "addContact",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Adds a new contact to RapidPro\n * @public\n * @example\n * addContact({\n *   name: \"Mamadou\",\n *   language: \"ENG\",\n *   urns: [\"tel:+250788123123\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function addContact(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { host, apiVersion, token } = state.configuration;\n\n    const url = `${host}/api/${apiVersion || 'v2'}/contacts.json`;\n\n    const config = {\n      url,\n      data: resolvedParams,\n      headers: { Authorization: `Token ${token}` },\n    };\n\n    return http\n      .post(config)(state)\n      .then(response => {\n        console.log('Contact added with uuid:', response.data.uuid);\n        const nextState = {\n          ...composeNextState(state, response.data),\n          response,\n        };\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}",
    "signature": "/**\n * Adds a new contact to RapidPro\n * @public\n * @example\n * addContact({\n *   name: \"Mamadou\",\n *   language: \"ENG\",\n *   urns: [\"tel:+250788123123\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function addContact(params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that adds a new contact to RapidPro.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that adds a new contact to RapidPro.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Adds a new contact to RapidPro\n * @public\n * @example\n * addContact({\n *   name: \"Mamadou\",\n *   language: \"ENG\",\n *   urns: [\"tel:+250788123123\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function addContact(params: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Adds a new contact to RapidPro\n * @public\n * @example\n * addContact({\n *   name: \"Mamadou\",\n *   language: \"ENG\",\n *   urns: [\"tel:+250788123123\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function addContact(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { host, apiVersion, token } = state.configuration;\n\n    const url = `${host}/api/${apiVersion || 'v2'}/contacts.json`;\n\n    const config = {\n      url,\n      data: resolvedParams,\n      headers: { Authorization: `Token ${token}` },\n    };\n\n    return http\n      .post(config)(state)\n      .then(response => {\n        console.log('Contact added with uuid:', response.data.uuid);\n        const nextState = {\n          ...composeNextState(state, response.data),\n          response,\n        };\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}\n"
  },
  {
    "name": "upsertContact",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Upserts a contact to RapidPro by URN\n * @public\n * @example\n * upsertContact({\n *   name: \"Mamadou\",\n *   language: \"ENG\",\n *   urns: [\"tel:+250788123123\"]\n * });\n * @function\n * @param {object} params - data to upsert a contact\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertContact(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { host, apiVersion, token } = state.configuration;\n\n    const url = `${host}/api/${apiVersion || 'v2'}/contacts.json`;\n\n    const config = {\n      url,\n      data: resolvedParams,\n      headers: { Authorization: `Token ${token}` },\n    };\n\n    return http\n      .post(config)(state)\n      .then(resp => {\n        console.log('Contact added with uuid:', resp.data.uuid);\n        return resp;\n      })\n      .catch(err => {\n        const { data } = err.response;\n        if (\n          data &&\n          data.urns &&\n          Array.isArray(data.urns) &&\n          data.urns.find(x => x.includes('URN belongs to another'))\n        ) {\n          const newUrl = `${url}?urn=${config.data.urns[0]}`;\n          delete config.data['urns'];\n          return http\n            .post({ ...config, url: newUrl })(state)\n            .then(resp => {\n              console.log('Contact updated with uuid:', resp.data.uuid);\n              return resp;\n            });\n        } else {\n          console.log(JSON.stringify(data, null, 2));\n\n          delete err.response.request;\n          delete err.response.config;\n\n          throw err.response;\n        }\n      })\n      .then(response => {\n        const nextState = {\n          ...composeNextState(state, response.data),\n          response,\n        };\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}",
    "signature": "/**\n * Upserts a contact to RapidPro by URN\n * @public\n * @example\n * upsertContact({\n *   name: \"Mamadou\",\n *   language: \"ENG\",\n *   urns: [\"tel:+250788123123\"]\n * });\n * @function\n * @param {object} params - data to upsert a contact\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertContact(params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts a contact to RapidPro by URN.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts a contact to RapidPro by URN.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Upserts a contact to RapidPro by URN\n * @public\n * @example\n * upsertContact({\n *   name: \"Mamadou\",\n *   language: \"ENG\",\n *   urns: [\"tel:+250788123123\"]\n * });\n * @function\n * @param {object} params - data to upsert a contact\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertContact(params: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Upserts a contact to RapidPro by URN\n * @public\n * @example\n * upsertContact({\n *   name: \"Mamadou\",\n *   language: \"ENG\",\n *   urns: [\"tel:+250788123123\"]\n * });\n * @function\n * @param {object} params - data to upsert a contact\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertContact(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { host, apiVersion, token } = state.configuration;\n\n    const url = `${host}/api/${apiVersion || 'v2'}/contacts.json`;\n\n    const config = {\n      url,\n      data: resolvedParams,\n      headers: { Authorization: `Token ${token}` },\n    };\n\n    return http\n      .post(config)(state)\n      .then(resp => {\n        console.log('Contact added with uuid:', resp.data.uuid);\n        return resp;\n      })\n      .catch(err => {\n        const { data } = err.response;\n        if (\n          data &&\n          data.urns &&\n          Array.isArray(data.urns) &&\n          data.urns.find(x => x.includes('URN belongs to another'))\n        ) {\n          const newUrl = `${url}?urn=${config.data.urns[0]}`;\n          delete config.data['urns'];\n          return http\n            .post({ ...config, url: newUrl })(state)\n            .then(resp => {\n              console.log('Contact updated with uuid:', resp.data.uuid);\n              return resp;\n            });\n        } else {\n          console.log(JSON.stringify(data, null, 2));\n\n          delete err.response.request;\n          delete err.response.config;\n\n          throw err.response;\n        }\n      })\n      .then(response => {\n        const nextState = {\n          ...composeNextState(state, response.data),\n          response,\n        };\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}\n"
  },
  {
    "name": "startFlow",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Start a RapidPro flow for a number of contacts\n * @public\n * @example\n * startFlow({\n *   flow: \"f5901b62-ba76-4003-9c62-72fdacc1b7b7\",\n *   restart_participants: false,\n *   contacts: [\"a052b00c-15b3-48e6-9771-edbaa277a353\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function startFlow(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { host, apiVersion, token } = state.configuration;\n\n    const url = `${host}/api/${apiVersion || 'v2'}/flow_starts.json`;\n\n    const config = {\n      url,\n      data: resolvedParams,\n      headers: {\n        Authorization: `Token ${token}`,\n        'Content-Type': 'application/json',\n      },\n    };\n\n    return http\n      .post(config)(state)\n      .catch(error => {\n        console.log(error.response);\n        throw 'That was an error from RapidPro.';\n      })\n      .then(response => {\n        console.log('Flow started:', response.data);\n        const nextState = {\n          ...composeNextState(state, response.data),\n          response,\n        };\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}",
    "signature": "/**\n * Start a RapidPro flow for a number of contacts\n * @public\n * @example\n * startFlow({\n *   flow: \"f5901b62-ba76-4003-9c62-72fdacc1b7b7\",\n *   restart_participants: false,\n *   contacts: [\"a052b00c-15b3-48e6-9771-edbaa277a353\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function startFlow(params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that starts a RapidPro flow for a number of contacts.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that starts a RapidPro flow for a number of contacts.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Start a RapidPro flow for a number of contacts\n * @public\n * @example\n * startFlow({\n *   flow: \"f5901b62-ba76-4003-9c62-72fdacc1b7b7\",\n *   restart_participants: false,\n *   contacts: [\"a052b00c-15b3-48e6-9771-edbaa277a353\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function startFlow(params: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Start a RapidPro flow for a number of contacts\n * @public\n * @example\n * startFlow({\n *   flow: \"f5901b62-ba76-4003-9c62-72fdacc1b7b7\",\n *   restart_participants: false,\n *   contacts: [\"a052b00c-15b3-48e6-9771-edbaa277a353\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function startFlow(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { host, apiVersion, token } = state.configuration;\n\n    const url = `${host}/api/${apiVersion || 'v2'}/flow_starts.json`;\n\n    const config = {\n      url,\n      data: resolvedParams,\n      headers: {\n        Authorization: `Token ${token}`,\n        'Content-Type': 'application/json',\n      },\n    };\n\n    return http\n      .post(config)(state)\n      .catch(error => {\n        console.log(error.response);\n        throw 'That was an error from RapidPro.';\n      })\n      .then(response => {\n        console.log('Flow started:', response.data);\n        const nextState = {\n          ...composeNextState(state, response.data),\n          response,\n        };\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}\n"
  },
  {
    "name": "sendBroadcast",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Sends a message to a list of contacts and/or URNs\n * @public\n * @example\n * sendBroadcast({\n *   text: \"Hello world\",\n *   urns: [\"twitter:sirmixalot\"],\n *   contacts: [\"a052b00c-15b3-48e6-9771-edbaa277a353\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function sendBroadcast(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { host, apiVersion, token } = state.configuration;\n\n    const url = `${host}/api/${apiVersion || 'v2'}/broadcasts.json`;\n\n    const config = {\n      url,\n      data: resolvedParams,\n      headers: {\n        Authorization: `Token ${token}`,\n        'Content-Type': 'application/json',\n      },\n    };\n\n    return http\n      .post(config)(state)\n      .catch(error => {\n        console.log(error.response);\n        throw 'That was an error from RapidPro.';\n      })\n      .then(response => {\n        console.log('Broadcast queued:', response.data);\n        const nextState = {\n          ...composeNextState(state, response.data),\n          response,\n        };\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}",
    "signature": "/**\n * Sends a message to a list of contacts and/or URNs\n * @public\n * @example\n * sendBroadcast({\n *   text: \"Hello world\",\n *   urns: [\"twitter:sirmixalot\"],\n *   contacts: [\"a052b00c-15b3-48e6-9771-edbaa277a353\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function sendBroadcast(params: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that sends a message to a list of contacts and/or UR",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that sends a message to a list of contacts and/or UR\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Sends a message to a list of contacts and/or URNs\n * @public\n * @example\n * sendBroadcast({\n *   text: \"Hello world\",\n *   urns: [\"twitter:sirmixalot\"],\n *   contacts: [\"a052b00c-15b3-48e6-9771-edbaa277a353\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function sendBroadcast(params: object, callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Sends a message to a list of contacts and/or URNs\n * @public\n * @example\n * sendBroadcast({\n *   text: \"Hello world\",\n *   urns: [\"twitter:sirmixalot\"],\n *   contacts: [\"a052b00c-15b3-48e6-9771-edbaa277a353\"]\n * });\n * @function\n * @param {object} params - data to create the new resource\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function sendBroadcast(params, callback) {\n  return state => {\n    const resolvedParams = expandReferences(params)(state);\n\n    const { host, apiVersion, token } = state.configuration;\n\n    const url = `${host}/api/${apiVersion || 'v2'}/broadcasts.json`;\n\n    const config = {\n      url,\n      data: resolvedParams,\n      headers: {\n        Authorization: `Token ${token}`,\n        'Content-Type': 'application/json',\n      },\n    };\n\n    return http\n      .post(config)(state)\n      .catch(error => {\n        console.log(error.response);\n        throw 'That was an error from RapidPro.';\n      })\n      .then(response => {\n        console.log('Broadcast queued:', response.data);\n        const nextState = {\n          ...composeNextState(state, response.data),\n          response,\n        };\n        if (callback) return callback(nextState);\n        return nextState;\n      });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for mailgun.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      setupClient,\n      ...operations,\n      teardownClient\n    )({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for mailgun.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for mailgun.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for mailgun.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(\n      setupClient,\n      ...operations,\n      teardownClient\n    )({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "send",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Create an event\n * @public\n * @example\n * send({\n *   from: 'from_email',\n *   to: 'to_email',\n *   subject: 'Your Subject',\n *   text: 'Your message goes here',\n *   attachment: {\n *     url: 'www.google.com/doodle.png',\n *     filename: 'forYou.png',\n *   },\n * })\n * @function\n * @param {object} params - Params for sending an email\n */\nexport function send(params) {\n  return state => {\n    const { client } = state;\n    const { domain } = state.configuration;\n\n    const body = expandReferences(params)(state);\n\n    if (body.attachment) {\n      const response = request('GET', body.attachment.url);\n      console.log(response);\n      body.attachment = {\n        data: response.body,\n        filename: body.attachment.filename,\n      };\n    }\n    console.log('Sending mail:');\n    return client.messages.create(domain, body).then(response => {\n      console.log(response);\n      return composeNextState(state, response);\n    });\n  };\n}",
    "signature": "/**\n * Create an event\n * @public\n * @example\n * send({\n *   from: 'from_email',\n *   to: 'to_email',\n *   subject: 'Your Subject',\n *   text: 'Your message goes here',\n *   attachment: {\n *     url: 'www.google.com/doodle.png',\n *     filename: 'forYou.png',\n *   },\n * })\n * @function\n * @param {object} params - Params for sending an email\n */\nexport function send(params: object): (state: any) => any;",
    "test": "",
    "instruction": "Create an OpenFn function that sends an email to/from a specified address.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that sends an email to/from a specified address.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create an event\n * @public\n * @example\n * send({\n *   from: 'from_email',\n *   to: 'to_email',\n *   subject: 'Your Subject',\n *   text: 'Your message goes here',\n *   attachment: {\n *     url: 'www.google.com/doodle.png',\n *     filename: 'forYou.png',\n *   },\n * })\n * @function\n * @param {object} params - Params for sending an email\n */\nexport function send(params: object): (state: any) => any;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Create an event\n * @public\n * @example\n * send({\n *   from: 'from_email',\n *   to: 'to_email',\n *   subject: 'Your Subject',\n *   text: 'Your message goes here',\n *   attachment: {\n *     url: 'www.google.com/doodle.png',\n *     filename: 'forYou.png',\n *   },\n * })\n * @function\n * @param {object} params - Params for sending an email\n */\nexport function send(params) {\n  return state => {\n    const { client } = state;\n    const { domain } = state.configuration;\n\n    const body = expandReferences(params)(state);\n\n    if (body.attachment) {\n      const response = request('GET', body.attachment.url);\n      console.log(response);\n      body.attachment = {\n        data: response.body,\n        filename: body.attachment.filename,\n      };\n    }\n    console.log('Sending mail:');\n    return client.messages.create(domain, body).then(response => {\n      console.log(response);\n      return composeNextState(state, response);\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create(\"foo\"),\n *   delete(\"bar\")\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(login, ...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create(\"foo\"),\n *   delete(\"bar\")\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "describe('execute', () => {\n    it('executes each operation in sequence', done => {\n      const operations = [\n        state => {\n          return { counter: 1 };\n        },\n        state => {\n          return { counter: 2 };\n        },\n        state => {\n          return { counter: 3 };\n        },\n      ];\n\n      execute(...operations)(state)\n        .then(finalState => {\n          expect(finalState).to.eql({ counter: 3 });",
    "instruction": "Create an OpenFn function that executes a sequence of operations.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create(\"foo\"),\n *   delete(\"bar\")\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create(\"foo\"),\n *   delete(\"bar\")\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(login, ...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "getGroup",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * Logs in to OpenSpp, gets a session token.\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { baseUrl, username, password, database } = state.configuration;\n  sppConnector = new Odoo({\n    baseUrl: baseUrl,\n    db: database,\n    username: username,\n    password: password,\n  });\n  try {\n    await sppConnector.connect();\n  } catch (err) {\n    console.log(`\u2717 Error: ${err}`);\n    sppConnector = null;\n  }\n  return state;\n}\n\n/**\n * Create a brand new program membership for registrant.\n * @example\n * createProgramMembership(\"IND_Q4VGGZPF\", \"PROG_2023_00000001\")\n * @private\n * @param {string} registrant_id - registrant_id of group / individual wanted to unenroll\n * @param {string} program_id - program_id of program\n */\nasync function createProgramMembership(registrant_id, program_id) {\n  try {\n    let registrant = await sppConnector.searchRead(\n      'res.partner',\n      [\n        ['is_registrant', '=', true],\n        ['registrant_id', '=', registrant_id],\n      ],\n      ['id'],\n      { limit: 1 }\n    );\n    if (registrant.length === 0) {\n      throw new Error(`Registrant ${registrant_id} not exists!`);\n    }\n    registrant = registrant[0].id;\n    let program = await sppConnector.searchRead(\n      'g2p.program',\n      [['program_id', '=', program_id]],\n      ['id'],\n      { limit: 1 }\n    );\n    if (program.length === 0) {\n      throw new Error(`Program ${program_id} not exists!`);\n    }\n    program = program[0].id;\n    await sppConnector.create('g2p.program_membership', {\n      program_id: program,\n      partner_id: registrant,\n      state: 'enrolled',\n    });\n  } catch (err) {\n    console.log(`\u2717 Error: ${err}`);\n  }\n}\n\n/**\n * get group information from OpenSPP\n * @public\n * @example\n * getGroup(\"GRP_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - The registrant_id of the group\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getGroup(registrant_id, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [\n      ['is_registrant', '=', true],\n      ['is_group', '=', true],\n      ['registrant_id', '=', registrant_id],\n    ];\n    const defaultFields = [\n      'name',\n      'address',\n      'phone',\n      'kind',\n      'registration_date',\n      'registrant_id',\n    ];\n    try {\n      const group = await sppConnector.searchRead(\n        'res.partner',\n        defaultDomain,\n        defaultFields,\n        { limit: 1, order: 'id desc' }\n      );\n      if (group.length === 0) {\n        console.log(`\u2717 Error: Group ${registrant_id} not found!`);\n        return state;\n      }\n      console.log(`\u2139 Group ${registrant_id} found!`);\n      const nextState = composeNextState(state, group[0]);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}",
    "signature": "/**\n * get group information from OpenSPP\n * @public\n * @example\n * getGroup(\"GRP_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - The registrant_id of the group\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getGroup(registrant_id: string, callback?: Function): Operation;",
    "instruction": "Create an OpenFn function that gets group information from OpenSPP using a registrant_",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets group information from OpenSPP using a registrant_\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * get group information from OpenSPP\n * @public\n * @example\n * getGroup(\"GRP_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - The registrant_id of the group\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getGroup(registrant_id: string, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * Logs in to OpenSpp, gets a session token.\n * @example\n *  login(state)\n * @private\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nasync function login(state) {\n  const { baseUrl, username, password, database } = state.configuration;\n  sppConnector = new Odoo({\n    baseUrl: baseUrl,\n    db: database,\n    username: username,\n    password: password,\n  });\n  try {\n    await sppConnector.connect();\n  } catch (err) {\n    console.log(`\u2717 Error: ${err}`);\n    sppConnector = null;\n  }\n  return state;\n}\n\n/**\n * Create a brand new program membership for registrant.\n * @example\n * createProgramMembership(\"IND_Q4VGGZPF\", \"PROG_2023_00000001\")\n * @private\n * @param {string} registrant_id - registrant_id of group / individual wanted to unenroll\n * @param {string} program_id - program_id of program\n */\nasync function createProgramMembership(registrant_id, program_id) {\n  try {\n    let registrant = await sppConnector.searchRead(\n      'res.partner',\n      [\n        ['is_registrant', '=', true],\n        ['registrant_id', '=', registrant_id],\n      ],\n      ['id'],\n      { limit: 1 }\n    );\n    if (registrant.length === 0) {\n      throw new Error(`Registrant ${registrant_id} not exists!`);\n    }\n    registrant = registrant[0].id;\n    let program = await sppConnector.searchRead(\n      'g2p.program',\n      [['program_id', '=', program_id]],\n      ['id'],\n      { limit: 1 }\n    );\n    if (program.length === 0) {\n      throw new Error(`Program ${program_id} not exists!`);\n    }\n    program = program[0].id;\n    await sppConnector.create('g2p.program_membership', {\n      program_id: program,\n      partner_id: registrant,\n      state: 'enrolled',\n    });\n  } catch (err) {\n    console.log(`\u2717 Error: ${err}`);\n  }\n}\n\n/**\n * get group information from OpenSPP\n * @public\n * @example\n * getGroup(\"GRP_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - The registrant_id of the group\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getGroup(registrant_id, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [\n      ['is_registrant', '=', true],\n      ['is_group', '=', true],\n      ['registrant_id', '=', registrant_id],\n    ];\n    const defaultFields = [\n      'name',\n      'address',\n      'phone',\n      'kind',\n      'registration_date',\n      'registrant_id',\n    ];\n    try {\n      const group = await sppConnector.searchRead(\n        'res.partner',\n        defaultDomain,\n        defaultFields,\n        { limit: 1, order: 'id desc' }\n      );\n      if (group.length === 0) {\n        console.log(`\u2717 Error: Group ${registrant_id} not found!`);\n        return state;\n      }\n      console.log(`\u2139 Group ${registrant_id} found!`);\n      const nextState = composeNextState(state, group[0]);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}\n"
  },
  {
    "name": "getIndividual",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get individual information from OpenSPP\n * @public\n * @example\n * getIndividual(\"IND_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - The registrant_id of the individual\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getIndividual(registrant_id, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [\n      ['is_registrant', '=', true],\n      ['is_group', '=', false],\n      ['registrant_id', '=', registrant_id],\n    ];\n    const defaultFields = [\n      'name',\n      'address',\n      'phone',\n      'registrant_id',\n      'gender',\n      'email',\n      'category_id',\n      'birthdate',\n    ];\n    try {\n      const individual = await sppConnector.searchRead(\n        'res.partner',\n        defaultDomain,\n        defaultFields,\n        { limit: 1, order: 'id desc' }\n      );\n      if (individual.length === 0) {\n        console.log(`\u2717 Error: Individual with id=${registrant_id} not found!`);\n        return state;\n      }\n      console.log(`\u2139 Individual with id=${registrant_id} found!`);\n      const nextState = composeNextState(state, individual[0]);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}",
    "signature": "/**\n * get individual information from OpenSPP\n * @public\n * @example\n * getIndividual(\"IND_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - The registrant_id of the individual\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getIndividual(registrant_id: string, callback?: Function): Operation;",
    "instruction": "Create an OpenFn function that gets individual information from OpenSPP using a registrant_",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets individual information from OpenSPP using a registrant_\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * get individual information from OpenSPP\n * @public\n * @example\n * getIndividual(\"IND_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - The registrant_id of the individual\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getIndividual(registrant_id: string, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get individual information from OpenSPP\n * @public\n * @example\n * getIndividual(\"IND_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - The registrant_id of the individual\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getIndividual(registrant_id, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [\n      ['is_registrant', '=', true],\n      ['is_group', '=', false],\n      ['registrant_id', '=', registrant_id],\n    ];\n    const defaultFields = [\n      'name',\n      'address',\n      'phone',\n      'registrant_id',\n      'gender',\n      'email',\n      'category_id',\n      'birthdate',\n    ];\n    try {\n      const individual = await sppConnector.searchRead(\n        'res.partner',\n        defaultDomain,\n        defaultFields,\n        { limit: 1, order: 'id desc' }\n      );\n      if (individual.length === 0) {\n        console.log(`\u2717 Error: Individual with id=${registrant_id} not found!`);\n        return state;\n      }\n      console.log(`\u2139 Individual with id=${registrant_id} found!`);\n      const nextState = composeNextState(state, individual[0]);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}\n"
  },
  {
    "name": "getGroupMembers",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get group members information from OpenSPP\n * @public\n * @example\n * getGroupMembers(\"GRP_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - The name of the group\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getGroupMembers(registrant_id, offset = 0, callback=(s) => s) {\n  return async state => {\n    try {\n      const group_id = await sppConnector.search('res.partner', [\n        ['is_group', '=', true],\n        ['is_registrant', '=', true],\n        ['registrant_id', '=', registrant_id],\n      ]);\n      if (group_id.length === 0) {\n        console.log(`\u2717 Error: Group id=${registrant_id} not found!`);\n        return state;\n      }\n      const defaultDomain = [\n        ['is_ended', '=', false],\n        ['group', '=', group_id[0]],\n      ];\n      const defaultFields = [\n        'individual',\n        'kind',\n        'start_date',\n        'ended_date',\n        'individual_birthdate',\n        'individual_gender',\n      ];\n      const options = {\n        limit: 100,\n        order: 'id desc',\n      };\n      if (offset > 0) {\n        options.offset = offset;\n      }\n      const members = await sppConnector.searchRead(\n        'g2p.group.membership',\n        defaultDomain,\n        defaultFields,\n        options\n      );\n      if (!members) {\n        console.log(\n          `\u26a0 Warning: Household ${registrant_id} not having members!`\n        );\n        return state;\n      }\n      console.log(`\u2139 Household ${registrant_id} members found!`);\n      const nextState = composeNextState(state, members);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}",
    "signature": "/**\n * get group members information from OpenSPP\n * @public\n * @example\n * getGroupMembers(\"GRP_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - The name of the group\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getGroupMembers(registrant_id: string, offset?: number, callback?: Function): Operation;",
    "instruction": "Create an OpenFn function that gets group members information from OpenSPP.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets group members information from OpenSPP.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * get group members information from OpenSPP\n * @public\n * @example\n * getGroupMembers(\"GRP_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - The name of the group\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getGroupMembers(registrant_id: string, offset?: number, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get group members information from OpenSPP\n * @public\n * @example\n * getGroupMembers(\"GRP_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - The name of the group\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getGroupMembers(registrant_id, offset = 0, callback=(s) => s) {\n  return async state => {\n    try {\n      const group_id = await sppConnector.search('res.partner', [\n        ['is_group', '=', true],\n        ['is_registrant', '=', true],\n        ['registrant_id', '=', registrant_id],\n      ]);\n      if (group_id.length === 0) {\n        console.log(`\u2717 Error: Group id=${registrant_id} not found!`);\n        return state;\n      }\n      const defaultDomain = [\n        ['is_ended', '=', false],\n        ['group', '=', group_id[0]],\n      ];\n      const defaultFields = [\n        'individual',\n        'kind',\n        'start_date',\n        'ended_date',\n        'individual_birthdate',\n        'individual_gender',\n      ];\n      const options = {\n        limit: 100,\n        order: 'id desc',\n      };\n      if (offset > 0) {\n        options.offset = offset;\n      }\n      const members = await sppConnector.searchRead(\n        'g2p.group.membership',\n        defaultDomain,\n        defaultFields,\n        options\n      );\n      if (!members) {\n        console.log(\n          `\u26a0 Warning: Household ${registrant_id} not having members!`\n        );\n        return state;\n      }\n      console.log(`\u2139 Household ${registrant_id} members found!`);\n      const nextState = composeNextState(state, members);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}\n"
  },
  {
    "name": "getServicePoint",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get service points information from OpenSPP\n * @public\n * @example\n * getServicePoint(\"000117\")\n * @function\n * @param {string} name - The number of the agent\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getServicePoint(name, offset = 0, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [['name', '=', name]];\n    const defaultFields = [\n      'name',\n      'area_id',\n      'service_type_ids',\n      'phone_sanitized',\n      'shop_address',\n      'is_contract_active',\n      'is_disabled',\n    ];\n    const options = {\n      limit: 100,\n      order: 'id desc',\n    };\n    if (offset > 0) {\n      options.offset = offset;\n    }\n    try {\n      const agents = await sppConnector.searchRead(\n        'spp.service.point',\n        defaultDomain,\n        defaultFields,\n        options\n      );\n      if (agents.length === 0) {\n        console.log(`\u26a0 Warning: Agent ${name} not found!`);\n        return state;\n      }\n      console.log(`\u2139 Agent ${name} found!`);\n      const nextState = composeNextState(state, agents);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}",
    "signature": "/**\n * get service points information from OpenSPP\n * @public\n * @example\n * getServicePoint(\"000117\")\n * @function\n * @param {string} name - The number of the agent\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getServicePoint(name: string, offset?: number, callback?: Function): Operation;",
    "test": "describe('getServicePoint', () => {\n    it('get non-existing service point from demo server', async () => {\n      let finalState = await getServicePoint('n0n-3x15t1n6-53rv1c3-p01nt')(\n        state\n      );\n      expect(finalState.data).to.be.undefined;\n    });",
    "instruction": "Create an OpenFn function that gets service points information from OpenSPP.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets service points information from OpenSPP.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * get service points information from OpenSPP\n * @public\n * @example\n * getServicePoint(\"000117\")\n * @function\n * @param {string} name - The number of the agent\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getServicePoint(name: string, offset?: number, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get service points information from OpenSPP\n * @public\n * @example\n * getServicePoint(\"000117\")\n * @function\n * @param {string} name - The number of the agent\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getServicePoint(name, offset = 0, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [['name', '=', name]];\n    const defaultFields = [\n      'name',\n      'area_id',\n      'service_type_ids',\n      'phone_sanitized',\n      'shop_address',\n      'is_contract_active',\n      'is_disabled',\n    ];\n    const options = {\n      limit: 100,\n      order: 'id desc',\n    };\n    if (offset > 0) {\n      options.offset = offset;\n    }\n    try {\n      const agents = await sppConnector.searchRead(\n        'spp.service.point',\n        defaultDomain,\n        defaultFields,\n        options\n      );\n      if (agents.length === 0) {\n        console.log(`\u26a0 Warning: Agent ${name} not found!`);\n        return state;\n      }\n      console.log(`\u2139 Agent ${name} found!`);\n      const nextState = composeNextState(state, agents);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}\n"
  },
  {
    "name": "searchGroup",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get groups from OpenSPP\n * @public\n * @example\n * searchGroup([[\"registrant_id\", \"=\", \"GRP_Q4VGGZPF\"]])\n * @function\n * @param {string} domain - searching domain\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function searchGroup(domain, offset = 0, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [\n      ['is_registrant', '=', true],\n      ['is_group', '=', true],\n    ];\n    const defaultOrder = 'id desc';\n    const defaultFields = ['name', 'registrant_id'];\n    let isDomain = true;\n    for (const element of domain) {\n      if (!Array.isArray(element)) {\n        isDomain = false;\n        break;\n      }\n    }\n    if (!isDomain) {\n      domain = [domain];\n    }\n    const finalDomain = [...domain, ...defaultDomain];\n    const options = {\n      limit: 100,\n      offset: offset,\n      order: defaultOrder,\n    };\n    try {\n      const groups = await sppConnector.searchRead(\n        'res.partner',\n        finalDomain,\n        defaultFields,\n        options\n      );\n      if (groups.length === 0) {\n        console.log(`\u26a0 Warning: Group with domain=${domain} not found!`);\n        return state;\n      }\n      console.log(`\u2139 Group with domain=${domain} found!`);\n      const nextState = composeNextState(state, groups);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}",
    "signature": "/**\n * get groups from OpenSPP\n * @public\n * @example\n * searchGroup([[\"registrant_id\", \"=\", \"GRP_Q4VGGZPF\"]])\n * @function\n * @param {string} domain - searching domain\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function searchGroup(domain: string, offset?: number, callback?: Function): Operation;",
    "test": "describe('searchGroup', () => {\n    it('search non-existing group from demo server', async () => {\n      let finalState = await searchGroup([['id', '=', -1]])(state);\n      expect(finalState.data).to.be.undefined;\n    });",
    "instruction": "Create an OpenFn function that searches groups from OpenSPP.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that searches groups from OpenSPP.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * get groups from OpenSPP\n * @public\n * @example\n * searchGroup([[\"registrant_id\", \"=\", \"GRP_Q4VGGZPF\"]])\n * @function\n * @param {string} domain - searching domain\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function searchGroup(domain: string, offset?: number, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get groups from OpenSPP\n * @public\n * @example\n * searchGroup([[\"registrant_id\", \"=\", \"GRP_Q4VGGZPF\"]])\n * @function\n * @param {string} domain - searching domain\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function searchGroup(domain, offset = 0, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [\n      ['is_registrant', '=', true],\n      ['is_group', '=', true],\n    ];\n    const defaultOrder = 'id desc';\n    const defaultFields = ['name', 'registrant_id'];\n    let isDomain = true;\n    for (const element of domain) {\n      if (!Array.isArray(element)) {\n        isDomain = false;\n        break;\n      }\n    }\n    if (!isDomain) {\n      domain = [domain];\n    }\n    const finalDomain = [...domain, ...defaultDomain];\n    const options = {\n      limit: 100,\n      offset: offset,\n      order: defaultOrder,\n    };\n    try {\n      const groups = await sppConnector.searchRead(\n        'res.partner',\n        finalDomain,\n        defaultFields,\n        options\n      );\n      if (groups.length === 0) {\n        console.log(`\u26a0 Warning: Group with domain=${domain} not found!`);\n        return state;\n      }\n      console.log(`\u2139 Group with domain=${domain} found!`);\n      const nextState = composeNextState(state, groups);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}\n"
  },
  {
    "name": "searchIndividual",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get individuals from OpenSPP\n * @public\n * @example\n * searchIndividual([[\"registrant_id\", \"=\", \"IND_Q4VGGZPF\"]])\n * @function\n * @param {string} domain - searching domain\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function searchIndividual(domain, offset = 0, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [\n      ['is_registrant', '=', true],\n      ['is_group', '=', false],\n    ];\n    const defaultOrder = 'id desc';\n    const defaultFields = ['name', 'registrant_id'];\n    let isDomain = true;\n    for (const element of domain) {\n      if (!Array.isArray(element)) {\n        isDomain = false;\n        break;\n      }\n    }\n    if (!isDomain) {\n      domain = [domain];\n    }\n    const finalDomain = [...domain, ...defaultDomain];\n    const options = {\n      limit: 100,\n      offset: offset,\n      order: defaultOrder,\n    };\n    try {\n      const individuals = await sppConnector.searchRead(\n        'res.partner',\n        finalDomain,\n        defaultFields,\n        options\n      );\n      if (individuals.length === 0) {\n        console.log(`\u26a0 Warning: Individual with domain=${domain} not found!`);\n        return state;\n      }\n      console.log(`\u2139 Individual with domain=${domain} found!`);\n      const nextState = composeNextState(state, individuals);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}",
    "signature": "/**\n * get individuals from OpenSPP\n * @public\n * @example\n * searchIndividual([[\"registrant_id\", \"=\", \"IND_Q4VGGZPF\"]])\n * @function\n * @param {string} domain - searching domain\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function searchIndividual(domain: string, offset?: number, callback?: Function): Operation;",
    "test": "describe('searchIndividual', () => {\n    it('search non-existing individual from demo server', async () => {\n      let finalState = await searchIndividual([['id', '=', -1]])(state);\n      expect(finalState.data).to.be.undefined;\n    });",
    "instruction": "Create an OpenFn function that searches individuals from OpenSPP.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that searches individuals from OpenSPP.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * get individuals from OpenSPP\n * @public\n * @example\n * searchIndividual([[\"registrant_id\", \"=\", \"IND_Q4VGGZPF\"]])\n * @function\n * @param {string} domain - searching domain\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function searchIndividual(domain: string, offset?: number, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get individuals from OpenSPP\n * @public\n * @example\n * searchIndividual([[\"registrant_id\", \"=\", \"IND_Q4VGGZPF\"]])\n * @function\n * @param {string} domain - searching domain\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function searchIndividual(domain, offset = 0, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [\n      ['is_registrant', '=', true],\n      ['is_group', '=', false],\n    ];\n    const defaultOrder = 'id desc';\n    const defaultFields = ['name', 'registrant_id'];\n    let isDomain = true;\n    for (const element of domain) {\n      if (!Array.isArray(element)) {\n        isDomain = false;\n        break;\n      }\n    }\n    if (!isDomain) {\n      domain = [domain];\n    }\n    const finalDomain = [...domain, ...defaultDomain];\n    const options = {\n      limit: 100,\n      offset: offset,\n      order: defaultOrder,\n    };\n    try {\n      const individuals = await sppConnector.searchRead(\n        'res.partner',\n        finalDomain,\n        defaultFields,\n        options\n      );\n      if (individuals.length === 0) {\n        console.log(`\u26a0 Warning: Individual with domain=${domain} not found!`);\n        return state;\n      }\n      console.log(`\u2139 Individual with domain=${domain} found!`);\n      const nextState = composeNextState(state, individuals);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}\n"
  },
  {
    "name": "getProgram",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get program information from OpenSPP\n * @public\n * @example\n * getProgram(\"PROG_2023_00000001\")\n * @function\n * @param {string} program_id - searching domain\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getProgram(program_id, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [['program_id', '=', program_id]];\n    const defaultFields = [\n      'name',\n      'program_id',\n      'eligible_beneficiaries_count',\n      'cycles_count',\n      'state',\n      'target_type',\n    ];\n    const options = { limit: 1 };\n    try {\n      const program = await sppConnector.searchRead(\n        'g2p.program',\n        defaultDomain,\n        defaultFields,\n        options\n      );\n      if (program.length === 0) {\n        console.log(`\u26a0 Warning: Program ${program_id} not found!`);\n        return state;\n      }\n      console.log(`\u2139 Program ${program_id} found!`);\n      const nextState = composeNextState(state, program[0]);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}",
    "signature": "/**\n * get program information from OpenSPP\n * @public\n * @example\n * getProgram(\"PROG_2023_00000001\")\n * @function\n * @param {string} program_id - searching domain\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getProgram(program_id: string, callback?: Function): Operation;",
    "instruction": "Create an OpenFn function that gets program information from OpenSPP.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets program information from OpenSPP.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * get program information from OpenSPP\n * @public\n * @example\n * getProgram(\"PROG_2023_00000001\")\n * @function\n * @param {string} program_id - searching domain\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getProgram(program_id: string, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get program information from OpenSPP\n * @public\n * @example\n * getProgram(\"PROG_2023_00000001\")\n * @function\n * @param {string} program_id - searching domain\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getProgram(program_id, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [['program_id', '=', program_id]];\n    const defaultFields = [\n      'name',\n      'program_id',\n      'eligible_beneficiaries_count',\n      'cycles_count',\n      'state',\n      'target_type',\n    ];\n    const options = { limit: 1 };\n    try {\n      const program = await sppConnector.searchRead(\n        'g2p.program',\n        defaultDomain,\n        defaultFields,\n        options\n      );\n      if (program.length === 0) {\n        console.log(`\u26a0 Warning: Program ${program_id} not found!`);\n        return state;\n      }\n      console.log(`\u2139 Program ${program_id} found!`);\n      const nextState = composeNextState(state, program[0]);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}\n"
  },
  {
    "name": "getPrograms",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get programs list from OpenSPP\n * @public\n * @example\n * getPrograms(100)\n * @function\n * @param {number} [offset=0] - offset from start\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getPrograms(offset = 0, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [];\n    const defaultFields = ['name', 'program_id'];\n    const defaultOrder = 'id';\n    const options = {\n      limit: 100,\n      offset: offset,\n      order: defaultOrder,\n    };\n    try {\n      const programs = await sppConnector.searchRead(\n        'g2p.program',\n        defaultDomain,\n        defaultFields,\n        options\n      );\n      if (programs.length === 0) {\n        console.log(`\u26a0 Warning: No program found!`);\n        return state;\n      }\n      console.log(`\u2139 Program(s) found!`);\n      const nextState = composeNextState(state, programs);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}",
    "signature": "/**\n * get programs list from OpenSPP\n * @public\n * @example\n * getPrograms(100)\n * @function\n * @param {number} [offset=0] - offset from start\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getPrograms(offset?: number, callback?: Function): Operation;",
    "instruction": "create an OpenFn function that gets programs list from OpenSPP",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\ncreate an OpenFn function that gets programs list from OpenSPP\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * get programs list from OpenSPP\n * @public\n * @example\n * getPrograms(100)\n * @function\n * @param {number} [offset=0] - offset from start\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getPrograms(offset?: number, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get programs list from OpenSPP\n * @public\n * @example\n * getPrograms(100)\n * @function\n * @param {number} [offset=0] - offset from start\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getPrograms(offset = 0, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [];\n    const defaultFields = ['name', 'program_id'];\n    const defaultOrder = 'id';\n    const options = {\n      limit: 100,\n      offset: offset,\n      order: defaultOrder,\n    };\n    try {\n      const programs = await sppConnector.searchRead(\n        'g2p.program',\n        defaultDomain,\n        defaultFields,\n        options\n      );\n      if (programs.length === 0) {\n        console.log(`\u26a0 Warning: No program found!`);\n        return state;\n      }\n      console.log(`\u2139 Program(s) found!`);\n      const nextState = composeNextState(state, programs);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}\n"
  },
  {
    "name": "getEnrolledPrograms",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get programs list for specific registrant from OpenSPP\n * @public\n * @example\n * getEnrolledPrograms(\"IND_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - registrant_id of group / individual wanted to search\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getEnrolledPrograms(registrant_id, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [['partner_id.registrant_id', '=', registrant_id]];\n    const defaultFields = ['program_id'];\n    try {\n      let program_ids = await sppConnector.searchRead(\n        'g2p.program_membership',\n        defaultDomain,\n        defaultFields\n      );\n      if (program_ids.length === 0) {\n        console.log(`\u26a0 Warning: No enrolled program(s) found!`);\n        return state;\n      }\n      console.log(`\u2139 Enrolled program(s) found!`);\n      program_ids = program_ids.map(i => i.program_id[0]);\n      const programs = await sppConnector.searchRead(\n        'g2p.program',\n        [['id', 'in', program_ids]],\n        defaultFields,\n        { limit: program_ids.length }\n      );\n      const nextState = composeNextState(state, programs);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}",
    "signature": "/**\n * get programs list for specific registrant from OpenSPP\n * @public\n * @example\n * getEnrolledPrograms(\"IND_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - registrant_id of group / individual wanted to search\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getEnrolledPrograms(registrant_id: string, callback?: Function): Operation;",
    "instruction": "Create an OpenFn function that gets programs list for a specific registrant from OpenSPP",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets programs list for a specific registrant from OpenSPP\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * get programs list for specific registrant from OpenSPP\n * @public\n * @example\n * getEnrolledPrograms(\"IND_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - registrant_id of group / individual wanted to search\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getEnrolledPrograms(registrant_id: string, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get programs list for specific registrant from OpenSPP\n * @public\n * @example\n * getEnrolledPrograms(\"IND_Q4VGGZPF\")\n * @function\n * @param {string} registrant_id - registrant_id of group / individual wanted to search\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function getEnrolledPrograms(registrant_id, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [['partner_id.registrant_id', '=', registrant_id]];\n    const defaultFields = ['program_id'];\n    try {\n      let program_ids = await sppConnector.searchRead(\n        'g2p.program_membership',\n        defaultDomain,\n        defaultFields\n      );\n      if (program_ids.length === 0) {\n        console.log(`\u26a0 Warning: No enrolled program(s) found!`);\n        return state;\n      }\n      console.log(`\u2139 Enrolled program(s) found!`);\n      program_ids = program_ids.map(i => i.program_id[0]);\n      const programs = await sppConnector.searchRead(\n        'g2p.program',\n        [['id', 'in', program_ids]],\n        defaultFields,\n        { limit: program_ids.length }\n      );\n      const nextState = composeNextState(state, programs);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}\n"
  },
  {
    "name": "enroll",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * enroll registrant to program in OpenSPP\n * @public\n * @example\n * enroll(\"IND_Q4VGGZPF\", \"PROG_2023_00000001\")\n * @function\n * @param {string} registrant_id - registrant_id of group / individual wanted to enroll\n * @param {string} program_id - program_id of program\n */\nexport function enroll(registrant_id, program_id) {\n  return async state => {\n    const domain = [\n      ['partner_id.registrant_id', '=', registrant_id],\n      ['program_id.program_id', '=', program_id],\n    ];\n    const fields = ['partner_id', 'program_id', 'state'];\n    try {\n      const programMember = await sppConnector.searchRead(\n        'g2p.program_membership',\n        domain,\n        fields,\n        { limit: 1 }\n      );\n      if (programMember.length > 0) {\n        const membership = programMember[0];\n        if (membership.state !== 'enrolled') {\n          await sppConnector.update('g2p.program_membership', membership.id, {\n            state: 'enrolled',\n          });\n        }\n        console.log(\n          `\u2139 Registrant ${registrant_id} enrolled into Program ${program_id}`\n        );\n      } else {\n        await createProgramMembership(registrant_id, program_id);\n      }\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n    } finally {\n      return state;\n    }\n  };\n}",
    "signature": "/**\n * enroll registrant to program in OpenSPP\n * @public\n * @example\n * enroll(\"IND_Q4VGGZPF\", \"PROG_2023_00000001\")\n * @function\n * @param {string} registrant_id - registrant_id of group / individual wanted to enroll\n * @param {string} program_id - program_id of program\n */\nexport function enroll(registrant_id: string, program_id: string): (state: any) => Promise<any>;",
    "instruction": "Create an OpenFn function that enrolls a registrant to a program in OpenSPP",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that enrolls a registrant to a program in OpenSPP\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * enroll registrant to program in OpenSPP\n * @public\n * @example\n * enroll(\"IND_Q4VGGZPF\", \"PROG_2023_00000001\")\n * @function\n * @param {string} registrant_id - registrant_id of group / individual wanted to enroll\n * @param {string} program_id - program_id of program\n */\nexport function enroll(registrant_id: string, program_id: string): (state: any) => Promise<any>;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * enroll registrant to program in OpenSPP\n * @public\n * @example\n * enroll(\"IND_Q4VGGZPF\", \"PROG_2023_00000001\")\n * @function\n * @param {string} registrant_id - registrant_id of group / individual wanted to enroll\n * @param {string} program_id - program_id of program\n */\nexport function enroll(registrant_id, program_id) {\n  return async state => {\n    const domain = [\n      ['partner_id.registrant_id', '=', registrant_id],\n      ['program_id.program_id', '=', program_id],\n    ];\n    const fields = ['partner_id', 'program_id', 'state'];\n    try {\n      const programMember = await sppConnector.searchRead(\n        'g2p.program_membership',\n        domain,\n        fields,\n        { limit: 1 }\n      );\n      if (programMember.length > 0) {\n        const membership = programMember[0];\n        if (membership.state !== 'enrolled') {\n          await sppConnector.update('g2p.program_membership', membership.id, {\n            state: 'enrolled',\n          });\n        }\n        console.log(\n          `\u2139 Registrant ${registrant_id} enrolled into Program ${program_id}`\n        );\n      } else {\n        await createProgramMembership(registrant_id, program_id);\n      }\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n    } finally {\n      return state;\n    }\n  };\n}\n"
  },
  {
    "name": "unenroll",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * unenroll registrant from program in OpenSPP\n * @public\n * @example\n * unenroll(\"IND_Q4VGGZPF\", \"PROG_2023_00000001\")\n * @function\n * @param {string} registrant_id - registrant_id of group / individual wanted to unenroll\n * @param {string} program_id - program_id of program\n */\nexport function unenroll(registrant_id, program_id) {\n  return async state => {\n    const domain = [\n      ['partner_id.registrant_id', '=', registrant_id],\n      ['program_id.program_id', '=', program_id],\n    ];\n    const fields = ['partner_id', 'program_id', 'state'];\n    try {\n      const programMember = await sppConnector.searchRead(\n        'g2p.program_membership',\n        domain,\n        fields,\n        { limit: 1 }\n      );\n      if (programMember.length > 0 && programMember[0].state === 'enrolled') {\n        const membership = programMember[0];\n        await sppConnector.update('g2p.program_membership', membership.id, {\n          state: 'not_eligible',\n        });\n      }\n      console.log(\n        `\u2139 Registrant ${registrant_id} not enroll into Program ${program_id}`\n      );\n      return state;\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}",
    "signature": "/**\n * unenroll registrant from program in OpenSPP\n * @public\n * @example\n * unenroll(\"IND_Q4VGGZPF\", \"PROG_2023_00000001\")\n * @function\n * @param {string} registrant_id - registrant_id of group / individual wanted to unenroll\n * @param {string} program_id - program_id of program\n */\nexport function unenroll(registrant_id: string, program_id: string): (state: any) => Promise<any>;",
    "instruction": "Create an OpenFn function that unenrolls from a program in OpenSPP.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that unenrolls from a program in OpenSPP.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * unenroll registrant from program in OpenSPP\n * @public\n * @example\n * unenroll(\"IND_Q4VGGZPF\", \"PROG_2023_00000001\")\n * @function\n * @param {string} registrant_id - registrant_id of group / individual wanted to unenroll\n * @param {string} program_id - program_id of program\n */\nexport function unenroll(registrant_id: string, program_id: string): (state: any) => Promise<any>;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * unenroll registrant from program in OpenSPP\n * @public\n * @example\n * unenroll(\"IND_Q4VGGZPF\", \"PROG_2023_00000001\")\n * @function\n * @param {string} registrant_id - registrant_id of group / individual wanted to unenroll\n * @param {string} program_id - program_id of program\n */\nexport function unenroll(registrant_id, program_id) {\n  return async state => {\n    const domain = [\n      ['partner_id.registrant_id', '=', registrant_id],\n      ['program_id.program_id', '=', program_id],\n    ];\n    const fields = ['partner_id', 'program_id', 'state'];\n    try {\n      const programMember = await sppConnector.searchRead(\n        'g2p.program_membership',\n        domain,\n        fields,\n        { limit: 1 }\n      );\n      if (programMember.length > 0 && programMember[0].state === 'enrolled') {\n        const membership = programMember[0];\n        await sppConnector.update('g2p.program_membership', membership.id, {\n          state: 'not_eligible',\n        });\n      }\n      console.log(\n        `\u2139 Registrant ${registrant_id} not enroll into Program ${program_id}`\n      );\n      return state;\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}\n"
  },
  {
    "name": "createIndividual",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * create new individual for OpenSPP\n * @public\n * @example\n * createIndividual({ name: \"Individual 1\" })\n * @function\n * @param {object} data - registrant create data\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createIndividual(data, callback=(s) => s) {\n  return async state => {\n    try {\n      if (!data.name) {\n        throw new Error(`\"name\" is a required parameter!`);\n      }\n      data.is_registrant = true;\n      data.is_group = false;\n      const individualId = await sppConnector.create('res.partner', data);\n      const res = await sppConnector.searchRead(\n        'res.partner',\n        [['id', '=', individualId]],\n        ['registrant_id'],\n        { limit: 1 }\n      );\n      const individualRegistrantId = res[0].registrant_id;\n      console.log(`\u2139 Individual created with registrant ID: ${individualRegistrantId}`);\n      const nextState = composeNextState(state, individualRegistrantId);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  }\n}",
    "signature": "/**\n * create new individual for OpenSPP\n * @public\n * @example\n * createIndividual({ name: \"Individual 1\" })\n * @function\n * @param {object} data - registrant create data\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createIndividual(data: object, callback?: Function): Operation;",
    "instruction": "Create an OpenFn function that creates an individual from data.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates an individual from data.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * create new individual for OpenSPP\n * @public\n * @example\n * createIndividual({ name: \"Individual 1\" })\n * @function\n * @param {object} data - registrant create data\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createIndividual(data: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * create new individual for OpenSPP\n * @public\n * @example\n * createIndividual({ name: \"Individual 1\" })\n * @function\n * @param {object} data - registrant create data\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createIndividual(data, callback=(s) => s) {\n  return async state => {\n    try {\n      if (!data.name) {\n        throw new Error(`\"name\" is a required parameter!`);\n      }\n      data.is_registrant = true;\n      data.is_group = false;\n      const individualId = await sppConnector.create('res.partner', data);\n      const res = await sppConnector.searchRead(\n        'res.partner',\n        [['id', '=', individualId]],\n        ['registrant_id'],\n        { limit: 1 }\n      );\n      const individualRegistrantId = res[0].registrant_id;\n      console.log(`\u2139 Individual created with registrant ID: ${individualRegistrantId}`);\n      const nextState = composeNextState(state, individualRegistrantId);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  }\n}\n"
  },
  {
    "name": "createGroup",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * create new group for OpenSPP\n * @public\n * @example\n * createGroup({ name: \"Group 1\" })\n * @function\n * @param {object} data - registrant create data\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createGroup(data, callback=(s) => s) {\n  return async state => {\n    try {\n      if (!data.name) {\n        throw new Error(`\"name\" is a required parameter!`);\n      }\n      data.is_registrant = true;\n      data.is_group = true;\n      const groupId = await sppConnector.create('res.partner', data);\n      const res = await sppConnector.searchRead(\n        'res.partner',\n        [['id', '=', groupId]],\n        ['registrant_id'],\n        { limit: 1 }\n      );\n      const groupRegistrantId = res[0].registrant_id;\n      console.log(`\u2139 Group created with registrant ID: ${groupRegistrantId}`);\n      const nextState = composeNextState(state, groupRegistrantId);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  }\n}",
    "signature": "/**\n * create new group for OpenSPP\n * @public\n * @example\n * createGroup({ name: \"Group 1\" })\n * @function\n * @param {object} data - registrant create data\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createGroup(data: object, callback?: Function): Operation;",
    "instruction": "Create an OpenFn function that creates a new group for OpenSPP.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates a new group for OpenSPP.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * create new group for OpenSPP\n * @public\n * @example\n * createGroup({ name: \"Group 1\" })\n * @function\n * @param {object} data - registrant create data\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createGroup(data: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * create new group for OpenSPP\n * @public\n * @example\n * createGroup({ name: \"Group 1\" })\n * @function\n * @param {object} data - registrant create data\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createGroup(data, callback=(s) => s) {\n  return async state => {\n    try {\n      if (!data.name) {\n        throw new Error(`\"name\" is a required parameter!`);\n      }\n      data.is_registrant = true;\n      data.is_group = true;\n      const groupId = await sppConnector.create('res.partner', data);\n      const res = await sppConnector.searchRead(\n        'res.partner',\n        [['id', '=', groupId]],\n        ['registrant_id'],\n        { limit: 1 }\n      );\n      const groupRegistrantId = res[0].registrant_id;\n      console.log(`\u2139 Group created with registrant ID: ${groupRegistrantId}`);\n      const nextState = composeNextState(state, groupRegistrantId);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  }\n}\n"
  },
  {
    "name": "updateGroup",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * update group for OpenSPP\n * @public\n * @example\n * updateGroup(\"GRP_B2BRHJN2\", { name: \"Group 1\" })\n * @function\n * @param {string} group_id - group registrant id\n * @param {object} data - registrant update data\n * @returns {Operation}\n */\nexport function updateGroup(group_id, data) {\n  return async state => {\n    try {\n      const res = await sppConnector.searchRead(\n        'res.partner',\n        [\n          ['registrant_id', '=', group_id],\n          ['is_registrant', '=', true],\n          ['is_group', '=', true],\n        ],\n        ['id'],\n        { limit: 1, order: 'id desc' },\n      );\n      if (res.length === 0) {\n        throw new Error(`Group with registrant id: ${group_id} does not exists!`);\n      }\n      const groupId = res[0].id;\n      await sppConnector.update(\n        'res.partner',\n        groupId,\n        data\n      );\n      console.log(`\u2139 Group ${group_id} updated!`);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n    } finally {\n      return state;\n    }\n  }\n}",
    "signature": "/**\n * update group for OpenSPP\n * @public\n * @example\n * updateGroup(\"GRP_B2BRHJN2\", { name: \"Group 1\" })\n * @function\n * @param {string} group_id - group registrant id\n * @param {object} data - registrant update data\n * @returns {Operation}\n */\nexport function updateGroup(group_id: string, data: object): Operation;",
    "instruction": "Create an OpenFn function that updates a group from OpenSPP.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that updates a group from OpenSPP.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * update group for OpenSPP\n * @public\n * @example\n * updateGroup(\"GRP_B2BRHJN2\", { name: \"Group 1\" })\n * @function\n * @param {string} group_id - group registrant id\n * @param {object} data - registrant update data\n * @returns {Operation}\n */\nexport function updateGroup(group_id: string, data: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * update group for OpenSPP\n * @public\n * @example\n * updateGroup(\"GRP_B2BRHJN2\", { name: \"Group 1\" })\n * @function\n * @param {string} group_id - group registrant id\n * @param {object} data - registrant update data\n * @returns {Operation}\n */\nexport function updateGroup(group_id, data) {\n  return async state => {\n    try {\n      const res = await sppConnector.searchRead(\n        'res.partner',\n        [\n          ['registrant_id', '=', group_id],\n          ['is_registrant', '=', true],\n          ['is_group', '=', true],\n        ],\n        ['id'],\n        { limit: 1, order: 'id desc' },\n      );\n      if (res.length === 0) {\n        throw new Error(`Group with registrant id: ${group_id} does not exists!`);\n      }\n      const groupId = res[0].id;\n      await sppConnector.update(\n        'res.partner',\n        groupId,\n        data\n      );\n      console.log(`\u2139 Group ${group_id} updated!`);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n    } finally {\n      return state;\n    }\n  }\n}\n"
  },
  {
    "name": "updateIndividual",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * update individual for OpenSPP\n * @public\n * @example\n * updateIndividual(\"IND_8DUQL4M4\", { name: \"Individual 1\" })\n * @function\n * @param {string} individual_id - individual registrant id\n * @param {object} data - registrant update data\n * @returns {Operation}\n */\nexport function updateIndividual(individual_id, data) {\n  return async state => {\n    try {\n      if (typeof data !== 'object' || Array.isArray(data) || data === null) {\n        throw new Error(`${data} is not an update object!`);\n      }\n      const res = await sppConnector.searchRead(\n        'res.partner',\n        [\n          ['registrant_id', '=', individual_id],\n          ['is_registrant', '=', true],\n          ['is_group', '=', false],\n        ],\n        ['id'],\n        { limit: 1, order: 'id desc' },\n      );\n      if (res.length === 0) {\n        throw new Error(`Individual with registrant id: ${individual_id} does not exists!`);\n      }\n      const individualId = res[0].id;\n      await sppConnector.update(\n        'res.partner',\n        individualId,\n        data\n      );\n      console.log(`\u2139 Individual ${individual_id} updated!`);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n    } finally {\n      return state;\n    }\n  }\n}",
    "signature": "/**\n * update individual for OpenSPP\n * @public\n * @example\n * updateIndividual(\"IND_8DUQL4M4\", { name: \"Individual 1\" })\n * @function\n * @param {string} individual_id - individual registrant id\n * @param {object} data - registrant update data\n * @returns {Operation}\n */\nexport function updateIndividual(individual_id: string, data: object): Operation;",
    "instruction": "Create an OpenFn function that updates an individual from OpenSPP.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that updates an individual from OpenSPP.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * update individual for OpenSPP\n * @public\n * @example\n * updateIndividual(\"IND_8DUQL4M4\", { name: \"Individual 1\" })\n * @function\n * @param {string} individual_id - individual registrant id\n * @param {object} data - registrant update data\n * @returns {Operation}\n */\nexport function updateIndividual(individual_id: string, data: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * update individual for OpenSPP\n * @public\n * @example\n * updateIndividual(\"IND_8DUQL4M4\", { name: \"Individual 1\" })\n * @function\n * @param {string} individual_id - individual registrant id\n * @param {object} data - registrant update data\n * @returns {Operation}\n */\nexport function updateIndividual(individual_id, data) {\n  return async state => {\n    try {\n      if (typeof data !== 'object' || Array.isArray(data) || data === null) {\n        throw new Error(`${data} is not an update object!`);\n      }\n      const res = await sppConnector.searchRead(\n        'res.partner',\n        [\n          ['registrant_id', '=', individual_id],\n          ['is_registrant', '=', true],\n          ['is_group', '=', false],\n        ],\n        ['id'],\n        { limit: 1, order: 'id desc' },\n      );\n      if (res.length === 0) {\n        throw new Error(`Individual with registrant id: ${individual_id} does not exists!`);\n      }\n      const individualId = res[0].id;\n      await sppConnector.update(\n        'res.partner',\n        individualId,\n        data\n      );\n      console.log(`\u2139 Individual ${individual_id} updated!`);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n    } finally {\n      return state;\n    }\n  }\n}\n"
  },
  {
    "name": "addToGroup",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * add individual to group in OpenSPP\n * @public\n * @example\n * addToGroup(\"GRP_B2BRHJN2\", \"IND_8DUQL4M4\", \"Head\")\n * @function\n * @param {string} group_id - group registrant id\n * @param {string} individual_id - individual registrant id\n * @param {string} role - individual role in group\n * @returns {Operation}\n */\nexport function addToGroup(group_id, individual_id, role='') {\n  return async state => {\n    try {\n      let roleId = [];\n      if (role.length > 0) {\n        roleId = await sppConnector.search(\n          'g2p.group.membership.kind',\n          [['name', '=', role]]\n        );\n        if (roleId.length === 0) {\n          roleId = [await sppConnector.create(\n            'g2p.group.membership.kind',\n            { name: role }\n          )];\n        }\n      }\n      const res = await sppConnector.searchRead(\n        'g2p.group.membership',\n        [\n          ['group.registrant_id', '=', group_id],\n          ['individual.registrant_id', '=', individual_id],\n          ['is_ended', '=', false],\n        ],\n        ['id', 'kind'],\n        { limit: 1 },\n      );\n      if (res.length === 0) {\n        const individual = await sppConnector.searchRead(\n          'res.partner',\n          [\n            ['registrant_id', '=', individual_id],\n            ['is_registrant', '=', true],\n            ['is_group', '=', false],\n          ],\n          ['id'],\n          { limit: 1 },\n        );\n        const group = await sppConnector.searchRead(\n          'res.partner',\n          [\n            ['registrant_id', '=', group_id],\n            ['is_registrant', '=', true],\n            ['is_group', '=', true],\n          ],\n          ['id'],\n          { limit: 1 },\n        );\n        if (individual.length === 0 || group.length === 0) {\n          throw new Error(`Individual or Group does not exist!`);\n        }\n        await sppConnector.create(\n          'g2p.group.membership',\n          {\n            individual: individual[0].id,\n            group: group[0].id,\n            kind: [[6, 0, roleId]],\n          }\n        );\n      } else {\n        const groupMembershipIds = res.map( i => i.id );\n        await sppConnector.update(\n          'g2p.group.membership',\n          groupMembershipIds,\n          { kind: [[6, 0, roleId]] },\n        );\n      }\n      if (role.length > 0) {\n        console.log(`\u2139 Individual ${individual_id} added to group ${group_id} with role ${role}!`);\n      } else {\n        console.log(`\u2139 Individual ${individual_id} added to group ${group_id}!`);\n      }\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n    } finally {\n      return state;\n    }\n  }\n}",
    "signature": "/**\n * add individual to group in OpenSPP\n * @public\n * @example\n * addToGroup(\"GRP_B2BRHJN2\", \"IND_8DUQL4M4\", \"Head\")\n * @function\n * @param {string} group_id - group registrant id\n * @param {string} individual_id - individual registrant id\n * @param {string} role - individual role in group\n * @returns {Operation}\n */\nexport function addToGroup(group_id: string, individual_id: string, role?: string): Operation;",
    "instruction": "Create an OpenFn function that adds an individual to a group in OpenSPP.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that adds an individual to a group in OpenSPP.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * add individual to group in OpenSPP\n * @public\n * @example\n * addToGroup(\"GRP_B2BRHJN2\", \"IND_8DUQL4M4\", \"Head\")\n * @function\n * @param {string} group_id - group registrant id\n * @param {string} individual_id - individual registrant id\n * @param {string} role - individual role in group\n * @returns {Operation}\n */\nexport function addToGroup(group_id: string, individual_id: string, role?: string): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * add individual to group in OpenSPP\n * @public\n * @example\n * addToGroup(\"GRP_B2BRHJN2\", \"IND_8DUQL4M4\", \"Head\")\n * @function\n * @param {string} group_id - group registrant id\n * @param {string} individual_id - individual registrant id\n * @param {string} role - individual role in group\n * @returns {Operation}\n */\nexport function addToGroup(group_id, individual_id, role='') {\n  return async state => {\n    try {\n      let roleId = [];\n      if (role.length > 0) {\n        roleId = await sppConnector.search(\n          'g2p.group.membership.kind',\n          [['name', '=', role]]\n        );\n        if (roleId.length === 0) {\n          roleId = [await sppConnector.create(\n            'g2p.group.membership.kind',\n            { name: role }\n          )];\n        }\n      }\n      const res = await sppConnector.searchRead(\n        'g2p.group.membership',\n        [\n          ['group.registrant_id', '=', group_id],\n          ['individual.registrant_id', '=', individual_id],\n          ['is_ended', '=', false],\n        ],\n        ['id', 'kind'],\n        { limit: 1 },\n      );\n      if (res.length === 0) {\n        const individual = await sppConnector.searchRead(\n          'res.partner',\n          [\n            ['registrant_id', '=', individual_id],\n            ['is_registrant', '=', true],\n            ['is_group', '=', false],\n          ],\n          ['id'],\n          { limit: 1 },\n        );\n        const group = await sppConnector.searchRead(\n          'res.partner',\n          [\n            ['registrant_id', '=', group_id],\n            ['is_registrant', '=', true],\n            ['is_group', '=', true],\n          ],\n          ['id'],\n          { limit: 1 },\n        );\n        if (individual.length === 0 || group.length === 0) {\n          throw new Error(`Individual or Group does not exist!`);\n        }\n        await sppConnector.create(\n          'g2p.group.membership',\n          {\n            individual: individual[0].id,\n            group: group[0].id,\n            kind: [[6, 0, roleId]],\n          }\n        );\n      } else {\n        const groupMembershipIds = res.map( i => i.id );\n        await sppConnector.update(\n          'g2p.group.membership',\n          groupMembershipIds,\n          { kind: [[6, 0, roleId]] },\n        );\n      }\n      if (role.length > 0) {\n        console.log(`\u2139 Individual ${individual_id} added to group ${group_id} with role ${role}!`);\n      } else {\n        console.log(`\u2139 Individual ${individual_id} added to group ${group_id}!`);\n      }\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n    } finally {\n      return state;\n    }\n  }\n}\n"
  },
  {
    "name": "removeFromGroup",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * remove individual from group in OpenSPP\n * @public\n * @example\n * removeFromGroup(\"GRP_B2BRHJN2\", \"IND_8DUQL4M4\")\n * @function\n * @param {string} group_id - group registrant id\n * @param {string} individual_id - individual registrant id\n * @returns {Operation}\n */\nexport function removeFromGroup(group_id, individual_id) {\n  return async state => {\n    try {\n      const res = await sppConnector.searchRead(\n        'g2p.group.membership',\n        [\n          ['group.registrant_id', '=', group_id],\n          ['individual.registrant_id', '=', individual_id],\n          ['is_ended', '=', false],\n        ],\n        ['id'],\n      );\n      if (res.length > 0) {\n        const groupMembershipIds = res.map( i => i.id );\n        const now = new Date();\n        const sppDateTimeNowString = dateFns.format(now, 'y-M-d HH:mm:ss');\n        await sppConnector.update(\n          'g2p.group.membership',\n          groupMembershipIds,\n          { ended_date: sppDateTimeNowString }\n        );\n      }\n      console.log(`\u2139 Individual ${individual_id} membership to group ${group_id} is ended!`);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n    } finally {\n      return state;\n    }\n  }\n}",
    "signature": "/**\n * remove individual from group in OpenSPP\n * @public\n * @example\n * removeFromGroup(\"GRP_B2BRHJN2\", \"IND_8DUQL4M4\")\n * @function\n * @param {string} group_id - group registrant id\n * @param {string} individual_id - individual registrant id\n * @returns {Operation}\n */\nexport function removeFromGroup(group_id: string, individual_id: string): Operation;",
    "instruction": "Create an OpenFn function that removes an individual from a group in OpenSPP.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that removes an individual from a group in OpenSPP.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * remove individual from group in OpenSPP\n * @public\n * @example\n * removeFromGroup(\"GRP_B2BRHJN2\", \"IND_8DUQL4M4\")\n * @function\n * @param {string} group_id - group registrant id\n * @param {string} individual_id - individual registrant id\n * @returns {Operation}\n */\nexport function removeFromGroup(group_id: string, individual_id: string): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * remove individual from group in OpenSPP\n * @public\n * @example\n * removeFromGroup(\"GRP_B2BRHJN2\", \"IND_8DUQL4M4\")\n * @function\n * @param {string} group_id - group registrant id\n * @param {string} individual_id - individual registrant id\n * @returns {Operation}\n */\nexport function removeFromGroup(group_id, individual_id) {\n  return async state => {\n    try {\n      const res = await sppConnector.searchRead(\n        'g2p.group.membership',\n        [\n          ['group.registrant_id', '=', group_id],\n          ['individual.registrant_id', '=', individual_id],\n          ['is_ended', '=', false],\n        ],\n        ['id'],\n      );\n      if (res.length > 0) {\n        const groupMembershipIds = res.map( i => i.id );\n        const now = new Date();\n        const sppDateTimeNowString = dateFns.format(now, 'y-M-d HH:mm:ss');\n        await sppConnector.update(\n          'g2p.group.membership',\n          groupMembershipIds,\n          { ended_date: sppDateTimeNowString }\n        );\n      }\n      console.log(`\u2139 Individual ${individual_id} membership to group ${group_id} is ended!`);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n    } finally {\n      return state;\n    }\n  }\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for cartodb.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Array} ...operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for cartodb.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Array} ...operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "describe('execute', () => {\n  it('executes each operation in sequence', done => {\n    const state = {};\n    const operations = [\n      state => {\n        return { counter: 1 };\n      },\n      state => {\n        return { counter: 2 };\n      },\n      state => {\n        return { counter: 3 };\n      },\n    ];\n\n    execute(...operations)(state)\n      .then(finalState => {\n        expect(finalState).to.eql({ counter: 3 });",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n  http,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for mssql.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for mssql.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `@openfn/language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Creates a connection.\n * @example\n *  createConnection(state)\n * @function\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nfunction createConnection(state) {\n  const { server, userName, password, database } = state.configuration;\n\n  if (!server) {\n    throw new Error('server missing from configuration.');\n  }\n\n  const config = {\n    authentication: {\n      options: { userName, password },\n      type: 'default',\n    },\n    server,\n    options: {\n      database,\n      encrypt: true,\n      rowCollectionOnRequestCompletion: true,\n    },\n  };\n\n  var connection = new Connection(config);\n\n  // Attempt to connect and execute queries if connection goes through\n  return new Promise((resolve, reject) => {\n    connection.on('connect', err => {\n      if (err) {\n        console.error(err.message);\n        reject(err);\n      } else {\n        resolve({ ...state, connection });\n      }\n    });\n    // Initialize connection\n    connection.connect();\n  });\n}\n\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for mssql.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n    queries: [],\n  };\n\n  return state => {\n    return commonExecute(\n      createConnection,\n      ...operations,\n      cleanupState\n    )({ ...initialState, ...state }).catch(e => {\n      console.error(e);\n      console.error('Unhandled error in the operations. Exiting process.');\n      process.exit(1);\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Creates a connection.\n * @example\n *  createConnection(state)\n * @function\n * @param {State} state - Runtime state.\n * @returns {State}\n */\nfunction createConnection(state) {\n  const { server, userName, password, database } = state.configuration;\n\n  if (!server) {\n    throw new Error('server missing from configuration.');\n  }\n\n  const config = {\n    authentication: {\n      options: { userName, password },\n      type: 'default',\n    },\n    server,\n    options: {\n      database,\n      encrypt: true,\n      rowCollectionOnRequestCompletion: true,\n    },\n  };\n\n  var connection = new Connection(config);\n\n  // Attempt to connect and execute queries if connection goes through\n  return new Promise((resolve, reject) => {\n    connection.on('connect', err => {\n      if (err) {\n        console.error(err.message);\n        reject(err);\n      } else {\n        resolve({ ...state, connection });\n      }\n    });\n    // Initialize connection\n    connection.connect();\n  });\n}\n\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for mssql.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n    queries: [],\n  };\n\n  return state => {\n    return commonExecute(\n      createConnection,\n      ...operations,\n      cleanupState\n    )({ ...initialState, ...state }).catch(e => {\n      console.error(e);\n      console.error('Unhandled error in the operations. Exiting process.');\n      process.exit(1);\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}\n"
  }
]