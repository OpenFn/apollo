[
  {
    "name": "execute",
    "implementation": "\n\nimport {\n  execute as commonExecute,\n  http,\n  expandReferences,\n} from '@openfn/language-common';\nimport pkg from '@openfn/language-http';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for commcare.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    state.configuration.authType = 'basic';\n    state.configuration.baseUrl = 'https://www.commcarehq.org/a/'.concat(\n      state.configuration.applicationName\n    );\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for commcare.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for commcare.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\n\n\nimport {\n  execute as commonExecute,\n  http,\n  expandReferences,\n} from '@openfn/language-common';\nimport pkg from '@openfn/language-http';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for commcare.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    state.configuration.authType = 'basic';\n    state.configuration.baseUrl = 'https://www.commcarehq.org/a/'.concat(\n      state.configuration.applicationName\n    );\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "searchGroup",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get groups from OpenSPP\n * @public\n * @example\n * searchGroup([[\"registrant_id\", \"=\", \"GRP_Q4VGGZPF\"]])\n * @function\n * @param {string} domain - searching domain\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function searchGroup(domain, offset = 0, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [\n      ['is_registrant', '=', true],\n      ['is_group', '=', true],\n    ];\n    const defaultOrder = 'id desc';\n    const defaultFields = ['name', 'registrant_id'];\n    let isDomain = true;\n    for (const element of domain) {\n      if (!Array.isArray(element)) {\n        isDomain = false;\n        break;\n      }\n    }\n    if (!isDomain) {\n      domain = [domain];\n    }\n    const finalDomain = [...domain, ...defaultDomain];\n    const options = {\n      limit: 100,\n      offset: offset,\n      order: defaultOrder,\n    };\n    try {\n      const groups = await sppConnector.searchRead(\n        'res.partner',\n        finalDomain,\n        defaultFields,\n        options\n      );\n      if (groups.length === 0) {\n        console.log(`\u26a0 Warning: Group with domain=${domain} not found!`);\n        return state;\n      }\n      console.log(`\u2139 Group with domain=${domain} found!`);\n      const nextState = composeNextState(state, groups);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}",
    "signature": "/**\n * get groups from OpenSPP\n * @public\n * @example\n * searchGroup([[\"registrant_id\", \"=\", \"GRP_Q4VGGZPF\"]])\n * @function\n * @param {string} domain - searching domain\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function searchGroup(domain: string, offset?: number, callback?: Function): Operation;",
    "test": "describe('searchGroup', () => {\n    it('search non-existing group from demo server', async () => {\n      let finalState = await searchGroup([['id', '=', -1]])(state);\n      expect(finalState.data).to.be.undefined;\n    });",
    "instruction": "Create an OpenFn function that searches groups from OpenSPP.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that searches groups from OpenSPP.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * get groups from OpenSPP\n * @public\n * @example\n * searchGroup([[\"registrant_id\", \"=\", \"GRP_Q4VGGZPF\"]])\n * @function\n * @param {string} domain - searching domain\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function searchGroup(domain: string, offset?: number, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * get groups from OpenSPP\n * @public\n * @example\n * searchGroup([[\"registrant_id\", \"=\", \"GRP_Q4VGGZPF\"]])\n * @function\n * @param {string} domain - searching domain\n * @param {number} [offset=0] - Offset searching\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function searchGroup(domain, offset = 0, callback=(s) => s) {\n  return async state => {\n    const defaultDomain = [\n      ['is_registrant', '=', true],\n      ['is_group', '=', true],\n    ];\n    const defaultOrder = 'id desc';\n    const defaultFields = ['name', 'registrant_id'];\n    let isDomain = true;\n    for (const element of domain) {\n      if (!Array.isArray(element)) {\n        isDomain = false;\n        break;\n      }\n    }\n    if (!isDomain) {\n      domain = [domain];\n    }\n    const finalDomain = [...domain, ...defaultDomain];\n    const options = {\n      limit: 100,\n      offset: offset,\n      order: defaultOrder,\n    };\n    try {\n      const groups = await sppConnector.searchRead(\n        'res.partner',\n        finalDomain,\n        defaultFields,\n        options\n      );\n      if (groups.length === 0) {\n        console.log(`\u26a0 Warning: Group with domain=${domain} not found!`);\n        return state;\n      }\n      console.log(`\u2139 Group with domain=${domain} found!`);\n      const nextState = composeNextState(state, groups);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  };\n}\n"
  },
  {
    "name": "createGroup",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * create new group for OpenSPP\n * @public\n * @example\n * createGroup({ name: \"Group 1\" })\n * @function\n * @param {object} data - registrant create data\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createGroup(data, callback=(s) => s) {\n  return async state => {\n    try {\n      if (!data.name) {\n        throw new Error(`\"name\" is a required parameter!`);\n      }\n      data.is_registrant = true;\n      data.is_group = true;\n      const groupId = await sppConnector.create('res.partner', data);\n      const res = await sppConnector.searchRead(\n        'res.partner',\n        [['id', '=', groupId]],\n        ['registrant_id'],\n        { limit: 1 }\n      );\n      const groupRegistrantId = res[0].registrant_id;\n      console.log(`\u2139 Group created with registrant ID: ${groupRegistrantId}`);\n      const nextState = composeNextState(state, groupRegistrantId);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  }\n}",
    "signature": "/**\n * create new group for OpenSPP\n * @public\n * @example\n * createGroup({ name: \"Group 1\" })\n * @function\n * @param {object} data - registrant create data\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createGroup(data: object, callback?: Function): Operation;",
    "instruction": "Create an OpenFn function that creates a new group for OpenSPP.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates a new group for OpenSPP.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * create new group for OpenSPP\n * @public\n * @example\n * createGroup({ name: \"Group 1\" })\n * @function\n * @param {object} data - registrant create data\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createGroup(data: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  dateFns,\n} from '@openfn/language-common';\n/**\n * create new group for OpenSPP\n * @public\n * @example\n * createGroup({ name: \"Group 1\" })\n * @function\n * @param {object} data - registrant create data\n * @param {function} callback - An optional callback function\n * @returns {Operation}\n */\nexport function createGroup(data, callback=(s) => s) {\n  return async state => {\n    try {\n      if (!data.name) {\n        throw new Error(`\"name\" is a required parameter!`);\n      }\n      data.is_registrant = true;\n      data.is_group = true;\n      const groupId = await sppConnector.create('res.partner', data);\n      const res = await sppConnector.searchRead(\n        'res.partner',\n        [['id', '=', groupId]],\n        ['registrant_id'],\n        { limit: 1 }\n      );\n      const groupRegistrantId = res[0].registrant_id;\n      console.log(`\u2139 Group created with registrant ID: ${groupRegistrantId}`);\n      const nextState = composeNextState(state, groupRegistrantId);\n      return callback(nextState);\n    } catch (err) {\n      console.log(`\u2717 Error: ${err}`);\n      return state;\n    }\n  }\n}\n"
  },
  {
    "name": "getJSON",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * Fetch a json file from an FTP server\n * @public\n * @example\n * getJSON(\n *   '/path/To/File',\n *   'utf8',\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {string} encoding - Character encoding for the json\n * @returns {Operation}\n */\nexport function getJSON(filePath, encoding) {\n  return state => {\n    let results = [];\n\n    return sftp\n      .get(filePath)\n      .then(chunk => {\n        results.push(chunk);\n      })\n      .then(() => {\n        console.debug('Receiving stream.\\n');\n        console.time('Stream finished');\n\n        return new Promise((resolve, reject) => {\n          const content = Buffer.concat(results).toString('utf8');\n          resolve(content.split('\\r\\n'));\n        }).then(json => {\n          const nextState = composeNextState(state, json);\n          return nextState;\n        });\n      })\n      .then(state => {\n        console.timeEnd('Stream finished');\n        return state;\n      });\n  };\n}",
    "signature": "/**\n * Fetch a json file from an FTP server\n * @public\n * @example\n * getJSON(\n *   '/path/To/File',\n *   'utf8',\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {string} encoding - Character encoding for the json\n * @returns {Operation}\n */\nexport function getJSON(filePath: string, encoding: string): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that fetches a json file from an FTP server.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that fetches a json file from an FTP server.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Fetch a json file from an FTP server\n * @public\n * @example\n * getJSON(\n *   '/path/To/File',\n *   'utf8',\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {string} encoding - Character encoding for the json\n * @returns {Operation}\n */\nexport function getJSON(filePath: string, encoding: string): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * Fetch a json file from an FTP server\n * @public\n * @example\n * getJSON(\n *   '/path/To/File',\n *   'utf8',\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {string} encoding - Character encoding for the json\n * @returns {Operation}\n */\nexport function getJSON(filePath, encoding) {\n  return state => {\n    let results = [];\n\n    return sftp\n      .get(filePath)\n      .then(chunk => {\n        results.push(chunk);\n      })\n      .then(() => {\n        console.debug('Receiving stream.\\n');\n        console.time('Stream finished');\n\n        return new Promise((resolve, reject) => {\n          const content = Buffer.concat(results).toString('utf8');\n          resolve(content.split('\\r\\n'));\n        }).then(json => {\n          const nextState = composeNextState(state, json);\n          return nextState;\n        });\n      })\n      .then(state => {\n        console.timeEnd('Stream finished');\n        return state;\n      });\n  };\n}\n"
  },
  {
    "name": "createPatient",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Creates a new patient\n * @example\n * createPatient({\n *   identifiers: [\n *     {\n *       identifier: '4023287',\n *       identifierType: '05a29f94-c0ed-11e2-94be-8c13b969e334',\n *       preferred: true,\n *     },\n *   ],\n *   person: {\n *     gender: 'M',\n *     age: 42,\n *     birthdate: '1970-01-01T00:00:00.000+0100',\n *     birthdateEstimated: false,\n *     names: [\n *       {\n *         givenName: 'Doe',\n *         familyName: 'John',\n *       },\n *     ],\n *   },\n * })\n * @function\n * @param {object} data - Object parameters of the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createPatient(data, callback = false) {\n  return state => {\n    const body = expandReferences(data)(state);\n    const { instanceUrl } = state.configuration;\n    const url = `${instanceUrl}/ws/rest/v1/patient`;\n\n    Log.info(`Creating a patient.`);\n\n    return agent\n      .post(url)\n      .type('json')\n      .send(body)\n      .then(response => {\n        Log.success(`Created a new patient.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Creates a new patient\n * @example\n * createPatient({\n *   identifiers: [\n *     {\n *       identifier: '4023287',\n *       identifierType: '05a29f94-c0ed-11e2-94be-8c13b969e334',\n *       preferred: true,\n *     },\n *   ],\n *   person: {\n *     gender: 'M',\n *     age: 42,\n *     birthdate: '1970-01-01T00:00:00.000+0100',\n *     birthdateEstimated: false,\n *     names: [\n *       {\n *         givenName: 'Doe',\n *         familyName: 'John',\n *       },\n *     ],\n *   },\n * })\n * @function\n * @param {object} data - Object parameters of the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createPatient(data: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that creates a new patient.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates a new patient.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Creates a new patient\n * @example\n * createPatient({\n *   identifiers: [\n *     {\n *       identifier: '4023287',\n *       identifierType: '05a29f94-c0ed-11e2-94be-8c13b969e334',\n *       preferred: true,\n *     },\n *   ],\n *   person: {\n *     gender: 'M',\n *     age: 42,\n *     birthdate: '1970-01-01T00:00:00.000+0100',\n *     birthdateEstimated: false,\n *     names: [\n *       {\n *         givenName: 'Doe',\n *         familyName: 'John',\n *       },\n *     ],\n *   },\n * })\n * @function\n * @param {object} data - Object parameters of the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createPatient(data: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Creates a new patient\n * @example\n * createPatient({\n *   identifiers: [\n *     {\n *       identifier: '4023287',\n *       identifierType: '05a29f94-c0ed-11e2-94be-8c13b969e334',\n *       preferred: true,\n *     },\n *   ],\n *   person: {\n *     gender: 'M',\n *     age: 42,\n *     birthdate: '1970-01-01T00:00:00.000+0100',\n *     birthdateEstimated: false,\n *     names: [\n *       {\n *         givenName: 'Doe',\n *         familyName: 'John',\n *       },\n *     ],\n *   },\n * })\n * @function\n * @param {object} data - Object parameters of the patient\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function createPatient(data, callback = false) {\n  return state => {\n    const body = expandReferences(data)(state);\n    const { instanceUrl } = state.configuration;\n    const url = `${instanceUrl}/ws/rest/v1/patient`;\n\n    Log.info(`Creating a patient.`);\n\n    return agent\n      .post(url)\n      .type('json')\n      .send(body)\n      .then(response => {\n        Log.success(`Created a new patient.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "get",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a get request to any OpenMRS endpoint\n * @example\n * get(\"patient\", {\n *   q: \"Patient\",\n *   limit: 1,\n * });\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - parameters for the request\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function get(path, query, callback = false) {\n  return state => {\n    const { instanceUrl } = state.configuration;\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedQuery = expandReferences(query)(state);\n    const urlPath = `${instanceUrl}/ws/rest/v1/${resolvedPath}`;\n\n    return agent\n      .get(urlPath)\n      .query(resolvedQuery)\n      .then(response => handleResponse(response, state, callback))\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Make a get request to any OpenMRS endpoint\n * @example\n * get(\"patient\", {\n *   q: \"Patient\",\n *   limit: 1,\n * });\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - parameters for the request\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function get(path: string, query: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a get request to any OpenMRS endpoint.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a get request to any OpenMRS endpoint.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a get request to any OpenMRS endpoint\n * @example\n * get(\"patient\", {\n *   q: \"Patient\",\n *   limit: 1,\n * });\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - parameters for the request\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function get(path: string, query: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a get request to any OpenMRS endpoint\n * @example\n * get(\"patient\", {\n *   q: \"Patient\",\n *   limit: 1,\n * });\n * @function\n * @param {string} path - Path to resource\n * @param {object} query - parameters for the request\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function get(path, query, callback = false) {\n  return state => {\n    const { instanceUrl } = state.configuration;\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedQuery = expandReferences(query)(state);\n    const urlPath = `${instanceUrl}/ws/rest/v1/${resolvedPath}`;\n\n    return agent\n      .get(urlPath)\n      .query(resolvedQuery)\n      .then(response => handleResponse(response, state, callback))\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "dataValue",
    "implementation": "\n/**\n * Picks out a single value from the source data object\u2014usually `state.data`.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * dataValue('key')\n * @function\n * @param {String} path - JSONPath referencing a point in `data`.\n * @returns {Operation}\n */\nexport function dataValue(path) {\n  return sourceValue(dataPath(path));\n}",
    "signature": "/**\n * Picks out a single value from the source data object\u2014usually `state.data`.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * dataValue('key')\n * @function\n * @param {String} path - JSONPath referencing a point in `data`.\n * @returns {Operation}\n */\nexport function dataValue(path: string): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that picks out a single value from the source data object using a",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that picks out a single value from the source data object using a\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Picks out a single value from the source data object\u2014usually `state.data`.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * dataValue('key')\n * @function\n * @param {String} path - JSONPath referencing a point in `data`.\n * @returns {Operation}\n */\nexport function dataValue(path: string): Operation;\n\n### Implementation:\n\n/**\n * Picks out a single value from the source data object\u2014usually `state.data`.\n * If a JSONPath returns more than one value for the reference, the first\n * item will be returned.\n * @public\n * @example\n * dataValue('key')\n * @function\n * @param {String} path - JSONPath referencing a point in `data`.\n * @returns {Operation}\n */\nexport function dataValue(path) {\n  return sourceValue(dataPath(path));\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  // TODO: Add session-based authentication here if your API needs it.\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "describe('execute', () => {\n  it('executes each operation in sequence', done => {\n    const state = {};\n    const operations = [\n      state => {\n        return { counter: 1 };\n      },\n      state => {\n        return { counter: 2 };\n      },\n      state => {\n        return { counter: 3 };\n      },\n    ];\n\n    execute(...operations)(state)\n      .then(finalState => {\n        expect(finalState).to.eql({ counter: 3 });",
    "instruction": "Create an OpenFn function that executes a sequence of operations.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute` to make working with this API easier.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  // TODO: Add session-based authentication here if your API needs it.\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for beyonic.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for beyonic.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for beyonic.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for beyonic.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({ ...initialState, ...state });\n  };\n}\n"
  },
  {
    "name": "getCSV",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * Get a CSV and return a JSON array of strings for each item separated by the delimiter\n * @public\n * @example\n * getCSV(\n *   '/some/path/to_file.csv',\n *   {delimiter: \";\", flatKeys: true }\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {{readStreamOptions: object,delimiter: string,noheader: boolean, quote: string, trim: boolean, flatKeys: boolean, output: string}} [parsingOptions] - Optional. `parsingOptions` Parsing options which can be passed to convert csv to json See more {@link https://github.com/Keyang/node-csvtojson#parameters on csvtojson docs}\n * @returns {Operation}\n */\nexport function getCSV(filePath, parsingOptions = {}) {\n  const defaultOptions = {\n    readStreamOptions: {\n      encoding: null,\n      autoClose: false,\n    },\n    columns: true,\n  };\n\n  return state => {\n    let results = [];\n\n    const { readStreamOptions, ...csvDefaultOptions } = defaultOptions;\n    const useParser = !isObjectEmpty(parsingOptions);\n\n    if (useParser) {\n      const stream = sftp.createReadStream(filePath, readStreamOptions);\n      return parseCsv(stream, { ...csvDefaultOptions, ...parsingOptions })(\n        state\n      );\n    } else {\n      return sftp\n        .get(filePath)\n        .then(chunk => {\n          results.push(chunk);\n        })\n        .then(() => {\n          console.debug('Parsing rows to JSON.\\n');\n          console.time('Stream finished');\n          return new Promise((resolve, reject) => {\n            const content = Buffer.concat(results).toString('utf8');\n            resolve(content.split('\\r\\n'));\n          }).then(json => {\n            const nextState = composeNextState(state, json);\n            return nextState;\n          });\n        })\n        .then(state => {\n          console.timeEnd('Stream finished');\n          return state;\n        });\n    }\n  };\n}",
    "signature": "/**\n * Get a CSV and return a JSON array of strings for each item separated by the delimiter\n * @public\n * @example\n * getCSV(\n *   '/some/path/to_file.csv',\n *   {delimiter: \";\", flatKeys: true }\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {{readStreamOptions: object,delimiter: string,noheader: boolean, quote: string, trim: boolean, flatKeys: boolean, output: string}} [parsingOptions] - Optional. `parsingOptions` Parsing options which can be passed to convert csv to json See more {@link https://github.com/Keyang/node-csvtojson#parameters on csvtojson docs}\n * @returns {Operation}\n */\nexport function getCSV(filePath: string, parsingOptions?: {\n    readStreamOptions: object;\n    delimiter: string;\n    noheader: boolean;\n    quote: string;\n    trim: boolean;\n    flatKeys: boolean;\n    output: string;\n}): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets a CSV and returns a JSON array of strings for each",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets a CSV and returns a JSON array of strings for each\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get a CSV and return a JSON array of strings for each item separated by the delimiter\n * @public\n * @example\n * getCSV(\n *   '/some/path/to_file.csv',\n *   {delimiter: \";\", flatKeys: true }\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {{readStreamOptions: object,delimiter: string,noheader: boolean, quote: string, trim: boolean, flatKeys: boolean, output: string}} [parsingOptions] - Optional. `parsingOptions` Parsing options which can be passed to convert csv to json See more {@link https://github.com/Keyang/node-csvtojson#parameters on csvtojson docs}\n * @returns {Operation}\n */\nexport function getCSV(filePath: string, parsingOptions?: {\n    readStreamOptions: object;\n    delimiter: string;\n    noheader: boolean;\n    quote: string;\n    trim: boolean;\n    flatKeys: boolean;\n    output: string;\n}): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * Get a CSV and return a JSON array of strings for each item separated by the delimiter\n * @public\n * @example\n * getCSV(\n *   '/some/path/to_file.csv',\n *   {delimiter: \";\", flatKeys: true }\n * );\n * @function\n * @param {string} filePath - Path to resource\n * @param {{readStreamOptions: object,delimiter: string,noheader: boolean, quote: string, trim: boolean, flatKeys: boolean, output: string}} [parsingOptions] - Optional. `parsingOptions` Parsing options which can be passed to convert csv to json See more {@link https://github.com/Keyang/node-csvtojson#parameters on csvtojson docs}\n * @returns {Operation}\n */\nexport function getCSV(filePath, parsingOptions = {}) {\n  const defaultOptions = {\n    readStreamOptions: {\n      encoding: null,\n      autoClose: false,\n    },\n    columns: true,\n  };\n\n  return state => {\n    let results = [];\n\n    const { readStreamOptions, ...csvDefaultOptions } = defaultOptions;\n    const useParser = !isObjectEmpty(parsingOptions);\n\n    if (useParser) {\n      const stream = sftp.createReadStream(filePath, readStreamOptions);\n      return parseCsv(stream, { ...csvDefaultOptions, ...parsingOptions })(\n        state\n      );\n    } else {\n      return sftp\n        .get(filePath)\n        .then(chunk => {\n          results.push(chunk);\n        })\n        .then(() => {\n          console.debug('Parsing rows to JSON.\\n');\n          console.time('Stream finished');\n          return new Promise((resolve, reject) => {\n            const content = Buffer.concat(results).toString('utf8');\n            resolve(content.split('\\r\\n'));\n          }).then(json => {\n            const nextState = composeNextState(state, json);\n            return nextState;\n          });\n        })\n        .then(state => {\n          console.timeEnd('Stream finished');\n          return state;\n        });\n    }\n  };\n}\n"
  },
  {
    "name": "listOutbreaks",
    "implementation": "\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch the list of outbreaks\n * @public\n * @example\n *  listOutbreaks(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listOutbreaks(callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/outbreaks',\n      params: {\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}",
    "signature": "/**\n * Fetch the list of outbreaks\n * @public\n * @example\n *  listOutbreaks(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listOutbreaks(callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that fetches the list of outbreaks.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that fetches the list of outbreaks.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Fetch the list of outbreaks\n * @public\n * @example\n *  listOutbreaks(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listOutbreaks(callback: Function): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Fetch the list of outbreaks\n * @public\n * @example\n *  listOutbreaks(state => {\n *    console.log(state.data);\n *    return state;\n *  });\n * @function\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function listOutbreaks(callback) {\n  return state => {\n    const { apiUrl, access_token } = state.configuration;\n\n    return axios({\n      method: 'GET',\n      baseURL: apiUrl,\n      url: '/outbreaks',\n      params: {\n        access_token,\n      },\n    })\n      .then(response => {\n        const nextState = composeNextState(state, response.data);\n        if (callback) return callback(nextState);\n        return nextState;\n      })\n      .catch(error => {\n        return error;\n      });\n  };\n}\n"
  },
  {
    "name": "create",
    "implementation": "import axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Migrates `apiUrl` to `hostUrl` if `hostUrl` is `blank`.\n * For `OpenFn.org` users with the `old-style configuration`.\n * @example\n * configMigrationHelper(state)\n * @function\n * @param {object} state - the runtime state\n * @returns {object}\n */\nfunction configMigrationHelper(state) {\n  const { hostUrl, apiUrl } = state.configuration;\n  if (!hostUrl) {\n    console.warn(\n      'DEPRECATION WARNING: Please migrate instance address from `apiUrl` to `hostUrl`.'\n    );\n    state.configuration.hostUrl = apiUrl;\n    return state;\n  }\n  return state;\n}\n\n// NOTE: In order to prevent unintended exposure of authentication information\n// in the logs, we make use of an axios interceptor.\naxios.interceptors.response.use(\n  function (response) {\n    const contentType = response.headers['content-type']?.split(';')[0];\n\n    const acceptHeaders = response.config.headers['Accept']\n      .split(';')[0]\n      .split(',');\n\n    if (response.config.method === 'get') {\n      if (indexOf(acceptHeaders, contentType) === -1) {\n        const newError = {\n          status: 404,\n          message: 'Unexpected content returned',\n          responseData: response.data,\n        };\n\n        console.error(newError.message);\n\n        return Promise.reject(newError);\n      }\n    }\n\n    if (\n      typeof response?.data === 'string' &&\n      contentType === CONTENT_TYPES?.json\n    ) {\n      try {\n        // eslint-disable-next-line no-param-reassign\n        response = { ...response, data: JSON.parse(response.data) };\n      } catch (error) {\n        console.warn('Non-JSON response detected, unable to parse.');\n      }\n    }\n    return response;\n  },\n  function (error) {\n    if (error.config?.auth) error.config.auth = '--REDACTED--';\n    if (error.config?.data) error.config.data = '--REDACTED--';\n\n    const details = error.response?.data;\n\n    console.error(error.message || \"That didn't work.\");\n\n    if (details) console.log(JSON.stringify(details, null, 2));\n\n    return Promise.reject({\n      request: error.config,\n      message: error.message,\n      response: error.response?.data,\n    });\n  }\n);\n\n/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `trackedEntityInstances`, `programs`, `events`, ...\n * @magic resourceType $.children.resourceTypes[*]\n * @param {Dhis2Data} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * create('programs', {\n *   name: 'name 20',\n *   shortName: 'n20',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * create('events', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'DiszpKrYNg8',\n *   status: 'COMPLETED',\n * });\n * @example <caption>a trackedEntityInstance</caption>\n * create('trackedEntityInstances', {\n *   orgUnit: 'TSyzvBiovKh',\n *   trackedEntityType: 'nEenWmSyUEp',\n *   attributes: [\n *     {\n *       attribute: 'w75KJ2mc4zz',\n *       value: 'Gigiwe',\n *     },\n *   ]\n * });\n * @example <caption>a dataSet</caption>\n * create('dataSets', { name: 'OpenFn Data Set', periodType: 'Monthly' });\n * @example <caption>a dataSetNotification</caption>\n * create('dataSetNotificationTemplates', {\n *   dataSetNotificationTrigger: 'DATA_SET_COMPLETION',\n *   notificationRecipient: 'ORGANISATION_UNIT_CONTACT',\n *   name: 'Notification',\n *   messageTemplate: 'Hello',\n *   deliveryChannels: ['SMS'],\n *   dataSets: [],\n * });\n * @example <caption>a dataElement</caption>\n * create('dataElements', {\n *   aggregationType: 'SUM',\n *   domainType: 'AGGREGATE',\n *   valueType: 'NUMBER',\n *   name: 'Paracetamol',\n *   shortName: 'Para',\n * });\n * @example <caption>a dataElementGroup</caption>\n * create('dataElementGroups', {\n *   name: 'Data Element Group 1',\n *   dataElements: [],\n * });\n * @example <caption>a dataElementGroupSet</caption>\n * create('dataElementGroupSets', {\n *   name: 'Data Element Group Set 4',\n *   dataDimension: true,\n *   shortName: 'DEGS4',\n *   dataElementGroups: [],\n * });\n * @example <caption>a dataValueSet</caption>\n * create('dataValueSets', {\n *   dataElement: 'f7n9E0hX8qk',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   value: '12',\n * });\n * @example <caption>a dataValueSet with related dataValues</caption>\n * create('dataValueSets', {\n *   dataSet: 'pBOMPrpg1QX',\n *   completeDate: '2014-02-03',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   dataValues: [\n *     {\n *       dataElement: 'f7n9E0hX8qk',\n *       value: '1',\n *     },\n *     {\n *       dataElement: 'Ix2HsbDMLea',\n *       value: '2',\n *     },\n *     {\n *       dataElement: 'eY5ehpbEsB7',\n *       value: '3',\n *     },\n *   ],\n * });\n * @example <caption>an enrollment</caption>\n * create('enrollments', {\n *   trackedEntityInstance: 'bmshzEacgxa',\n *   orgUnit: 'TSyzvBiovKh',\n *   program: 'gZBxv9Ujxg0',\n *   enrollmentDate: '2013-09-17',\n *   incidentDate: '2013-09-17',\n * });\n */\nexport function create(resourceType, data, options = {}, callback = false) {\n  return state => {\n    console.log(`Preparing create operation...`);\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedData = expandReferences(data)(state);\n    const resolvedOptions = expandReferences(options)(state);\n\n    const { params, requestConfig } = resolvedOptions;\n    const { configuration } = state;\n\n    return request(configuration, {\n      method: 'post',\n      url: generateUrl(configuration, resolvedOptions, resolvedResourceType),\n      params,\n      data: nestArray(resolvedData, resolvedResourceType),\n      ...requestConfig,\n    }).then(result => {\n      const details = `with response ${JSON.stringify(result.data, null, 2)}`;\n      console.log(`Created ${resolvedResourceType} ${details}`);\n\n      const { location } = result.headers;\n      if (location) console.log(`Record available @ ${location}`);\n\n      return handleResponse(result, state, callback);\n    });\n  };\n}",
    "signature": "/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `trackedEntityInstances`, `programs`, `events`, ...\n * @magic resourceType $.children.resourceTypes[*]\n * @param {Dhis2Data} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * create('programs', {\n *   name: 'name 20',\n *   shortName: 'n20',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * create('events', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'DiszpKrYNg8',\n *   status: 'COMPLETED',\n * });\n * @example <caption>a trackedEntityInstance</caption>\n * create('trackedEntityInstances', {\n *   orgUnit: 'TSyzvBiovKh',\n *   trackedEntityType: 'nEenWmSyUEp',\n *   attributes: [\n *     {\n *       attribute: 'w75KJ2mc4zz',\n *       value: 'Gigiwe',\n *     },\n *   ]\n * });\n * @example <caption>a dataSet</caption>\n * create('dataSets', { name: 'OpenFn Data Set', periodType: 'Monthly' });\n * @example <caption>a dataSetNotification</caption>\n * create('dataSetNotificationTemplates', {\n *   dataSetNotificationTrigger: 'DATA_SET_COMPLETION',\n *   notificationRecipient: 'ORGANISATION_UNIT_CONTACT',\n *   name: 'Notification',\n *   messageTemplate: 'Hello',\n *   deliveryChannels: ['SMS'],\n *   dataSets: [],\n * });\n * @example <caption>a dataElement</caption>\n * create('dataElements', {\n *   aggregationType: 'SUM',\n *   domainType: 'AGGREGATE',\n *   valueType: 'NUMBER',\n *   name: 'Paracetamol',\n *   shortName: 'Para',\n * });\n * @example <caption>a dataElementGroup</caption>\n * create('dataElementGroups', {\n *   name: 'Data Element Group 1',\n *   dataElements: [],\n * });\n * @example <caption>a dataElementGroupSet</caption>\n * create('dataElementGroupSets', {\n *   name: 'Data Element Group Set 4',\n *   dataDimension: true,\n *   shortName: 'DEGS4',\n *   dataElementGroups: [],\n * });\n * @example <caption>a dataValueSet</caption>\n * create('dataValueSets', {\n *   dataElement: 'f7n9E0hX8qk',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   value: '12',\n * });\n * @example <caption>a dataValueSet with related dataValues</caption>\n * create('dataValueSets', {\n *   dataSet: 'pBOMPrpg1QX',\n *   completeDate: '2014-02-03',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   dataValues: [\n *     {\n *       dataElement: 'f7n9E0hX8qk',\n *       value: '1',\n *     },\n *     {\n *       dataElement: 'Ix2HsbDMLea',\n *       value: '2',\n *     },\n *     {\n *       dataElement: 'eY5ehpbEsB7',\n *       value: '3',\n *     },\n *   ],\n * });\n * @example <caption>an enrollment</caption>\n * create('enrollments', {\n *   trackedEntityInstance: 'bmshzEacgxa',\n *   orgUnit: 'TSyzvBiovKh',\n *   program: 'gZBxv9Ujxg0',\n *   enrollmentDate: '2013-09-17',\n *   incidentDate: '2013-09-17',\n * });\n */\nexport function create(resourceType: string, data: Dhis2Data, options?: any, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that creates a record to/on/from resourceType.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that creates a record to/on/from resourceType.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `trackedEntityInstances`, `programs`, `events`, ...\n * @magic resourceType $.children.resourceTypes[*]\n * @param {Dhis2Data} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * create('programs', {\n *   name: 'name 20',\n *   shortName: 'n20',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * create('events', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'DiszpKrYNg8',\n *   status: 'COMPLETED',\n * });\n * @example <caption>a trackedEntityInstance</caption>\n * create('trackedEntityInstances', {\n *   orgUnit: 'TSyzvBiovKh',\n *   trackedEntityType: 'nEenWmSyUEp',\n *   attributes: [\n *     {\n *       attribute: 'w75KJ2mc4zz',\n *       value: 'Gigiwe',\n *     },\n *   ]\n * });\n * @example <caption>a dataSet</caption>\n * create('dataSets', { name: 'OpenFn Data Set', periodType: 'Monthly' });\n * @example <caption>a dataSetNotification</caption>\n * create('dataSetNotificationTemplates', {\n *   dataSetNotificationTrigger: 'DATA_SET_COMPLETION',\n *   notificationRecipient: 'ORGANISATION_UNIT_CONTACT',\n *   name: 'Notification',\n *   messageTemplate: 'Hello',\n *   deliveryChannels: ['SMS'],\n *   dataSets: [],\n * });\n * @example <caption>a dataElement</caption>\n * create('dataElements', {\n *   aggregationType: 'SUM',\n *   domainType: 'AGGREGATE',\n *   valueType: 'NUMBER',\n *   name: 'Paracetamol',\n *   shortName: 'Para',\n * });\n * @example <caption>a dataElementGroup</caption>\n * create('dataElementGroups', {\n *   name: 'Data Element Group 1',\n *   dataElements: [],\n * });\n * @example <caption>a dataElementGroupSet</caption>\n * create('dataElementGroupSets', {\n *   name: 'Data Element Group Set 4',\n *   dataDimension: true,\n *   shortName: 'DEGS4',\n *   dataElementGroups: [],\n * });\n * @example <caption>a dataValueSet</caption>\n * create('dataValueSets', {\n *   dataElement: 'f7n9E0hX8qk',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   value: '12',\n * });\n * @example <caption>a dataValueSet with related dataValues</caption>\n * create('dataValueSets', {\n *   dataSet: 'pBOMPrpg1QX',\n *   completeDate: '2014-02-03',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   dataValues: [\n *     {\n *       dataElement: 'f7n9E0hX8qk',\n *       value: '1',\n *     },\n *     {\n *       dataElement: 'Ix2HsbDMLea',\n *       value: '2',\n *     },\n *     {\n *       dataElement: 'eY5ehpbEsB7',\n *       value: '3',\n *     },\n *   ],\n * });\n * @example <caption>an enrollment</caption>\n * create('enrollments', {\n *   trackedEntityInstance: 'bmshzEacgxa',\n *   orgUnit: 'TSyzvBiovKh',\n *   program: 'gZBxv9Ujxg0',\n *   enrollmentDate: '2013-09-17',\n *   incidentDate: '2013-09-17',\n * });\n */\nexport function create(resourceType: string, data: Dhis2Data, options?: any, callback?: Function): Operation;\n\n### Implementation:\nimport axios from 'axios';\nimport _ from 'lodash';\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Migrates `apiUrl` to `hostUrl` if `hostUrl` is `blank`.\n * For `OpenFn.org` users with the `old-style configuration`.\n * @example\n * configMigrationHelper(state)\n * @function\n * @param {object} state - the runtime state\n * @returns {object}\n */\nfunction configMigrationHelper(state) {\n  const { hostUrl, apiUrl } = state.configuration;\n  if (!hostUrl) {\n    console.warn(\n      'DEPRECATION WARNING: Please migrate instance address from `apiUrl` to `hostUrl`.'\n    );\n    state.configuration.hostUrl = apiUrl;\n    return state;\n  }\n  return state;\n}\n\n// NOTE: In order to prevent unintended exposure of authentication information\n// in the logs, we make use of an axios interceptor.\naxios.interceptors.response.use(\n  function (response) {\n    const contentType = response.headers['content-type']?.split(';')[0];\n\n    const acceptHeaders = response.config.headers['Accept']\n      .split(';')[0]\n      .split(',');\n\n    if (response.config.method === 'get') {\n      if (indexOf(acceptHeaders, contentType) === -1) {\n        const newError = {\n          status: 404,\n          message: 'Unexpected content returned',\n          responseData: response.data,\n        };\n\n        console.error(newError.message);\n\n        return Promise.reject(newError);\n      }\n    }\n\n    if (\n      typeof response?.data === 'string' &&\n      contentType === CONTENT_TYPES?.json\n    ) {\n      try {\n        // eslint-disable-next-line no-param-reassign\n        response = { ...response, data: JSON.parse(response.data) };\n      } catch (error) {\n        console.warn('Non-JSON response detected, unable to parse.');\n      }\n    }\n    return response;\n  },\n  function (error) {\n    if (error.config?.auth) error.config.auth = '--REDACTED--';\n    if (error.config?.data) error.config.data = '--REDACTED--';\n\n    const details = error.response?.data;\n\n    console.error(error.message || \"That didn't work.\");\n\n    if (details) console.log(JSON.stringify(details, null, 2));\n\n    return Promise.reject({\n      request: error.config,\n      message: error.message,\n      response: error.response?.data,\n    });\n  }\n);\n\n/**\n * Create a record\n * @public\n * @function\n * @param {string} resourceType - Type of resource to create. E.g. `trackedEntityInstances`, `programs`, `events`, ...\n * @magic resourceType $.children.resourceTypes[*]\n * @param {Dhis2Data} data - Object which defines data that will be used to create a given instance of resource. To create a single instance of a resource, `data` must be a javascript object, and to create multiple instances of a resources, `data` must be an array of javascript objects.\n * @param {Object} [options] - Optional `options` to define URL parameters via params (E.g. `filter`, `dimension` and other import parameters), request config (E.g. `auth`) and the DHIS2 apiVersion.\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n * @example <caption>a program</caption>\n * create('programs', {\n *   name: 'name 20',\n *   shortName: 'n20',\n *   programType: 'WITHOUT_REGISTRATION',\n * });\n * @example <caption>an event</caption>\n * create('events', {\n *   program: 'eBAyeGv0exc',\n *   orgUnit: 'DiszpKrYNg8',\n *   status: 'COMPLETED',\n * });\n * @example <caption>a trackedEntityInstance</caption>\n * create('trackedEntityInstances', {\n *   orgUnit: 'TSyzvBiovKh',\n *   trackedEntityType: 'nEenWmSyUEp',\n *   attributes: [\n *     {\n *       attribute: 'w75KJ2mc4zz',\n *       value: 'Gigiwe',\n *     },\n *   ]\n * });\n * @example <caption>a dataSet</caption>\n * create('dataSets', { name: 'OpenFn Data Set', periodType: 'Monthly' });\n * @example <caption>a dataSetNotification</caption>\n * create('dataSetNotificationTemplates', {\n *   dataSetNotificationTrigger: 'DATA_SET_COMPLETION',\n *   notificationRecipient: 'ORGANISATION_UNIT_CONTACT',\n *   name: 'Notification',\n *   messageTemplate: 'Hello',\n *   deliveryChannels: ['SMS'],\n *   dataSets: [],\n * });\n * @example <caption>a dataElement</caption>\n * create('dataElements', {\n *   aggregationType: 'SUM',\n *   domainType: 'AGGREGATE',\n *   valueType: 'NUMBER',\n *   name: 'Paracetamol',\n *   shortName: 'Para',\n * });\n * @example <caption>a dataElementGroup</caption>\n * create('dataElementGroups', {\n *   name: 'Data Element Group 1',\n *   dataElements: [],\n * });\n * @example <caption>a dataElementGroupSet</caption>\n * create('dataElementGroupSets', {\n *   name: 'Data Element Group Set 4',\n *   dataDimension: true,\n *   shortName: 'DEGS4',\n *   dataElementGroups: [],\n * });\n * @example <caption>a dataValueSet</caption>\n * create('dataValueSets', {\n *   dataElement: 'f7n9E0hX8qk',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   value: '12',\n * });\n * @example <caption>a dataValueSet with related dataValues</caption>\n * create('dataValueSets', {\n *   dataSet: 'pBOMPrpg1QX',\n *   completeDate: '2014-02-03',\n *   period: '201401',\n *   orgUnit: 'DiszpKrYNg8',\n *   dataValues: [\n *     {\n *       dataElement: 'f7n9E0hX8qk',\n *       value: '1',\n *     },\n *     {\n *       dataElement: 'Ix2HsbDMLea',\n *       value: '2',\n *     },\n *     {\n *       dataElement: 'eY5ehpbEsB7',\n *       value: '3',\n *     },\n *   ],\n * });\n * @example <caption>an enrollment</caption>\n * create('enrollments', {\n *   trackedEntityInstance: 'bmshzEacgxa',\n *   orgUnit: 'TSyzvBiovKh',\n *   program: 'gZBxv9Ujxg0',\n *   enrollmentDate: '2013-09-17',\n *   incidentDate: '2013-09-17',\n * });\n */\nexport function create(resourceType, data, options = {}, callback = false) {\n  return state => {\n    console.log(`Preparing create operation...`);\n\n    const resolvedResourceType = expandReferences(resourceType)(state);\n    const resolvedData = expandReferences(data)(state);\n    const resolvedOptions = expandReferences(options)(state);\n\n    const { params, requestConfig } = resolvedOptions;\n    const { configuration } = state;\n\n    return request(configuration, {\n      method: 'post',\n      url: generateUrl(configuration, resolvedOptions, resolvedResourceType),\n      params,\n      data: nestArray(resolvedData, resolvedResourceType),\n      ...requestConfig,\n    }).then(result => {\n      const details = `with response ${JSON.stringify(result.data, null, 2)}`;\n      console.log(`Created ${resolvedResourceType} ${details}`);\n\n      const { location } = result.headers;\n      if (location) console.log(`Record available @ ${location}`);\n\n      return handleResponse(result, state, callback);\n    });\n  };\n}\n"
  },
  {
    "name": "request",
    "implementation": "import { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Make an HTTP request to Mailchimp API\n * @example <caption>Get list to all other resources available in the API</caption>\n * request('GET','/');\n * @example <caption>Create a new account export in your Mailchimp account</caption>\n * request('POST','/accounts-export', {include_stages:[]});\n * @function\n * @param {string} method - The HTTP method for the request (e.g., 'GET', 'POST', 'PUT', 'DELETE').\n * @param {string} path - The endpoint of the api to which the request should be made.\n * @param {Object} options - Additional options for the request (query, body only).\n * @param {function} [callback] - (Optional) callback function to handle the response.\n * @returns {Operation}\n */\nexport function request(method, path, options, callback) {\n  return async state => {\n    const apiVersion = '3.0';\n    const { apiKey, server } = state.configuration;\n\n    const [resolvedMethod, resolvedPath, resolvedOptions] = expandReferences(\n      state,\n      method,\n      path,\n      options\n    );\n    const { query, body } = { ...defaultOptions, ...resolvedOptions };\n\n    const apiToken = Buffer.from(`openfn:${apiKey}`, 'utf-8').toString(\n      'base64'\n    );\n\n    const headers = {\n      'Content-Type': 'application/json',\n      Authorization: `Basic ${apiToken}`,\n    };\n\n    const urlPath = `/${apiVersion}${resolvedPath}`;\n    const response = await state.apiClient.request({\n      method: resolvedMethod,\n      path: urlPath,\n      headers,\n      query,\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    console.log('Mailchimp says', response.statusCode);\n\n    const responseBody = await response.body.json();\n    assertOK(responseBody, `https://${server}.api.mailchimp.com${urlPath}`);\n\n    const nextState = {\n      ...state,\n      data: responseBody,\n      response: responseBody,\n    };\n    if (callback) return callback(nextState);\n\n    return nextState;\n  };\n}",
    "signature": "/**\n * Make an HTTP request to Mailchimp API\n * @example <caption>Get list to all other resources available in the API</caption>\n * request('GET','/');\n * @example <caption>Create a new account export in your Mailchimp account</caption>\n * request('POST','/accounts-export', {include_stages:[]});\n * @function\n * @param {string} method - The HTTP method for the request (e.g., 'GET', 'POST', 'PUT', 'DELETE').\n * @param {string} path - The endpoint of the api to which the request should be made.\n * @param {Object} options - Additional options for the request (query, body only).\n * @param {function} [callback] - (Optional) callback function to handle the response.\n * @returns {Operation}\n */\nexport function request(method: string, path: string, options: any, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes an HTTP request to the Mailchimp API.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes an HTTP request to the Mailchimp API.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make an HTTP request to Mailchimp API\n * @example <caption>Get list to all other resources available in the API</caption>\n * request('GET','/');\n * @example <caption>Create a new account export in your Mailchimp account</caption>\n * request('POST','/accounts-export', {include_stages:[]});\n * @function\n * @param {string} method - The HTTP method for the request (e.g., 'GET', 'POST', 'PUT', 'DELETE').\n * @param {string} path - The endpoint of the api to which the request should be made.\n * @param {Object} options - Additional options for the request (query, body only).\n * @param {function} [callback] - (Optional) callback function to handle the response.\n * @returns {Operation}\n */\nexport function request(method: string, path: string, options: any, callback?: Function): Operation;\n\n### Implementation:\nimport { execute as commonExecute } from '@openfn/language-common';\nimport md5 from 'md5';\nimport axios from 'axios';\nimport client from '@mailchimp/mailchimp_marketing';\nimport { expandReferences } from '@openfn/language-common/util';\n/**\n * Make an HTTP request to Mailchimp API\n * @example <caption>Get list to all other resources available in the API</caption>\n * request('GET','/');\n * @example <caption>Create a new account export in your Mailchimp account</caption>\n * request('POST','/accounts-export', {include_stages:[]});\n * @function\n * @param {string} method - The HTTP method for the request (e.g., 'GET', 'POST', 'PUT', 'DELETE').\n * @param {string} path - The endpoint of the api to which the request should be made.\n * @param {Object} options - Additional options for the request (query, body only).\n * @param {function} [callback] - (Optional) callback function to handle the response.\n * @returns {Operation}\n */\nexport function request(method, path, options, callback) {\n  return async state => {\n    const apiVersion = '3.0';\n    const { apiKey, server } = state.configuration;\n\n    const [resolvedMethod, resolvedPath, resolvedOptions] = expandReferences(\n      state,\n      method,\n      path,\n      options\n    );\n    const { query, body } = { ...defaultOptions, ...resolvedOptions };\n\n    const apiToken = Buffer.from(`openfn:${apiKey}`, 'utf-8').toString(\n      'base64'\n    );\n\n    const headers = {\n      'Content-Type': 'application/json',\n      Authorization: `Basic ${apiToken}`,\n    };\n\n    const urlPath = `/${apiVersion}${resolvedPath}`;\n    const response = await state.apiClient.request({\n      method: resolvedMethod,\n      path: urlPath,\n      headers,\n      query,\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    console.log('Mailchimp says', response.statusCode);\n\n    const responseBody = await response.body.json();\n    assertOK(responseBody, `https://${server}.api.mailchimp.com${urlPath}`);\n\n    const nextState = {\n      ...state,\n      data: responseBody,\n      response: responseBody,\n    };\n    if (callback) return callback(nextState);\n\n    return nextState;\n  };\n}\n"
  },
  {
    "name": "insertTable",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create a table in database when given an array of columns and a table_name.\n * @public\n * @example\n * insertTable('table_name', state => state.data.map(\n *   column => ({\n *     name: column.name,\n *     type: column.type,\n *     required: true, // optional\n *     unique: false, // optional - to be set to true for unique constraint\n *   })\n * ));\n * @function\n * @param {string} tableName - The name of the table to create\n * @param {array} columns - An array of form columns\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insertTable(tableName, columns, options, callback) {\n  return state => {\n    let { client } = state;\n    try {\n      const data = expandReferences(columns)(state);\n\n      return new Promise((resolve, reject) => {\n        if (!data || data.length === 0) {\n          console.log('No columns provided; skipping table creation.');\n          resolve(state);\n        }\n        const structureData = data\n          .map(\n            x =>\n              `${x.name} ${x.type} ${\n                x.hasOwnProperty('default')\n                  ? x.type.includes('varchar') ||\n                    x.type.includes('text') ||\n                    x.type.includes('BIT')\n                    ? `DEFAULT '${x.default}'`\n                    : `DEFAULT ${x.default}`\n                  : ''\n              } ${x.unique ? 'UNIQUE' : ''} ${\n                x.identity ? 'GENERATED BY DEFAULT AS IDENTITY' : ''\n              } ${x.required ? 'NOT NULL' : ''}`\n          )\n          .join(', ');\n\n        const query = `CREATE TABLE ${tableName} (\n        ${structureData}\n      );`;\n\n        console.log('Preparing to create table via:', query);\n        resolve(queryHandler(state, query, options, callback));\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}",
    "signature": "/**\n * Create a table in database when given an array of columns and a table_name.\n * @public\n * @example\n * insertTable('table_name', state => state.data.map(\n *   column => ({\n *     name: column.name,\n *     type: column.type,\n *     required: true, // optional\n *     unique: false, // optional - to be set to true for unique constraint\n *   })\n * ));\n * @function\n * @param {string} tableName - The name of the table to create\n * @param {array} columns - An array of form columns\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insertTable(tableName: string, columns: any[], options?: {\n    writeSql?: boolean;\n    execute?: boolean;\n}, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that inserts a table into a database from an array of columns and",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that inserts a table into a database from an array of columns and\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Create a table in database when given an array of columns and a table_name.\n * @public\n * @example\n * insertTable('table_name', state => state.data.map(\n *   column => ({\n *     name: column.name,\n *     type: column.type,\n *     required: true, // optional\n *     unique: false, // optional - to be set to true for unique constraint\n *   })\n * ));\n * @function\n * @param {string} tableName - The name of the table to create\n * @param {array} columns - An array of form columns\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insertTable(tableName: string, columns: any[], options?: {\n    writeSql?: boolean;\n    execute?: boolean;\n}, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Create a table in database when given an array of columns and a table_name.\n * @public\n * @example\n * insertTable('table_name', state => state.data.map(\n *   column => ({\n *     name: column.name,\n *     type: column.type,\n *     required: true, // optional\n *     unique: false, // optional - to be set to true for unique constraint\n *   })\n * ));\n * @function\n * @param {string} tableName - The name of the table to create\n * @param {array} columns - An array of form columns\n * @param {object} [options] - Optional options argument\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function insertTable(tableName, columns, options, callback) {\n  return state => {\n    let { client } = state;\n    try {\n      const data = expandReferences(columns)(state);\n\n      return new Promise((resolve, reject) => {\n        if (!data || data.length === 0) {\n          console.log('No columns provided; skipping table creation.');\n          resolve(state);\n        }\n        const structureData = data\n          .map(\n            x =>\n              `${x.name} ${x.type} ${\n                x.hasOwnProperty('default')\n                  ? x.type.includes('varchar') ||\n                    x.type.includes('text') ||\n                    x.type.includes('BIT')\n                    ? `DEFAULT '${x.default}'`\n                    : `DEFAULT ${x.default}`\n                  : ''\n              } ${x.unique ? 'UNIQUE' : ''} ${\n                x.identity ? 'GENERATED BY DEFAULT AS IDENTITY' : ''\n              } ${x.required ? 'NOT NULL' : ''}`\n          )\n          .join(', ');\n\n        const query = `CREATE TABLE ${tableName} (\n        ${structureData}\n      );`;\n\n        console.log('Preparing to create table via:', query);\n        resolve(queryHandler(state, query, options, callback));\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}\n"
  },
  {
    "name": "getLookups",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get lookups from Primero\n *\n * Use this function to get a paginated list of all lookups that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1)\n * @public\n * @example <caption>Get lookups from Primero with query parameters</caption>\n * getLookups({\n *   per: 10000,\n *   page: 5\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLookups(query, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const expandedQuery = expandReferences(query)(state);\n\n    const params = {\n      method: 'GET',\n      url: `${url}/api/v2/lookups`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs: expandedQuery,\n    };\n\n    return new Promise((resolve, reject) => {\n      request(params, async",
    "signature": "/**\n * Get lookups from Primero\n *\n * Use this function to get a paginated list of all lookups that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1)\n * @public\n * @example <caption>Get lookups from Primero with query parameters</caption>\n * getLookups({\n *   per: 10000,\n *   page: 5\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLookups(query: object, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets lookups from Primero.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets lookups from Primero.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Get lookups from Primero\n *\n * Use this function to get a paginated list of all lookups that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1)\n * @public\n * @example <caption>Get lookups from Primero with query parameters</caption>\n * getLookups({\n *   per: 10000,\n *   page: 5\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLookups(query: object, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Get lookups from Primero\n *\n * Use this function to get a paginated list of all lookups that are accessible to this user from Primero.\n * Note: You can specify a `per` value to fetch records per page(Defaults to 20).\n * Also you can specify `page` value to fetch pagination (Defaults to 1)\n * @public\n * @example <caption>Get lookups from Primero with query parameters</caption>\n * getLookups({\n *   per: 10000,\n *   page: 5\n * });\n * @function\n * @param {object} query - an object with a query param at minimum\n * @param {function} callback - (Optional) Callback function\n * @returns {Operation}\n */\nexport function getLookups(query, callback) {\n  return state => {\n    const { auth } = state;\n    const { url } = state.configuration;\n\n    const expandedQuery = expandReferences(query)(state);\n\n    const params = {\n      method: 'GET',\n      url: `${url}/api/v2/lookups`,\n      headers: {\n        Authorization: auth.token,\n        'Content-Type': 'application/json',\n      },\n      qs: expandedQuery,\n    };\n\n    return new Promise((resolve, reject) => {\n      request(params, async\n"
  },
  {
    "name": "upsertIf",
    "implementation": "\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Upsert if conditions are met.\n * @public\n * @example\n * upsertIf(true, 'obj_name', 'ext_id', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {boolean} logical - a logical statement that will be evaluated.\n * @param {String} sObject - API name of the sObject.\n * @param {String} externalId - ID.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function upsertIf(logical, sObject, externalId, attrs) {\n  return state => {\n    const resolvedLogical = expandReferences(logical)(state);\n\n    if (resolvedLogical) {\n      const { connection } = state;\n      const finalAttrs = expandReferences(attrs)(state);\n      console.info(\n        `Upserting ${sObject} with externalId`,\n        externalId,\n        ':',\n        finalAttrs\n      );\n\n      return connection\n        .upsert(sObject, finalAttrs, externalId)\n        .then(",
    "signature": "/**\n * Upsert if conditions are met.\n * @public\n * @example\n * upsertIf(true, 'obj_name', 'ext_id', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {boolean} logical - a logical statement that will be evaluated.\n * @param {String} sObject - API name of the sObject.\n * @param {String} externalId - ID.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function upsertIf(logical: boolean, sObject: string, externalId: string, attrs: any): Operation;",
    "test": "describe('upsertIf', () => {\n    it('upserts if a logical is true', done => {\n      const fakeConnection = {\n        upsert: function () {\n          return Promise.resolve({ Id: 10 });",
    "instruction": "Create an OpenFn function that upserts to/on/from an object with field",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts to/on/from an object with field\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Upsert if conditions are met.\n * @public\n * @example\n * upsertIf(true, 'obj_name', 'ext_id', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {boolean} logical - a logical statement that will be evaluated.\n * @param {String} sObject - API name of the sObject.\n * @param {String} externalId - ID.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function upsertIf(logical: boolean, sObject: string, externalId: string, attrs: any): Operation;\n\n### Implementation:\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  field,\n  chunk,\n} from '@openfn/language-common';\n\nimport { expandReferences as newExpandReferences } from '@openfn/language-common/util';\n/**\n * Upsert if conditions are met.\n * @public\n * @example\n * upsertIf(true, 'obj_name', 'ext_id', {\n *   attr1: \"foo\",\n *   attr2: \"bar\"\n * })\n * @function\n * @param {boolean} logical - a logical statement that will be evaluated.\n * @param {String} sObject - API name of the sObject.\n * @param {String} externalId - ID.\n * @param {Object} attrs - Field attributes for the new object.\n * @returns {Operation}\n */\nexport function upsertIf(logical, sObject, externalId, attrs) {\n  return state => {\n    const resolvedLogical = expandReferences(logical)(state);\n\n    if (resolvedLogical) {\n      const { connection } = state;\n      const finalAttrs = expandReferences(attrs)(state);\n      console.info(\n        `Upserting ${sObject} with externalId`,\n        externalId,\n        ':',\n        finalAttrs\n      );\n\n      return connection\n        .upsert(sObject, finalAttrs, externalId)\n        .then(\n"
  },
  {
    "name": "upsertIf",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert or update a record based on a logical condition using ON CONFLICT UPDATE\n * @public\n * @example\n * upsertIf(\n *   dataValue('name'),\n *   'users', // the DB table\n *   'ON CONSTRAINT users_pkey', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   { name: 'Elodie', id: 7 },\n *   { writeSql:true, execute: true }\n * )\n * @function\n * @param {string} logical - a data to check existing value for.\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertIf(logical, table, uuid, record, options, callback) {\n  return state => {\n    let { client } = state;\n\n    try {\n      const data = expandReferences(record)(state);\n      const logicalData = expandReferences(logical)(state);\n\n      return new Promise((resolve, reject) => {\n        if (!logicalData) {\n          console.log(`Skipping upsert for ${uuid}.`);\n          resolve(state);\n          return state;\n        }\n        const columns = Object.keys(data).sort();\n        const columnsList = columns.join(', ');\n        const values = columns.map(key => data[key]);\n        const conflict = uuid.split(' ').length > 1 ? uuid : `(${uuid})`;\n\n        const updateValues = columns\n          .map(key => {\n            return `${key}=excluded.${key}`;\n          })\n          .join(', ');\n\n        const insertValues = format(\n          `INSERT INTO ${table} (${columnsList}) VALUES (%L)`,\n          values\n        );\n\n        const query = handleValues(\n          `${insertValues}\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`,\n          handleOptions(options)\n        );\n\n        const safeQuery = `INSERT INTO ${table} (${columnsList}) VALUES [--REDACTED--]\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`;\n\n        const queryToLog = options && options.logValues ? query : safeQuery;\n        console.log('Preparing to upsert via:', queryToLog);\n        resolve(queryHandler(state, query, options, callback));\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}",
    "signature": "/**\n * Insert or update a record based on a logical condition using ON CONFLICT UPDATE\n * @public\n * @example\n * upsertIf(\n *   dataValue('name'),\n *   'users', // the DB table\n *   'ON CONSTRAINT users_pkey', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   { name: 'Elodie', id: 7 },\n *   { writeSql:true, execute: true }\n * )\n * @function\n * @param {string} logical - a data to check existing value for.\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertIf(logical: string, table: string, uuid: string, record: object, options?: {\n    setNull?: string;\n    writeSql?: boolean;\n    execute?: boolean;\n    logValues?: boolean;\n}, callback: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that upserts a record to/on/from the '",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that upserts a record to/on/from the '\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Insert or update a record based on a logical condition using ON CONFLICT UPDATE\n * @public\n * @example\n * upsertIf(\n *   dataValue('name'),\n *   'users', // the DB table\n *   'ON CONSTRAINT users_pkey', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   { name: 'Elodie', id: 7 },\n *   { writeSql:true, execute: true }\n * )\n * @function\n * @param {string} logical - a data to check existing value for.\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertIf(logical: string, table: string, uuid: string, record: object, options?: {\n    setNull?: string;\n    writeSql?: boolean;\n    execute?: boolean;\n    logValues?: boolean;\n}, callback: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Insert or update a record based on a logical condition using ON CONFLICT UPDATE\n * @public\n * @example\n * upsertIf(\n *   dataValue('name'),\n *   'users', // the DB table\n *   'ON CONSTRAINT users_pkey', // a DB column with a unique constraint OR a CONSTRAINT NAME\n *   { name: 'Elodie', id: 7 },\n *   { writeSql:true, execute: true }\n * )\n * @function\n * @param {string} logical - a data to check existing value for.\n * @param {string} table - The target table\n * @param {string} uuid - The uuid column to determine a matching/existing record\n * @param {object} record - Payload data for the record as a JS object or function\n * @param {object} [options] - Optional options argument\n * @param {string} [options.setNull] - A string value that specifies the behavior for inserting null values.\n * @param {boolean} [options.writeSql] - A boolean value that specifies whether to log the generated SQL statement. Defaults to false.\n * @param {boolean} [options.execute] - A boolean value that specifies whether to execute the generated SQL statement. Defaults to false.\n * @param {boolean} [options.logValues] - A boolean value that specifies whether to log the inserted values to the console. Defaults to false.\n * @param {function} callback - (Optional) callback function\n * @returns {Operation}\n */\nexport function upsertIf(logical, table, uuid, record, options, callback) {\n  return state => {\n    let { client } = state;\n\n    try {\n      const data = expandReferences(record)(state);\n      const logicalData = expandReferences(logical)(state);\n\n      return new Promise((resolve, reject) => {\n        if (!logicalData) {\n          console.log(`Skipping upsert for ${uuid}.`);\n          resolve(state);\n          return state;\n        }\n        const columns = Object.keys(data).sort();\n        const columnsList = columns.join(', ');\n        const values = columns.map(key => data[key]);\n        const conflict = uuid.split(' ').length > 1 ? uuid : `(${uuid})`;\n\n        const updateValues = columns\n          .map(key => {\n            return `${key}=excluded.${key}`;\n          })\n          .join(', ');\n\n        const insertValues = format(\n          `INSERT INTO ${table} (${columnsList}) VALUES (%L)`,\n          values\n        );\n\n        const query = handleValues(\n          `${insertValues}\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`,\n          handleOptions(options)\n        );\n\n        const safeQuery = `INSERT INTO ${table} (${columnsList}) VALUES [--REDACTED--]\n        ON CONFLICT ${conflict}\n        DO UPDATE SET ${updateValues};`;\n\n        const queryToLog = options && options.logValues ? query : safeQuery;\n        console.log('Preparing to upsert via:', queryToLog);\n        resolve(queryHandler(state, query, options, callback));\n      });\n    } catch (e) {\n      client.end();\n      throw e;\n    }\n  };\n}\n"
  },
  {
    "name": "addRow",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * To add a row data to a database table\n * @example\n * addRow(\n * 'testing_openfn',\n * 'Customers',\n * fields(field('Subject', dataValue('formId')), field('Status', 'Closed'))\n * );\n * @function\n * @param {string} db - Database\n * @param {string} table - Database table\n * @param {object} rowData - row data to be added into the database\n * @returns {Operation}\n */\nexport function addRow(db, table, rowData) {\n  return state => {\n    const action = 'ADDROW';\n    const body = expandReferences(rowData)(state);\n\n    const { account, authToken, apiVersion } = state.configuration;\n\n    const url = `https://reportsapi.zoho.com/api/`.concat(\n      account,\n      '/',\n      db,\n      '/',\n      table\n    );\n\n    console.log('POST URL:');\n    console.log(url);\n    console.log('POST Parameters:');\n    console.log(body);\n\n    return post({ url, body, authToken, apiVersion, action }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}",
    "signature": "/**\n * To add a row data to a database table\n * @example\n * addRow(\n * 'testing_openfn',\n * 'Customers',\n * fields(field('Subject', dataValue('formId')), field('Status', 'Closed'))\n * );\n * @function\n * @param {string} db - Database\n * @param {string} table - Database table\n * @param {object} rowData - row data to be added into the database\n * @returns {Operation}\n */\nexport function addRow(db: string, table: string, rowData: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that adds row data to a database table.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that adds row data to a database table.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * To add a row data to a database table\n * @example\n * addRow(\n * 'testing_openfn',\n * 'Customers',\n * fields(field('Subject', dataValue('formId')), field('Status', 'Closed'))\n * );\n * @function\n * @param {string} db - Database\n * @param {string} table - Database table\n * @param {object} rowData - row data to be added into the database\n * @returns {Operation}\n */\nexport function addRow(db: string, table: string, rowData: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * To add a row data to a database table\n * @example\n * addRow(\n * 'testing_openfn',\n * 'Customers',\n * fields(field('Subject', dataValue('formId')), field('Status', 'Closed'))\n * );\n * @function\n * @param {string} db - Database\n * @param {string} table - Database table\n * @param {object} rowData - row data to be added into the database\n * @returns {Operation}\n */\nexport function addRow(db, table, rowData) {\n  return state => {\n    const action = 'ADDROW';\n    const body = expandReferences(rowData)(state);\n\n    const { account, authToken, apiVersion } = state.configuration;\n\n    const url = `https://reportsapi.zoho.com/api/`.concat(\n      account,\n      '/',\n      db,\n      '/',\n      table\n    );\n\n    console.log('POST URL:');\n    console.log(url);\n    console.log('POST Parameters:');\n    console.log(body);\n\n    return post({ url, body, authToken, apiVersion, action }).then(result => {\n      console.log('Success:', result);\n      return { ...state, references: [result, ...state.references] };\n    });\n  };\n}\n"
  },
  {
    "name": "getEncounter",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Gets encounter matching a uuid\n * @example\n * getEncounter(\"123\")\n * @function\n * @param {object} uuid - A uuid for the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounter(uuid, callback = false) {\n  return state => {\n    Log.info(`Searching for encounter with uuid: ${uuid}`);\n    const { instanceUrl } = state.configuration;\n\n    const url = `${instanceUrl}/ws/rest/v1/encounter/${uuid}`;\n\n    return agent\n      .get(url)\n      .accept('json')\n      .then(response => {\n        Log.success(`Found an encounter.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Gets encounter matching a uuid\n * @example\n * getEncounter(\"123\")\n * @function\n * @param {object} uuid - A uuid for the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounter(uuid: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that gets an encounter matching a uuid.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that gets an encounter matching a uuid.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Gets encounter matching a uuid\n * @example\n * getEncounter(\"123\")\n * @function\n * @param {object} uuid - A uuid for the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounter(uuid: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Gets encounter matching a uuid\n * @example\n * getEncounter(\"123\")\n * @function\n * @param {object} uuid - A uuid for the encounter\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function getEncounter(uuid, callback = false) {\n  return state => {\n    Log.info(`Searching for encounter with uuid: ${uuid}`);\n    const { instanceUrl } = state.configuration;\n\n    const url = `${instanceUrl}/ws/rest/v1/encounter/${uuid}`;\n\n    return agent\n      .get(url)\n      .accept('json')\n      .then(response => {\n        Log.success(`Found an encounter.`);\n\n        return handleResponse(response, state, callback);\n      })\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "post",
    "implementation": "import {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a POST request\n * @public\n * @example\n *  post('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {operation}\n */\nexport function post(path, params, callback) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedParams = http.expandRequestReferences(params)(state);\n\n    const url = setUrl(state.configuration, resolvedPath);\n\n    const auth = setAuth(\n      state.configuration,\n      resolvedParams?.authentication ?? resolvedParams?.auth\n    );\n\n    const config = mapToAxiosConfig({ ...resolvedParams, url, auth });\n\n    return http\n      .post(config)(state)\n      .then(response => handleResponse(state, response))\n      .then(nextState => handleCallback(nextState, callback));\n  };\n}",
    "signature": "/**\n * Make a POST request\n * @public\n * @example\n *  post('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {operation}\n */\nexport function post(path: string, params: object, callback: Function): operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a POST request to '/myEndpoint'.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a POST request to '/myEndpoint'.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a POST request\n * @public\n * @example\n *  post('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {operation}\n */\nexport function post(path: string, params: object, callback: Function): operation;\n\n### Implementation:\nimport {\n  setAuth,\n  setUrl,\n  mapToAxiosConfig,\n  tryJson,\n  assembleError,\n} from './Utils';\n\nimport {\n  execute as commonExecute,\n  expandReferences,\n  composeNextState,\n  http,\n} from '@openfn/language-common';\n/**\n * Make a POST request\n * @public\n * @example\n *  post('/myEndpoint', {\n *    body: {'foo': 'bar'},\n *    headers: {'content-type': 'application/json'},\n *    authentication: {username: 'user', password: 'pass'}\n *  })\n * @function\n * @param {string} path - Path to resource\n * @param {object} params - Body, Query, Headers and Authentication parameters\n * @param {function} callback - (Optional) Callback function\n * @returns {operation}\n */\nexport function post(path, params, callback) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedParams = http.expandRequestReferences(params)(state);\n\n    const url = setUrl(state.configuration, resolvedPath);\n\n    const auth = setAuth(\n      state.configuration,\n      resolvedParams?.authentication ?? resolvedParams?.auth\n    );\n\n    const config = mapToAxiosConfig({ ...resolvedParams, url, auth });\n\n    return http\n      .post(config)(state)\n      .then(response => handleResponse(state, response))\n      .then(nextState => handleCallback(nextState, callback));\n  };\n}\n"
  },
  {
    "name": "list",
    "implementation": "import {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * List files present in a directory\n * @public\n * @example\n * <caption>basic files listing</caption>\n * list('/some/path/')\n * @example\n * <caption>list files with filters</caption>\n * list('/some/path/', file=> {\n *  return /foo.\\.txt/.test(file.name);\n * })\n * @example\n * <caption>list files with filters and use callback</caption>\n * list(\n *   \"/some/path/\",\n *   (file) => /foo.\\.txt/.test(file.name),\n *   (state) => {\n *     const latestFile = state.data.filter(\n *       (file) => file.modifyTime <= new Date()\n *     );\n *     return { ...state, latestFile };\n *   }\n * );\n * @function\n * @param {string} dirPath - Path to remote directory\n * @param {function} filter - a filter function used to select return entries\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function list(dirPath, filter, callback) {\n  return state => {\n    return sftp\n      .list(dirPath, filter)\n      .then(files => handleResponse(files, state, callback));\n  };\n}",
    "signature": "/**\n * List files present in a directory\n * @public\n * @example\n * <caption>basic files listing</caption>\n * list('/some/path/')\n * @example\n * <caption>list files with filters</caption>\n * list('/some/path/', file=> {\n *  return /foo.\\.txt/.test(file.name);\n * })\n * @example\n * <caption>list files with filters and use callback</caption>\n * list(\n *   \"/some/path/\",\n *   (file) => /foo.\\.txt/.test(file.name),\n *   (state) => {\n *     const latestFile = state.data.filter(\n *       (file) => file.modifyTime <= new Date()\n *     );\n *     return { ...state, latestFile };\n *   }\n * );\n * @function\n * @param {string} dirPath - Path to remote directory\n * @param {function} filter - a filter function used to select return entries\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function list(dirPath: string, filter: Function, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that lists files present in a directory.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that lists files present in a directory.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * List files present in a directory\n * @public\n * @example\n * <caption>basic files listing</caption>\n * list('/some/path/')\n * @example\n * <caption>list files with filters</caption>\n * list('/some/path/', file=> {\n *  return /foo.\\.txt/.test(file.name);\n * })\n * @example\n * <caption>list files with filters and use callback</caption>\n * list(\n *   \"/some/path/\",\n *   (file) => /foo.\\.txt/.test(file.name),\n *   (state) => {\n *     const latestFile = state.data.filter(\n *       (file) => file.modifyTime <= new Date()\n *     );\n *     return { ...state, latestFile };\n *   }\n * );\n * @function\n * @param {string} dirPath - Path to remote directory\n * @param {function} filter - a filter function used to select return entries\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function list(dirPath: string, filter: Function, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  composeNextState,\n  parseCsv,\n} from '@openfn/language-common';\n/**\n * List files present in a directory\n * @public\n * @example\n * <caption>basic files listing</caption>\n * list('/some/path/')\n * @example\n * <caption>list files with filters</caption>\n * list('/some/path/', file=> {\n *  return /foo.\\.txt/.test(file.name);\n * })\n * @example\n * <caption>list files with filters and use callback</caption>\n * list(\n *   \"/some/path/\",\n *   (file) => /foo.\\.txt/.test(file.name),\n *   (state) => {\n *     const latestFile = state.data.filter(\n *       (file) => file.modifyTime <= new Date()\n *     );\n *     return { ...state, latestFile };\n *   }\n * );\n * @function\n * @param {string} dirPath - Path to remote directory\n * @param {function} filter - a filter function used to select return entries\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function list(dirPath, filter, callback) {\n  return state => {\n    return sftp\n      .list(dirPath, filter)\n      .then(files => handleResponse(files, state, callback));\n  };\n}\n"
  },
  {
    "name": "fetchSurveyData",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a POST request to fetch Magpi data and POST it somewhere else\n * @public\n * @example\n * fetchSurveyData({\n *  \"surveyId\": \"37479\",\n *  \"afterDate\": \"2017-09-27\",\n *  \"postUrl\": \"https://www.openfn.org/inbox/your-inbox-url\"\n * })\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function fetchSurveyData(params) {\n  return state => {",
    "signature": "/**\n * Make a POST request to fetch Magpi data and POST it somewhere else\n * @public\n * @example\n * fetchSurveyData({\n *  \"surveyId\": \"37479\",\n *  \"afterDate\": \"2017-09-27\",\n *  \"postUrl\": \"https://www.openfn.org/inbox/your-inbox-url\"\n * })\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function fetchSurveyData(params: object): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a POST request to fetch Magpi data and POST it",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a POST request to fetch Magpi data and POST it\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a POST request to fetch Magpi data and POST it somewhere else\n * @public\n * @example\n * fetchSurveyData({\n *  \"surveyId\": \"37479\",\n *  \"afterDate\": \"2017-09-27\",\n *  \"postUrl\": \"https://www.openfn.org/inbox/your-inbox-url\"\n * })\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function fetchSurveyData(params: object): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a POST request to fetch Magpi data and POST it somewhere else\n * @public\n * @example\n * fetchSurveyData({\n *  \"surveyId\": \"37479\",\n *  \"afterDate\": \"2017-09-27\",\n *  \"postUrl\": \"https://www.openfn.org/inbox/your-inbox-url\"\n * })\n * @function\n * @param {object} params - data to make the fetch\n * @returns {Operation}\n */\nexport function fetchSurveyData(params) {\n  return state => {\n"
  },
  {
    "name": "post",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a post request to any OpenMRS endpoint\n * @example\n * post(\n *   \"idgen/identifiersource/8549f706-7e85-4c1d-9424-217d50a2988b/identifier\",\n *   {}\n * );\n * @function\n * @param {string} path - Path to resource\n * @param {object} data - Object which defines data that will be used to create a given instance of resource\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function post(path, data, callback = false) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedData = expandReferences(data)(state);\n    const { instanceUrl } = state.configuration;\n\n    const urlPath = `${instanceUrl}/ws/rest/v1/${resolvedPath}`;\n\n    return agent\n      .post(urlPath)\n      .type('json')\n      .send(resolvedData)\n      .then(response => handleResponse(response, state, callback))\n      .catch(handleError);\n  };\n}",
    "signature": "/**\n * Make a post request to any OpenMRS endpoint\n * @example\n * post(\n *   \"idgen/identifiersource/8549f706-7e85-4c1d-9424-217d50a2988b/identifier\",\n *   {}\n * );\n * @function\n * @param {string} path - Path to resource\n * @param {object} data - Object which defines data that will be used to create a given instance of resource\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function post(path: string, data: object, callback?: Function): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that makes a post request to an OpenMRS endpoint.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that makes a post request to an OpenMRS endpoint.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Make a post request to any OpenMRS endpoint\n * @example\n * post(\n *   \"idgen/identifiersource/8549f706-7e85-4c1d-9424-217d50a2988b/identifier\",\n *   {}\n * );\n * @function\n * @param {string} path - Path to resource\n * @param {object} data - Object which defines data that will be used to create a given instance of resource\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function post(path: string, data: object, callback?: Function): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Make a post request to any OpenMRS endpoint\n * @example\n * post(\n *   \"idgen/identifiersource/8549f706-7e85-4c1d-9424-217d50a2988b/identifier\",\n *   {}\n * );\n * @function\n * @param {string} path - Path to resource\n * @param {object} data - Object which defines data that will be used to create a given instance of resource\n * @param {function} [callback] - Optional callback to handle the response\n * @returns {Operation}\n */\nexport function post(path, data, callback = false) {\n  return state => {\n    const resolvedPath = expandReferences(path)(state);\n    const resolvedData = expandReferences(data)(state);\n    const { instanceUrl } = state.configuration;\n\n    const urlPath = `${instanceUrl}/ws/rest/v1/${resolvedPath}`;\n\n    return agent\n      .post(urlPath)\n      .type('json')\n      .send(resolvedData)\n      .then(response => handleResponse(response, state, callback))\n      .catch(handleError);\n  };\n}\n"
  },
  {
    "name": "execute",
    "implementation": "import {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}",
    "signature": "/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;",
    "test": "",
    "instruction": "Create an OpenFn function that executes a sequence of operations on state.",
    "prompt": "\nGiven the following OpenFn instruction:\n\n### Instruction:\nCreate an OpenFn function that executes a sequence of operations on state.\n\nProvide the implementation code that corresponds to the following OpenFn signature. Ensure that all imports are from '@openfn/':\n\n### Signature:\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations: Operations): Operation;\n\n### Implementation:\nimport {\n  execute as commonExecute,\n  expandReferences,\n} from '@openfn/language-common';\n/**\n * Execute a sequence of operations.\n * Wraps `language-common/execute`, and prepends initial state for http.\n * @example\n * execute(\n *   create('foo'),\n *   delete('bar')\n * )(state)\n * @private\n * @param {Operations} operations - Operations to be performed.\n * @returns {Operation}\n */\nexport function execute(...operations) {\n  const initialState = {\n    references: [],\n    data: null,\n  };\n\n  return state => {\n    return commonExecute(...operations)({\n      ...initialState,\n      ...state,\n    });\n  };\n}\n"
  }
]