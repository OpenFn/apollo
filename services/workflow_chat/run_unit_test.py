import unittest
import subprocess
import sys
from pathlib import Path
import json

class WorkflowChatIntegrationTest(unittest.TestCase):
    pass  # Test methods will be added dynamically

def read_tests_config():
    config_file = Path(__file__).parent / "tests_to_run.txt"
    tests = []
    if not config_file.exists():
        raise FileNotFoundError(f"{config_file} not found")
    with open(config_file, 'r') as f:
        for line_num, line in enumerate(f, 1):
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            parts = line.split()
            if len(parts) < 2:
                print(f"Warning: Invalid line {line_num} in tests_to_run.txt: {line}")
                continue
            yaml_file = parts[0]
            history_file = parts[1]
            error_message = ' '.join(parts[2:]) if len(parts) > 2 else None
            tests.append({
                'yaml_file': yaml_file,
                'history_file': history_file,
                'error_message': error_message,
                'line_num': line_num
            })
    return tests

def print_json_output(test_config):
    """Print the JSON output files generated by the test."""
    yaml_file = test_config['yaml_file']
    history_file = test_config['history_file']
    error_message = test_config['error_message']
    yaml_name = Path(yaml_file).stem
    history_name = Path(history_file).stem
    base_filename = f"{yaml_name}_{history_name}"
    if error_message:
        base_filename += "_errors"
    output_dir = Path(__file__).parent / "test_outputs"
    response_file = output_dir / f"{base_filename}_response.json"
    if response_file.exists():
        try:
            with open(response_file, 'r') as f:
                response_data = json.load(f)
            print("\nüìù WORKFLOW_CHAT RESPONSE:")
            print(json.dumps(response_data, indent=2))
        except Exception as e:
            print(f"\n‚ùå Could not read response file: {e}")
    yaml_json_file = output_dir / f"{base_filename}_response_yaml.json"
    yaml_yaml_file = output_dir / f"{base_filename}_response_yaml.yaml"
    if yaml_json_file.exists():
        try:
            with open(yaml_json_file, 'r') as f:
                yaml_data = json.load(f)
            if yaml_data and isinstance(yaml_data, str) and yaml_data.strip():
                print("\nüìÑ GENERATED YAML:")
                print(yaml_data)
            elif yaml_data and yaml_data is not None:
                print("\nüìÑ GENERATED YAML:")
                print(json.dumps(yaml_data, indent=2))
            else:
                print("\nüìÑ GENERATED YAML: None (workflow_chat provided only text description)")
        except Exception as e:
            print(f"\n‚ùå Could not read YAML JSON file: {e}")
    elif yaml_yaml_file.exists():
        try:
            with open(yaml_yaml_file, 'r') as f:
                yaml_content = f.read()
            if yaml_content.strip():
                print("\nüìÑ GENERATED YAML:")
                print(yaml_content)
            else:
                print("\nüìÑ GENERATED YAML: Empty file")
        except Exception as e:
            print(f"\n‚ùå Could not read YAML file: {e}")
    else:
        print("\nüìÑ GENERATED YAML: File not found")
    usage_file = output_dir / f"{base_filename}_usage.json"
    if usage_file.exists():
        try:
            with open(usage_file, 'r') as f:
                usage_data = json.load(f)
            print("\nüìä TOKEN USAGE:")
            print(json.dumps(usage_data, indent=2))
        except Exception as e:
            print(f"\n‚ùå Could not read usage file: {e}")

def make_test_func(test_config):
    def test_func(self):
        base_dir = Path(__file__).parent
        yaml_path = base_dir / test_config['yaml_file']
        history_path = base_dir / test_config['history_file']
        error_message = test_config['error_message']
        cmd = [
            sys.executable,
            str(base_dir / "run_test.py"),
            "--existing_yaml", str(yaml_path),
            "--history", str(history_path)
        ]
        if error_message:
            cmd.extend(["--errors", error_message])
        result = subprocess.run(cmd, cwd=base_dir, capture_output=True, text=True)
        print(f"\n{'='*40}\nTest: {yaml_path.name} + {history_path.name}")
        if error_message:
            print(f"  With errors: {error_message}")
        print(f"  Return code: {result.returncode}")
        print(f"  STDOUT:\n{result.stdout}")
        print(f"  STDERR:\n{result.stderr}")
        print_json_output(test_config)
        self.assertEqual(result.returncode, 0, f"run_test.py failed for {yaml_path} + {history_path}\nSTDERR:\n{result.stderr}")
    return test_func

# Dynamically add test methods at module load time
for idx, test_config in enumerate(read_tests_config()):
    test_name = f"test_case_{idx+1:02d}_line_{test_config['line_num']}"
    setattr(WorkflowChatIntegrationTest, test_name, make_test_func(test_config))

if __name__ == "__main__":
    unittest.main() 