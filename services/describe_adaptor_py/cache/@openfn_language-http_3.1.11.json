{"@openfn/language-common": {"name": "@openfn/language-common", "description": "export interface AxiosTransformer {\n  (data: any, headers?: any): any;\n}\n\nexport interface AxiosAdapter {\n  (config: AxiosRequestConfig): AxiosPromise<any>;\n}\n\nexport interface AxiosBasicCredentials {\n  username: string;\n  password: string;\n}\n\nexport interface AxiosProxyConfig {\n  host: string;\n  port: number;\n  auth?: {\n    username: string;\n    password:string;\n  };\n  protocol?: string;\n}\n\nexport type Method =\n  | 'get' | 'GET'\n  | 'delete' | 'DELETE'\n  | 'head' | 'HEAD'\n  | 'options' | 'OPTIONS'\n  | 'post' | 'POST'\n  | 'put' | 'PUT'\n  | 'patch' | 'PATCH'\n  | 'purge' | 'PURGE'\n  | 'link' | 'LINK'\n  | 'unlink' | 'UNLINK'\n\nexport type ResponseType =\n  | 'arraybuffer'\n  | 'blob'\n  | 'document'\n  | 'json'\n  | 'text'\n  | 'stream'\n\nexport interface AxiosRequestConfig {\n  url?: string;\n  method?: Method;\n  baseURL?: string;\n  transformRequest?: AxiosTransformer | AxiosTransformer[];\n  transformResponse?: AxiosTransformer | AxiosTransformer[];\n  headers?: any;\n  params?: any;\n  paramsSerializer?: (params: any) => string;\n  data?: any;\n  timeout?: number;\n  timeoutErrorMessage?: string;\n  withCredentials?: boolean;\n  adapter?: AxiosAdapter;\n  auth?: AxiosBasicCredentials;\n  responseType?: ResponseType;\n  xsrfCookieName?: string;\n  xsrfHeaderName?: string;\n  onUploadProgress?: (progressEvent: any) => void;\n  onDownloadProgress?: (progressEvent: any) => void;\n  maxContentLength?: number;\n  validateStatus?: ((status: number) => boolean) | null;\n  maxBodyLength?: number;\n  maxRedirects?: number;\n  socketPath?: string | null;\n  httpAgent?: any;\n  httpsAgent?: any;\n  proxy?: AxiosProxyConfig | false;\n  cancelToken?: CancelToken;\n  decompress?: boolean;\n}\n\nexport interface AxiosResponse<T = any>  {\n  data: T;\n  status: number;\n  statusText: string;\n  headers: any;\n  config: AxiosRequestConfig;\n  request?: any;\n}\n\nexport interface AxiosError<T = any> extends Error {\n  config: AxiosRequestConfig;\n  code?: string;\n  request?: any;\n  response?: AxiosResponse<T>;\n  isAxiosError: boolean;\n  toJSON: () => object;\n}\n\nexport interface AxiosPromise<T = any> extends Promise<AxiosResponse<T>> {\n}\n\nexport interface CancelStatic {\n  new (message?: string): Cancel;\n}\n\nexport interface Cancel {\n  message: string;\n}\n\nexport interface Canceler {\n  (message?: string): void;\n}\n\nexport interface CancelTokenStatic {\n  new (executor: (cancel: Canceler) => void): CancelToken;\n  source(): CancelTokenSource;\n}\n\nexport interface CancelToken {\n  promise: Promise<Cancel>;\n  reason?: Cancel;\n  throwIfRequested(): void;\n}\n\nexport interface CancelTokenSource {\n  token: CancelToken;\n  cancel: Canceler;\n}\n\nexport interface AxiosInterceptorManager<V> {\n  use(onFulfilled?: (value: V) => V | Promise<V>, onRejected?: (error: any) => any): number;\n  eject(id: number): void;\n}\n\nexport interface AxiosInstance {\n  (config: AxiosRequestConfig): AxiosPromise;\n  (url: string, config?: AxiosRequestConfig): AxiosPromise;\n  defaults: AxiosRequestConfig;\n  interceptors: {\n    request: AxiosInterceptorManager<AxiosRequestConfig>;\n    response: AxiosInterceptorManager<AxiosResponse>;\n  };\n  getUri(config?: AxiosRequestConfig): string;\n  request<T = any, R = AxiosResponse<T>> (config: AxiosRequestConfig): Promise<R>;\n  get<T = any, R = AxiosResponse<T>>(url: string, config?: AxiosRequestConfig): Promise<R>;\n  delete<T = any, R = AxiosResponse<T>>(url: string, config?: AxiosRequestConfig): Promise<R>;\n  head<T = any, R = AxiosResponse<T>>(url: string, config?: AxiosRequestConfig): Promise<R>;\n  options<T = any, R = AxiosResponse<T>>(url: string, config?: AxiosRequestConfig): Promise<R>;\n  post<T = any, R = AxiosResponse<T>>(url: string, data?: any, config?: AxiosRequestConfig): Promise<R>;\n  put<T = any, R = AxiosResponse<T>>(url: string, data?: any, config?: AxiosRequestConfig): Promise<R>;\n  patch<T = any, R = AxiosResponse<T>>(url: string, data?: any, config?: AxiosRequestConfig): Promise<R>;\n}\n\nexport interface AxiosStatic extends AxiosInstance {\n  create(config?: AxiosRequestConfig): AxiosInstance;\n  Cancel: CancelStatic;\n  CancelToken: CancelTokenStatic;\n  isCancel(value: any): boolean;\n  all<T>(values: (T | Promise<T>)[]): Promise<T[]>;\n  spread<T, R>(callback: (...args: T[]) => R): (array: T[]) => R;\n  isAxiosError(payload: any): payload is AxiosError;\n}\n\ndeclare const axios: AxiosStatic;\n\nexport default axios;\n\n\n/**\n * Declaration for https://github.com/s3u/JSONPath\n */\ndeclare module 'jsonpath-plus' {\n  type JSONPathCallback = (\n      payload: any, payloadType: any, fullPayload: any\n  ) => any\n\n  type JSONPathOtherTypeCallback = (...args: any[]) => void\n\n  interface JSONPathOptions {\n    /**\n     * The JSONPath expression as a (normalized or unnormalized) string or\n     *   array.\n     */\n    path: string | any[]\n    /**\n     * The JSON object to evaluate (whether of null, boolean, number,\n     *   string, object, or array type).\n     */\n    json: null | boolean | number | string | object | any[]\n    /**\n     * If this is supplied as false, one may call the evaluate method\n     *  manually.\n     *\n     * @default true\n     */\n    autostart?: true | boolean\n    /**\n     * Whether the returned array of results will be flattened to a\n     *   single dimension array.\n     *\n     * @default false\n     */\n    flatten?: false | boolean\n    /**\n     * Can be case-insensitive form of \"value\", \"path\", \"pointer\", \"parent\",\n     *   or \"parentProperty\" to determine respectively whether to return\n     *   results as the values of the found items, as their absolute paths,\n     *   as JSON Pointers to the absolute paths, as their parent objects,\n     *   or as their parent's property name.\n     *\n     * If set to \"all\", all of these types will be returned on an object with\n     *   the type as key name.\n     *\n     * @default 'value'\n     */\n    resultType?:\n        'value' | 'path' | 'pointer' | 'parent' | 'parentProperty' | 'all'\n\n    /**\n     * Key-value map of variables to be available to code evaluations such\n     *   as filtering expressions.\n     * (Note that the current path and value will also be available to those\n     *   expressions; see the Syntax section for details.)\n     */\n    sandbox?: Map<string, any>\n    /**\n     * Whether or not to wrap the results in an array.\n     *\n     * If wrap is set to false, and no results are found, undefined will be\n     *   returned (as opposed to an empty array when wrap is set to true).\n     *\n     * If wrap is set to false and a single non-array result is found, that\n     *   result will be the only item returned (not within an array).\n     *\n     * An array will still be returned if multiple results are found, however.\n     * To avoid ambiguities (in the case where it is necessary to distinguish\n     * between a result which is a failure and one which is an empty array),\n     * it is recommended to switch the default to false.\n     *\n     * @default true\n     */\n    wrap?: true | boolean\n    /**\n     * Although JavaScript evaluation expressions are allowed by default,\n     * for security reasons (if one is operating on untrusted user input,\n     * for example), one may wish to set this option to true to throw\n     * exceptions when these expressions are attempted.\n     *\n     * @default false\n     */\n    preventEval?: false | boolean\n    /**\n     * In the event that a query could be made to return the root node,\n     * this allows the parent of that root node to be returned within results.\n     *\n     * @default null\n     */\n    parent?: null | any\n    /**\n     * In the event that a query could be made to return the root node,\n     * this allows the parentProperty of that root node to be returned within\n     * results.\n     *\n     * @default null\n     */\n    parentProperty?: null | any\n    /**\n     * If supplied, a callback will be called immediately upon retrieval of\n     * an end point value.\n     *\n     * The three arguments supplied will be the value of the payload\n     * (according to `resultType`), the type of the payload (whether it is\n     * a normal \"value\" or a \"property\" name), and a full payload object\n     * (with all `resultType`s).\n     *\n     * @default undefined\n     */\n    callback?: undefined | JSONPathCallback\n    /**\n     * In the current absence of JSON Schema support,\n     * one can determine types beyond the built-in types by adding the\n     * perator `@other()` at the end of one's query.\n     *\n     * If such a path is encountered, the `otherTypeCallback` will be invoked\n     * with the value of the item, its path, its parent, and its parent's\n     * property name, and it should return a boolean indicating whether the\n     * supplied value belongs to the \"other\" type or not (or it may handle\n     * transformations and return false).\n     *\n     * @default undefined\n     *   <A function that throws an error when `@other()` is encountered>\n     */\n    otherTypeCallback?: undefined | JSONPathOtherTypeCallback\n  }\n\n  interface JSONPathOptionsAutoStart extends JSONPathOptions {\n    autostart: false\n  }\n\n  interface JSONPathCallable {\n    <T = any>(options: JSONPathOptionsAutoStart): JSONPathClass\n    <T = any>(options: JSONPathOptions): T\n\n    <T = any>(\n        path: JSONPathOptions['path'],\n        json: JSONPathOptions['json'],\n        callback: JSONPathOptions['callback'],\n        otherTypeCallback: JSONPathOptions['otherTypeCallback']\n    ): T\n  }\n\n  class JSONPathClass {\n    /**\n     * Exposes the cache object for those who wish to preserve and reuse\n     *   it for optimization purposes.\n     */\n    static cache: any\n\n    /**\n     * Accepts a normalized or unnormalized path as string and\n     * converts to an array: for example,\n     * `['$', 'aProperty', 'anotherProperty']`.\n     */\n    static toPathArray(path: string): string[]\n\n    /**\n     * Accepts a path array and converts to a normalized path string.\n     * The string will be in a form like:\n     *   `$['aProperty']['anotherProperty][0]`.\n     * The JSONPath terminal constructions `~` and `^` and type operators\n     *   like `@string()` are silently stripped.\n     */\n    static toPathString(path: string[]): string\n\n    /**\n     * Accepts a path array and converts to a JSON Pointer.\n     *\n     * The string will be in a form like: `/aProperty/anotherProperty/0`\n     * (with any `~` and `/` internal characters escaped as per the JSON\n     * Pointer spec).\n     *\n     * The JSONPath terminal constructions `~` and `^` and type operators\n     *   like `@string()` are silently stripped.\n     */\n    static toPointer(path: string[]): any\n\n    evaluate(\n        path: JSONPathOptions['path'],\n        json: JSONPathOptions['json'],\n        callback: JSONPathOptions['callback'],\n        otherTypeCallback: JSONPathOptions['otherTypeCallback']\n    ): any\n    evaluate(options: {\n        path: JSONPathOptions['path'],\n        json: JSONPathOptions['json'],\n        callback: JSONPathOptions['callback'],\n        otherTypeCallback: JSONPathOptions['otherTypeCallback']\n    }): any\n  }\n\n  type JSONPathType = JSONPathCallable & JSONPathClass\n\n  export const JSONPath: JSONPathType\n}\n"}, "@openfn/language-http": {"name": "@openfn/language-http", "description": "export interface AxiosTransformer {\n  (data: any, headers?: any): any;\n}\n\nexport interface AxiosAdapter {\n  (config: AxiosRequestConfig): AxiosPromise<any>;\n}\n\nexport interface AxiosBasicCredentials {\n  username: string;\n  password: string;\n}\n\nexport interface AxiosProxyConfig {\n  host: string;\n  port: number;\n  auth?: {\n    username: string;\n    password:string;\n  };\n  protocol?: string;\n}\n\nexport type Method =\n  | 'get' | 'GET'\n  | 'delete' | 'DELETE'\n  | 'head' | 'HEAD'\n  | 'options' | 'OPTIONS'\n  | 'post' | 'POST'\n  | 'put' | 'PUT'\n  | 'patch' | 'PATCH'\n  | 'purge' | 'PURGE'\n  | 'link' | 'LINK'\n  | 'unlink' | 'UNLINK'\n\nexport type ResponseType =\n  | 'arraybuffer'\n  | 'blob'\n  | 'document'\n  | 'json'\n  | 'text'\n  | 'stream'\n\nexport interface AxiosRequestConfig {\n  url?: string;\n  method?: Method;\n  baseURL?: string;\n  transformRequest?: AxiosTransformer | AxiosTransformer[];\n  transformResponse?: AxiosTransformer | AxiosTransformer[];\n  headers?: any;\n  params?: any;\n  paramsSerializer?: (params: any) => string;\n  data?: any;\n  timeout?: number;\n  timeoutErrorMessage?: string;\n  withCredentials?: boolean;\n  adapter?: AxiosAdapter;\n  auth?: AxiosBasicCredentials;\n  responseType?: ResponseType;\n  xsrfCookieName?: string;\n  xsrfHeaderName?: string;\n  onUploadProgress?: (progressEvent: any) => void;\n  onDownloadProgress?: (progressEvent: any) => void;\n  maxContentLength?: number;\n  validateStatus?: ((status: number) => boolean) | null;\n  maxBodyLength?: number;\n  maxRedirects?: number;\n  socketPath?: string | null;\n  httpAgent?: any;\n  httpsAgent?: any;\n  proxy?: AxiosProxyConfig | false;\n  cancelToken?: CancelToken;\n  decompress?: boolean;\n}\n\nexport interface AxiosResponse<T = any>  {\n  data: T;\n  status: number;\n  statusText: string;\n  headers: any;\n  config: AxiosRequestConfig;\n  request?: any;\n}\n\nexport interface AxiosError<T = any> extends Error {\n  config: AxiosRequestConfig;\n  code?: string;\n  request?: any;\n  response?: AxiosResponse<T>;\n  isAxiosError: boolean;\n  toJSON: () => object;\n}\n\nexport interface AxiosPromise<T = any> extends Promise<AxiosResponse<T>> {\n}\n\nexport interface CancelStatic {\n  new (message?: string): Cancel;\n}\n\nexport interface Cancel {\n  message: string;\n}\n\nexport interface Canceler {\n  (message?: string): void;\n}\n\nexport interface CancelTokenStatic {\n  new (executor: (cancel: Canceler) => void): CancelToken;\n  source(): CancelTokenSource;\n}\n\nexport interface CancelToken {\n  promise: Promise<Cancel>;\n  reason?: Cancel;\n  throwIfRequested(): void;\n}\n\nexport interface CancelTokenSource {\n  token: CancelToken;\n  cancel: Canceler;\n}\n\nexport interface AxiosInterceptorManager<V> {\n  use(onFulfilled?: (value: V) => V | Promise<V>, onRejected?: (error: any) => any): number;\n  eject(id: number): void;\n}\n\nexport interface AxiosInstance {\n  (config: AxiosRequestConfig): AxiosPromise;\n  (url: string, config?: AxiosRequestConfig): AxiosPromise;\n  defaults: AxiosRequestConfig;\n  interceptors: {\n    request: AxiosInterceptorManager<AxiosRequestConfig>;\n    response: AxiosInterceptorManager<AxiosResponse>;\n  };\n  getUri(config?: AxiosRequestConfig): string;\n  request<T = any, R = AxiosResponse<T>> (config: AxiosRequestConfig): Promise<R>;\n  get<T = any, R = AxiosResponse<T>>(url: string, config?: AxiosRequestConfig): Promise<R>;\n  delete<T = any, R = AxiosResponse<T>>(url: string, config?: AxiosRequestConfig): Promise<R>;\n  head<T = any, R = AxiosResponse<T>>(url: string, config?: AxiosRequestConfig): Promise<R>;\n  options<T = any, R = AxiosResponse<T>>(url: string, config?: AxiosRequestConfig): Promise<R>;\n  post<T = any, R = AxiosResponse<T>>(url: string, data?: any, config?: AxiosRequestConfig): Promise<R>;\n  put<T = any, R = AxiosResponse<T>>(url: string, data?: any, config?: AxiosRequestConfig): Promise<R>;\n  patch<T = any, R = AxiosResponse<T>>(url: string, data?: any, config?: AxiosRequestConfig): Promise<R>;\n}\n\nexport interface AxiosStatic extends AxiosInstance {\n  create(config?: AxiosRequestConfig): AxiosInstance;\n  Cancel: CancelStatic;\n  CancelToken: CancelTokenStatic;\n  isCancel(value: any): boolean;\n  all<T>(values: (T | Promise<T>)[]): Promise<T[]>;\n  spread<T, R>(callback: (...args: T[]) => R): (array: T[]) => R;\n  isAxiosError(payload: any): payload is AxiosError;\n}\n\ndeclare const axios: AxiosStatic;\n\nexport default axios;\n\n\n/**\n * Declaration for https://github.com/s3u/JSONPath\n */\ndeclare module 'jsonpath-plus' {\n  type JSONPathCallback = (\n      payload: any, payloadType: any, fullPayload: any\n  ) => any\n\n  type JSONPathOtherTypeCallback = (...args: any[]) => void\n\n  interface JSONPathOptions {\n    /**\n     * The JSONPath expression as a (normalized or unnormalized) string or\n     *   array.\n     */\n    path: string | any[]\n    /**\n     * The JSON object to evaluate (whether of null, boolean, number,\n     *   string, object, or array type).\n     */\n    json: null | boolean | number | string | object | any[]\n    /**\n     * If this is supplied as false, one may call the evaluate method\n     *  manually.\n     *\n     * @default true\n     */\n    autostart?: true | boolean\n    /**\n     * Whether the returned array of results will be flattened to a\n     *   single dimension array.\n     *\n     * @default false\n     */\n    flatten?: false | boolean\n    /**\n     * Can be case-insensitive form of \"value\", \"path\", \"pointer\", \"parent\",\n     *   or \"parentProperty\" to determine respectively whether to return\n     *   results as the values of the found items, as their absolute paths,\n     *   as JSON Pointers to the absolute paths, as their parent objects,\n     *   or as their parent's property name.\n     *\n     * If set to \"all\", all of these types will be returned on an object with\n     *   the type as key name.\n     *\n     * @default 'value'\n     */\n    resultType?:\n        'value' | 'path' | 'pointer' | 'parent' | 'parentProperty' | 'all'\n\n    /**\n     * Key-value map of variables to be available to code evaluations such\n     *   as filtering expressions.\n     * (Note that the current path and value will also be available to those\n     *   expressions; see the Syntax section for details.)\n     */\n    sandbox?: Map<string, any>\n    /**\n     * Whether or not to wrap the results in an array.\n     *\n     * If wrap is set to false, and no results are found, undefined will be\n     *   returned (as opposed to an empty array when wrap is set to true).\n     *\n     * If wrap is set to false and a single non-array result is found, that\n     *   result will be the only item returned (not within an array).\n     *\n     * An array will still be returned if multiple results are found, however.\n     * To avoid ambiguities (in the case where it is necessary to distinguish\n     * between a result which is a failure and one which is an empty array),\n     * it is recommended to switch the default to false.\n     *\n     * @default true\n     */\n    wrap?: true | boolean\n    /**\n     * Although JavaScript evaluation expressions are allowed by default,\n     * for security reasons (if one is operating on untrusted user input,\n     * for example), one may wish to set this option to true to throw\n     * exceptions when these expressions are attempted.\n     *\n     * @default false\n     */\n    preventEval?: false | boolean\n    /**\n     * In the event that a query could be made to return the root node,\n     * this allows the parent of that root node to be returned within results.\n     *\n     * @default null\n     */\n    parent?: null | any\n    /**\n     * In the event that a query could be made to return the root node,\n     * this allows the parentProperty of that root node to be returned within\n     * results.\n     *\n     * @default null\n     */\n    parentProperty?: null | any\n    /**\n     * If supplied, a callback will be called immediately upon retrieval of\n     * an end point value.\n     *\n     * The three arguments supplied will be the value of the payload\n     * (according to `resultType`), the type of the payload (whether it is\n     * a normal \"value\" or a \"property\" name), and a full payload object\n     * (with all `resultType`s).\n     *\n     * @default undefined\n     */\n    callback?: undefined | JSONPathCallback\n    /**\n     * In the current absence of JSON Schema support,\n     * one can determine types beyond the built-in types by adding the\n     * perator `@other()` at the end of one's query.\n     *\n     * If such a path is encountered, the `otherTypeCallback` will be invoked\n     * with the value of the item, its path, its parent, and its parent's\n     * property name, and it should return a boolean indicating whether the\n     * supplied value belongs to the \"other\" type or not (or it may handle\n     * transformations and return false).\n     *\n     * @default undefined\n     *   <A function that throws an error when `@other()` is encountered>\n     */\n    otherTypeCallback?: undefined | JSONPathOtherTypeCallback\n  }\n\n  interface JSONPathOptionsAutoStart extends JSONPathOptions {\n    autostart: false\n  }\n\n  interface JSONPathCallable {\n    <T = any>(options: JSONPathOptionsAutoStart): JSONPathClass\n    <T = any>(options: JSONPathOptions): T\n\n    <T = any>(\n        path: JSONPathOptions['path'],\n        json: JSONPathOptions['json'],\n        callback: JSONPathOptions['callback'],\n        otherTypeCallback: JSONPathOptions['otherTypeCallback']\n    ): T\n  }\n\n  class JSONPathClass {\n    /**\n     * Exposes the cache object for those who wish to preserve and reuse\n     *   it for optimization purposes.\n     */\n    static cache: any\n\n    /**\n     * Accepts a normalized or unnormalized path as string and\n     * converts to an array: for example,\n     * `['$', 'aProperty', 'anotherProperty']`.\n     */\n    static toPathArray(path: string): string[]\n\n    /**\n     * Accepts a path array and converts to a normalized path string.\n     * The string will be in a form like:\n     *   `$['aProperty']['anotherProperty][0]`.\n     * The JSONPath terminal constructions `~` and `^` and type operators\n     *   like `@string()` are silently stripped.\n     */\n    static toPathString(path: string[]): string\n\n    /**\n     * Accepts a path array and converts to a JSON Pointer.\n     *\n     * The string will be in a form like: `/aProperty/anotherProperty/0`\n     * (with any `~` and `/` internal characters escaped as per the JSON\n     * Pointer spec).\n     *\n     * The JSONPath terminal constructions `~` and `^` and type operators\n     *   like `@string()` are silently stripped.\n     */\n    static toPointer(path: string[]): any\n\n    evaluate(\n        path: JSONPathOptions['path'],\n        json: JSONPathOptions['json'],\n        callback: JSONPathOptions['callback'],\n        otherTypeCallback: JSONPathOptions['otherTypeCallback']\n    ): any\n    evaluate(options: {\n        path: JSONPathOptions['path'],\n        json: JSONPathOptions['json'],\n        callback: JSONPathOptions['callback'],\n        otherTypeCallback: JSONPathOptions['otherTypeCallback']\n    }): any\n  }\n\n  type JSONPathType = JSONPathCallable & JSONPathClass\n\n  export const JSONPath: JSONPathType\n}\n\n\ndeclare module \"assert\" {\n    function internal(value: any, message?: string | Error): void;\n    namespace internal {\n        class AssertionError implements Error {\n            name: string;\n            message: string;\n            actual: any;\n            expected: any;\n            operator: string;\n            generatedMessage: boolean;\n            code: 'ERR_ASSERTION';\n\n            constructor(options?: {\n                message?: string; actual?: any; expected?: any;\n                operator?: string; stackStartFn?: Function\n            });\n        }\n\n        type AssertPredicate = RegExp | (new() => object) | ((thrown: any) => boolean) | object | Error;\n\n        function fail(message?: string | Error): never;\n        /** @deprecated since v10.0.0 - use fail([message]) or other assert functions instead. */\n        function fail(actual: any, expected: any, message?: string | Error, operator?: string, stackStartFn?: Function): never;\n        function ok(value: any, message?: string | Error): void;\n        function equal(actual: any, expected: any, message?: string | Error): void;\n        function notEqual(actual: any, expected: any, message?: string | Error): void;\n        function deepEqual(actual: any, expected: any, message?: string | Error): void;\n        function notDeepEqual(actual: any, expected: any, message?: string | Error): void;\n        function strictEqual(actual: any, expected: any, message?: string | Error): void;\n        function notStrictEqual(actual: any, expected: any, message?: string | Error): void;\n        function deepStrictEqual(actual: any, expected: any, message?: string | Error): void;\n        function notDeepStrictEqual(actual: any, expected: any, message?: string | Error): void;\n\n        function throws(block: () => any, message?: string | Error): void;\n        function throws(block: () => any, error: AssertPredicate, message?: string | Error): void;\n        function doesNotThrow(block: () => any, message?: string | Error): void;\n        function doesNotThrow(block: () => any, error: RegExp | Function, message?: string | Error): void;\n\n        function ifError(value: any): void;\n\n        function rejects(block: (() => Promise<any>) | Promise<any>, message?: string | Error): Promise<void>;\n        function rejects(block: (() => Promise<any>) | Promise<any>, error: AssertPredicate, message?: string | Error): Promise<void>;\n        function doesNotReject(block: (() => Promise<any>) | Promise<any>, message?: string | Error): Promise<void>;\n        function doesNotReject(block: (() => Promise<any>) | Promise<any>, error: RegExp | Function, message?: string | Error): Promise<void>;\n\n        function match(value: string, regExp: RegExp, message?: string | Error): void;\n        function doesNotMatch(value: string, regExp: RegExp, message?: string | Error): void;\n\n        const strict: typeof internal;\n    }\n\n    export = internal;\n}\n\n\n/**\n * Async Hooks module: https://nodejs.org/api/async_hooks.html\n */\ndeclare module \"async_hooks\" {\n    /**\n     * Returns the asyncId of the current execution context.\n     */\n    function executionAsyncId(): number;\n\n    /**\n     * The resource representing the current execution.\n     *  Useful to store data within the resource.\n     *\n     * Resource objects returned by `executionAsyncResource()` are most often internal\n     * Node.js handle objects with undocumented APIs. Using any functions or properties\n     * on the object is likely to crash your application and should be avoided.\n     *\n     * Using `executionAsyncResource()` in the top-level execution context will\n     * return an empty object as there is no handle or request object to use,\n     * but having an object representing the top-level can be helpful.\n     */\n    function executionAsyncResource(): object;\n\n    /**\n     * Returns the ID of the resource responsible for calling the callback that is currently being executed.\n     */\n    function triggerAsyncId(): number;\n\n    interface HookCallbacks {\n        /**\n         * Called when a class is constructed that has the possibility to emit an asynchronous event.\n         * @param asyncId a unique ID for the async resource\n         * @param type the type of the async resource\n         * @param triggerAsyncId the unique ID of the async resource in whose execution context this async resource was created\n         * @param resource reference to the resource representing the async operation, needs to be released during destroy\n         */\n        init?(asyncId: number, type: string, triggerAsyncId: number, resource: object): void;\n\n        /**\n         * When an asynchronous operation is initiated or completes a callback is called to notify the user.\n         * The before callback is called just before said callback is executed.\n         * @param asyncId the unique identifier assigned to the resource about to execute the callback.\n         */\n        before?(asyncId: number): void;\n\n        /**\n         * Called immediately after the callback specified in before is completed.\n         * @param asyncId the unique identifier assigned to the resource which has executed the callback.\n         */\n        after?(asyncId: number): void;\n\n        /**\n         * Called when a promise has resolve() called. This may not be in the same execution id\n         * as the promise itself.\n         * @param asyncId the unique id for the promise that was resolve()d.\n         */\n        promiseResolve?(asyncId: number): void;\n\n        /**\n         * Called after the resource corresponding to asyncId is destroyed\n         * @param asyncId a unique ID for the async resource\n         */\n        destroy?(asyncId: number): void;\n    }\n\n    interface AsyncHook {\n        /**\n         * Enable the callbacks for a given AsyncHook instance. If no callbacks are provided enabling is a noop.\n         */\n        enable(): this;\n\n        /**\n         * Disable the callbacks for a given AsyncHook instance from the global pool of AsyncHook callbacks to be executed. Once a hook has been disabled it will not be called again until enabled.\n         */\n        disable(): this;\n    }\n\n    /**\n     * Registers functions to be called for different lifetime events of each async operation.\n     * @param options the callbacks to register\n     * @return an AsyncHooks instance used for disabling and enabling hooks\n     */\n    function createHook(options: HookCallbacks): AsyncHook;\n\n    interface AsyncResourceOptions {\n      /**\n       * The ID of the execution context that created this async event.\n       * Default: `executionAsyncId()`\n       */\n      triggerAsyncId?: number;\n\n      /**\n       * Disables automatic `emitDestroy` when the object is garbage collected.\n       * This usually does not need to be set (even if `emitDestroy` is called\n       * manually), unless the resource's `asyncId` is retrieved and the\n       * sensitive API's `emitDestroy` is called with it.\n       * Default: `false`\n       */\n      requireManualDestroy?: boolean;\n    }\n\n    /**\n     * The class AsyncResource was designed to be extended by the embedder's async resources.\n     * Using this users can easily trigger the lifetime events of their own resources.\n     */\n    class AsyncResource {\n        /**\n         * AsyncResource() is meant to be extended. Instantiating a\n         * new AsyncResource() also triggers init. If triggerAsyncId is omitted then\n         * async_hook.executionAsyncId() is used.\n         * @param type The type of async event.\n         * @param triggerAsyncId The ID of the execution context that created\n         *   this async event (default: `executionAsyncId()`), or an\n         *   AsyncResourceOptions object (since 9.3)\n         */\n        constructor(type: string, triggerAsyncId?: number|AsyncResourceOptions);\n\n        /**\n         * Call the provided function with the provided arguments in the\n         * execution context of the async resource. This will establish the\n         * context, trigger the AsyncHooks before callbacks, call the function,\n         * trigger the AsyncHooks after callbacks, and then restore the original\n         * execution context.\n         * @param fn The function to call in the execution context of this\n         *   async resource.\n         * @param thisArg The receiver to be used for the function call.\n         * @param args Optional arguments to pass to the function.\n         */\n        runInAsyncScope<This, Result>(fn: (this: This, ...args: any[]) => Result, thisArg?: This, ...args: any[]): Result;\n\n        /**\n         * Call AsyncHooks destroy callbacks.\n         */\n        emitDestroy(): void;\n\n        /**\n         * @return the unique ID assigned to this AsyncResource instance.\n         */\n        asyncId(): number;\n\n        /**\n         * @return the trigger ID for this AsyncResource instance.\n         */\n        triggerAsyncId(): number;\n    }\n\n    /**\n     * When having multiple instances of `AsyncLocalStorage`, they are independent\n     * from each other. It is safe to instantiate this class multiple times.\n     */\n    class AsyncLocalStorage<T> {\n        /**\n         * This method disables the instance of `AsyncLocalStorage`. All subsequent calls\n         * to `asyncLocalStorage.getStore()` will return `undefined` until\n         * `asyncLocalStorage.run()` or `asyncLocalStorage.runSyncAndReturn()`\n         * is called again.\n         *\n         * When calling `asyncLocalStorage.disable()`, all current contexts linked to the\n         * instance will be exited.\n         *\n         * Calling `asyncLocalStorage.disable()` is required before the\n         * `asyncLocalStorage` can be garbage collected. This does not apply to stores\n         * provided by the `asyncLocalStorage`, as those objects are garbage collected\n         * along with the corresponding async resources.\n         *\n         * This method is to be used when the `asyncLocalStorage` is not in use anymore\n         * in the current process.\n         */\n        disable(): void;\n\n        /**\n         * This method returns the current store.\n         * If this method is called outside of an asynchronous context initialized by\n         * calling `asyncLocalStorage.run` or `asyncLocalStorage.runAndReturn`, it will\n         * return `undefined`.\n         */\n        getStore(): T | undefined;\n\n        /**\n         * Calling `asyncLocalStorage.run(callback)` will create a new asynchronous\n         * context.\n         * Within the callback function and the asynchronous operations from the callback,\n         * `asyncLocalStorage.getStore()` will return an instance of `Map` known as\n         * \"the store\". This store will be persistent through the following\n         * asynchronous calls.\n         *\n         * The callback will be ran asynchronously. Optionally, arguments can be passed\n         * to the function. They will be passed to the callback function.\n         *\n         * If an error is thrown by the callback function, it will not be caught by\n         * a `try/catch` block as the callback is ran in a new asynchronous resource.\n         * Also, the stacktrace will be impacted by the asynchronous call.\n         */\n        // TODO: Apply generic vararg once available\n        run(store: T, callback: (...args: any[]) => void, ...args: any[]): void;\n\n        /**\n         * Calling `asyncLocalStorage.exit(callback)` will create a new asynchronous\n         * context.\n         * Within the callback function and the asynchronous operations from the callback,\n         * `asyncLocalStorage.getStore()` will return `undefined`.\n         *\n         * The callback will be ran asynchronously. Optionally, arguments can be passed\n         * to the function. They will be passed to the callback function.\n         *\n         * If an error is thrown by the callback function, it will not be caught by\n         * a `try/catch` block as the callback is ran in a new asynchronous resource.\n         * Also, the stacktrace will be impacted by the asynchronous call.\n         */\n        exit(callback: (...args: any[]) => void, ...args: any[]): void;\n\n        /**\n         * This methods runs a function synchronously within a context and return its\n         * return value. The store is not accessible outside of the callback function or\n         * the asynchronous operations created within the callback.\n         *\n         * Optionally, arguments can be passed to the function. They will be passed to\n         * the callback function.\n         *\n         * If the callback function throws an error, it will be thrown by\n         * `runSyncAndReturn` too. The stacktrace will not be impacted by this call and\n         * the context will be exited.\n         */\n        runSyncAndReturn<R>(store: T, callback: (...args: any[]) => R, ...args: any[]): R;\n\n        /**\n         * This methods runs a function synchronously outside of a context and return its\n         * return value. The store is not accessible within the callback function or\n         * the asynchronous operations created within the callback.\n         *\n         * Optionally, arguments can be passed to the function. They will be passed to\n         * the callback function.\n         *\n         * If the callback function throws an error, it will be thrown by\n         * `exitSyncAndReturn` too. The stacktrace will not be impacted by this call and\n         * the context will be re-entered.\n         */\n        exitSyncAndReturn<R>(callback: (...args: any[]) => R, ...args: any[]): R;\n\n        /**\n         * Calling `asyncLocalStorage.enterWith(store)` will transition into the context\n         * for the remainder of the current synchronous execution and will persist\n         * through any following asynchronous calls.\n         */\n        enterWith(store: T): void;\n    }\n}\n\n\n// base definnitions for all NodeJS modules that are not specific to any version of TypeScript\n/// <reference path=\"globals.d.ts\" />\n/// <reference path=\"assert.d.ts\" />\n/// <reference path=\"async_hooks.d.ts\" />\n/// <reference path=\"buffer.d.ts\" />\n/// <reference path=\"child_process.d.ts\" />\n/// <reference path=\"cluster.d.ts\" />\n/// <reference path=\"console.d.ts\" />\n/// <reference path=\"constants.d.ts\" />\n/// <reference path=\"crypto.d.ts\" />\n/// <reference path=\"dgram.d.ts\" />\n/// <reference path=\"dns.d.ts\" />\n/// <reference path=\"domain.d.ts\" />\n/// <reference path=\"events.d.ts\" />\n/// <reference path=\"fs.d.ts\" />\n/// <reference path=\"http.d.ts\" />\n/// <reference path=\"http2.d.ts\" />\n/// <reference path=\"https.d.ts\" />\n/// <reference path=\"inspector.d.ts\" />\n/// <reference path=\"module.d.ts\" />\n/// <reference path=\"net.d.ts\" />\n/// <reference path=\"os.d.ts\" />\n/// <reference path=\"path.d.ts\" />\n/// <reference path=\"perf_hooks.d.ts\" />\n/// <reference path=\"process.d.ts\" />\n/// <reference path=\"punycode.d.ts\" />\n/// <reference path=\"querystring.d.ts\" />\n/// <reference path=\"readline.d.ts\" />\n/// <reference path=\"repl.d.ts\" />\n/// <reference path=\"stream.d.ts\" />\n/// <reference path=\"string_decoder.d.ts\" />\n/// <reference path=\"timers.d.ts\" />\n/// <reference path=\"tls.d.ts\" />\n/// <reference path=\"trace_events.d.ts\" />\n/// <reference path=\"tty.d.ts\" />\n/// <reference path=\"url.d.ts\" />\n/// <reference path=\"util.d.ts\" />\n/// <reference path=\"v8.d.ts\" />\n/// <reference path=\"vm.d.ts\" />\n/// <reference path=\"worker_threads.d.ts\" />\n/// <reference path=\"zlib.d.ts\" />\n\n\ndeclare module \"buffer\" {\n    export const INSPECT_MAX_BYTES: number;\n    export const kMaxLength: number;\n    export const kStringMaxLength: number;\n    export const constants: {\n        MAX_LENGTH: number;\n        MAX_STRING_LENGTH: number;\n    };\n    const BuffType: typeof Buffer;\n\n    export type TranscodeEncoding = \"ascii\" | \"utf8\" | \"utf16le\" | \"ucs2\" | \"latin1\" | \"binary\";\n\n    export function transcode(source: Uint8Array, fromEnc: TranscodeEncoding, toEnc: TranscodeEncoding): Buffer;\n\n    export const SlowBuffer: {\n        /** @deprecated since v6.0.0, use Buffer.allocUnsafeSlow() */\n        new(size: number): Buffer;\n        prototype: Buffer;\n    };\n\n    export { BuffType as Buffer };\n}\n\n\ndeclare module \"child_process\" {\n    import * as events from \"events\";\n    import * as net from \"net\";\n    import { Writable, Readable, Stream, Pipe } from \"stream\";\n\n    type Serializable = string | object | number | boolean;\n    type SendHandle = net.Socket | net.Server;\n\n    interface ChildProcess extends events.EventEmitter {\n        stdin: Writable | null;\n        stdout: Readable | null;\n        stderr: Readable | null;\n        readonly channel?: Pipe | null;\n        readonly stdio: [\n            Writable | null, // stdin\n            Readable | null, // stdout\n            Readable | null, // stderr\n            Readable | Writable | null | undefined, // extra\n            Readable | Writable | null | undefined // extra\n        ];\n        readonly killed: boolean;\n        readonly pid: number;\n        readonly connected: boolean;\n        kill(signal?: NodeJS.Signals | number): boolean;\n        send(message: Serializable, callback?: (error: Error | null) => void): boolean;\n        send(message: Serializable, sendHandle?: SendHandle, callback?: (error: Error | null) => void): boolean;\n        send(message: Serializable, sendHandle?: SendHandle, options?: MessageOptions, callback?: (error: Error | null) => void): boolean;\n        disconnect(): void;\n        unref(): void;\n        ref(): void;\n\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. disconnect\n         * 3. error\n         * 4. exit\n         * 5. message\n         */\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: (code: number, signal: NodeJS.Signals) => void): this;\n        addListener(event: \"disconnect\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"exit\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;\n        addListener(event: \"message\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\", code: number, signal: NodeJS.Signals): boolean;\n        emit(event: \"disconnect\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"exit\", code: number | null, signal: NodeJS.Signals | null): boolean;\n        emit(event: \"message\", message: Serializable, sendHandle: SendHandle): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: (code: number, signal: NodeJS.Signals) => void): this;\n        on(event: \"disconnect\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"exit\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;\n        on(event: \"message\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: (code: number, signal: NodeJS.Signals) => void): this;\n        once(event: \"disconnect\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"exit\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;\n        once(event: \"message\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: (code: number, signal: NodeJS.Signals) => void): this;\n        prependListener(event: \"disconnect\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"exit\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;\n        prependListener(event: \"message\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: (code: number, signal: NodeJS.Signals) => void): this;\n        prependOnceListener(event: \"disconnect\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"exit\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;\n        prependOnceListener(event: \"message\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;\n    }\n\n    // return this object when stdio option is undefined or not specified\n    interface ChildProcessWithoutNullStreams extends ChildProcess {\n        stdin: Writable;\n        stdout: Readable;\n        stderr: Readable;\n        readonly stdio: [\n            Writable, // stdin\n            Readable, // stdout\n            Readable, // stderr\n            Readable | Writable | null | undefined, // extra, no modification\n            Readable | Writable | null | undefined // extra, no modification\n        ];\n    }\n\n    // return this object when stdio option is a tuple of 3\n    interface ChildProcessByStdio<\n        I extends null | Writable,\n        O extends null | Readable,\n        E extends null | Readable,\n    > extends ChildProcess {\n        stdin: I;\n        stdout: O;\n        stderr: E;\n        readonly stdio: [\n            I,\n            O,\n            E,\n            Readable | Writable | null | undefined, // extra, no modification\n            Readable | Writable | null | undefined // extra, no modification\n        ];\n    }\n\n    interface MessageOptions {\n        keepOpen?: boolean;\n    }\n\n    type StdioOptions = \"pipe\" | \"ignore\" | \"inherit\" | Array<(\"pipe\" | \"ipc\" | \"ignore\" | \"inherit\" | Stream | number | null | undefined)>;\n\n    type SerializationType = 'json' | 'advanced';\n\n    interface MessagingOptions {\n        /**\n         * Specify the kind of serialization used for sending messages between processes.\n         * @default 'json'\n         */\n        serialization?: SerializationType;\n    }\n\n    interface ProcessEnvOptions {\n        uid?: number;\n        gid?: number;\n        cwd?: string;\n        env?: NodeJS.ProcessEnv;\n    }\n\n    interface CommonOptions extends ProcessEnvOptions {\n        /**\n         * @default true\n         */\n        windowsHide?: boolean;\n        /**\n         * @default 0\n         */\n        timeout?: number;\n    }\n\n    interface CommonSpawnOptions extends CommonOptions, MessagingOptions {\n        argv0?: string;\n        stdio?: StdioOptions;\n        shell?: boolean | string;\n        windowsVerbatimArguments?: boolean;\n    }\n\n    interface SpawnOptions extends CommonSpawnOptions {\n        detached?: boolean;\n    }\n\n    interface SpawnOptionsWithoutStdio extends SpawnOptions {\n        stdio?: 'pipe' | Array<null | undefined | 'pipe'>;\n    }\n\n    type StdioNull = 'inherit' | 'ignore' | Stream;\n    type StdioPipe = undefined | null | 'pipe';\n\n    interface SpawnOptionsWithStdioTuple<\n        Stdin extends StdioNull | StdioPipe,\n        Stdout extends StdioNull | StdioPipe,\n        Stderr extends StdioNull | StdioPipe,\n    > extends SpawnOptions {\n        stdio: [Stdin, Stdout, Stderr];\n    }\n\n    // overloads of spawn without 'args'\n    function spawn(command: string, options?: SpawnOptionsWithoutStdio): ChildProcessWithoutNullStreams;\n\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioPipe>,\n    ): ChildProcessByStdio<Writable, Readable, Readable>;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioNull>,\n    ): ChildProcessByStdio<Writable, Readable, null>;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioPipe>,\n    ): ChildProcessByStdio<Writable, null, Readable>;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioPipe>,\n    ): ChildProcessByStdio<null, Readable, Readable>;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioNull>,\n    ): ChildProcessByStdio<Writable, null, null>;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioNull>,\n    ): ChildProcessByStdio<null, Readable, null>;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioPipe>,\n    ): ChildProcessByStdio<null, null, Readable>;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioNull>,\n    ): ChildProcessByStdio<null, null, null>;\n\n    function spawn(command: string, options: SpawnOptions): ChildProcess;\n\n    // overloads of spawn with 'args'\n    function spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptionsWithoutStdio): ChildProcessWithoutNullStreams;\n\n    function spawn(\n        command: string,\n        args: ReadonlyArray<string>,\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioPipe>,\n    ): ChildProcessByStdio<Writable, Readable, Readable>;\n    function spawn(\n        command: string,\n        args: ReadonlyArray<string>,\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioNull>,\n    ): ChildProcessByStdio<Writable, Readable, null>;\n    function spawn(\n        command: string,\n        args: ReadonlyArray<string>,\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioPipe>,\n    ): ChildProcessByStdio<Writable, null, Readable>;\n    function spawn(\n        command: string,\n        args: ReadonlyArray<string>,\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioPipe>,\n    ): ChildProcessByStdio<null, Readable, Readable>;\n    function spawn(\n        command: string,\n        args: ReadonlyArray<string>,\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioNull>,\n    ): ChildProcessByStdio<Writable, null, null>;\n    function spawn(\n        command: string,\n        args: ReadonlyArray<string>,\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioNull>,\n    ): ChildProcessByStdio<null, Readable, null>;\n    function spawn(\n        command: string,\n        args: ReadonlyArray<string>,\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioPipe>,\n    ): ChildProcessByStdio<null, null, Readable>;\n    function spawn(\n        command: string,\n        args: ReadonlyArray<string>,\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioNull>,\n    ): ChildProcessByStdio<null, null, null>;\n\n    function spawn(command: string, args: ReadonlyArray<string>, options: SpawnOptions): ChildProcess;\n\n    interface ExecOptions extends CommonOptions {\n        shell?: string;\n        maxBuffer?: number;\n        killSignal?: NodeJS.Signals | number;\n    }\n\n    interface ExecOptionsWithStringEncoding extends ExecOptions {\n        encoding: BufferEncoding;\n    }\n\n    interface ExecOptionsWithBufferEncoding extends ExecOptions {\n        encoding: string | null; // specify `null`.\n    }\n\n    interface ExecException extends Error {\n        cmd?: string;\n        killed?: boolean;\n        code?: number;\n        signal?: NodeJS.Signals;\n    }\n\n    // no `options` definitely means stdout/stderr are `string`.\n    function exec(command: string, callback?: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // `options` with `\"buffer\"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.\n    function exec(command: string, options: { encoding: \"buffer\" | null } & ExecOptions, callback?: (error: ExecException | null, stdout: Buffer, stderr: Buffer) => void): ChildProcess;\n\n    // `options` with well known `encoding` means stdout/stderr are definitely `string`.\n    function exec(command: string, options: { encoding: BufferEncoding } & ExecOptions, callback?: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // `options` with an `encoding` whose type is `string` means stdout/stderr could either be `Buffer` or `string`.\n    // There is no guarantee the `encoding` is unknown as `string` is a superset of `BufferEncoding`.\n    function exec(command: string, options: { encoding: string } & ExecOptions, callback?: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void): ChildProcess;\n\n    // `options` without an `encoding` means stdout/stderr are definitely `string`.\n    function exec(command: string, options: ExecOptions, callback?: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // fallback if nothing else matches. Worst case is always `string | Buffer`.\n    function exec(\n        command: string,\n        options: ({ encoding?: string | null } & ExecOptions) | undefined | null,\n        callback?: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n\n    interface PromiseWithChild<T> extends Promise<T> {\n        child: ChildProcess;\n    }\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace exec {\n        function __promisify__(command: string): PromiseWithChild<{ stdout: string, stderr: string }>;\n        function __promisify__(command: string, options: { encoding: \"buffer\" | null } & ExecOptions): PromiseWithChild<{ stdout: Buffer, stderr: Buffer }>;\n        function __promisify__(command: string, options: { encoding: BufferEncoding } & ExecOptions): PromiseWithChild<{ stdout: string, stderr: string }>;\n        function __promisify__(command: string, options: ExecOptions): PromiseWithChild<{ stdout: string, stderr: string }>;\n        function __promisify__(command: string, options?: ({ encoding?: string | null } & ExecOptions) | null): PromiseWithChild<{ stdout: string | Buffer, stderr: string | Buffer }>;\n    }\n\n    interface ExecFileOptions extends CommonOptions {\n        maxBuffer?: number;\n        killSignal?: NodeJS.Signals | number;\n        windowsVerbatimArguments?: boolean;\n        shell?: boolean | string;\n    }\n    interface ExecFileOptionsWithStringEncoding extends ExecFileOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecFileOptionsWithBufferEncoding extends ExecFileOptions {\n        encoding: 'buffer' | null;\n    }\n    interface ExecFileOptionsWithOtherEncoding extends ExecFileOptions {\n        encoding: string;\n    }\n\n    function execFile(file: string): ChildProcess;\n    function execFile(file: string, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): ChildProcess;\n    function execFile(file: string, args?: ReadonlyArray<string> | null): ChildProcess;\n    function execFile(file: string, args: ReadonlyArray<string> | undefined | null, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): ChildProcess;\n\n    // no `options` definitely means stdout/stderr are `string`.\n    function execFile(file: string, callback: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n    function execFile(file: string, args: ReadonlyArray<string> | undefined | null, callback: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // `options` with `\"buffer\"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.\n    function execFile(file: string, options: ExecFileOptionsWithBufferEncoding, callback: (error: ExecException | null, stdout: Buffer, stderr: Buffer) => void): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ExecFileOptionsWithBufferEncoding,\n        callback: (error: ExecException | null, stdout: Buffer, stderr: Buffer) => void,\n    ): ChildProcess;\n\n    // `options` with well known `encoding` means stdout/stderr are definitely `string`.\n    function execFile(file: string, options: ExecFileOptionsWithStringEncoding, callback: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ExecFileOptionsWithStringEncoding,\n        callback: (error: ExecException | null, stdout: string, stderr: string) => void,\n    ): ChildProcess;\n\n    // `options` with an `encoding` whose type is `string` means stdout/stderr could either be `Buffer` or `string`.\n    // There is no guarantee the `encoding` is unknown as `string` is a superset of `BufferEncoding`.\n    function execFile(\n        file: string,\n        options: ExecFileOptionsWithOtherEncoding,\n        callback: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ExecFileOptionsWithOtherEncoding,\n        callback: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n\n    // `options` without an `encoding` means stdout/stderr are definitely `string`.\n    function execFile(file: string, options: ExecFileOptions, callback: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ExecFileOptions,\n        callback: (error: ExecException | null, stdout: string, stderr: string) => void\n    ): ChildProcess;\n\n    // fallback if nothing else matches. Worst case is always `string | Buffer`.\n    function execFile(\n        file: string,\n        options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null,\n        callback: ((error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void) | undefined | null,\n    ): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null,\n        callback: ((error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void) | undefined | null,\n    ): ChildProcess;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace execFile {\n        function __promisify__(file: string): PromiseWithChild<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, args: string[] | undefined | null): PromiseWithChild<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, options: ExecFileOptionsWithBufferEncoding): PromiseWithChild<{ stdout: Buffer, stderr: Buffer }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithBufferEncoding): PromiseWithChild<{ stdout: Buffer, stderr: Buffer }>;\n        function __promisify__(file: string, options: ExecFileOptionsWithStringEncoding): PromiseWithChild<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithStringEncoding): PromiseWithChild<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, options: ExecFileOptionsWithOtherEncoding): PromiseWithChild<{ stdout: string | Buffer, stderr: string | Buffer }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithOtherEncoding): PromiseWithChild<{ stdout: string | Buffer, stderr: string | Buffer }>;\n        function __promisify__(file: string, options: ExecFileOptions): PromiseWithChild<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptions): PromiseWithChild<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): PromiseWithChild<{ stdout: string | Buffer, stderr: string | Buffer }>;\n        function __promisify__(\n            file: string,\n            args: string[] | undefined | null,\n            options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null,\n        ): PromiseWithChild<{ stdout: string | Buffer, stderr: string | Buffer }>;\n    }\n\n    interface ForkOptions extends ProcessEnvOptions, MessagingOptions {\n        execPath?: string;\n        execArgv?: string[];\n        silent?: boolean;\n        stdio?: StdioOptions;\n        detached?: boolean;\n        windowsVerbatimArguments?: boolean;\n    }\n    function fork(modulePath: string, args?: ReadonlyArray<string>, options?: ForkOptions): ChildProcess;\n\n    interface SpawnSyncOptions extends CommonSpawnOptions {\n        input?: string | NodeJS.ArrayBufferView;\n        killSignal?: NodeJS.Signals | number;\n        maxBuffer?: number;\n        encoding?: string;\n    }\n    interface SpawnSyncOptionsWithStringEncoding extends SpawnSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface SpawnSyncOptionsWithBufferEncoding extends SpawnSyncOptions {\n        encoding: string; // specify `null`.\n    }\n    interface SpawnSyncReturns<T> {\n        pid: number;\n        output: string[];\n        stdout: T;\n        stderr: T;\n        status: number | null;\n        signal: NodeJS.Signals | null;\n        error?: Error;\n    }\n    function spawnSync(command: string): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, options?: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;\n    function spawnSync(command: string, options?: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, options?: SpawnSyncOptions): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, args?: ReadonlyArray<string>, options?: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;\n    function spawnSync(command: string, args?: ReadonlyArray<string>, options?: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, args?: ReadonlyArray<string>, options?: SpawnSyncOptions): SpawnSyncReturns<Buffer>;\n\n    interface ExecSyncOptions extends CommonOptions {\n        input?: string | Uint8Array;\n        stdio?: StdioOptions;\n        shell?: string;\n        killSignal?: NodeJS.Signals | number;\n        maxBuffer?: number;\n        encoding?: string;\n    }\n    interface ExecSyncOptionsWithStringEncoding extends ExecSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecSyncOptionsWithBufferEncoding extends ExecSyncOptions {\n        encoding: string; // specify `null`.\n    }\n    function execSync(command: string): Buffer;\n    function execSync(command: string, options?: ExecSyncOptionsWithStringEncoding): string;\n    function execSync(command: string, options?: ExecSyncOptionsWithBufferEncoding): Buffer;\n    function execSync(command: string, options?: ExecSyncOptions): Buffer;\n\n    interface ExecFileSyncOptions extends CommonOptions {\n        input?: string | NodeJS.ArrayBufferView;\n        stdio?: StdioOptions;\n        killSignal?: NodeJS.Signals | number;\n        maxBuffer?: number;\n        encoding?: string;\n        shell?: boolean | string;\n    }\n    interface ExecFileSyncOptionsWithStringEncoding extends ExecFileSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecFileSyncOptionsWithBufferEncoding extends ExecFileSyncOptions {\n        encoding: string; // specify `null`.\n    }\n    function execFileSync(command: string): Buffer;\n    function execFileSync(command: string, options?: ExecFileSyncOptionsWithStringEncoding): string;\n    function execFileSync(command: string, options?: ExecFileSyncOptionsWithBufferEncoding): Buffer;\n    function execFileSync(command: string, options?: ExecFileSyncOptions): Buffer;\n    function execFileSync(command: string, args?: ReadonlyArray<string>, options?: ExecFileSyncOptionsWithStringEncoding): string;\n    function execFileSync(command: string, args?: ReadonlyArray<string>, options?: ExecFileSyncOptionsWithBufferEncoding): Buffer;\n    function execFileSync(command: string, args?: ReadonlyArray<string>, options?: ExecFileSyncOptions): Buffer;\n}\n\n\ndeclare module \"cluster\" {\n    import * as child from \"child_process\";\n    import * as events from \"events\";\n    import * as net from \"net\";\n\n    // interfaces\n    interface ClusterSettings {\n        execArgv?: string[]; // default: process.execArgv\n        exec?: string;\n        args?: string[];\n        silent?: boolean;\n        stdio?: any[];\n        uid?: number;\n        gid?: number;\n        inspectPort?: number | (() => number);\n    }\n\n    interface Address {\n        address: string;\n        port: number;\n        addressType: number | \"udp4\" | \"udp6\";  // 4, 6, -1, \"udp4\", \"udp6\"\n    }\n\n    class Worker extends events.EventEmitter {\n        id: number;\n        process: child.ChildProcess;\n        send(message: child.Serializable, sendHandle?: child.SendHandle, callback?: (error: Error | null) => void): boolean;\n        kill(signal?: string): void;\n        destroy(signal?: string): void;\n        disconnect(): void;\n        isConnected(): boolean;\n        isDead(): boolean;\n        exitedAfterDisconnect: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. disconnect\n         *   2. error\n         *   3. exit\n         *   4. listening\n         *   5. message\n         *   6. online\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"disconnect\", listener: () => void): this;\n        addListener(event: \"error\", listener: (error: Error) => void): this;\n        addListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        addListener(event: \"listening\", listener: (address: Address) => void): this;\n        addListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        addListener(event: \"online\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"disconnect\"): boolean;\n        emit(event: \"error\", error: Error): boolean;\n        emit(event: \"exit\", code: number, signal: string): boolean;\n        emit(event: \"listening\", address: Address): boolean;\n        emit(event: \"message\", message: any, handle: net.Socket | net.Server): boolean;\n        emit(event: \"online\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"disconnect\", listener: () => void): this;\n        on(event: \"error\", listener: (error: Error) => void): this;\n        on(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        on(event: \"listening\", listener: (address: Address) => void): this;\n        on(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        on(event: \"online\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"disconnect\", listener: () => void): this;\n        once(event: \"error\", listener: (error: Error) => void): this;\n        once(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        once(event: \"listening\", listener: (address: Address) => void): this;\n        once(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        once(event: \"online\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"disconnect\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\n        prependListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        prependListener(event: \"listening\", listener: (address: Address) => void): this;\n        prependListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        prependListener(event: \"online\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"disconnect\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\n        prependOnceListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        prependOnceListener(event: \"listening\", listener: (address: Address) => void): this;\n        prependOnceListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        prependOnceListener(event: \"online\", listener: () => void): this;\n    }\n\n    interface Cluster extends events.EventEmitter {\n        Worker: Worker;\n        disconnect(callback?: () => void): void;\n        fork(env?: any): Worker;\n        isMaster: boolean;\n        isWorker: boolean;\n        schedulingPolicy: number;\n        settings: ClusterSettings;\n        setupMaster(settings?: ClusterSettings): void;\n        worker?: Worker;\n        workers?: {\n            [index: string]: Worker | undefined\n        };\n\n        readonly SCHED_NONE: number;\n        readonly SCHED_RR: number;\n\n        /**\n         * events.EventEmitter\n         *   1. disconnect\n         *   2. exit\n         *   3. fork\n         *   4. listening\n         *   5. message\n         *   6. online\n         *   7. setup\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        addListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        addListener(event: \"fork\", listener: (worker: Worker) => void): this;\n        addListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        addListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        addListener(event: \"online\", listener: (worker: Worker) => void): this;\n        addListener(event: \"setup\", listener: (settings: ClusterSettings) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"disconnect\", worker: Worker): boolean;\n        emit(event: \"exit\", worker: Worker, code: number, signal: string): boolean;\n        emit(event: \"fork\", worker: Worker): boolean;\n        emit(event: \"listening\", worker: Worker, address: Address): boolean;\n        emit(event: \"message\", worker: Worker, message: any, handle: net.Socket | net.Server): boolean;\n        emit(event: \"online\", worker: Worker): boolean;\n        emit(event: \"setup\", settings: ClusterSettings): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        on(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        on(event: \"fork\", listener: (worker: Worker) => void): this;\n        on(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        on(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        on(event: \"online\", listener: (worker: Worker) => void): this;\n        on(event: \"setup\", listener: (settings: ClusterSettings) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        once(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        once(event: \"fork\", listener: (worker: Worker) => void): this;\n        once(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        once(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        once(event: \"online\", listener: (worker: Worker) => void): this;\n        once(event: \"setup\", listener: (settings: ClusterSettings) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        prependListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        prependListener(event: \"fork\", listener: (worker: Worker) => void): this;\n        prependListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        prependListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        prependListener(event: \"online\", listener: (worker: Worker) => void): this;\n        prependListener(event: \"setup\", listener: (settings: ClusterSettings) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        prependOnceListener(event: \"fork\", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        // the handle is a net.Socket or net.Server object, or undefined.\n        prependOnceListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;\n        prependOnceListener(event: \"online\", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: \"setup\", listener: (settings: ClusterSettings) => void): this;\n    }\n\n    const SCHED_NONE: number;\n    const SCHED_RR: number;\n\n    function disconnect(callback?: () => void): void;\n    function fork(env?: any): Worker;\n    const isMaster: boolean;\n    const isWorker: boolean;\n    let schedulingPolicy: number;\n    const settings: ClusterSettings;\n    function setupMaster(settings?: ClusterSettings): void;\n    const worker: Worker;\n    const workers: {\n        [index: string]: Worker | undefined\n    };\n\n    /**\n     * events.EventEmitter\n     *   1. disconnect\n     *   2. exit\n     *   3. fork\n     *   4. listening\n     *   5. message\n     *   6. online\n     *   7. setup\n     */\n    function addListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function addListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function addListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function addListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function addListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n     // the handle is a net.Socket or net.Server object, or undefined.\n    function addListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;\n    function addListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function addListener(event: \"setup\", listener: (settings: ClusterSettings) => void): Cluster;\n\n    function emit(event: string | symbol, ...args: any[]): boolean;\n    function emit(event: \"disconnect\", worker: Worker): boolean;\n    function emit(event: \"exit\", worker: Worker, code: number, signal: string): boolean;\n    function emit(event: \"fork\", worker: Worker): boolean;\n    function emit(event: \"listening\", worker: Worker, address: Address): boolean;\n    function emit(event: \"message\", worker: Worker, message: any, handle: net.Socket | net.Server): boolean;\n    function emit(event: \"online\", worker: Worker): boolean;\n    function emit(event: \"setup\", settings: ClusterSettings): boolean;\n\n    function on(event: string, listener: (...args: any[]) => void): Cluster;\n    function on(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function on(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function on(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function on(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n    function on(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\n    function on(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function on(event: \"setup\", listener: (settings: ClusterSettings) => void): Cluster;\n\n    function once(event: string, listener: (...args: any[]) => void): Cluster;\n    function once(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function once(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function once(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function once(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n    function once(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\n    function once(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function once(event: \"setup\", listener: (settings: ClusterSettings) => void): Cluster;\n\n    function removeListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function removeAllListeners(event?: string): Cluster;\n    function setMaxListeners(n: number): Cluster;\n    function getMaxListeners(): number;\n    function listeners(event: string): Function[];\n    function listenerCount(type: string): number;\n\n    function prependListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function prependListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function prependListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function prependListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function prependListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n     // the handle is a net.Socket or net.Server object, or undefined.\n    function prependListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;\n    function prependListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function prependListener(event: \"setup\", listener: (settings: ClusterSettings) => void): Cluster;\n\n    function prependOnceListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function prependOnceListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function prependOnceListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function prependOnceListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function prependOnceListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n     // the handle is a net.Socket or net.Server object, or undefined.\n    function prependOnceListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;\n    function prependOnceListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function prependOnceListener(event: \"setup\", listener: (settings: ClusterSettings) => void): Cluster;\n\n    function eventNames(): string[];\n}\n\n\ndeclare module \"console\" {\n    export = console;\n}\n\n\n/** @deprecated since v6.3.0 - use constants property exposed by the relevant module instead. */\ndeclare module \"constants\" {\n    import { constants as osConstants, SignalConstants } from 'os';\n    import { constants as cryptoConstants } from 'crypto';\n    import { constants as fsConstants } from 'fs';\n    const exp: typeof osConstants.errno & typeof osConstants.priority & SignalConstants & typeof cryptoConstants & typeof fsConstants;\n    export = exp;\n}\n\n\ndeclare module \"crypto\" {\n    import * as stream from \"stream\";\n\n    interface Certificate {\n        exportChallenge(spkac: BinaryLike): Buffer;\n        exportPublicKey(spkac: BinaryLike): Buffer;\n        verifySpkac(spkac: NodeJS.ArrayBufferView): boolean;\n    }\n    const Certificate: {\n        new(): Certificate;\n        (): Certificate;\n    };\n\n    namespace constants { // https://nodejs.org/dist/latest-v10.x/docs/api/crypto.html#crypto_crypto_constants\n        const OPENSSL_VERSION_NUMBER: number;\n\n        /** Applies multiple bug workarounds within OpenSSL. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html for detail. */\n        const SSL_OP_ALL: number;\n        /** Allows legacy insecure renegotiation between OpenSSL and unpatched clients or servers. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html. */\n        const SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: number;\n        /** Attempts to use the server's preferences instead of the client's when selecting a cipher. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html. */\n        const SSL_OP_CIPHER_SERVER_PREFERENCE: number;\n        /** Instructs OpenSSL to use Cisco's \"speshul\" version of DTLS_BAD_VER. */\n        const SSL_OP_CISCO_ANYCONNECT: number;\n        /** Instructs OpenSSL to turn on cookie exchange. */\n        const SSL_OP_COOKIE_EXCHANGE: number;\n        /** Instructs OpenSSL to add server-hello extension from an early version of the cryptopro draft. */\n        const SSL_OP_CRYPTOPRO_TLSEXT_BUG: number;\n        /** Instructs OpenSSL to disable a SSL 3.0/TLS 1.0 vulnerability workaround added in OpenSSL 0.9.6d. */\n        const SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: number;\n        /** Instructs OpenSSL to always use the tmp_rsa key when performing RSA operations. */\n        const SSL_OP_EPHEMERAL_RSA: number;\n        /** Allows initial connection to servers that do not support RI. */\n        const SSL_OP_LEGACY_SERVER_CONNECT: number;\n        const SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: number;\n        const SSL_OP_MICROSOFT_SESS_ID_BUG: number;\n        /** Instructs OpenSSL to disable the workaround for a man-in-the-middle protocol-version vulnerability in the SSL 2.0 server implementation. */\n        const SSL_OP_MSIE_SSLV2_RSA_PADDING: number;\n        const SSL_OP_NETSCAPE_CA_DN_BUG: number;\n        const SSL_OP_NETSCAPE_CHALLENGE_BUG: number;\n        const SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: number;\n        const SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: number;\n        /** Instructs OpenSSL to disable support for SSL/TLS compression. */\n        const SSL_OP_NO_COMPRESSION: number;\n        const SSL_OP_NO_QUERY_MTU: number;\n        /** Instructs OpenSSL to always start a new session when performing renegotiation. */\n        const SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: number;\n        const SSL_OP_NO_SSLv2: number;\n        const SSL_OP_NO_SSLv3: number;\n        const SSL_OP_NO_TICKET: number;\n        const SSL_OP_NO_TLSv1: number;\n        const SSL_OP_NO_TLSv1_1: number;\n        const SSL_OP_NO_TLSv1_2: number;\n        const SSL_OP_PKCS1_CHECK_1: number;\n        const SSL_OP_PKCS1_CHECK_2: number;\n        /** Instructs OpenSSL to always create a new key when using temporary/ephemeral DH parameters. */\n        const SSL_OP_SINGLE_DH_USE: number;\n        /** Instructs OpenSSL to always create a new key when using temporary/ephemeral ECDH parameters. */\n        const SSL_OP_SINGLE_ECDH_USE: number;\n        const SSL_OP_SSLEAY_080_CLIENT_DH_BUG: number;\n        const SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: number;\n        const SSL_OP_TLS_BLOCK_PADDING_BUG: number;\n        const SSL_OP_TLS_D5_BUG: number;\n        /** Instructs OpenSSL to disable version rollback attack detection. */\n        const SSL_OP_TLS_ROLLBACK_BUG: number;\n\n        const ENGINE_METHOD_RSA: number;\n        const ENGINE_METHOD_DSA: number;\n        const ENGINE_METHOD_DH: number;\n        const ENGINE_METHOD_RAND: number;\n        const ENGINE_METHOD_EC: number;\n        const ENGINE_METHOD_CIPHERS: number;\n        const ENGINE_METHOD_DIGESTS: number;\n        const ENGINE_METHOD_PKEY_METHS: number;\n        const ENGINE_METHOD_PKEY_ASN1_METHS: number;\n        const ENGINE_METHOD_ALL: number;\n        const ENGINE_METHOD_NONE: number;\n\n        const DH_CHECK_P_NOT_SAFE_PRIME: number;\n        const DH_CHECK_P_NOT_PRIME: number;\n        const DH_UNABLE_TO_CHECK_GENERATOR: number;\n        const DH_NOT_SUITABLE_GENERATOR: number;\n\n        const ALPN_ENABLED: number;\n\n        const RSA_PKCS1_PADDING: number;\n        const RSA_SSLV23_PADDING: number;\n        const RSA_NO_PADDING: number;\n        const RSA_PKCS1_OAEP_PADDING: number;\n        const RSA_X931_PADDING: number;\n        const RSA_PKCS1_PSS_PADDING: number;\n        /** Sets the salt length for RSA_PKCS1_PSS_PADDING to the digest size when signing or verifying. */\n        const RSA_PSS_SALTLEN_DIGEST: number;\n        /** Sets the salt length for RSA_PKCS1_PSS_PADDING to the maximum permissible value when signing data. */\n        const RSA_PSS_SALTLEN_MAX_SIGN: number;\n        /** Causes the salt length for RSA_PKCS1_PSS_PADDING to be determined automatically when verifying a signature. */\n        const RSA_PSS_SALTLEN_AUTO: number;\n\n        const POINT_CONVERSION_COMPRESSED: number;\n        const POINT_CONVERSION_UNCOMPRESSED: number;\n        const POINT_CONVERSION_HYBRID: number;\n\n        /** Specifies the built-in default cipher list used by Node.js (colon-separated values). */\n        const defaultCoreCipherList: string;\n        /** Specifies the active default cipher list used by the current Node.js process  (colon-separated values). */\n        const defaultCipherList: string;\n    }\n\n    interface HashOptions extends stream.TransformOptions {\n        /**\n         * For XOF hash functions such as `shake256`, the\n         * outputLength option can be used to specify the desired output length in bytes.\n         */\n        outputLength?: number;\n    }\n\n    /** @deprecated since v10.0.0 */\n    const fips: boolean;\n\n    function createHash(algorithm: string, options?: HashOptions): Hash;\n    function createHmac(algorithm: string, key: BinaryLike | KeyObject, options?: stream.TransformOptions): Hmac;\n\n    type Utf8AsciiLatin1Encoding = \"utf8\" | \"ascii\" | \"latin1\";\n    type HexBase64Latin1Encoding = \"latin1\" | \"hex\" | \"base64\";\n    type Utf8AsciiBinaryEncoding = \"utf8\" | \"ascii\" | \"binary\";\n    type HexBase64BinaryEncoding = \"binary\" | \"base64\" | \"hex\";\n    type ECDHKeyFormat = \"compressed\" | \"uncompressed\" | \"hybrid\";\n\n    class Hash extends stream.Transform {\n        private constructor();\n        copy(): Hash;\n        update(data: BinaryLike): Hash;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Hash;\n        digest(): Buffer;\n        digest(encoding: HexBase64Latin1Encoding): string;\n    }\n    class Hmac extends stream.Transform {\n        private constructor();\n        update(data: BinaryLike): Hmac;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Hmac;\n        digest(): Buffer;\n        digest(encoding: HexBase64Latin1Encoding): string;\n    }\n\n    type KeyObjectType = 'secret' | 'public' | 'private';\n\n    interface KeyExportOptions<T extends KeyFormat> {\n        type: 'pkcs1' | 'spki' | 'pkcs8' | 'sec1';\n        format: T;\n        cipher?: string;\n        passphrase?: string | Buffer;\n    }\n\n    class KeyObject {\n        private constructor();\n        asymmetricKeyType?: KeyType;\n        /**\n         * For asymmetric keys, this property represents the size of the embedded key in\n         * bytes. This property is `undefined` for symmetric keys.\n         */\n        asymmetricKeySize?: number;\n        export(options: KeyExportOptions<'pem'>): string | Buffer;\n        export(options?: KeyExportOptions<'der'>): Buffer;\n        symmetricKeySize?: number;\n        type: KeyObjectType;\n    }\n\n    type CipherCCMTypes = 'aes-128-ccm' | 'aes-192-ccm' | 'aes-256-ccm' | 'chacha20-poly1305';\n    type CipherGCMTypes = 'aes-128-gcm' | 'aes-192-gcm' | 'aes-256-gcm';\n\n    type BinaryLike = string | NodeJS.ArrayBufferView;\n\n    type CipherKey = BinaryLike | KeyObject;\n\n    interface CipherCCMOptions extends stream.TransformOptions {\n        authTagLength: number;\n    }\n    interface CipherGCMOptions extends stream.TransformOptions {\n        authTagLength?: number;\n    }\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createCipher(algorithm: CipherCCMTypes, password: BinaryLike, options: CipherCCMOptions): CipherCCM;\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createCipher(algorithm: CipherGCMTypes, password: BinaryLike, options?: CipherGCMOptions): CipherGCM;\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createCipher(algorithm: string, password: BinaryLike, options?: stream.TransformOptions): Cipher;\n\n    function createCipheriv(\n        algorithm: CipherCCMTypes,\n        key: CipherKey,\n        iv: BinaryLike | null,\n        options: CipherCCMOptions\n    ): CipherCCM;\n    function createCipheriv(\n        algorithm: CipherGCMTypes,\n        key: CipherKey,\n        iv: BinaryLike | null,\n        options?: CipherGCMOptions\n    ): CipherGCM;\n    function createCipheriv(\n        algorithm: string, key: CipherKey, iv: BinaryLike | null, options?: stream.TransformOptions\n    ): Cipher;\n\n    class Cipher extends stream.Transform {\n        private constructor();\n        update(data: BinaryLike): Buffer;\n        update(data: string, input_encoding: Utf8AsciiBinaryEncoding): Buffer;\n        update(data: NodeJS.ArrayBufferView, input_encoding: undefined, output_encoding: HexBase64BinaryEncoding): string;\n        update(data: string, input_encoding: Utf8AsciiBinaryEncoding | undefined, output_encoding: HexBase64BinaryEncoding): string;\n        final(): Buffer;\n        final(output_encoding: string): string;\n        setAutoPadding(auto_padding?: boolean): this;\n        // getAuthTag(): Buffer;\n        // setAAD(buffer: Buffer): this; // docs only say buffer\n    }\n    interface CipherCCM extends Cipher {\n        setAAD(buffer: Buffer, options: { plaintextLength: number }): this;\n        getAuthTag(): Buffer;\n    }\n    interface CipherGCM extends Cipher {\n        setAAD(buffer: Buffer, options?: { plaintextLength: number }): this;\n        getAuthTag(): Buffer;\n    }\n    /** @deprecated since v10.0.0 use createDecipheriv() */\n    function createDecipher(algorithm: CipherCCMTypes, password: BinaryLike, options: CipherCCMOptions): DecipherCCM;\n    /** @deprecated since v10.0.0 use createDecipheriv() */\n    function createDecipher(algorithm: CipherGCMTypes, password: BinaryLike, options?: CipherGCMOptions): DecipherGCM;\n    /** @deprecated since v10.0.0 use createDecipheriv() */\n    function createDecipher(algorithm: string, password: BinaryLike, options?: stream.TransformOptions): Decipher;\n\n    function createDecipheriv(\n        algorithm: CipherCCMTypes,\n        key: CipherKey,\n        iv: BinaryLike | null,\n        options: CipherCCMOptions,\n    ): DecipherCCM;\n    function createDecipheriv(\n        algorithm: CipherGCMTypes,\n        key: CipherKey,\n        iv: BinaryLike | null,\n        options?: CipherGCMOptions,\n    ): DecipherGCM;\n    function createDecipheriv(algorithm: string, key: CipherKey, iv: BinaryLike | null, options?: stream.TransformOptions): Decipher;\n\n    class Decipher extends stream.Transform {\n        private constructor();\n        update(data: NodeJS.ArrayBufferView): Buffer;\n        update(data: string, input_encoding: HexBase64BinaryEncoding): Buffer;\n        update(data: NodeJS.ArrayBufferView, input_encoding: HexBase64BinaryEncoding | undefined, output_encoding: Utf8AsciiBinaryEncoding): string;\n        update(data: string, input_encoding: HexBase64BinaryEncoding | undefined, output_encoding: Utf8AsciiBinaryEncoding): string;\n        final(): Buffer;\n        final(output_encoding: string): string;\n        setAutoPadding(auto_padding?: boolean): this;\n        // setAuthTag(tag: NodeJS.ArrayBufferView): this;\n        // setAAD(buffer: NodeJS.ArrayBufferView): this;\n    }\n    interface DecipherCCM extends Decipher {\n        setAuthTag(buffer: NodeJS.ArrayBufferView): this;\n        setAAD(buffer: NodeJS.ArrayBufferView, options: { plaintextLength: number }): this;\n    }\n    interface DecipherGCM extends Decipher {\n        setAuthTag(buffer: NodeJS.ArrayBufferView): this;\n        setAAD(buffer: NodeJS.ArrayBufferView, options?: { plaintextLength: number }): this;\n    }\n\n    interface PrivateKeyInput {\n        key: string | Buffer;\n        format?: KeyFormat;\n        type?: 'pkcs1' | 'pkcs8' | 'sec1';\n        passphrase?: string | Buffer;\n    }\n\n    interface PublicKeyInput {\n        key: string | Buffer;\n        format?: KeyFormat;\n        type?: 'pkcs1' | 'spki';\n    }\n\n    function createPrivateKey(key: PrivateKeyInput | string | Buffer): KeyObject;\n    function createPublicKey(key: PublicKeyInput | string | Buffer | KeyObject): KeyObject;\n    function createSecretKey(key: Buffer): KeyObject;\n\n    function createSign(algorithm: string, options?: stream.WritableOptions): Signer;\n\n    interface SigningOptions {\n        /**\n         * @See crypto.constants.RSA_PKCS1_PADDING\n         */\n        padding?: number;\n        saltLength?: number;\n    }\n\n    interface SignPrivateKeyInput extends PrivateKeyInput, SigningOptions {\n    }\n\n    type KeyLike = string | Buffer | KeyObject;\n\n    class Signer extends stream.Writable {\n        private constructor();\n\n        update(data: BinaryLike): Signer;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Signer;\n        sign(private_key: SignPrivateKeyInput | KeyLike): Buffer;\n        sign(private_key: SignPrivateKeyInput | KeyLike, output_format: HexBase64Latin1Encoding): string;\n    }\n\n    function createVerify(algorithm: string, options?: stream.WritableOptions): Verify;\n    class Verify extends stream.Writable {\n        private constructor();\n\n        update(data: BinaryLike): Verify;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Verify;\n        verify(object: object | KeyLike, signature: NodeJS.ArrayBufferView): boolean;\n        verify(object: object | KeyLike, signature: string, signature_format?: HexBase64Latin1Encoding): boolean;\n        // https://nodejs.org/api/crypto.html#crypto_verifier_verify_object_signature_signature_format\n        // The signature field accepts a TypedArray type, but it is only available starting ES2017\n    }\n    function createDiffieHellman(prime_length: number, generator?: number | NodeJS.ArrayBufferView): DiffieHellman;\n    function createDiffieHellman(prime: NodeJS.ArrayBufferView): DiffieHellman;\n    function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding): DiffieHellman;\n    function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding, generator: number | NodeJS.ArrayBufferView): DiffieHellman;\n    function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding, generator: string, generator_encoding: HexBase64Latin1Encoding): DiffieHellman;\n    class DiffieHellman {\n        private constructor();\n        generateKeys(): Buffer;\n        generateKeys(encoding: HexBase64Latin1Encoding): string;\n        computeSecret(other_public_key: NodeJS.ArrayBufferView): Buffer;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding): Buffer;\n        computeSecret(other_public_key: NodeJS.ArrayBufferView, output_encoding: HexBase64Latin1Encoding): string;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding, output_encoding: HexBase64Latin1Encoding): string;\n        getPrime(): Buffer;\n        getPrime(encoding: HexBase64Latin1Encoding): string;\n        getGenerator(): Buffer;\n        getGenerator(encoding: HexBase64Latin1Encoding): string;\n        getPublicKey(): Buffer;\n        getPublicKey(encoding: HexBase64Latin1Encoding): string;\n        getPrivateKey(): Buffer;\n        getPrivateKey(encoding: HexBase64Latin1Encoding): string;\n        setPublicKey(public_key: NodeJS.ArrayBufferView): void;\n        setPublicKey(public_key: string, encoding: string): void;\n        setPrivateKey(private_key: NodeJS.ArrayBufferView): void;\n        setPrivateKey(private_key: string, encoding: string): void;\n        verifyError: number;\n    }\n    function getDiffieHellman(group_name: string): DiffieHellman;\n    function pbkdf2(\n        password: BinaryLike,\n        salt: BinaryLike,\n        iterations: number,\n        keylen: number,\n        digest: string,\n        callback: (err: Error | null, derivedKey: Buffer) => any,\n    ): void;\n    function pbkdf2Sync(password: BinaryLike, salt: BinaryLike, iterations: number, keylen: number, digest: string): Buffer;\n\n    function randomBytes(size: number): Buffer;\n    function randomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;\n    function pseudoRandomBytes(size: number): Buffer;\n    function pseudoRandomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;\n\n    function randomFillSync<T extends NodeJS.ArrayBufferView>(buffer: T, offset?: number, size?: number): T;\n    function randomFill<T extends NodeJS.ArrayBufferView>(buffer: T, callback: (err: Error | null, buf: T) => void): void;\n    function randomFill<T extends NodeJS.ArrayBufferView>(buffer: T, offset: number, callback: (err: Error | null, buf: T) => void): void;\n    function randomFill<T extends NodeJS.ArrayBufferView>(buffer: T, offset: number, size: number, callback: (err: Error | null, buf: T) => void): void;\n\n    interface ScryptOptions {\n        N?: number;\n        r?: number;\n        p?: number;\n        maxmem?: number;\n    }\n    function scrypt(\n        password: BinaryLike,\n        salt: BinaryLike,\n        keylen: number, callback: (err: Error | null, derivedKey: Buffer) => void,\n    ): void;\n    function scrypt(\n        password: BinaryLike,\n        salt: BinaryLike,\n        keylen: number,\n        options: ScryptOptions,\n        callback: (err: Error | null, derivedKey: Buffer) => void,\n    ): void;\n    function scryptSync(password: BinaryLike, salt: BinaryLike, keylen: number, options?: ScryptOptions): Buffer;\n\n    interface RsaPublicKey {\n        key: KeyLike;\n        padding?: number;\n    }\n    interface RsaPrivateKey {\n        key: KeyLike;\n        passphrase?: string;\n        /**\n         * @default 'sha1'\n         */\n        oaepHash?: string;\n        oaepLabel?: NodeJS.TypedArray;\n        padding?: number;\n    }\n    function publicEncrypt(key: RsaPublicKey | RsaPrivateKey | KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;\n    function publicDecrypt(key: RsaPublicKey | RsaPrivateKey | KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;\n    function privateDecrypt(private_key: RsaPrivateKey | KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;\n    function privateEncrypt(private_key: RsaPrivateKey | KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;\n    function getCiphers(): string[];\n    function getCurves(): string[];\n    function getHashes(): string[];\n    class ECDH {\n        private constructor();\n        static convertKey(\n            key: BinaryLike,\n            curve: string,\n            inputEncoding?: HexBase64Latin1Encoding,\n            outputEncoding?: \"latin1\" | \"hex\" | \"base64\",\n            format?: \"uncompressed\" | \"compressed\" | \"hybrid\",\n        ): Buffer | string;\n        generateKeys(): Buffer;\n        generateKeys(encoding: HexBase64Latin1Encoding, format?: ECDHKeyFormat): string;\n        computeSecret(other_public_key: NodeJS.ArrayBufferView): Buffer;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding): Buffer;\n        computeSecret(other_public_key: NodeJS.ArrayBufferView, output_encoding: HexBase64Latin1Encoding): string;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding, output_encoding: HexBase64Latin1Encoding): string;\n        getPrivateKey(): Buffer;\n        getPrivateKey(encoding: HexBase64Latin1Encoding): string;\n        getPublicKey(): Buffer;\n        getPublicKey(encoding: HexBase64Latin1Encoding, format?: ECDHKeyFormat): string;\n        setPrivateKey(private_key: NodeJS.ArrayBufferView): void;\n        setPrivateKey(private_key: string, encoding: HexBase64Latin1Encoding): void;\n    }\n    function createECDH(curve_name: string): ECDH;\n    function timingSafeEqual(a: NodeJS.ArrayBufferView, b: NodeJS.ArrayBufferView): boolean;\n    /** @deprecated since v10.0.0 */\n    const DEFAULT_ENCODING: string;\n\n    type KeyType = 'rsa' | 'dsa' | 'ec';\n    type KeyFormat = 'pem' | 'der';\n\n    interface BasePrivateKeyEncodingOptions<T extends KeyFormat> {\n        format: T;\n        cipher?: string;\n        passphrase?: string;\n    }\n\n    interface KeyPairKeyObjectResult {\n        publicKey: KeyObject;\n        privateKey: KeyObject;\n    }\n\n    interface ECKeyPairKeyObjectOptions {\n        /**\n         * Name of the curve to use.\n         */\n        namedCurve: string;\n    }\n\n    interface RSAKeyPairKeyObjectOptions {\n        /**\n         * Key size in bits\n         */\n        modulusLength: number;\n\n        /**\n         * @default 0x10001\n         */\n        publicExponent?: number;\n    }\n\n    interface DSAKeyPairKeyObjectOptions {\n        /**\n         * Key size in bits\n         */\n        modulusLength: number;\n\n        /**\n         * Size of q in bits\n         */\n        divisorLength: number;\n    }\n\n    interface RSAKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {\n        /**\n         * Key size in bits\n         */\n        modulusLength: number;\n        /**\n         * @default 0x10001\n         */\n        publicExponent?: number;\n\n        publicKeyEncoding: {\n            type: 'pkcs1' | 'spki';\n            format: PubF;\n        };\n        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {\n            type: 'pkcs1' | 'pkcs8';\n        };\n    }\n\n    interface DSAKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {\n        /**\n         * Key size in bits\n         */\n        modulusLength: number;\n        /**\n         * Size of q in bits\n         */\n        divisorLength: number;\n\n        publicKeyEncoding: {\n            type: 'spki';\n            format: PubF;\n        };\n        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {\n            type: 'pkcs8';\n        };\n    }\n\n    interface ECKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {\n        /**\n         * Name of the curve to use.\n         */\n        namedCurve: string;\n\n        publicKeyEncoding: {\n            type: 'pkcs1' | 'spki';\n            format: PubF;\n        };\n        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {\n            type: 'sec1' | 'pkcs8';\n        };\n    }\n\n    interface KeyPairSyncResult<T1 extends string | Buffer, T2 extends string | Buffer> {\n        publicKey: T1;\n        privateKey: T2;\n    }\n\n    function generateKeyPairSync(type: 'rsa', options: RSAKeyPairOptions<'pem', 'pem'>): KeyPairSyncResult<string, string>;\n    function generateKeyPairSync(type: 'rsa', options: RSAKeyPairOptions<'pem', 'der'>): KeyPairSyncResult<string, Buffer>;\n    function generateKeyPairSync(type: 'rsa', options: RSAKeyPairOptions<'der', 'pem'>): KeyPairSyncResult<Buffer, string>;\n    function generateKeyPairSync(type: 'rsa', options: RSAKeyPairOptions<'der', 'der'>): KeyPairSyncResult<Buffer, Buffer>;\n    function generateKeyPairSync(type: 'rsa', options: RSAKeyPairKeyObjectOptions): KeyPairKeyObjectResult;\n\n    function generateKeyPairSync(type: 'dsa', options: DSAKeyPairOptions<'pem', 'pem'>): KeyPairSyncResult<string, string>;\n    function generateKeyPairSync(type: 'dsa', options: DSAKeyPairOptions<'pem', 'der'>): KeyPairSyncResult<string, Buffer>;\n    function generateKeyPairSync(type: 'dsa', options: DSAKeyPairOptions<'der', 'pem'>): KeyPairSyncResult<Buffer, string>;\n    function generateKeyPairSync(type: 'dsa', options: DSAKeyPairOptions<'der', 'der'>): KeyPairSyncResult<Buffer, Buffer>;\n    function generateKeyPairSync(type: 'dsa', options: DSAKeyPairKeyObjectOptions): KeyPairKeyObjectResult;\n\n    function generateKeyPairSync(type: 'ec', options: ECKeyPairOptions<'pem', 'pem'>): KeyPairSyncResult<string, string>;\n    function generateKeyPairSync(type: 'ec', options: ECKeyPairOptions<'pem', 'der'>): KeyPairSyncResult<string, Buffer>;\n    function generateKeyPairSync(type: 'ec', options: ECKeyPairOptions<'der', 'pem'>): KeyPairSyncResult<Buffer, string>;\n    function generateKeyPairSync(type: 'ec', options: ECKeyPairOptions<'der', 'der'>): KeyPairSyncResult<Buffer, Buffer>;\n    function generateKeyPairSync(type: 'ec', options: ECKeyPairKeyObjectOptions): KeyPairKeyObjectResult;\n\n    function generateKeyPair(type: 'rsa', options: RSAKeyPairOptions<'pem', 'pem'>, callback: (err: Error | null, publicKey: string, privateKey: string) => void): void;\n    function generateKeyPair(type: 'rsa', options: RSAKeyPairOptions<'pem', 'der'>, callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void): void;\n    function generateKeyPair(type: 'rsa', options: RSAKeyPairOptions<'der', 'pem'>, callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void): void;\n    function generateKeyPair(type: 'rsa', options: RSAKeyPairOptions<'der', 'der'>, callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void): void;\n    function generateKeyPair(type: 'rsa', options: RSAKeyPairKeyObjectOptions, callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void): void;\n\n    function generateKeyPair(type: 'dsa', options: DSAKeyPairOptions<'pem', 'pem'>, callback: (err: Error | null, publicKey: string, privateKey: string) => void): void;\n    function generateKeyPair(type: 'dsa', options: DSAKeyPairOptions<'pem', 'der'>, callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void): void;\n    function generateKeyPair(type: 'dsa', options: DSAKeyPairOptions<'der', 'pem'>, callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void): void;\n    function generateKeyPair(type: 'dsa', options: DSAKeyPairOptions<'der', 'der'>, callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void): void;\n    function generateKeyPair(type: 'dsa', options: DSAKeyPairKeyObjectOptions, callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void): void;\n\n    function generateKeyPair(type: 'ec', options: ECKeyPairOptions<'pem', 'pem'>, callback: (err: Error | null, publicKey: string, privateKey: string) => void): void;\n    function generateKeyPair(type: 'ec', options: ECKeyPairOptions<'pem', 'der'>, callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void): void;\n    function generateKeyPair(type: 'ec', options: ECKeyPairOptions<'der', 'pem'>, callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void): void;\n    function generateKeyPair(type: 'ec', options: ECKeyPairOptions<'der', 'der'>, callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void): void;\n    function generateKeyPair(type: 'ec', options: ECKeyPairKeyObjectOptions, callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void): void;\n\n    namespace generateKeyPair {\n        function __promisify__(type: \"rsa\", options: RSAKeyPairOptions<'pem', 'pem'>): Promise<{ publicKey: string, privateKey: string }>;\n        function __promisify__(type: \"rsa\", options: RSAKeyPairOptions<'pem', 'der'>): Promise<{ publicKey: string, privateKey: Buffer }>;\n        function __promisify__(type: \"rsa\", options: RSAKeyPairOptions<'der', 'pem'>): Promise<{ publicKey: Buffer, privateKey: string }>;\n        function __promisify__(type: \"rsa\", options: RSAKeyPairOptions<'der', 'der'>): Promise<{ publicKey: Buffer, privateKey: Buffer }>;\n        function __promisify__(type: \"rsa\", options: RSAKeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;\n\n        function __promisify__(type: \"dsa\", options: DSAKeyPairOptions<'pem', 'pem'>): Promise<{ publicKey: string, privateKey: string }>;\n        function __promisify__(type: \"dsa\", options: DSAKeyPairOptions<'pem', 'der'>): Promise<{ publicKey: string, privateKey: Buffer }>;\n        function __promisify__(type: \"dsa\", options: DSAKeyPairOptions<'der', 'pem'>): Promise<{ publicKey: Buffer, privateKey: string }>;\n        function __promisify__(type: \"dsa\", options: DSAKeyPairOptions<'der', 'der'>): Promise<{ publicKey: Buffer, privateKey: Buffer }>;\n        function __promisify__(type: \"dsa\", options: DSAKeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;\n\n        function __promisify__(type: \"ec\", options: ECKeyPairOptions<'pem', 'pem'>): Promise<{ publicKey: string, privateKey: string }>;\n        function __promisify__(type: \"ec\", options: ECKeyPairOptions<'pem', 'der'>): Promise<{ publicKey: string, privateKey: Buffer }>;\n        function __promisify__(type: \"ec\", options: ECKeyPairOptions<'der', 'pem'>): Promise<{ publicKey: Buffer, privateKey: string }>;\n        function __promisify__(type: \"ec\", options: ECKeyPairOptions<'der', 'der'>): Promise<{ publicKey: Buffer, privateKey: Buffer }>;\n        function __promisify__(type: \"ec\", options: ECKeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;\n    }\n\n    /**\n     * Calculates and returns the signature for `data` using the given private key and\n     * algorithm. If `algorithm` is `null` or `undefined`, then the algorithm is\n     * dependent upon the key type (especially Ed25519 and Ed448).\n     *\n     * If `key` is not a [`KeyObject`][], this function behaves as if `key` had been\n     * passed to [`crypto.createPrivateKey()`][].\n     */\n    function sign(algorithm: string | null | undefined, data: NodeJS.ArrayBufferView, key: KeyLike | SignPrivateKeyInput): Buffer;\n\n    interface VerifyKeyWithOptions extends KeyObject, SigningOptions {\n    }\n\n    /**\n     * Calculates and returns the signature for `data` using the given private key and\n     * algorithm. If `algorithm` is `null` or `undefined`, then the algorithm is\n     * dependent upon the key type (especially Ed25519 and Ed448).\n     *\n     * If `key` is not a [`KeyObject`][], this function behaves as if `key` had been\n     * passed to [`crypto.createPublicKey()`][].\n     */\n    function verify(algorithm: string | null | undefined, data: NodeJS.ArrayBufferView, key: KeyLike | VerifyKeyWithOptions, signature: NodeJS.ArrayBufferView): boolean;\n}\n\n\ndeclare module \"dgram\" {\n    import { AddressInfo } from \"net\";\n    import * as dns from \"dns\";\n    import * as events from \"events\";\n\n    interface RemoteInfo {\n        address: string;\n        family: 'IPv4' | 'IPv6';\n        port: number;\n        size: number;\n    }\n\n    interface BindOptions {\n        port?: number;\n        address?: string;\n        exclusive?: boolean;\n        fd?: number;\n    }\n\n    type SocketType = \"udp4\" | \"udp6\";\n\n    interface SocketOptions {\n        type: SocketType;\n        reuseAddr?: boolean;\n        /**\n         * @default false\n         */\n        ipv6Only?: boolean;\n        recvBufferSize?: number;\n        sendBufferSize?: number;\n        lookup?: (hostname: string, options: dns.LookupOneOptions, callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void) => void;\n    }\n\n    function createSocket(type: SocketType, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;\n    function createSocket(options: SocketOptions, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;\n\n    class Socket extends events.EventEmitter {\n        addMembership(multicastAddress: string, multicastInterface?: string): void;\n        address(): AddressInfo;\n        bind(port?: number, address?: string, callback?: () => void): void;\n        bind(port?: number, callback?: () => void): void;\n        bind(callback?: () => void): void;\n        bind(options: BindOptions, callback?: () => void): void;\n        close(callback?: () => void): void;\n        connect(port: number, address?: string, callback?: () => void): void;\n        connect(port: number, callback: () => void): void;\n        disconnect(): void;\n        dropMembership(multicastAddress: string, multicastInterface?: string): void;\n        getRecvBufferSize(): number;\n        getSendBufferSize(): number;\n        ref(): this;\n        remoteAddress(): AddressInfo;\n        send(msg: string | Uint8Array | any[], port?: number, address?: string, callback?: (error: Error | null, bytes: number) => void): void;\n        send(msg: string | Uint8Array | any[], port?: number, callback?: (error: Error | null, bytes: number) => void): void;\n        send(msg: string | Uint8Array | any[], callback?: (error: Error | null, bytes: number) => void): void;\n        send(msg: string | Uint8Array, offset: number, length: number, port?: number, address?: string, callback?: (error: Error | null, bytes: number) => void): void;\n        send(msg: string | Uint8Array, offset: number, length: number, port?: number, callback?: (error: Error | null, bytes: number) => void): void;\n        send(msg: string | Uint8Array, offset: number, length: number, callback?: (error: Error | null, bytes: number) => void): void;\n        setBroadcast(flag: boolean): void;\n        setMulticastInterface(multicastInterface: string): void;\n        setMulticastLoopback(flag: boolean): void;\n        setMulticastTTL(ttl: number): void;\n        setRecvBufferSize(size: number): void;\n        setSendBufferSize(size: number): void;\n        setTTL(ttl: number): void;\n        unref(): this;\n        /**\n         * Tells the kernel to join a source-specific multicast channel at the given\n         * `sourceAddress` and `groupAddress`, using the `multicastInterface` with the\n         * `IP_ADD_SOURCE_MEMBERSHIP` socket option.\n         * If the `multicastInterface` argument\n         * is not specified, the operating system will choose one interface and will add\n         * membership to it.\n         * To add membership to every available interface, call\n         * `socket.addSourceSpecificMembership()` multiple times, once per interface.\n         */\n        addSourceSpecificMembership(sourceAddress: string, groupAddress: string, multicastInterface?: string): void;\n\n        /**\n         * Instructs the kernel to leave a source-specific multicast channel at the given\n         * `sourceAddress` and `groupAddress` using the `IP_DROP_SOURCE_MEMBERSHIP`\n         * socket option. This method is automatically called by the kernel when the\n         * socket is closed or the process terminates, so most apps will never have\n         * reason to call this.\n         *\n         * If `multicastInterface` is not specified, the operating system will attempt to\n         * drop membership on all valid interfaces.\n         */\n        dropSourceSpecificMembership(sourceAddress: string, groupAddress: string, multicastInterface?: string): void;\n\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. connect\n         * 3. error\n         * 4. listening\n         * 5. message\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"connect\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"listening\", listener: () => void): this;\n        addListener(event: \"message\", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"connect\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"listening\"): boolean;\n        emit(event: \"message\", msg: Buffer, rinfo: RemoteInfo): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"connect\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"listening\", listener: () => void): this;\n        on(event: \"message\", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"connect\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"listening\", listener: () => void): this;\n        once(event: \"message\", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"connect\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"listening\", listener: () => void): this;\n        prependListener(event: \"message\", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"connect\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"listening\", listener: () => void): this;\n        prependOnceListener(event: \"message\", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;\n    }\n}\n\n\ndeclare module \"dns\" {\n    // Supported getaddrinfo flags.\n    const ADDRCONFIG: number;\n    const V4MAPPED: number;\n\n    interface LookupOptions {\n        family?: number;\n        hints?: number;\n        all?: boolean;\n        verbatim?: boolean;\n    }\n\n    interface LookupOneOptions extends LookupOptions {\n        all?: false;\n    }\n\n    interface LookupAllOptions extends LookupOptions {\n        all: true;\n    }\n\n    interface LookupAddress {\n        address: string;\n        family: number;\n    }\n\n    function lookup(hostname: string, family: number, callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void): void;\n    function lookup(hostname: string, options: LookupOneOptions, callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void): void;\n    function lookup(hostname: string, options: LookupAllOptions, callback: (err: NodeJS.ErrnoException | null, addresses: LookupAddress[]) => void): void;\n    function lookup(hostname: string, options: LookupOptions, callback: (err: NodeJS.ErrnoException | null, address: string | LookupAddress[], family: number) => void): void;\n    function lookup(hostname: string, callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lookup {\n        function __promisify__(hostname: string, options: LookupAllOptions): Promise<LookupAddress[]>;\n        function __promisify__(hostname: string, options?: LookupOneOptions | number): Promise<LookupAddress>;\n        function __promisify__(hostname: string, options: LookupOptions): Promise<LookupAddress | LookupAddress[]>;\n    }\n\n    function lookupService(address: string, port: number, callback: (err: NodeJS.ErrnoException | null, hostname: string, service: string) => void): void;\n\n    namespace lookupService {\n        function __promisify__(address: string, port: number): Promise<{ hostname: string, service: string }>;\n    }\n\n    interface ResolveOptions {\n        ttl: boolean;\n    }\n\n    interface ResolveWithTtlOptions extends ResolveOptions {\n        ttl: true;\n    }\n\n    interface RecordWithTtl {\n        address: string;\n        ttl: number;\n    }\n\n    /** @deprecated Use AnyARecord or AnyAaaaRecord instead. */\n    type AnyRecordWithTtl = AnyARecord | AnyAaaaRecord;\n\n    interface AnyARecord extends RecordWithTtl {\n        type: \"A\";\n    }\n\n    interface AnyAaaaRecord extends RecordWithTtl {\n        type: \"AAAA\";\n    }\n\n    interface MxRecord {\n        priority: number;\n        exchange: string;\n    }\n\n    interface AnyMxRecord extends MxRecord {\n        type: \"MX\";\n    }\n\n    interface NaptrRecord {\n        flags: string;\n        service: string;\n        regexp: string;\n        replacement: string;\n        order: number;\n        preference: number;\n    }\n\n    interface AnyNaptrRecord extends NaptrRecord {\n        type: \"NAPTR\";\n    }\n\n    interface SoaRecord {\n        nsname: string;\n        hostmaster: string;\n        serial: number;\n        refresh: number;\n        retry: number;\n        expire: number;\n        minttl: number;\n    }\n\n    interface AnySoaRecord extends SoaRecord {\n        type: \"SOA\";\n    }\n\n    interface SrvRecord {\n        priority: number;\n        weight: number;\n        port: number;\n        name: string;\n    }\n\n    interface AnySrvRecord extends SrvRecord {\n        type: \"SRV\";\n    }\n\n    interface AnyTxtRecord {\n        type: \"TXT\";\n        entries: string[];\n    }\n\n    interface AnyNsRecord {\n        type: \"NS\";\n        value: string;\n    }\n\n    interface AnyPtrRecord {\n        type: \"PTR\";\n        value: string;\n    }\n\n    interface AnyCnameRecord {\n        type: \"CNAME\";\n        value: string;\n    }\n\n    type AnyRecord = AnyARecord |\n        AnyAaaaRecord |\n        AnyCnameRecord |\n        AnyMxRecord |\n        AnyNaptrRecord |\n        AnyNsRecord |\n        AnyPtrRecord |\n        AnySoaRecord |\n        AnySrvRecord |\n        AnyTxtRecord;\n\n    function resolve(hostname: string, callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"A\", callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"AAAA\", callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"ANY\", callback: (err: NodeJS.ErrnoException | null, addresses: AnyRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: \"CNAME\", callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"MX\", callback: (err: NodeJS.ErrnoException | null, addresses: MxRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: \"NAPTR\", callback: (err: NodeJS.ErrnoException | null, addresses: NaptrRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: \"NS\", callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"PTR\", callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"SOA\", callback: (err: NodeJS.ErrnoException | null, addresses: SoaRecord) => void): void;\n    function resolve(hostname: string, rrtype: \"SRV\", callback: (err: NodeJS.ErrnoException | null, addresses: SrvRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: \"TXT\", callback: (err: NodeJS.ErrnoException | null, addresses: string[][]) => void): void;\n    function resolve(\n        hostname: string,\n        rrtype: string,\n        callback: (err: NodeJS.ErrnoException | null, addresses: string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][] | AnyRecord[]) => void,\n    ): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace resolve {\n        function __promisify__(hostname: string, rrtype?: \"A\" | \"AAAA\" | \"CNAME\" | \"NS\" | \"PTR\"): Promise<string[]>;\n        function __promisify__(hostname: string, rrtype: \"ANY\"): Promise<AnyRecord[]>;\n        function __promisify__(hostname: string, rrtype: \"MX\"): Promise<MxRecord[]>;\n        function __promisify__(hostname: string, rrtype: \"NAPTR\"): Promise<NaptrRecord[]>;\n        function __promisify__(hostname: string, rrtype: \"SOA\"): Promise<SoaRecord>;\n        function __promisify__(hostname: string, rrtype: \"SRV\"): Promise<SrvRecord[]>;\n        function __promisify__(hostname: string, rrtype: \"TXT\"): Promise<string[][]>;\n        function __promisify__(hostname: string, rrtype: string): Promise<string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][] | AnyRecord[]>;\n    }\n\n    function resolve4(hostname: string, callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void): void;\n    function resolve4(hostname: string, options: ResolveWithTtlOptions, callback: (err: NodeJS.ErrnoException | null, addresses: RecordWithTtl[]) => void): void;\n    function resolve4(hostname: string, options: ResolveOptions, callback: (err: NodeJS.ErrnoException | null, addresses: string[] | RecordWithTtl[]) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace resolve4 {\n        function __promisify__(hostname: string): Promise<string[]>;\n        function __promisify__(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;\n        function __promisify__(hostname: string, options?: ResolveOptions): Promise<string[] | RecordWithTtl[]>;\n    }\n\n    function resolve6(hostname: string, callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void): void;\n    function resolve6(hostname: string, options: ResolveWithTtlOptions, callback: (err: NodeJS.ErrnoException | null, addresses: RecordWithTtl[]) => void): void;\n    function resolve6(hostname: string, options: ResolveOptions, callback: (err: NodeJS.ErrnoException | null, addresses: string[] | RecordWithTtl[]) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace resolve6 {\n        function __promisify__(hostname: string): Promise<string[]>;\n        function __promisify__(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;\n        function __promisify__(hostname: string, options?: ResolveOptions): Promise<string[] | RecordWithTtl[]>;\n    }\n\n    function resolveCname(hostname: string, callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void): void;\n    namespace resolveCname {\n        function __promisify__(hostname: string): Promise<string[]>;\n    }\n\n    function resolveMx(hostname: string, callback: (err: NodeJS.ErrnoException | null, addresses: MxRecord[]) => void): void;\n    namespace resolveMx {\n        function __promisify__(hostname: string): Promise<MxRecord[]>;\n    }\n\n    function resolveNaptr(hostname: string, callback: (err: NodeJS.ErrnoException | null, addresses: NaptrRecord[]) => void): void;\n    namespace resolveNaptr {\n        function __promisify__(hostname: string): Promise<NaptrRecord[]>;\n    }\n\n    function resolveNs(hostname: string, callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void): void;\n    namespace resolveNs {\n        function __promisify__(hostname: string): Promise<string[]>;\n    }\n\n    function resolvePtr(hostname: string, callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void): void;\n    namespace resolvePtr {\n        function __promisify__(hostname: string): Promise<string[]>;\n    }\n\n    function resolveSoa(hostname: string, callback: (err: NodeJS.ErrnoException | null, address: SoaRecord) => void): void;\n    namespace resolveSoa {\n        function __promisify__(hostname: string): Promise<SoaRecord>;\n    }\n\n    function resolveSrv(hostname: string, callback: (err: NodeJS.ErrnoException | null, addresses: SrvRecord[]) => void): void;\n    namespace resolveSrv {\n        function __promisify__(hostname: string): Promise<SrvRecord[]>;\n    }\n\n    function resolveTxt(hostname: string, callback: (err: NodeJS.ErrnoException | null, addresses: string[][]) => void): void;\n    namespace resolveTxt {\n        function __promisify__(hostname: string): Promise<string[][]>;\n    }\n\n    function resolveAny(hostname: string, callback: (err: NodeJS.ErrnoException | null, addresses: AnyRecord[]) => void): void;\n    namespace resolveAny {\n        function __promisify__(hostname: string): Promise<AnyRecord[]>;\n    }\n\n    function reverse(ip: string, callback: (err: NodeJS.ErrnoException | null, hostnames: string[]) => void): void;\n    function setServers(servers: ReadonlyArray<string>): void;\n    function getServers(): string[];\n\n    // Error codes\n    const NODATA: string;\n    const FORMERR: string;\n    const SERVFAIL: string;\n    const NOTFOUND: string;\n    const NOTIMP: string;\n    const REFUSED: string;\n    const BADQUERY: string;\n    const BADNAME: string;\n    const BADFAMILY: string;\n    const BADRESP: string;\n    const CONNREFUSED: string;\n    const TIMEOUT: string;\n    const EOF: string;\n    const FILE: string;\n    const NOMEM: string;\n    const DESTRUCTION: string;\n    const BADSTR: string;\n    const BADFLAGS: string;\n    const NONAME: string;\n    const BADHINTS: string;\n    const NOTINITIALIZED: string;\n    const LOADIPHLPAPI: string;\n    const ADDRGETNETWORKPARAMS: string;\n    const CANCELLED: string;\n\n    class Resolver {\n        getServers: typeof getServers;\n        setServers: typeof setServers;\n        resolve: typeof resolve;\n        resolve4: typeof resolve4;\n        resolve6: typeof resolve6;\n        resolveAny: typeof resolveAny;\n        resolveCname: typeof resolveCname;\n        resolveMx: typeof resolveMx;\n        resolveNaptr: typeof resolveNaptr;\n        resolveNs: typeof resolveNs;\n        resolvePtr: typeof resolvePtr;\n        resolveSoa: typeof resolveSoa;\n        resolveSrv: typeof resolveSrv;\n        resolveTxt: typeof resolveTxt;\n        reverse: typeof reverse;\n        cancel(): void;\n    }\n\n    namespace promises {\n        function getServers(): string[];\n\n        function lookup(hostname: string, family: number): Promise<LookupAddress>;\n        function lookup(hostname: string, options: LookupOneOptions): Promise<LookupAddress>;\n        function lookup(hostname: string, options: LookupAllOptions): Promise<LookupAddress[]>;\n        function lookup(hostname: string, options: LookupOptions): Promise<LookupAddress | LookupAddress[]>;\n        function lookup(hostname: string): Promise<LookupAddress>;\n\n        function lookupService(address: string, port: number): Promise<{ hostname: string, service: string }>;\n\n        function resolve(hostname: string): Promise<string[]>;\n        function resolve(hostname: string, rrtype: \"A\"): Promise<string[]>;\n        function resolve(hostname: string, rrtype: \"AAAA\"): Promise<string[]>;\n        function resolve(hostname: string, rrtype: \"ANY\"): Promise<AnyRecord[]>;\n        function resolve(hostname: string, rrtype: \"CNAME\"): Promise<string[]>;\n        function resolve(hostname: string, rrtype: \"MX\"): Promise<MxRecord[]>;\n        function resolve(hostname: string, rrtype: \"NAPTR\"): Promise<NaptrRecord[]>;\n        function resolve(hostname: string, rrtype: \"NS\"): Promise<string[]>;\n        function resolve(hostname: string, rrtype: \"PTR\"): Promise<string[]>;\n        function resolve(hostname: string, rrtype: \"SOA\"): Promise<SoaRecord>;\n        function resolve(hostname: string, rrtype: \"SRV\"): Promise<SrvRecord[]>;\n        function resolve(hostname: string, rrtype: \"TXT\"): Promise<string[][]>;\n        function resolve(hostname: string, rrtype: string): Promise<string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][] | AnyRecord[]>;\n\n        function resolve4(hostname: string): Promise<string[]>;\n        function resolve4(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;\n        function resolve4(hostname: string, options: ResolveOptions): Promise<string[] | RecordWithTtl[]>;\n\n        function resolve6(hostname: string): Promise<string[]>;\n        function resolve6(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;\n        function resolve6(hostname: string, options: ResolveOptions): Promise<string[] | RecordWithTtl[]>;\n\n        function resolveAny(hostname: string): Promise<AnyRecord[]>;\n\n        function resolveCname(hostname: string): Promise<string[]>;\n\n        function resolveMx(hostname: string): Promise<MxRecord[]>;\n\n        function resolveNaptr(hostname: string): Promise<NaptrRecord[]>;\n\n        function resolveNs(hostname: string): Promise<string[]>;\n\n        function resolvePtr(hostname: string): Promise<string[]>;\n\n        function resolveSoa(hostname: string): Promise<SoaRecord>;\n\n        function resolveSrv(hostname: string): Promise<SrvRecord[]>;\n\n        function resolveTxt(hostname: string): Promise<string[][]>;\n\n        function reverse(ip: string): Promise<string[]>;\n\n        function setServers(servers: ReadonlyArray<string>): void;\n\n        class Resolver {\n            getServers: typeof getServers;\n            resolve: typeof resolve;\n            resolve4: typeof resolve4;\n            resolve6: typeof resolve6;\n            resolveAny: typeof resolveAny;\n            resolveCname: typeof resolveCname;\n            resolveMx: typeof resolveMx;\n            resolveNaptr: typeof resolveNaptr;\n            resolveNs: typeof resolveNs;\n            resolvePtr: typeof resolvePtr;\n            resolveSoa: typeof resolveSoa;\n            resolveSrv: typeof resolveSrv;\n            resolveTxt: typeof resolveTxt;\n            reverse: typeof reverse;\n            setServers: typeof setServers;\n        }\n    }\n}\n\n\ndeclare module \"domain\" {\n    import { EventEmitter } from \"events\";\n\n    class Domain extends EventEmitter implements NodeJS.Domain {\n        run<T>(fn: (...args: any[]) => T, ...args: any[]): T;\n        add(emitter: EventEmitter | NodeJS.Timer): void;\n        remove(emitter: EventEmitter | NodeJS.Timer): void;\n        bind<T extends Function>(cb: T): T;\n        intercept<T extends Function>(cb: T): T;\n        members: Array<EventEmitter | NodeJS.Timer>;\n        enter(): void;\n        exit(): void;\n    }\n\n    function create(): Domain;\n}\n\n\ndeclare module \"events\" {\n    interface EventEmitterOptions {\n        /**\n         * Enables automatic capturing of promise rejection.\n         */\n        captureRejections?: boolean;\n    }\n\n    interface NodeEventTarget {\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    interface DOMEventTarget {\n        addEventListener(event: string, listener: (...args: any[]) => void, opts?: { once: boolean }): any;\n    }\n\n    namespace EventEmitter {\n        function once(emitter: NodeEventTarget, event: string | symbol): Promise<any[]>;\n        function once(emitter: DOMEventTarget, event: string): Promise<any[]>;\n        function on(emitter: EventEmitter, event: string): AsyncIterableIterator<any>;\n        const captureRejectionSymbol: unique symbol;\n\n        /**\n         * This symbol shall be used to install a listener for only monitoring `'error'`\n         * events. Listeners installed using this symbol are called before the regular\n         * `'error'` listeners are called.\n         *\n         * Installing a listener using this symbol does not change the behavior once an\n         * `'error'` event is emitted, therefore the process will still crash if no\n         * regular `'error'` listener is installed.\n         */\n        const errorMonitor: unique symbol;\n        /**\n         * Sets or gets the default captureRejection value for all emitters.\n         */\n        let captureRejections: boolean;\n\n        interface EventEmitter extends NodeJS.EventEmitter {\n        }\n\n        class EventEmitter {\n            constructor(options?: EventEmitterOptions);\n            /** @deprecated since v4.0.0 */\n            static listenerCount(emitter: EventEmitter, event: string | symbol): number;\n            static defaultMaxListeners: number;\n        }\n    }\n\n    export = EventEmitter;\n}\n\n\ndeclare module \"fs\" {\n    import * as stream from \"stream\";\n    import * as events from \"events\";\n    import { URL } from \"url\";\n\n    /**\n     * Valid types for path values in \"fs\".\n     */\n    type PathLike = string | Buffer | URL;\n\n    type NoParamCallback = (err: NodeJS.ErrnoException | null) => void;\n\n    interface StatsBase<T> {\n        isFile(): boolean;\n        isDirectory(): boolean;\n        isBlockDevice(): boolean;\n        isCharacterDevice(): boolean;\n        isSymbolicLink(): boolean;\n        isFIFO(): boolean;\n        isSocket(): boolean;\n\n        dev: T;\n        ino: T;\n        mode: T;\n        nlink: T;\n        uid: T;\n        gid: T;\n        rdev: T;\n        size: T;\n        blksize: T;\n        blocks: T;\n        atimeMs: T;\n        mtimeMs: T;\n        ctimeMs: T;\n        birthtimeMs: T;\n        atime: Date;\n        mtime: Date;\n        ctime: Date;\n        birthtime: Date;\n    }\n\n    interface Stats extends StatsBase<number> {\n    }\n\n    class Stats {\n    }\n\n    class Dirent {\n        isFile(): boolean;\n        isDirectory(): boolean;\n        isBlockDevice(): boolean;\n        isCharacterDevice(): boolean;\n        isSymbolicLink(): boolean;\n        isFIFO(): boolean;\n        isSocket(): boolean;\n        name: string;\n    }\n\n    /**\n     * A class representing a directory stream.\n     */\n    class Dir {\n        readonly path: string;\n\n        /**\n         * Asynchronously iterates over the directory via `readdir(3)` until all entries have been read.\n         */\n        [Symbol.asyncIterator](): AsyncIterableIterator<Dirent>;\n\n        /**\n         * Asynchronously close the directory's underlying resource handle.\n         * Subsequent reads will result in errors.\n         */\n        close(): Promise<void>;\n        close(cb: NoParamCallback): void;\n\n        /**\n         * Synchronously close the directory's underlying resource handle.\n         * Subsequent reads will result in errors.\n         */\n        closeSync(): void;\n\n        /**\n         * Asynchronously read the next directory entry via `readdir(3)` as an `Dirent`.\n         * After the read is completed, a value is returned that will be resolved with an `Dirent`, or `null` if there are no more directory entries to read.\n         * Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms.\n         */\n        read(): Promise<Dirent | null>;\n        read(cb: (err: NodeJS.ErrnoException | null, dirEnt: Dirent | null) => void): void;\n\n        /**\n         * Synchronously read the next directory entry via `readdir(3)` as a `Dirent`.\n         * If there are no more directory entries to read, null will be returned.\n         * Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms.\n         */\n        readSync(): Dirent;\n    }\n\n    interface FSWatcher extends events.EventEmitter {\n        close(): void;\n\n        /**\n         * events.EventEmitter\n         *   1. change\n         *   2. error\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        addListener(event: \"error\", listener: (error: Error) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        on(event: \"error\", listener: (error: Error) => void): this;\n        on(event: \"close\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        once(event: \"error\", listener: (error: Error) => void): this;\n        once(event: \"close\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n    }\n\n    class ReadStream extends stream.Readable {\n        close(): void;\n        bytesRead: number;\n        path: string | Buffer;\n        pending: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. open\n         *   2. close\n         *   3. ready\n         */\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        addListener(event: \"end\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"open\", listener: (fd: number) => void): this;\n        addListener(event: \"pause\", listener: () => void): this;\n        addListener(event: \"readable\", listener: () => void): this;\n        addListener(event: \"ready\", listener: () => void): this;\n        addListener(event: \"resume\", listener: () => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        on(event: \"end\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"open\", listener: (fd: number) => void): this;\n        on(event: \"pause\", listener: () => void): this;\n        on(event: \"readable\", listener: () => void): this;\n        on(event: \"ready\", listener: () => void): this;\n        on(event: \"resume\", listener: () => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        once(event: \"end\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"open\", listener: (fd: number) => void): this;\n        once(event: \"pause\", listener: () => void): this;\n        once(event: \"readable\", listener: () => void): this;\n        once(event: \"ready\", listener: () => void): this;\n        once(event: \"resume\", listener: () => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependListener(event: \"end\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"open\", listener: (fd: number) => void): this;\n        prependListener(event: \"pause\", listener: () => void): this;\n        prependListener(event: \"readable\", listener: () => void): this;\n        prependListener(event: \"ready\", listener: () => void): this;\n        prependListener(event: \"resume\", listener: () => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependOnceListener(event: \"end\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"open\", listener: (fd: number) => void): this;\n        prependOnceListener(event: \"pause\", listener: () => void): this;\n        prependOnceListener(event: \"readable\", listener: () => void): this;\n        prependOnceListener(event: \"ready\", listener: () => void): this;\n        prependOnceListener(event: \"resume\", listener: () => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    class WriteStream extends stream.Writable {\n        close(): void;\n        bytesWritten: number;\n        path: string | Buffer;\n        pending: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. open\n         *   2. close\n         *   3. ready\n         */\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"finish\", listener: () => void): this;\n        addListener(event: \"open\", listener: (fd: number) => void): this;\n        addListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: \"ready\", listener: () => void): this;\n        addListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"finish\", listener: () => void): this;\n        on(event: \"open\", listener: (fd: number) => void): this;\n        on(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        on(event: \"ready\", listener: () => void): this;\n        on(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"finish\", listener: () => void): this;\n        once(event: \"open\", listener: (fd: number) => void): this;\n        once(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        once(event: \"ready\", listener: () => void): this;\n        once(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"finish\", listener: () => void): this;\n        prependListener(event: \"open\", listener: (fd: number) => void): this;\n        prependListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: \"ready\", listener: () => void): this;\n        prependListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"finish\", listener: () => void): this;\n        prependOnceListener(event: \"open\", listener: (fd: number) => void): this;\n        prependOnceListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: \"ready\", listener: () => void): this;\n        prependOnceListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    /**\n     * Asynchronous rename(2) - Change the name or location of a file or directory.\n     * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function rename(oldPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace rename {\n        /**\n         * Asynchronous rename(2) - Change the name or location of a file or directory.\n         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(oldPath: PathLike, newPath: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous rename(2) - Change the name or location of a file or directory.\n     * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function renameSync(oldPath: PathLike, newPath: PathLike): void;\n\n    /**\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param len If not specified, defaults to `0`.\n     */\n    function truncate(path: PathLike, len: number | undefined | null, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function truncate(path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace truncate {\n        /**\n         * Asynchronous truncate(2) - Truncate a file to a specified length.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param len If not specified, defaults to `0`.\n         */\n        function __promisify__(path: PathLike, len?: number | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param len If not specified, defaults to `0`.\n     */\n    function truncateSync(path: PathLike, len?: number | null): void;\n\n    /**\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     * @param len If not specified, defaults to `0`.\n     */\n    function ftruncate(fd: number, len: number | undefined | null, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     */\n    function ftruncate(fd: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace ftruncate {\n        /**\n         * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n         * @param fd A file descriptor.\n         * @param len If not specified, defaults to `0`.\n         */\n        function __promisify__(fd: number, len?: number | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     * @param len If not specified, defaults to `0`.\n     */\n    function ftruncateSync(fd: number, len?: number | null): void;\n\n    /**\n     * Asynchronous chown(2) - Change ownership of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function chown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace chown {\n        /**\n         * Asynchronous chown(2) - Change ownership of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous chown(2) - Change ownership of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function chownSync(path: PathLike, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous fchown(2) - Change ownership of a file.\n     * @param fd A file descriptor.\n     */\n    function fchown(fd: number, uid: number, gid: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fchown {\n        /**\n         * Asynchronous fchown(2) - Change ownership of a file.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fchown(2) - Change ownership of a file.\n     * @param fd A file descriptor.\n     */\n    function fchownSync(fd: number, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lchown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lchown {\n        /**\n         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lchownSync(path: PathLike, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous chmod(2) - Change permissions of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function chmod(path: PathLike, mode: string | number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace chmod {\n        /**\n         * Asynchronous chmod(2) - Change permissions of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(path: PathLike, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous chmod(2) - Change permissions of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function chmodSync(path: PathLike, mode: string | number): void;\n\n    /**\n     * Asynchronous fchmod(2) - Change permissions of a file.\n     * @param fd A file descriptor.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function fchmod(fd: number, mode: string | number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fchmod {\n        /**\n         * Asynchronous fchmod(2) - Change permissions of a file.\n         * @param fd A file descriptor.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(fd: number, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fchmod(2) - Change permissions of a file.\n     * @param fd A file descriptor.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function fchmodSync(fd: number, mode: string | number): void;\n\n    /**\n     * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function lchmod(path: PathLike, mode: string | number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lchmod {\n        /**\n         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(path: PathLike, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function lchmodSync(path: PathLike, mode: string | number): void;\n\n    /**\n     * Asynchronous stat(2) - Get file status.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function stat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace stat {\n        /**\n         * Asynchronous stat(2) - Get file status.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<Stats>;\n    }\n\n    /**\n     * Synchronous stat(2) - Get file status.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function statSync(path: PathLike): Stats;\n\n    /**\n     * Asynchronous fstat(2) - Get file status.\n     * @param fd A file descriptor.\n     */\n    function fstat(fd: number, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fstat {\n        /**\n         * Asynchronous fstat(2) - Get file status.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<Stats>;\n    }\n\n    /**\n     * Synchronous fstat(2) - Get file status.\n     * @param fd A file descriptor.\n     */\n    function fstatSync(fd: number): Stats;\n\n    /**\n     * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lstat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lstat {\n        /**\n         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<Stats>;\n    }\n\n    /**\n     * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lstatSync(path: PathLike): Stats;\n\n    /**\n     * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n     * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function link(existingPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace link {\n        /**\n         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(existingPath: PathLike, newPath: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n     * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function linkSync(existingPath: PathLike, newPath: PathLike): void;\n\n    /**\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n     * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\n     * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\n     */\n    function symlink(target: PathLike, path: PathLike, type: symlink.Type | undefined | null, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n     */\n    function symlink(target: PathLike, path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace symlink {\n        /**\n         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n         * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\n         * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\n         */\n        function __promisify__(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\n\n        type Type = \"dir\" | \"file\" | \"junction\";\n    }\n\n    /**\n     * Synchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n     * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\n     * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\n     */\n    function symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlink(\n        path: PathLike,\n        options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, linkString: string) => void\n    ): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlink(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException | null, linkString: Buffer) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlink(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException | null, linkString: string | Buffer) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function readlink(path: PathLike, callback: (err: NodeJS.ErrnoException | null, linkString: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readlink {\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlinkSync(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlinkSync(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlinkSync(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpath(\n        path: PathLike,\n        options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void\n    ): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpath(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpath(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function realpath(path: PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace realpath {\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        function native(\n            path: PathLike,\n            options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null,\n            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void\n        ): void;\n        function native(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void): void;\n        function native(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void): void;\n        function native(path: PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void): void;\n    }\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpathSync(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpathSync(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpathSync(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    namespace realpathSync {\n        function native(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n        function native(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n        function native(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n    }\n\n    /**\n     * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function unlink(path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace unlink {\n        /**\n         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous unlink(2) - delete a name and possibly the file it refers to.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function unlinkSync(path: PathLike): void;\n\n    interface RmDirOptions {\n        /**\n         * If `true`, perform a recursive directory removal. In\n         * recursive mode, errors are not reported if `path` does not exist, and\n         * operations are retried on failure.\n         * @experimental\n         * @default false\n         */\n        recursive?: boolean;\n    }\n\n    interface RmDirAsyncOptions extends RmDirOptions {\n        /**\n         * The amount of time in milliseconds to wait between retries.\n         * This option is ignored if the `recursive` option is not `true`.\n         * @default 100\n         */\n        retryDelay?: number;\n        /**\n         * If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or\n         * `EPERM` error is encountered, Node.js will retry the operation with a linear\n         * backoff wait of `retryDelay` ms longer on each try. This option represents the\n         * number of retries. This option is ignored if the `recursive` option is not\n         * `true`.\n         * @default 0\n         */\n        maxRetries?: number;\n    }\n\n    /**\n     * Asynchronous rmdir(2) - delete a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function rmdir(path: PathLike, callback: NoParamCallback): void;\n    function rmdir(path: PathLike, options: RmDirAsyncOptions, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace rmdir {\n        /**\n         * Asynchronous rmdir(2) - delete a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike, options?: RmDirAsyncOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronous rmdir(2) - delete a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function rmdirSync(path: PathLike, options?: RmDirOptions): void;\n\n    interface MakeDirectoryOptions {\n        /**\n         * Indicates whether parent folders should be created.\n         * If a folder was created, the path to the first created folder will be returned.\n         * @default false\n         */\n        recursive?: boolean;\n        /**\n         * A file mode. If a string is passed, it is parsed as an octal integer. If not specified\n         * @default 0o777\n         */\n        mode?: number | string;\n    }\n\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    function mkdir(path: PathLike, options: MakeDirectoryOptions & { recursive: true }, callback: (err: NodeJS.ErrnoException | null, path: string) => void): void;\n\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    function mkdir(path: PathLike, options: number | string | (MakeDirectoryOptions & { recursive?: false; }) | null | undefined, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    function mkdir(path: PathLike, options: number | string | MakeDirectoryOptions | null | undefined, callback: (err: NodeJS.ErrnoException | null, path: string | undefined) => void): void;\n\n    /**\n     * Asynchronous mkdir(2) - create a directory with a mode of `0o777`.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function mkdir(path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace mkdir {\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function __promisify__(path: PathLike, options: MakeDirectoryOptions & { recursive: true; }): Promise<string>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function __promisify__(path: PathLike, options?: number | string | (MakeDirectoryOptions & { recursive?: false; }) | null): Promise<void>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function __promisify__(path: PathLike, options?: number | string | MakeDirectoryOptions | null): Promise<string | undefined>;\n    }\n\n    /**\n     * Synchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    function mkdirSync(path: PathLike, options: MakeDirectoryOptions & { recursive: true; }): string;\n\n    /**\n     * Synchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    function mkdirSync(path: PathLike, options?: number | string | (MakeDirectoryOptions & { recursive?: false; }) | null): void;\n\n    /**\n     * Synchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    function mkdirSync(path: PathLike, options?: number | string | MakeDirectoryOptions | null): string | undefined;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtemp(prefix: string, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException | null, folder: string) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtemp(prefix: string, options: \"buffer\" | { encoding: \"buffer\" }, callback: (err: NodeJS.ErrnoException | null, folder: Buffer) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtemp(prefix: string, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException | null, folder: string | Buffer) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     */\n    function mkdtemp(prefix: string, callback: (err: NodeJS.ErrnoException | null, folder: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace mkdtemp {\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(prefix: string, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtempSync(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtempSync(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtempSync(prefix: string, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdir(\n        path: PathLike,\n        options: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, files: string[]) => void,\n    ): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdir(path: PathLike, options: { encoding: \"buffer\"; withFileTypes?: false } | \"buffer\", callback: (err: NodeJS.ErrnoException | null, files: Buffer[]) => void): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdir(\n        path: PathLike,\n        options: { encoding?: string | null; withFileTypes?: false } | string | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, files: string[] | Buffer[]) => void,\n    ): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function readdir(path: PathLike, callback: (err: NodeJS.ErrnoException | null, files: string[]) => void): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.\n     */\n    function readdir(path: PathLike, options: { encoding?: string | null; withFileTypes: true }, callback: (err: NodeJS.ErrnoException | null, files: Dirent[]) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readdir {\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): Promise<string[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options: \"buffer\" | { encoding: \"buffer\"; withFileTypes?: false }): Promise<Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): Promise<string[] | Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options If called with `withFileTypes: true` the result data will be an array of Dirent\n         */\n        function __promisify__(path: PathLike, options: { encoding?: string | null; withFileTypes: true }): Promise<Dirent[]>;\n    }\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdirSync(path: PathLike, options?: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): string[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdirSync(path: PathLike, options: { encoding: \"buffer\"; withFileTypes?: false } | \"buffer\"): Buffer[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdirSync(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): string[] | Buffer[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.\n     */\n    function readdirSync(path: PathLike, options: { encoding?: string | null; withFileTypes: true }): Dirent[];\n\n    /**\n     * Asynchronous close(2) - close a file descriptor.\n     * @param fd A file descriptor.\n     */\n    function close(fd: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace close {\n        /**\n         * Asynchronous close(2) - close a file descriptor.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous close(2) - close a file descriptor.\n     * @param fd A file descriptor.\n     */\n    function closeSync(fd: number): void;\n\n    /**\n     * Asynchronous open(2) - open and possibly create a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\n     */\n    function open(path: PathLike, flags: string | number, mode: string | number | undefined | null, callback: (err: NodeJS.ErrnoException | null, fd: number) => void): void;\n\n    /**\n     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function open(path: PathLike, flags: string | number, callback: (err: NodeJS.ErrnoException | null, fd: number) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace open {\n        /**\n         * Asynchronous open(2) - open and possibly create a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\n         */\n        function __promisify__(path: PathLike, flags: string | number, mode?: string | number | null): Promise<number>;\n    }\n\n    /**\n     * Synchronous open(2) - open and possibly create a file, returning a file descriptor..\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\n     */\n    function openSync(path: PathLike, flags: string | number, mode?: string | number | null): number;\n\n    /**\n     * Asynchronously change file timestamps of the file referenced by the supplied path.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace utimes {\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied path.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n    }\n\n    /**\n     * Synchronously change file timestamps of the file referenced by the supplied path.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function utimesSync(path: PathLike, atime: string | number | Date, mtime: string | number | Date): void;\n\n    /**\n     * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function futimes(fd: number, atime: string | number | Date, mtime: string | number | Date, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace futimes {\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(fd: number, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n    }\n\n    /**\n     * Synchronously change file timestamps of the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function futimesSync(fd: number, atime: string | number | Date, mtime: string | number | Date): void;\n\n    /**\n     * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n     * @param fd A file descriptor.\n     */\n    function fsync(fd: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fsync {\n        /**\n         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n     * @param fd A file descriptor.\n     */\n    function fsyncSync(fd: number): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function write<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        length: number | undefined | null,\n        position: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n     */\n    function write<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        length: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     */\n    function write<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void\n    ): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     */\n    function write<TBuffer extends NodeJS.ArrayBufferView>(fd: number, buffer: TBuffer, callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void): void;\n\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     * @param encoding The expected string encoding.\n     */\n    function write(\n        fd: number,\n        string: any,\n        position: number | undefined | null,\n        encoding: string | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function write(fd: number, string: any, position: number | undefined | null, callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void): void;\n\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     */\n    function write(fd: number, string: any, callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace write {\n        /**\n         * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         */\n        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(\n            fd: number,\n            buffer?: TBuffer,\n            offset?: number,\n            length?: number,\n            position?: number | null,\n        ): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         * @param encoding The expected string encoding.\n         */\n        function __promisify__(fd: number, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n    }\n\n    /**\n     * Synchronously writes `buffer` to the file referenced by the supplied file descriptor, returning the number of bytes written.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function writeSync(fd: number, buffer: NodeJS.ArrayBufferView, offset?: number | null, length?: number | null, position?: number | null): number;\n\n    /**\n     * Synchronously writes `string` to the file referenced by the supplied file descriptor, returning the number of bytes written.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     * @param encoding The expected string encoding.\n     */\n    function writeSync(fd: number, string: any, position?: number | null, encoding?: string | null): number;\n\n    /**\n     * Asynchronously reads data from the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param buffer The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n     */\n    function read<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number,\n        length: number,\n        position: number | null,\n        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,\n    ): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace read {\n        /**\n         * @param fd A file descriptor.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The offset in the buffer at which to start writing.\n         * @param length The number of bytes to read.\n         * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n         */\n        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(\n            fd: number,\n            buffer: TBuffer,\n            offset: number,\n            length: number,\n            position: number | null\n        ): Promise<{ bytesRead: number, buffer: TBuffer }>;\n    }\n\n    /**\n     * Synchronously reads data from the file referenced by the supplied file descriptor, returning the number of bytes read.\n     * @param fd A file descriptor.\n     * @param buffer The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n     */\n    function readSync(fd: number, buffer: NodeJS.ArrayBufferView, offset: number, length: number, position: number | null): number;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options An object that may contain an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFile(path: PathLike | number, options: { encoding?: null; flag?: string; } | undefined | null, callback: (err: NodeJS.ErrnoException | null, data: Buffer) => void): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFile(path: PathLike | number, options: { encoding: string; flag?: string; } | string, callback: (err: NodeJS.ErrnoException | null, data: string) => void): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFile(\n        path: PathLike | number,\n        options: { encoding?: string | null; flag?: string; } | string | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, data: string | Buffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     */\n    function readFile(path: PathLike | number, callback: (err: NodeJS.ErrnoException | null, data: Buffer) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readFile {\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function __promisify__(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Promise<Buffer>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function __promisify__(path: PathLike | number, options: { encoding: string; flag?: string; } | string): Promise<string>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function __promisify__(path: PathLike | number, options?: { encoding?: string | null; flag?: string; } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options An object that may contain an optional flag. If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFileSync(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Buffer;\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFileSync(path: PathLike | number, options: { encoding: string; flag?: string; } | string): string;\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFileSync(path: PathLike | number, options?: { encoding?: string | null; flag?: string; } | string | null): string | Buffer;\n\n    type WriteFileOptions = { encoding?: string | null; mode?: number | string; flag?: string; } | string | null;\n\n    /**\n     * Asynchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `'w'` is used.\n     */\n    function writeFile(path: PathLike | number, data: any, options: WriteFileOptions, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     */\n    function writeFile(path: PathLike | number, data: any, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace writeFile {\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `'w'` is used.\n         */\n        function __promisify__(path: PathLike | number, data: any, options?: WriteFileOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `'w'` is used.\n     */\n    function writeFileSync(path: PathLike | number, data: any, options?: WriteFileOptions): void;\n\n    /**\n     * Asynchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `'a'` is used.\n     */\n    function appendFile(file: PathLike | number, data: any, options: WriteFileOptions, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     */\n    function appendFile(file: PathLike | number, data: any, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace appendFile {\n        /**\n         * Asynchronously append data to a file, creating the file if it does not exist.\n         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `'a'` is used.\n         */\n        function __promisify__(file: PathLike | number, data: any, options?: WriteFileOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `'a'` is used.\n     */\n    function appendFileSync(file: PathLike | number, data: any, options?: WriteFileOptions): void;\n\n    /**\n     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.\n     */\n    function watchFile(filename: PathLike, options: { persistent?: boolean; interval?: number; } | undefined, listener: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function watchFile(filename: PathLike, listener: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Stop watching for changes on `filename`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function unwatchFile(filename: PathLike, listener?: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    function watch(\n        filename: PathLike,\n        options: { encoding?: BufferEncoding | null, persistent?: boolean, recursive?: boolean } | BufferEncoding | undefined | null,\n        listener?: (event: string, filename: string) => void,\n    ): FSWatcher;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    function watch(filename: PathLike, options: { encoding: \"buffer\", persistent?: boolean, recursive?: boolean } | \"buffer\", listener?: (event: string, filename: Buffer) => void): FSWatcher;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    function watch(\n        filename: PathLike,\n        options: { encoding?: string | null, persistent?: boolean, recursive?: boolean } | string | null,\n        listener?: (event: string, filename: string | Buffer) => void,\n    ): FSWatcher;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function watch(filename: PathLike, listener?: (event: string, filename: string) => any): FSWatcher;\n\n    /**\n     * Asynchronously tests whether or not the given path exists by checking with the file system.\n     * @deprecated\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function exists(path: PathLike, callback: (exists: boolean) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace exists {\n        /**\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(path: PathLike): Promise<boolean>;\n    }\n\n    /**\n     * Synchronously tests whether or not the given path exists by checking with the file system.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function existsSync(path: PathLike): boolean;\n\n    namespace constants {\n        // File Access Constants\n\n        /** Constant for fs.access(). File is visible to the calling process. */\n        const F_OK: number;\n\n        /** Constant for fs.access(). File can be read by the calling process. */\n        const R_OK: number;\n\n        /** Constant for fs.access(). File can be written by the calling process. */\n        const W_OK: number;\n\n        /** Constant for fs.access(). File can be executed by the calling process. */\n        const X_OK: number;\n\n        // File Copy Constants\n\n        /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */\n        const COPYFILE_EXCL: number;\n\n        /**\n         * Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.\n         * If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.\n         */\n        const COPYFILE_FICLONE: number;\n\n        /**\n         * Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.\n         * If the underlying platform does not support copy-on-write, then the operation will fail with an error.\n         */\n        const COPYFILE_FICLONE_FORCE: number;\n\n        // File Open Constants\n\n        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */\n        const O_RDONLY: number;\n\n        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */\n        const O_WRONLY: number;\n\n        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */\n        const O_RDWR: number;\n\n        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */\n        const O_CREAT: number;\n\n        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */\n        const O_EXCL: number;\n\n        /**\n         * Constant for fs.open(). Flag indicating that if path identifies a terminal device,\n         * opening the path shall not cause that terminal to become the controlling terminal for the process\n         * (if the process does not already have one).\n         */\n        const O_NOCTTY: number;\n\n        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */\n        const O_TRUNC: number;\n\n        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */\n        const O_APPEND: number;\n\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */\n        const O_DIRECTORY: number;\n\n        /**\n         * constant for fs.open().\n         * Flag indicating reading accesses to the file system will no longer result in\n         * an update to the atime information associated with the file.\n         * This flag is available on Linux operating systems only.\n         */\n        const O_NOATIME: number;\n\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */\n        const O_NOFOLLOW: number;\n\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */\n        const O_SYNC: number;\n\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */\n        const O_DSYNC: number;\n\n        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */\n        const O_SYMLINK: number;\n\n        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */\n        const O_DIRECT: number;\n\n        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */\n        const O_NONBLOCK: number;\n\n        // File Type Constants\n\n        /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */\n        const S_IFMT: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */\n        const S_IFREG: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */\n        const S_IFDIR: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */\n        const S_IFCHR: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */\n        const S_IFBLK: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */\n        const S_IFIFO: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */\n        const S_IFLNK: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */\n        const S_IFSOCK: number;\n\n        // File Mode Constants\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */\n        const S_IRWXU: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */\n        const S_IRUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */\n        const S_IWUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */\n        const S_IXUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */\n        const S_IRWXG: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */\n        const S_IRGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */\n        const S_IWGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */\n        const S_IXGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */\n        const S_IRWXO: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */\n        const S_IROTH: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */\n        const S_IWOTH: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */\n        const S_IXOTH: number;\n\n        /**\n         * When set, a memory file mapping is used to access the file. This flag\n         * is available on Windows operating systems only. On other operating systems,\n         * this flag is ignored.\n         */\n        const UV_FS_O_FILEMAP: number;\n    }\n\n    /**\n     * Asynchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function access(path: PathLike, mode: number | undefined, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function access(path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace access {\n        /**\n         * Asynchronously tests a user's permissions for the file specified by path.\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(path: PathLike, mode?: number): Promise<void>;\n    }\n\n    /**\n     * Synchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function accessSync(path: PathLike, mode?: number): void;\n\n    /**\n     * Returns a new `ReadStream` object.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function createReadStream(path: PathLike, options?: string | {\n        flags?: string;\n        encoding?: string;\n        fd?: number;\n        mode?: number;\n        autoClose?: boolean;\n        /**\n         * @default false\n         */\n        emitClose?: boolean;\n        start?: number;\n        end?: number;\n        highWaterMark?: number;\n    }): ReadStream;\n\n    /**\n     * Returns a new `WriteStream` object.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function createWriteStream(path: PathLike, options?: string | {\n        flags?: string;\n        encoding?: string;\n        fd?: number;\n        mode?: number;\n        autoClose?: boolean;\n        emitClose?: boolean;\n        start?: number;\n        highWaterMark?: number;\n    }): WriteStream;\n\n    /**\n     * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n     * @param fd A file descriptor.\n     */\n    function fdatasync(fd: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fdatasync {\n        /**\n         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n     * @param fd A file descriptor.\n     */\n    function fdatasyncSync(fd: number): void;\n\n    /**\n     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * No arguments other than a possible exception are given to the callback function.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     */\n    function copyFile(src: PathLike, dest: PathLike, callback: NoParamCallback): void;\n    /**\n     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * No arguments other than a possible exception are given to the callback function.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     * @param flags An integer that specifies the behavior of the copy operation. The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\n     */\n    function copyFile(src: PathLike, dest: PathLike, flags: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace copyFile {\n        /**\n         * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n         * No arguments other than a possible exception are given to the callback function.\n         * Node.js makes no guarantees about the atomicity of the copy operation.\n         * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n         * to remove the destination.\n         * @param src A path to the source file.\n         * @param dest A path to the destination file.\n         * @param flags An optional integer that specifies the behavior of the copy operation.\n         * The only supported flag is fs.constants.COPYFILE_EXCL,\n         * which causes the copy operation to fail if dest already exists.\n         */\n        function __promisify__(src: PathLike, dst: PathLike, flags?: number): Promise<void>;\n    }\n\n    /**\n     * Synchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     * @param flags An optional integer that specifies the behavior of the copy operation.\n     * The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\n     */\n    function copyFileSync(src: PathLike, dest: PathLike, flags?: number): void;\n\n    /**\n     * Write an array of ArrayBufferViews to the file specified by fd using writev().\n     * position is the offset from the beginning of the file where this data should be written.\n     * It is unsafe to use fs.writev() multiple times on the same file without waiting for the callback. For this scenario, use fs.createWriteStream().\n     * On Linux, positional writes don't work when the file is opened in append mode.\n     * The kernel ignores the position argument and always appends the data to the end of the file.\n     */\n    function writev(\n        fd: number,\n        buffers: NodeJS.ArrayBufferView[],\n        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void\n    ): void;\n    function writev(\n        fd: number,\n        buffers: NodeJS.ArrayBufferView[],\n        position: number,\n        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void\n    ): void;\n\n    interface WriteVResult {\n        bytesWritten: number;\n        buffers: NodeJS.ArrayBufferView[];\n    }\n\n    namespace writev {\n        function __promisify__(fd: number, buffers: NodeJS.ArrayBufferView[], position?: number): Promise<WriteVResult>;\n    }\n\n    /**\n     * See `writev`.\n     */\n    function writevSync(fd: number, buffers: NodeJS.ArrayBufferView[], position?: number): number;\n\n    interface OpenDirOptions {\n        encoding?: BufferEncoding;\n        /**\n         * Number of directory entries that are buffered\n         * internally when reading from the directory. Higher values lead to better\n         * performance but higher memory usage.\n         * @default 32\n         */\n        bufferSize?: number;\n    }\n\n    function opendirSync(path: string, options?: OpenDirOptions): Dir;\n\n    function opendir(path: string, cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void): void;\n    function opendir(path: string, options: OpenDirOptions, cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void): void;\n\n    namespace opendir {\n        function __promisify__(path: string, options?: OpenDirOptions): Promise<Dir>;\n    }\n\n    namespace promises {\n        interface FileHandle {\n            /**\n             * Gets the file descriptor for this file handle.\n             */\n            readonly fd: number;\n\n            /**\n             * Asynchronously append data to a file, creating the file if it does not exist. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for appending.\n             * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n             * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n             * If `encoding` is not supplied, the default of `'utf8'` is used.\n             * If `mode` is not supplied, the default of `0o666` is used.\n             * If `mode` is a string, it is parsed as an octal integer.\n             * If `flag` is not supplied, the default of `'a'` is used.\n             */\n            appendFile(data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n            /**\n             * Asynchronous fchown(2) - Change ownership of a file.\n             */\n            chown(uid: number, gid: number): Promise<void>;\n\n            /**\n             * Asynchronous fchmod(2) - Change permissions of a file.\n             * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n             */\n            chmod(mode: string | number): Promise<void>;\n\n            /**\n             * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n             */\n            datasync(): Promise<void>;\n\n            /**\n             * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n             */\n            sync(): Promise<void>;\n\n            /**\n             * Asynchronously reads data from the file.\n             * The `FileHandle` must have been opened for reading.\n             * @param buffer The buffer that the data will be written to.\n             * @param offset The offset in the buffer at which to start writing.\n             * @param length The number of bytes to read.\n             * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n             */\n            read<TBuffer extends Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesRead: number, buffer: TBuffer }>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to `'r'`.\n             */\n            readFile(options?: { encoding?: null, flag?: string | number } | null): Promise<Buffer>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to `'r'`.\n             */\n            readFile(options: { encoding: BufferEncoding, flag?: string | number } | BufferEncoding): Promise<string>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to `'r'`.\n             */\n            readFile(options?: { encoding?: string | null, flag?: string | number } | string | null): Promise<string | Buffer>;\n\n            /**\n             * Asynchronous fstat(2) - Get file status.\n             */\n            stat(): Promise<Stats>;\n\n            /**\n             * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n             * @param len If not specified, defaults to `0`.\n             */\n            truncate(len?: number): Promise<void>;\n\n            /**\n             * Asynchronously change file timestamps of the file.\n             * @param atime The last access time. If a string is provided, it will be coerced to number.\n             * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n             */\n            utimes(atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n            /**\n             * Asynchronously writes `buffer` to the file.\n             * The `FileHandle` must have been opened for writing.\n             * @param buffer The buffer that the data will be written to.\n             * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n             * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n             * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n             */\n            write<TBuffer extends Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n            /**\n             * Asynchronously writes `string` to the file.\n             * The `FileHandle` must have been opened for writing.\n             * It is unsafe to call `write()` multiple times on the same file without waiting for the `Promise`\n             * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.\n             * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n             * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n             * @param encoding The expected string encoding.\n             */\n            write(data: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n\n            /**\n             * Asynchronously writes data to a file, replacing the file if it already exists. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for writing.\n             * It is unsafe to call `writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected).\n             * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n             * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n             * If `encoding` is not supplied, the default of `'utf8'` is used.\n             * If `mode` is not supplied, the default of `0o666` is used.\n             * If `mode` is a string, it is parsed as an octal integer.\n             * If `flag` is not supplied, the default of `'w'` is used.\n             */\n            writeFile(data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n            /**\n             * See `fs.writev` promisified version.\n             */\n            writev(buffers: NodeJS.ArrayBufferView[], position?: number): Promise<WriteVResult>;\n\n            /**\n             * Asynchronous close(2) - close a `FileHandle`.\n             */\n            close(): Promise<void>;\n        }\n\n        /**\n         * Asynchronously tests a user's permissions for the file specified by path.\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function access(path: PathLike, mode?: number): Promise<void>;\n\n        /**\n         * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it already exists.\n         * Node.js makes no guarantees about the atomicity of the copy operation.\n         * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n         * to remove the destination.\n         * @param src A path to the source file.\n         * @param dest A path to the destination file.\n         * @param flags An optional integer that specifies the behavior of the copy operation. The only\n         * supported flag is `fs.constants.COPYFILE_EXCL`, which causes the copy operation to fail if\n         * `dest` already exists.\n         */\n        function copyFile(src: PathLike, dest: PathLike, flags?: number): Promise<void>;\n\n        /**\n         * Asynchronous open(2) - open and possibly create a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not\n         * supplied, defaults to `0o666`.\n         */\n        function open(path: PathLike, flags: string | number, mode?: string | number): Promise<FileHandle>;\n\n        /**\n         * Asynchronously reads data from the file referenced by the supplied `FileHandle`.\n         * @param handle A `FileHandle`.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The offset in the buffer at which to start writing.\n         * @param length The number of bytes to read.\n         * @param position The offset from the beginning of the file from which data should be read. If\n         * `null`, data will be read from the current position.\n         */\n        function read<TBuffer extends Uint8Array>(\n            handle: FileHandle,\n            buffer: TBuffer,\n            offset?: number | null,\n            length?: number | null,\n            position?: number | null,\n        ): Promise<{ bytesRead: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes `buffer` to the file referenced by the supplied `FileHandle`.\n         * It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`\n         * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.\n         * @param handle A `FileHandle`.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         */\n        function write<TBuffer extends Uint8Array>(\n            handle: FileHandle,\n            buffer: TBuffer,\n            offset?: number | null,\n            length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes `string` to the file referenced by the supplied `FileHandle`.\n         * It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`\n         * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.\n         * @param handle A `FileHandle`.\n         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         * @param encoding The expected string encoding.\n         */\n        function write(handle: FileHandle, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n\n        /**\n         * Asynchronous rename(2) - Change the name or location of a file or directory.\n         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function rename(oldPath: PathLike, newPath: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous truncate(2) - Truncate a file to a specified length.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param len If not specified, defaults to `0`.\n         */\n        function truncate(path: PathLike, len?: number): Promise<void>;\n\n        /**\n         * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n         * @param handle A `FileHandle`.\n         * @param len If not specified, defaults to `0`.\n         */\n        function ftruncate(handle: FileHandle, len?: number): Promise<void>;\n\n        /**\n         * Asynchronous rmdir(2) - delete a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function rmdir(path: PathLike, options?: RmDirAsyncOptions): Promise<void>;\n\n        /**\n         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n         * @param handle A `FileHandle`.\n         */\n        function fdatasync(handle: FileHandle): Promise<void>;\n\n        /**\n         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n         * @param handle A `FileHandle`.\n         */\n        function fsync(handle: FileHandle): Promise<void>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function mkdir(path: PathLike, options: MakeDirectoryOptions & { recursive: true; }): Promise<string>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function mkdir(path: PathLike, options?: number | string | (MakeDirectoryOptions & { recursive?: false; }) | null): Promise<void>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function mkdir(path: PathLike, options?: number | string | MakeDirectoryOptions | null): Promise<string | undefined>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readdir(path: PathLike, options?: { encoding?: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): Promise<string[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readdir(path: PathLike, options: { encoding: \"buffer\"; withFileTypes?: false } | \"buffer\"): Promise<Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readdir(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): Promise<string[] | Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.\n         */\n        function readdir(path: PathLike, options: { encoding?: string | null; withFileTypes: true }): Promise<Dirent[]>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readlink(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readlink(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readlink(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n         * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\n         * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\n         */\n        function symlink(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\n\n        /**\n         * Asynchronous fstat(2) - Get file status.\n         * @param handle A `FileHandle`.\n         */\n        function fstat(handle: FileHandle): Promise<Stats>;\n\n        /**\n         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function lstat(path: PathLike): Promise<Stats>;\n\n        /**\n         * Asynchronous stat(2) - Get file status.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function stat(path: PathLike): Promise<Stats>;\n\n        /**\n         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function link(existingPath: PathLike, newPath: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function unlink(path: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous fchmod(2) - Change permissions of a file.\n         * @param handle A `FileHandle`.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function fchmod(handle: FileHandle, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous chmod(2) - Change permissions of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function chmod(path: PathLike, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function lchmod(path: PathLike, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function lchown(path: PathLike, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronous fchown(2) - Change ownership of a file.\n         * @param handle A `FileHandle`.\n         */\n        function fchown(handle: FileHandle, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronous chown(2) - Change ownership of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function chown(path: PathLike, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied path.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied `FileHandle`.\n         * @param handle A `FileHandle`.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function futimes(handle: FileHandle, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function realpath(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function realpath(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function realpath(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function mkdtemp(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function mkdtemp(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function mkdtemp(prefix: string, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists.\n         * It is unsafe to call `fsPromises.writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected).\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `'w'` is used.\n         */\n        function writeFile(path: PathLike | FileHandle, data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n        /**\n         * Asynchronously append data to a file, creating the file if it does not exist.\n         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `'a'` is used.\n         */\n        function appendFile(path: PathLike | FileHandle, data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function readFile(path: PathLike | FileHandle, options?: { encoding?: null, flag?: string | number } | null): Promise<Buffer>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function readFile(path: PathLike | FileHandle, options: { encoding: BufferEncoding, flag?: string | number } | BufferEncoding): Promise<string>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function readFile(path: PathLike | FileHandle, options?: { encoding?: string | null, flag?: string | number } | string | null): Promise<string | Buffer>;\n\n        function opendir(path: string, options?: OpenDirOptions): Promise<Dir>;\n    }\n}\n\n\n// This needs to be global to avoid TS2403 in case lib.dom.d.ts is present in the same build\ninterface Console {\n    Console: NodeJS.ConsoleConstructor;\n    /**\n     * A simple assertion test that verifies whether `value` is truthy.\n     * If it is not, an `AssertionError` is thrown.\n     * If provided, the error `message` is formatted using `util.format()` and used as the error message.\n     */\n    assert(value: any, message?: string, ...optionalParams: any[]): void;\n    /**\n     * When `stdout` is a TTY, calling `console.clear()` will attempt to clear the TTY.\n     * When `stdout` is not a TTY, this method does nothing.\n     */\n    clear(): void;\n    /**\n     * Maintains an internal counter specific to `label` and outputs to `stdout` the number of times `console.count()` has been called with the given `label`.\n     */\n    count(label?: string): void;\n    /**\n     * Resets the internal counter specific to `label`.\n     */\n    countReset(label?: string): void;\n    /**\n     * The `console.debug()` function is an alias for {@link console.log()}.\n     */\n    debug(message?: any, ...optionalParams: any[]): void;\n    /**\n     * Uses {@link util.inspect()} on `obj` and prints the resulting string to `stdout`.\n     * This function bypasses any custom `inspect()` function defined on `obj`.\n     */\n    dir(obj: any, options?: NodeJS.InspectOptions): void;\n    /**\n     * This method calls {@link console.log()} passing it the arguments received. Please note that this method does not produce any XML formatting\n     */\n    dirxml(...data: any[]): void;\n    /**\n     * Prints to `stderr` with newline.\n     */\n    error(message?: any, ...optionalParams: any[]): void;\n    /**\n     * Increases indentation of subsequent lines by two spaces.\n     * If one or more `label`s are provided, those are printed first without the additional indentation.\n     */\n    group(...label: any[]): void;\n    /**\n     * The `console.groupCollapsed()` function is an alias for {@link console.group()}.\n     */\n    groupCollapsed(...label: any[]): void;\n    /**\n     * Decreases indentation of subsequent lines by two spaces.\n     */\n    groupEnd(): void;\n    /**\n     * The {@link console.info()} function is an alias for {@link console.log()}.\n     */\n    info(message?: any, ...optionalParams: any[]): void;\n    /**\n     * Prints to `stdout` with newline.\n     */\n    log(message?: any, ...optionalParams: any[]): void;\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Prints to `stdout` the array `array` formatted as a table.\n     */\n    table(tabularData: any, properties?: string[]): void;\n    /**\n     * Starts a timer that can be used to compute the duration of an operation. Timers are identified by a unique `label`.\n     */\n    time(label?: string): void;\n    /**\n     * Stops a timer that was previously started by calling {@link console.time()} and prints the result to `stdout`.\n     */\n    timeEnd(label?: string): void;\n    /**\n     * For a timer that was previously started by calling {@link console.time()}, prints the elapsed time and other `data` arguments to `stdout`.\n     */\n    timeLog(label?: string, ...data: any[]): void;\n    /**\n     * Prints to `stderr` the string 'Trace :', followed by the {@link util.format()} formatted message and stack trace to the current position in the code.\n     */\n    trace(message?: any, ...optionalParams: any[]): void;\n    /**\n     * The {@link console.warn()} function is an alias for {@link console.error()}.\n     */\n    warn(message?: any, ...optionalParams: any[]): void;\n\n    // --- Inspector mode only ---\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Starts a JavaScript CPU profile with an optional label.\n     */\n    profile(label?: string): void;\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Stops the current JavaScript CPU profiling session if one has been started and prints the report to the Profiles panel of the inspector.\n     */\n    profileEnd(label?: string): void;\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Adds an event with the label `label` to the Timeline panel of the inspector.\n     */\n    timeStamp(label?: string): void;\n}\n\n// Declare \"static\" methods in Error\ninterface ErrorConstructor {\n    /** Create .stack property on a target object */\n    captureStackTrace(targetObject: object, constructorOpt?: Function): void;\n\n    /**\n     * Optional override for formatting stack traces\n     *\n     * @see https://github.com/v8/v8/wiki/Stack%20Trace%20API#customizing-stack-traces\n     */\n    prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;\n\n    stackTraceLimit: number;\n}\n\n// Node.js ESNEXT support\ninterface String {\n    /** Removes whitespace from the left end of a string. */\n    trimLeft(): string;\n    /** Removes whitespace from the right end of a string. */\n    trimRight(): string;\n}\n\ninterface ImportMeta {\n    url: string;\n}\n\n/*-----------------------------------------------*\n *                                               *\n *                   GLOBAL                      *\n *                                               *\n ------------------------------------------------*/\n\n// For backwards compability\ninterface NodeRequire extends NodeJS.Require {}\ninterface RequireResolve extends NodeJS.RequireResolve {}\ninterface NodeModule extends NodeJS.Module {}\n\ndeclare var process: NodeJS.Process;\ndeclare var global: NodeJS.Global;\ndeclare var console: Console;\n\ndeclare var __filename: string;\ndeclare var __dirname: string;\n\ndeclare function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\ndeclare namespace setTimeout {\n    function __promisify__(ms: number): Promise<void>;\n    function __promisify__<T>(ms: number, value: T): Promise<T>;\n}\ndeclare function clearTimeout(timeoutId: NodeJS.Timeout): void;\ndeclare function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\ndeclare function clearInterval(intervalId: NodeJS.Timeout): void;\ndeclare function setImmediate(callback: (...args: any[]) => void, ...args: any[]): NodeJS.Immediate;\ndeclare namespace setImmediate {\n    function __promisify__(): Promise<void>;\n    function __promisify__<T>(value: T): Promise<T>;\n}\ndeclare function clearImmediate(immediateId: NodeJS.Immediate): void;\n\ndeclare function queueMicrotask(callback: () => void): void;\n\ndeclare var require: NodeRequire;\ndeclare var module: NodeModule;\n\n// Same as module.exports\ndeclare var exports: any;\n\n// Buffer class\ntype BufferEncoding = \"ascii\" | \"utf8\" | \"utf-8\" | \"utf16le\" | \"ucs2\" | \"ucs-2\" | \"base64\" | \"latin1\" | \"binary\" | \"hex\";\n\n/**\n * Raw data is stored in instances of the Buffer class.\n * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.\n * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\n */\ndeclare class Buffer extends Uint8Array {\n    /**\n     * Allocates a new buffer containing the given {str}.\n     *\n     * @param str String to store in buffer.\n     * @param encoding encoding to use, optional.  Default is 'utf8'\n     * @deprecated since v10.0.0 - Use `Buffer.from(string[, encoding])` instead.\n     */\n    constructor(str: string, encoding?: BufferEncoding);\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     * @deprecated since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`).\n     */\n    constructor(size: number);\n    /**\n     * Allocates a new buffer containing the given {array} of octets.\n     *\n     * @param array The octets to store.\n     * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.\n     */\n    constructor(array: Uint8Array);\n    /**\n     * Produces a Buffer backed by the same allocated memory as\n     * the given {ArrayBuffer}/{SharedArrayBuffer}.\n     *\n     *\n     * @param arrayBuffer The ArrayBuffer with which to share memory.\n     * @deprecated since v10.0.0 - Use `Buffer.from(arrayBuffer[, byteOffset[, length]])` instead.\n     */\n    constructor(arrayBuffer: ArrayBuffer | SharedArrayBuffer);\n    /**\n     * Allocates a new buffer containing the given {array} of octets.\n     *\n     * @param array The octets to store.\n     * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.\n     */\n    constructor(array: any[]);\n    /**\n     * Copies the passed {buffer} data onto a new {Buffer} instance.\n     *\n     * @param buffer The buffer to copy.\n     * @deprecated since v10.0.0 - Use `Buffer.from(buffer)` instead.\n     */\n    constructor(buffer: Buffer);\n    /**\n     * When passed a reference to the .buffer property of a TypedArray instance,\n     * the newly created Buffer will share the same allocated memory as the TypedArray.\n     * The optional {byteOffset} and {length} arguments specify a memory range\n     * within the {arrayBuffer} that will be shared by the Buffer.\n     *\n     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()\n     */\n    static from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;\n    /**\n     * Creates a new Buffer using the passed {data}\n     * @param data data to create a new Buffer\n     */\n    static from(data: number[]): Buffer;\n    static from(data: Uint8Array): Buffer;\n    /**\n     * Creates a new buffer containing the coerced value of an object\n     * A `TypeError` will be thrown if {obj} has not mentioned methods or is not of other type appropriate for `Buffer.from()` variants.\n     * @param obj An object supporting `Symbol.toPrimitive` or `valueOf()`.\n     */\n    static from(obj: { valueOf(): string | object } | { [Symbol.toPrimitive](hint: 'string'): string }, byteOffset?: number, length?: number): Buffer;\n    /**\n     * Creates a new Buffer containing the given JavaScript string {str}.\n     * If provided, the {encoding} parameter identifies the character encoding.\n     * If not provided, {encoding} defaults to 'utf8'.\n     */\n    static from(str: string, encoding?: BufferEncoding): Buffer;\n    /**\n     * Creates a new Buffer using the passed {data}\n     * @param values to create a new Buffer\n     */\n    static of(...items: number[]): Buffer;\n    /**\n     * Returns true if {obj} is a Buffer\n     *\n     * @param obj object to test.\n     */\n    static isBuffer(obj: any): obj is Buffer;\n    /**\n     * Returns true if {encoding} is a valid encoding argument.\n     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\n     *\n     * @param encoding string to test.\n     */\n    static isEncoding(encoding: string): encoding is BufferEncoding;\n    /**\n     * Gives the actual byte length of a string. encoding defaults to 'utf8'.\n     * This is not the same as String.prototype.length since that returns the number of characters in a string.\n     *\n     * @param string string to test.\n     * @param encoding encoding used to evaluate (defaults to 'utf8')\n     */\n    static byteLength(\n        string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,\n        encoding?: BufferEncoding\n    ): number;\n    /**\n     * Returns a buffer which is the result of concatenating all the buffers in the list together.\n     *\n     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.\n     * If the list has exactly one item, then the first item of the list is returned.\n     * If the list has more than one item, then a new Buffer is created.\n     *\n     * @param list An array of Buffer objects to concatenate\n     * @param totalLength Total length of the buffers when concatenated.\n     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.\n     */\n    static concat(list: Uint8Array[], totalLength?: number): Buffer;\n    /**\n     * The same as buf1.compare(buf2).\n     */\n    static compare(buf1: Uint8Array, buf2: Uint8Array): number;\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).\n     *    If parameter is omitted, buffer will be filled with zeros.\n     * @param encoding encoding used for call to buf.fill while initalizing\n     */\n    static alloc(size: number, fill?: string | Buffer | number, encoding?: BufferEncoding): Buffer;\n    /**\n     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    static allocUnsafe(size: number): Buffer;\n    /**\n     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    static allocUnsafeSlow(size: number): Buffer;\n    /**\n     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.\n     */\n    static poolSize: number;\n\n    write(string: string, encoding?: BufferEncoding): number;\n    write(string: string, offset: number, encoding?: BufferEncoding): number;\n    write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;\n    toString(encoding?: string, start?: number, end?: number): string;\n    toJSON(): { type: 'Buffer'; data: number[] };\n    equals(otherBuffer: Uint8Array): boolean;\n    compare(\n        otherBuffer: Uint8Array,\n        targetStart?: number,\n        targetEnd?: number,\n        sourceStart?: number,\n        sourceEnd?: number\n    ): number;\n    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;\n    /**\n     * Returns a new `Buffer` that references **the same memory as the original**, but offset and cropped by the start and end indices.\n     *\n     * This method is incompatible with `Uint8Array#slice()`, which returns a copy of the original memory.\n     *\n     * @param begin Where the new `Buffer` will start. Default: `0`.\n     * @param end Where the new `Buffer` will end (not inclusive). Default: `buf.length`.\n     */\n    slice(begin?: number, end?: number): Buffer;\n    /**\n     * Returns a new `Buffer` that references **the same memory as the original**, but offset and cropped by the start and end indices.\n     *\n     * This method is compatible with `Uint8Array#subarray()`.\n     *\n     * @param begin Where the new `Buffer` will start. Default: `0`.\n     * @param end Where the new `Buffer` will end (not inclusive). Default: `buf.length`.\n     */\n    subarray(begin?: number, end?: number): Buffer;\n    writeUIntLE(value: number, offset: number, byteLength: number): number;\n    writeUIntBE(value: number, offset: number, byteLength: number): number;\n    writeIntLE(value: number, offset: number, byteLength: number): number;\n    writeIntBE(value: number, offset: number, byteLength: number): number;\n    readUIntLE(offset: number, byteLength: number): number;\n    readUIntBE(offset: number, byteLength: number): number;\n    readIntLE(offset: number, byteLength: number): number;\n    readIntBE(offset: number, byteLength: number): number;\n    readUInt8(offset?: number): number;\n    readUInt16LE(offset?: number): number;\n    readUInt16BE(offset?: number): number;\n    readUInt32LE(offset?: number): number;\n    readUInt32BE(offset?: number): number;\n    readInt8(offset?: number): number;\n    readInt16LE(offset?: number): number;\n    readInt16BE(offset?: number): number;\n    readInt32LE(offset?: number): number;\n    readInt32BE(offset?: number): number;\n    readFloatLE(offset?: number): number;\n    readFloatBE(offset?: number): number;\n    readDoubleLE(offset?: number): number;\n    readDoubleBE(offset?: number): number;\n    reverse(): this;\n    swap16(): Buffer;\n    swap32(): Buffer;\n    swap64(): Buffer;\n    writeUInt8(value: number, offset?: number): number;\n    writeUInt16LE(value: number, offset?: number): number;\n    writeUInt16BE(value: number, offset?: number): number;\n    writeUInt32LE(value: number, offset?: number): number;\n    writeUInt32BE(value: number, offset?: number): number;\n    writeInt8(value: number, offset?: number): number;\n    writeInt16LE(value: number, offset?: number): number;\n    writeInt16BE(value: number, offset?: number): number;\n    writeInt32LE(value: number, offset?: number): number;\n    writeInt32BE(value: number, offset?: number): number;\n    writeFloatLE(value: number, offset?: number): number;\n    writeFloatBE(value: number, offset?: number): number;\n    writeDoubleLE(value: number, offset?: number): number;\n    writeDoubleBE(value: number, offset?: number): number;\n\n    fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;\n\n    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;\n    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;\n    entries(): IterableIterator<[number, number]>;\n    includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;\n    keys(): IterableIterator<number>;\n    values(): IterableIterator<number>;\n}\n\n/*----------------------------------------------*\n*                                               *\n*               GLOBAL INTERFACES               *\n*                                               *\n*-----------------------------------------------*/\ndeclare namespace NodeJS {\n    interface InspectOptions {\n        /**\n         * If set to `true`, getters are going to be\n         * inspected as well. If set to `'get'` only getters without setter are going\n         * to be inspected. If set to `'set'` only getters having a corresponding\n         * setter are going to be inspected. This might cause side effects depending on\n         * the getter function.\n         * @default `false`\n         */\n        getters?: 'get' | 'set' | boolean;\n        showHidden?: boolean;\n        /**\n         * @default 2\n         */\n        depth?: number | null;\n        colors?: boolean;\n        customInspect?: boolean;\n        showProxy?: boolean;\n        maxArrayLength?: number | null;\n        breakLength?: number;\n        /**\n         * Setting this to `false` causes each object key\n         * to be displayed on a new line. It will also add new lines to text that is\n         * longer than `breakLength`. If set to a number, the most `n` inner elements\n         * are united on a single line as long as all properties fit into\n         * `breakLength`. Short array elements are also grouped together. Note that no\n         * text will be reduced below 16 characters, no matter the `breakLength` size.\n         * For more information, see the example below.\n         * @default `true`\n         */\n        compact?: boolean | number;\n        sorted?: boolean | ((a: string, b: string) => number);\n    }\n\n    interface ConsoleConstructorOptions {\n        stdout: WritableStream;\n        stderr?: WritableStream;\n        ignoreErrors?: boolean;\n        colorMode?: boolean | 'auto';\n        inspectOptions?: InspectOptions;\n    }\n\n    interface ConsoleConstructor {\n        prototype: Console;\n        new(stdout: WritableStream, stderr?: WritableStream, ignoreErrors?: boolean): Console;\n        new(options: ConsoleConstructorOptions): Console;\n    }\n\n    interface CallSite {\n        /**\n         * Value of \"this\"\n         */\n        getThis(): any;\n\n        /**\n         * Type of \"this\" as a string.\n         * This is the name of the function stored in the constructor field of\n         * \"this\", if available.  Otherwise the object's [[Class]] internal\n         * property.\n         */\n        getTypeName(): string | null;\n\n        /**\n         * Current function\n         */\n        getFunction(): Function | undefined;\n\n        /**\n         * Name of the current function, typically its name property.\n         * If a name property is not available an attempt will be made to try\n         * to infer a name from the function's context.\n         */\n        getFunctionName(): string | null;\n\n        /**\n         * Name of the property [of \"this\" or one of its prototypes] that holds\n         * the current function\n         */\n        getMethodName(): string | null;\n\n        /**\n         * Name of the script [if this function was defined in a script]\n         */\n        getFileName(): string | null;\n\n        /**\n         * Current line number [if this function was defined in a script]\n         */\n        getLineNumber(): number | null;\n\n        /**\n         * Current column number [if this function was defined in a script]\n         */\n        getColumnNumber(): number | null;\n\n        /**\n         * A call site object representing the location where eval was called\n         * [if this function was created using a call to eval]\n         */\n        getEvalOrigin(): string | undefined;\n\n        /**\n         * Is this a toplevel invocation, that is, is \"this\" the global object?\n         */\n        isToplevel(): boolean;\n\n        /**\n         * Does this call take place in code defined by a call to eval?\n         */\n        isEval(): boolean;\n\n        /**\n         * Is this call in native V8 code?\n         */\n        isNative(): boolean;\n\n        /**\n         * Is this a constructor call?\n         */\n        isConstructor(): boolean;\n    }\n\n    interface ErrnoException extends Error {\n        errno?: number;\n        code?: string;\n        path?: string;\n        syscall?: string;\n        stack?: string;\n    }\n\n    interface EventEmitter {\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        off(event: string | symbol, listener: (...args: any[]) => void): this;\n        removeAllListeners(event?: string | symbol): this;\n        setMaxListeners(n: number): this;\n        getMaxListeners(): number;\n        listeners(event: string | symbol): Function[];\n        rawListeners(event: string | symbol): Function[];\n        emit(event: string | symbol, ...args: any[]): boolean;\n        listenerCount(type: string | symbol): number;\n        // Added in Node 6...\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        eventNames(): Array<string | symbol>;\n    }\n\n    interface ReadableStream extends EventEmitter {\n        readable: boolean;\n        read(size?: number): string | Buffer;\n        setEncoding(encoding: string): this;\n        pause(): this;\n        resume(): this;\n        isPaused(): boolean;\n        pipe<T extends WritableStream>(destination: T, options?: { end?: boolean; }): T;\n        unpipe(destination?: WritableStream): this;\n        unshift(chunk: string | Uint8Array, encoding?: BufferEncoding): void;\n        wrap(oldStream: ReadableStream): this;\n        [Symbol.asyncIterator](): AsyncIterableIterator<string | Buffer>;\n    }\n\n    interface WritableStream extends EventEmitter {\n        writable: boolean;\n        write(buffer: Uint8Array | string, cb?: (err?: Error | null) => void): boolean;\n        write(str: string, encoding?: string, cb?: (err?: Error | null) => void): boolean;\n        end(cb?: () => void): void;\n        end(data: string | Uint8Array, cb?: () => void): void;\n        end(str: string, encoding?: string, cb?: () => void): void;\n    }\n\n    interface ReadWriteStream extends ReadableStream, WritableStream { }\n\n    interface Domain extends EventEmitter {\n        run<T>(fn: (...args: any[]) => T, ...args: any[]): T;\n        add(emitter: EventEmitter | Timer): void;\n        remove(emitter: EventEmitter | Timer): void;\n        bind<T extends Function>(cb: T): T;\n        intercept<T extends Function>(cb: T): T;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        on(event: string, listener: (...args: any[]) => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        removeListener(event: string, listener: (...args: any[]) => void): this;\n        removeAllListeners(event?: string): this;\n    }\n\n    interface MemoryUsage {\n        rss: number;\n        heapTotal: number;\n        heapUsed: number;\n        external: number;\n        arrayBuffers: number;\n    }\n\n    interface CpuUsage {\n        user: number;\n        system: number;\n    }\n\n    interface ProcessRelease {\n        name: string;\n        sourceUrl?: string;\n        headersUrl?: string;\n        libUrl?: string;\n        lts?: string;\n    }\n\n    interface ProcessVersions {\n        http_parser: string;\n        node: string;\n        v8: string;\n        ares: string;\n        uv: string;\n        zlib: string;\n        modules: string;\n        openssl: string;\n    }\n\n    type Platform = 'aix'\n        | 'android'\n        | 'darwin'\n        | 'freebsd'\n        | 'linux'\n        | 'openbsd'\n        | 'sunos'\n        | 'win32'\n        | 'cygwin'\n        | 'netbsd';\n\n    type Signals =\n        \"SIGABRT\" | \"SIGALRM\" | \"SIGBUS\" | \"SIGCHLD\" | \"SIGCONT\" | \"SIGFPE\" | \"SIGHUP\" | \"SIGILL\" | \"SIGINT\" | \"SIGIO\" |\n        \"SIGIOT\" | \"SIGKILL\" | \"SIGPIPE\" | \"SIGPOLL\" | \"SIGPROF\" | \"SIGPWR\" | \"SIGQUIT\" | \"SIGSEGV\" | \"SIGSTKFLT\" |\n        \"SIGSTOP\" | \"SIGSYS\" | \"SIGTERM\" | \"SIGTRAP\" | \"SIGTSTP\" | \"SIGTTIN\" | \"SIGTTOU\" | \"SIGUNUSED\" | \"SIGURG\" |\n        \"SIGUSR1\" | \"SIGUSR2\" | \"SIGVTALRM\" | \"SIGWINCH\" | \"SIGXCPU\" | \"SIGXFSZ\" | \"SIGBREAK\" | \"SIGLOST\" | \"SIGINFO\";\n\n    type MultipleResolveType = 'resolve' | 'reject';\n\n    type BeforeExitListener = (code: number) => void;\n    type DisconnectListener = () => void;\n    type ExitListener = (code: number) => void;\n    type RejectionHandledListener = (promise: Promise<any>) => void;\n    type UncaughtExceptionListener = (error: Error) => void;\n    type UnhandledRejectionListener = (reason: {} | null | undefined, promise: Promise<any>) => void;\n    type WarningListener = (warning: Error) => void;\n    type MessageListener = (message: any, sendHandle: any) => void;\n    type SignalsListener = (signal: Signals) => void;\n    type NewListenerListener = (type: string | symbol, listener: (...args: any[]) => void) => void;\n    type RemoveListenerListener = (type: string | symbol, listener: (...args: any[]) => void) => void;\n    type MultipleResolveListener = (type: MultipleResolveType, promise: Promise<any>, value: any) => void;\n\n    interface Socket extends ReadWriteStream {\n        isTTY?: true;\n    }\n\n    interface ProcessEnv {\n        [key: string]: string | undefined;\n    }\n\n    interface HRTime {\n        (time?: [number, number]): [number, number];\n    }\n\n    interface ProcessReport {\n        /**\n         * Directory where the report is written.\n         * working directory of the Node.js process.\n         * @default '' indicating that reports are written to the current\n         */\n        directory: string;\n\n        /**\n         * Filename where the report is written.\n         * The default value is the empty string.\n         * @default '' the output filename will be comprised of a timestamp,\n         * PID, and sequence number.\n         */\n        filename: string;\n\n        /**\n         * Returns a JSON-formatted diagnostic report for the running process.\n         * The report's JavaScript stack trace is taken from err, if present.\n         */\n        getReport(err?: Error): string;\n\n        /**\n         * If true, a diagnostic report is generated on fatal errors,\n         * such as out of memory errors or failed C++ assertions.\n         * @default false\n         */\n        reportOnFatalError: boolean;\n\n        /**\n         * If true, a diagnostic report is generated when the process\n         * receives the signal specified by process.report.signal.\n         * @defaul false\n         */\n        reportOnSignal: boolean;\n\n        /**\n         * If true, a diagnostic report is generated on uncaught exception.\n         * @default false\n         */\n        reportOnUncaughtException: boolean;\n\n        /**\n         * The signal used to trigger the creation of a diagnostic report.\n         * @default 'SIGUSR2'\n         */\n        signal: Signals;\n\n        /**\n         * Writes a diagnostic report to a file. If filename is not provided, the default filename\n         * includes the date, time, PID, and a sequence number.\n         * The report's JavaScript stack trace is taken from err, if present.\n         *\n         * @param fileName Name of the file where the report is written.\n         * This should be a relative path, that will be appended to the directory specified in\n         * `process.report.directory`, or the current working directory of the Node.js process,\n         * if unspecified.\n         * @param error A custom error used for reporting the JavaScript stack.\n         * @return Filename of the generated report.\n         */\n        writeReport(fileName?: string): string;\n        writeReport(error?: Error): string;\n        writeReport(fileName?: string, err?: Error): string;\n    }\n\n    interface ResourceUsage {\n        fsRead: number;\n        fsWrite: number;\n        involuntaryContextSwitches: number;\n        ipcReceived: number;\n        ipcSent: number;\n        majorPageFault: number;\n        maxRSS: number;\n        minorPageFault: number;\n        sharedMemorySize: number;\n        signalsCount: number;\n        swappedOut: number;\n        systemCPUTime: number;\n        unsharedDataSize: number;\n        unsharedStackSize: number;\n        userCPUTime: number;\n        voluntaryContextSwitches: number;\n    }\n\n    interface Process extends EventEmitter {\n        /**\n         * Can also be a tty.WriteStream, not typed due to limitation.s\n         */\n        stdout: WriteStream;\n        /**\n         * Can also be a tty.WriteStream, not typed due to limitation.s\n         */\n        stderr: WriteStream;\n        stdin: ReadStream;\n        openStdin(): Socket;\n        argv: string[];\n        argv0: string;\n        execArgv: string[];\n        execPath: string;\n        abort(): void;\n        chdir(directory: string): void;\n        cwd(): string;\n        debugPort: number;\n        emitWarning(warning: string | Error, name?: string, ctor?: Function): void;\n        env: ProcessEnv;\n        exit(code?: number): never;\n        exitCode?: number;\n        getgid(): number;\n        setgid(id: number | string): void;\n        getuid(): number;\n        setuid(id: number | string): void;\n        geteuid(): number;\n        seteuid(id: number | string): void;\n        getegid(): number;\n        setegid(id: number | string): void;\n        getgroups(): number[];\n        setgroups(groups: Array<string | number>): void;\n        setUncaughtExceptionCaptureCallback(cb: ((err: Error) => void) | null): void;\n        hasUncaughtExceptionCaptureCallback(): boolean;\n        version: string;\n        versions: ProcessVersions;\n        config: {\n            target_defaults: {\n                cflags: any[];\n                default_configuration: string;\n                defines: string[];\n                include_dirs: string[];\n                libraries: string[];\n            };\n            variables: {\n                clang: number;\n                host_arch: string;\n                node_install_npm: boolean;\n                node_install_waf: boolean;\n                node_prefix: string;\n                node_shared_openssl: boolean;\n                node_shared_v8: boolean;\n                node_shared_zlib: boolean;\n                node_use_dtrace: boolean;\n                node_use_etw: boolean;\n                node_use_openssl: boolean;\n                target_arch: string;\n                v8_no_strict_aliasing: number;\n                v8_use_snapshot: boolean;\n                visibility: string;\n            };\n        };\n        kill(pid: number, signal?: string | number): void;\n        pid: number;\n        ppid: number;\n        title: string;\n        arch: string;\n        platform: Platform;\n        mainModule?: Module;\n        memoryUsage(): MemoryUsage;\n        cpuUsage(previousValue?: CpuUsage): CpuUsage;\n        nextTick(callback: Function, ...args: any[]): void;\n        release: ProcessRelease;\n        features: {\n            inspector: boolean;\n            debug: boolean;\n            uv: boolean;\n            ipv6: boolean;\n            tls_alpn: boolean;\n            tls_sni: boolean;\n            tls_ocsp: boolean;\n            tls: boolean;\n        };\n        /**\n         * Can only be set if not in worker thread.\n         */\n        umask(mask?: number): number;\n        uptime(): number;\n        hrtime: HRTime;\n        domain: Domain;\n\n        // Worker\n        send?(message: any, sendHandle?: any, options?: { swallowErrors?: boolean}, callback?: (error: Error | null) => void): boolean;\n        disconnect(): void;\n        connected: boolean;\n\n        /**\n         * The `process.allowedNodeEnvironmentFlags` property is a special,\n         * read-only `Set` of flags allowable within the [`NODE_OPTIONS`][]\n         * environment variable.\n         */\n        allowedNodeEnvironmentFlags: ReadonlySet<string>;\n\n        /**\n         * Only available with `--experimental-report`\n         */\n        report?: ProcessReport;\n\n        resourceUsage(): ResourceUsage;\n\n        /* EventEmitter */\n        addListener(event: \"beforeExit\", listener: BeforeExitListener): this;\n        addListener(event: \"disconnect\", listener: DisconnectListener): this;\n        addListener(event: \"exit\", listener: ExitListener): this;\n        addListener(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        addListener(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        addListener(event: \"uncaughtExceptionMonitor\", listener: UncaughtExceptionListener): this;\n        addListener(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        addListener(event: \"warning\", listener: WarningListener): this;\n        addListener(event: \"message\", listener: MessageListener): this;\n        addListener(event: Signals, listener: SignalsListener): this;\n        addListener(event: \"newListener\", listener: NewListenerListener): this;\n        addListener(event: \"removeListener\", listener: RemoveListenerListener): this;\n        addListener(event: \"multipleResolves\", listener: MultipleResolveListener): this;\n\n        emit(event: \"beforeExit\", code: number): boolean;\n        emit(event: \"disconnect\"): boolean;\n        emit(event: \"exit\", code: number): boolean;\n        emit(event: \"rejectionHandled\", promise: Promise<any>): boolean;\n        emit(event: \"uncaughtException\", error: Error): boolean;\n        emit(event: \"uncaughtExceptionMonitor\", error: Error): boolean;\n        emit(event: \"unhandledRejection\", reason: any, promise: Promise<any>): boolean;\n        emit(event: \"warning\", warning: Error): boolean;\n        emit(event: \"message\", message: any, sendHandle: any): this;\n        emit(event: Signals, signal: Signals): boolean;\n        emit(event: \"newListener\", eventName: string | symbol, listener: (...args: any[]) => void): this;\n        emit(event: \"removeListener\", eventName: string, listener: (...args: any[]) => void): this;\n        emit(event: \"multipleResolves\", listener: MultipleResolveListener): this;\n\n        on(event: \"beforeExit\", listener: BeforeExitListener): this;\n        on(event: \"disconnect\", listener: DisconnectListener): this;\n        on(event: \"exit\", listener: ExitListener): this;\n        on(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        on(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        on(event: \"uncaughtExceptionMonitor\", listener: UncaughtExceptionListener): this;\n        on(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        on(event: \"warning\", listener: WarningListener): this;\n        on(event: \"message\", listener: MessageListener): this;\n        on(event: Signals, listener: SignalsListener): this;\n        on(event: \"newListener\", listener: NewListenerListener): this;\n        on(event: \"removeListener\", listener: RemoveListenerListener): this;\n        on(event: \"multipleResolves\", listener: MultipleResolveListener): this;\n\n        once(event: \"beforeExit\", listener: BeforeExitListener): this;\n        once(event: \"disconnect\", listener: DisconnectListener): this;\n        once(event: \"exit\", listener: ExitListener): this;\n        once(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        once(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        once(event: \"uncaughtExceptionMonitor\", listener: UncaughtExceptionListener): this;\n        once(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        once(event: \"warning\", listener: WarningListener): this;\n        once(event: \"message\", listener: MessageListener): this;\n        once(event: Signals, listener: SignalsListener): this;\n        once(event: \"newListener\", listener: NewListenerListener): this;\n        once(event: \"removeListener\", listener: RemoveListenerListener): this;\n        once(event: \"multipleResolves\", listener: MultipleResolveListener): this;\n\n        prependListener(event: \"beforeExit\", listener: BeforeExitListener): this;\n        prependListener(event: \"disconnect\", listener: DisconnectListener): this;\n        prependListener(event: \"exit\", listener: ExitListener): this;\n        prependListener(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        prependListener(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        prependListener(event: \"uncaughtExceptionMonitor\", listener: UncaughtExceptionListener): this;\n        prependListener(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        prependListener(event: \"warning\", listener: WarningListener): this;\n        prependListener(event: \"message\", listener: MessageListener): this;\n        prependListener(event: Signals, listener: SignalsListener): this;\n        prependListener(event: \"newListener\", listener: NewListenerListener): this;\n        prependListener(event: \"removeListener\", listener: RemoveListenerListener): this;\n        prependListener(event: \"multipleResolves\", listener: MultipleResolveListener): this;\n\n        prependOnceListener(event: \"beforeExit\", listener: BeforeExitListener): this;\n        prependOnceListener(event: \"disconnect\", listener: DisconnectListener): this;\n        prependOnceListener(event: \"exit\", listener: ExitListener): this;\n        prependOnceListener(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        prependOnceListener(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        prependOnceListener(event: \"uncaughtExceptionMonitor\", listener: UncaughtExceptionListener): this;\n        prependOnceListener(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        prependOnceListener(event: \"warning\", listener: WarningListener): this;\n        prependOnceListener(event: \"message\", listener: MessageListener): this;\n        prependOnceListener(event: Signals, listener: SignalsListener): this;\n        prependOnceListener(event: \"newListener\", listener: NewListenerListener): this;\n        prependOnceListener(event: \"removeListener\", listener: RemoveListenerListener): this;\n        prependOnceListener(event: \"multipleResolves\", listener: MultipleResolveListener): this;\n\n        listeners(event: \"beforeExit\"): BeforeExitListener[];\n        listeners(event: \"disconnect\"): DisconnectListener[];\n        listeners(event: \"exit\"): ExitListener[];\n        listeners(event: \"rejectionHandled\"): RejectionHandledListener[];\n        listeners(event: \"uncaughtException\"): UncaughtExceptionListener[];\n        listeners(event: \"uncaughtExceptionMonitor\"): UncaughtExceptionListener[];\n        listeners(event: \"unhandledRejection\"): UnhandledRejectionListener[];\n        listeners(event: \"warning\"): WarningListener[];\n        listeners(event: \"message\"): MessageListener[];\n        listeners(event: Signals): SignalsListener[];\n        listeners(event: \"newListener\"): NewListenerListener[];\n        listeners(event: \"removeListener\"): RemoveListenerListener[];\n        listeners(event: \"multipleResolves\"): MultipleResolveListener[];\n    }\n\n    interface Global {\n        Array: typeof Array;\n        ArrayBuffer: typeof ArrayBuffer;\n        Boolean: typeof Boolean;\n        Buffer: typeof Buffer;\n        DataView: typeof DataView;\n        Date: typeof Date;\n        Error: typeof Error;\n        EvalError: typeof EvalError;\n        Float32Array: typeof Float32Array;\n        Float64Array: typeof Float64Array;\n        Function: typeof Function;\n        GLOBAL: Global;\n        Infinity: typeof Infinity;\n        Int16Array: typeof Int16Array;\n        Int32Array: typeof Int32Array;\n        Int8Array: typeof Int8Array;\n        Intl: typeof Intl;\n        JSON: typeof JSON;\n        Map: MapConstructor;\n        Math: typeof Math;\n        NaN: typeof NaN;\n        Number: typeof Number;\n        Object: typeof Object;\n        Promise: typeof Promise;\n        RangeError: typeof RangeError;\n        ReferenceError: typeof ReferenceError;\n        RegExp: typeof RegExp;\n        Set: SetConstructor;\n        String: typeof String;\n        Symbol: Function;\n        SyntaxError: typeof SyntaxError;\n        TypeError: typeof TypeError;\n        URIError: typeof URIError;\n        Uint16Array: typeof Uint16Array;\n        Uint32Array: typeof Uint32Array;\n        Uint8Array: typeof Uint8Array;\n        Uint8ClampedArray: typeof Uint8ClampedArray;\n        WeakMap: WeakMapConstructor;\n        WeakSet: WeakSetConstructor;\n        clearImmediate: (immediateId: Immediate) => void;\n        clearInterval: (intervalId: Timeout) => void;\n        clearTimeout: (timeoutId: Timeout) => void;\n        console: typeof console;\n        decodeURI: typeof decodeURI;\n        decodeURIComponent: typeof decodeURIComponent;\n        encodeURI: typeof encodeURI;\n        encodeURIComponent: typeof encodeURIComponent;\n        escape: (str: string) => string;\n        eval: typeof eval;\n        global: Global;\n        isFinite: typeof isFinite;\n        isNaN: typeof isNaN;\n        parseFloat: typeof parseFloat;\n        parseInt: typeof parseInt;\n        process: Process;\n        /**\n         * @deprecated Use `global`.\n         */\n        root: Global;\n        setImmediate: (callback: (...args: any[]) => void, ...args: any[]) => Immediate;\n        setInterval: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => Timeout;\n        setTimeout: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => Timeout;\n        queueMicrotask: typeof queueMicrotask;\n        undefined: typeof undefined;\n        unescape: (str: string) => string;\n        gc: () => void;\n        v8debug?: any;\n    }\n\n    interface RefCounted {\n        ref(): this;\n        unref(): this;\n    }\n\n    // compatibility with older typings\n    interface Timer extends RefCounted {\n        hasRef(): boolean;\n        refresh(): this;\n    }\n\n    interface Immediate extends RefCounted {\n        hasRef(): boolean;\n        _onImmediate: Function; // to distinguish it from the Timeout class\n    }\n\n    interface Timeout extends Timer {\n        hasRef(): boolean;\n        refresh(): this;\n    }\n\n    type TypedArray = Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array;\n    type ArrayBufferView = TypedArray | DataView;\n\n    interface NodeRequireCache {\n        [path: string]: NodeModule;\n    }\n\n    interface Require {\n        /* tslint:disable-next-line:callable-types */\n        (id: string): any;\n        resolve: RequireResolve;\n        cache: NodeRequireCache;\n        /**\n         * @deprecated\n         */\n        extensions: RequireExtensions;\n        main: Module | undefined;\n    }\n\n    interface RequireResolve {\n        (id: string, options?: { paths?: string[]; }): string;\n        paths(request: string): string[] | null;\n    }\n\n    interface RequireExtensions {\n        '.js': (m: Module, filename: string) => any;\n        '.json': (m: Module, filename: string) => any;\n        '.node': (m: Module, filename: string) => any;\n        [ext: string]: (m: Module, filename: string) => any;\n    }\n    interface Module {\n        exports: any;\n        require: Require;\n        id: string;\n        filename: string;\n        loaded: boolean;\n        parent: Module | null;\n        children: Module[];\n        paths: string[];\n    }\n}\n\n\ndeclare module \"http\" {\n    import * as events from \"events\";\n    import * as stream from \"stream\";\n    import { URL } from \"url\";\n    import { Socket, Server as NetServer } from \"net\";\n\n    // incoming headers will never contain number\n    interface IncomingHttpHeaders {\n        'accept'?: string;\n        'accept-language'?: string;\n        'accept-patch'?: string;\n        'accept-ranges'?: string;\n        'access-control-allow-credentials'?: string;\n        'access-control-allow-headers'?: string;\n        'access-control-allow-methods'?: string;\n        'access-control-allow-origin'?: string;\n        'access-control-expose-headers'?: string;\n        'access-control-max-age'?: string;\n        'age'?: string;\n        'allow'?: string;\n        'alt-svc'?: string;\n        'authorization'?: string;\n        'cache-control'?: string;\n        'connection'?: string;\n        'content-disposition'?: string;\n        'content-encoding'?: string;\n        'content-language'?: string;\n        'content-length'?: string;\n        'content-location'?: string;\n        'content-range'?: string;\n        'content-type'?: string;\n        'cookie'?: string;\n        'date'?: string;\n        'expect'?: string;\n        'expires'?: string;\n        'forwarded'?: string;\n        'from'?: string;\n        'host'?: string;\n        'if-match'?: string;\n        'if-modified-since'?: string;\n        'if-none-match'?: string;\n        'if-unmodified-since'?: string;\n        'last-modified'?: string;\n        'location'?: string;\n        'pragma'?: string;\n        'proxy-authenticate'?: string;\n        'proxy-authorization'?: string;\n        'public-key-pins'?: string;\n        'range'?: string;\n        'referer'?: string;\n        'retry-after'?: string;\n        'set-cookie'?: string[];\n        'strict-transport-security'?: string;\n        'tk'?: string;\n        'trailer'?: string;\n        'transfer-encoding'?: string;\n        'upgrade'?: string;\n        'user-agent'?: string;\n        'vary'?: string;\n        'via'?: string;\n        'warning'?: string;\n        'www-authenticate'?: string;\n        [header: string]: string | string[] | undefined;\n    }\n\n    // outgoing headers allows numbers (as they are converted internally to strings)\n    interface OutgoingHttpHeaders {\n        [header: string]: number | string | string[] | undefined;\n    }\n\n    interface ClientRequestArgs {\n        protocol?: string | null;\n        host?: string | null;\n        hostname?: string | null;\n        family?: number;\n        port?: number | string | null;\n        defaultPort?: number | string;\n        localAddress?: string;\n        socketPath?: string;\n        /**\n         * @default 8192\n         */\n        maxHeaderSize?: number;\n        method?: string;\n        path?: string | null;\n        headers?: OutgoingHttpHeaders;\n        auth?: string | null;\n        agent?: Agent | boolean;\n        _defaultAgent?: Agent;\n        timeout?: number;\n        setHost?: boolean;\n        // https://github.com/nodejs/node/blob/master/lib/_http_client.js#L278\n        createConnection?: (options: ClientRequestArgs, oncreate: (err: Error, socket: Socket) => void) => Socket;\n    }\n\n    interface ServerOptions {\n        IncomingMessage?: typeof IncomingMessage;\n        ServerResponse?: typeof ServerResponse;\n        /**\n         * Optionally overrides the value of\n         * [`--max-http-header-size`][] for requests received by this server, i.e.\n         * the maximum length of request headers in bytes.\n         * @default 8192\n         */\n        maxHeaderSize?: number;\n        /**\n         * Use an insecure HTTP parser that accepts invalid HTTP headers when true.\n         * Using the insecure parser should be avoided.\n         * See --insecure-http-parser for more information.\n         * @default false\n         */\n        insecureHTTPParser?: boolean;\n    }\n\n    type RequestListener = (req: IncomingMessage, res: ServerResponse) => void;\n\n    interface HttpBase {\n        setTimeout(msecs?: number, callback?: () => void): this;\n        setTimeout(callback: () => void): this;\n        /**\n         * Limits maximum incoming headers count. If set to 0, no limit will be applied.\n         * @default 2000\n         * {@link https://nodejs.org/api/http.html#http_server_maxheaderscount}\n         */\n        maxHeadersCount: number | null;\n        timeout: number;\n        /**\n         * Limit the amount of time the parser will wait to receive the complete HTTP headers.\n         * @default 60000\n         * {@link https://nodejs.org/api/http.html#http_server_headerstimeout}\n         */\n        headersTimeout: number;\n        keepAliveTimeout: number;\n    }\n\n    interface Server extends HttpBase {}\n    class Server extends NetServer {\n        constructor(requestListener?: RequestListener);\n        constructor(options: ServerOptions, requestListener?: RequestListener);\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/_http_outgoing.js\n    class OutgoingMessage extends stream.Writable {\n        upgrading: boolean;\n        chunkedEncoding: boolean;\n        shouldKeepAlive: boolean;\n        useChunkedEncodingByDefault: boolean;\n        sendDate: boolean;\n        /**\n         * @deprecated Use `writableEnded` instead.\n         */\n        finished: boolean;\n        headersSent: boolean;\n        /**\n         * @deprecate Use `socket` instead.\n         */\n        connection: Socket;\n        socket: Socket;\n\n        constructor();\n\n        setTimeout(msecs: number, callback?: () => void): this;\n        setHeader(name: string, value: number | string | string[]): void;\n        getHeader(name: string): number | string | string[] | undefined;\n        getHeaders(): OutgoingHttpHeaders;\n        getHeaderNames(): string[];\n        hasHeader(name: string): boolean;\n        removeHeader(name: string): void;\n        addTrailers(headers: OutgoingHttpHeaders | Array<[string, string]>): void;\n        flushHeaders(): void;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/_http_server.js#L108-L256\n    class ServerResponse extends OutgoingMessage {\n        statusCode: number;\n        statusMessage: string;\n\n        constructor(req: IncomingMessage);\n\n        assignSocket(socket: Socket): void;\n        detachSocket(socket: Socket): void;\n        // https://github.com/nodejs/node/blob/master/test/parallel/test-http-write-callbacks.js#L53\n        // no args in writeContinue callback\n        writeContinue(callback?: () => void): void;\n        writeHead(statusCode: number, reasonPhrase?: string, headers?: OutgoingHttpHeaders): this;\n        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): this;\n        writeProcessing(): void;\n    }\n\n    interface InformationEvent {\n        statusCode: number;\n        statusMessage: string;\n        httpVersion: string;\n        httpVersionMajor: number;\n        httpVersionMinor: number;\n        headers: IncomingHttpHeaders;\n        rawHeaders: string[];\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/_http_client.js#L77\n    class ClientRequest extends OutgoingMessage {\n        connection: Socket;\n        socket: Socket;\n        aborted: number;\n\n        constructor(url: string | URL | ClientRequestArgs, cb?: (res: IncomingMessage) => void);\n\n        method: string;\n        path: string;\n        abort(): void;\n        onSocket(socket: Socket): void;\n        setTimeout(timeout: number, callback?: () => void): this;\n        setNoDelay(noDelay?: boolean): void;\n        setSocketKeepAlive(enable?: boolean, initialDelay?: number): void;\n\n        addListener(event: 'abort', listener: () => void): this;\n        addListener(event: 'connect', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;\n        addListener(event: 'continue', listener: () => void): this;\n        addListener(event: 'information', listener: (info: InformationEvent) => void): this;\n        addListener(event: 'response', listener: (response: IncomingMessage) => void): this;\n        addListener(event: 'socket', listener: (socket: Socket) => void): this;\n        addListener(event: 'timeout', listener: () => void): this;\n        addListener(event: 'upgrade', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;\n        addListener(event: 'close', listener: () => void): this;\n        addListener(event: 'drain', listener: () => void): this;\n        addListener(event: 'error', listener: (err: Error) => void): this;\n        addListener(event: 'finish', listener: () => void): this;\n        addListener(event: 'pipe', listener: (src: stream.Readable) => void): this;\n        addListener(event: 'unpipe', listener: (src: stream.Readable) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        on(event: 'abort', listener: () => void): this;\n        on(event: 'connect', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;\n        on(event: 'continue', listener: () => void): this;\n        on(event: 'information', listener: (info: InformationEvent) => void): this;\n        on(event: 'response', listener: (response: IncomingMessage) => void): this;\n        on(event: 'socket', listener: (socket: Socket) => void): this;\n        on(event: 'timeout', listener: () => void): this;\n        on(event: 'upgrade', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;\n        on(event: 'close', listener: () => void): this;\n        on(event: 'drain', listener: () => void): this;\n        on(event: 'error', listener: (err: Error) => void): this;\n        on(event: 'finish', listener: () => void): this;\n        on(event: 'pipe', listener: (src: stream.Readable) => void): this;\n        on(event: 'unpipe', listener: (src: stream.Readable) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: 'abort', listener: () => void): this;\n        once(event: 'connect', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;\n        once(event: 'continue', listener: () => void): this;\n        once(event: 'information', listener: (info: InformationEvent) => void): this;\n        once(event: 'response', listener: (response: IncomingMessage) => void): this;\n        once(event: 'socket', listener: (socket: Socket) => void): this;\n        once(event: 'timeout', listener: () => void): this;\n        once(event: 'upgrade', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;\n        once(event: 'close', listener: () => void): this;\n        once(event: 'drain', listener: () => void): this;\n        once(event: 'error', listener: (err: Error) => void): this;\n        once(event: 'finish', listener: () => void): this;\n        once(event: 'pipe', listener: (src: stream.Readable) => void): this;\n        once(event: 'unpipe', listener: (src: stream.Readable) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: 'abort', listener: () => void): this;\n        prependListener(event: 'connect', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;\n        prependListener(event: 'continue', listener: () => void): this;\n        prependListener(event: 'information', listener: (info: InformationEvent) => void): this;\n        prependListener(event: 'response', listener: (response: IncomingMessage) => void): this;\n        prependListener(event: 'socket', listener: (socket: Socket) => void): this;\n        prependListener(event: 'timeout', listener: () => void): this;\n        prependListener(event: 'upgrade', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;\n        prependListener(event: 'close', listener: () => void): this;\n        prependListener(event: 'drain', listener: () => void): this;\n        prependListener(event: 'error', listener: (err: Error) => void): this;\n        prependListener(event: 'finish', listener: () => void): this;\n        prependListener(event: 'pipe', listener: (src: stream.Readable) => void): this;\n        prependListener(event: 'unpipe', listener: (src: stream.Readable) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: 'abort', listener: () => void): this;\n        prependOnceListener(event: 'connect', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;\n        prependOnceListener(event: 'continue', listener: () => void): this;\n        prependOnceListener(event: 'information', listener: (info: InformationEvent) => void): this;\n        prependOnceListener(event: 'response', listener: (response: IncomingMessage) => void): this;\n        prependOnceListener(event: 'socket', listener: (socket: Socket) => void): this;\n        prependOnceListener(event: 'timeout', listener: () => void): this;\n        prependOnceListener(event: 'upgrade', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;\n        prependOnceListener(event: 'close', listener: () => void): this;\n        prependOnceListener(event: 'drain', listener: () => void): this;\n        prependOnceListener(event: 'error', listener: (err: Error) => void): this;\n        prependOnceListener(event: 'finish', listener: () => void): this;\n        prependOnceListener(event: 'pipe', listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: 'unpipe', listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    class IncomingMessage extends stream.Readable {\n        constructor(socket: Socket);\n\n        aborted: boolean;\n        httpVersion: string;\n        httpVersionMajor: number;\n        httpVersionMinor: number;\n        complete: boolean;\n        /**\n         * @deprecate Use `socket` instead.\n         */\n        connection: Socket;\n        socket: Socket;\n        headers: IncomingHttpHeaders;\n        rawHeaders: string[];\n        trailers: { [key: string]: string | undefined };\n        rawTrailers: string[];\n        setTimeout(msecs: number, callback?: () => void): this;\n        /**\n         * Only valid for request obtained from http.Server.\n         */\n        method?: string;\n        /**\n         * Only valid for request obtained from http.Server.\n         */\n        url?: string;\n        /**\n         * Only valid for response obtained from http.ClientRequest.\n         */\n        statusCode?: number;\n        /**\n         * Only valid for response obtained from http.ClientRequest.\n         */\n        statusMessage?: string;\n        destroy(error?: Error): void;\n    }\n\n    interface AgentOptions {\n        /**\n         * Keep sockets around in a pool to be used by other requests in the future. Default = false\n         */\n        keepAlive?: boolean;\n        /**\n         * When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.\n         * Only relevant if keepAlive is set to true.\n         */\n        keepAliveMsecs?: number;\n        /**\n         * Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity\n         */\n        maxSockets?: number;\n        /**\n         * Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256.\n         */\n        maxFreeSockets?: number;\n        /**\n         * Socket timeout in milliseconds. This will set the timeout after the socket is connected.\n         */\n        timeout?: number;\n    }\n\n    class Agent {\n        maxFreeSockets: number;\n        maxSockets: number;\n        readonly sockets: {\n            readonly [key: string]: Socket[];\n        };\n        readonly requests: {\n            readonly [key: string]: IncomingMessage[];\n        };\n\n        constructor(opts?: AgentOptions);\n\n        /**\n         * Destroy any sockets that are currently in use by the agent.\n         * It is usually not necessary to do this. However, if you are using an agent with KeepAlive enabled,\n         * then it is best to explicitly shut down the agent when you know that it will no longer be used. Otherwise,\n         * sockets may hang open for quite a long time before the server terminates them.\n         */\n        destroy(): void;\n    }\n\n    const METHODS: string[];\n\n    const STATUS_CODES: {\n        [errorCode: number]: string | undefined;\n        [errorCode: string]: string | undefined;\n    };\n\n    function createServer(requestListener?: RequestListener): Server;\n    function createServer(options: ServerOptions, requestListener?: RequestListener): Server;\n\n    // although RequestOptions are passed as ClientRequestArgs to ClientRequest directly,\n    // create interface RequestOptions would make the naming more clear to developers\n    interface RequestOptions extends ClientRequestArgs { }\n    function request(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;\n    function request(url: string | URL, options: RequestOptions, callback?: (res: IncomingMessage) => void): ClientRequest;\n    function get(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;\n    function get(url: string | URL, options: RequestOptions, callback?: (res: IncomingMessage) => void): ClientRequest;\n    let globalAgent: Agent;\n\n    /**\n     * Read-only property specifying the maximum allowed size of HTTP headers in bytes.\n     * Defaults to 8KB. Configurable using the [`--max-http-header-size`][] CLI option.\n     */\n    const maxHeaderSize: number;\n}\n\n\ndeclare module \"http2\" {\n    import * as events from \"events\";\n    import * as fs from \"fs\";\n    import * as net from \"net\";\n    import * as stream from \"stream\";\n    import * as tls from \"tls\";\n    import * as url from \"url\";\n\n    import { IncomingHttpHeaders as Http1IncomingHttpHeaders, OutgoingHttpHeaders, IncomingMessage, ServerResponse } from \"http\";\n    export { OutgoingHttpHeaders } from \"http\";\n\n    export interface IncomingHttpStatusHeader {\n        \":status\"?: number;\n    }\n\n    export interface IncomingHttpHeaders extends Http1IncomingHttpHeaders {\n        \":path\"?: string;\n        \":method\"?: string;\n        \":authority\"?: string;\n        \":scheme\"?: string;\n    }\n\n    // Http2Stream\n\n    export interface StreamPriorityOptions {\n        exclusive?: boolean;\n        parent?: number;\n        weight?: number;\n        silent?: boolean;\n    }\n\n    export interface StreamState {\n        localWindowSize?: number;\n        state?: number;\n        localClose?: number;\n        remoteClose?: number;\n        sumDependencyWeight?: number;\n        weight?: number;\n    }\n\n    export interface ServerStreamResponseOptions {\n        endStream?: boolean;\n        waitForTrailers?: boolean;\n    }\n\n    export interface StatOptions {\n        offset: number;\n        length: number;\n    }\n\n    export interface ServerStreamFileResponseOptions {\n        statCheck?(stats: fs.Stats, headers: OutgoingHttpHeaders, statOptions: StatOptions): void | boolean;\n        waitForTrailers?: boolean;\n        offset?: number;\n        length?: number;\n    }\n\n    export interface ServerStreamFileResponseOptionsWithError extends ServerStreamFileResponseOptions {\n        onError?(err: NodeJS.ErrnoException): void;\n    }\n\n    export interface Http2Stream extends stream.Duplex {\n        readonly aborted: boolean;\n        readonly bufferSize: number;\n        readonly closed: boolean;\n        readonly destroyed: boolean;\n        /**\n         * Set the true if the END_STREAM flag was set in the request or response HEADERS frame received,\n         * indicating that no additional data should be received and the readable side of the Http2Stream will be closed.\n         */\n        readonly endAfterHeaders: boolean;\n        readonly id?: number;\n        readonly pending: boolean;\n        readonly rstCode: number;\n        readonly sentHeaders: OutgoingHttpHeaders;\n        readonly sentInfoHeaders?: OutgoingHttpHeaders[];\n        readonly sentTrailers?: OutgoingHttpHeaders;\n        readonly session: Http2Session;\n        readonly state: StreamState;\n\n        close(code?: number, callback?: () => void): void;\n        priority(options: StreamPriorityOptions): void;\n        setTimeout(msecs: number, callback?: () => void): void;\n        sendTrailers(headers: OutgoingHttpHeaders): void;\n\n        addListener(event: \"aborted\", listener: () => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"end\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"finish\", listener: () => void): this;\n        addListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        addListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: \"streamClosed\", listener: (code: number) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n        addListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: \"wantTrailers\", listener: () => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        emit(event: \"aborted\"): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"data\", chunk: Buffer | string): boolean;\n        emit(event: \"drain\"): boolean;\n        emit(event: \"end\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"finish\"): boolean;\n        emit(event: \"frameError\", frameType: number, errorCode: number): boolean;\n        emit(event: \"pipe\", src: stream.Readable): boolean;\n        emit(event: \"unpipe\", src: stream.Readable): boolean;\n        emit(event: \"streamClosed\", code: number): boolean;\n        emit(event: \"timeout\"): boolean;\n        emit(event: \"trailers\", trailers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: \"wantTrailers\"): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n\n        on(event: \"aborted\", listener: () => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"end\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"finish\", listener: () => void): this;\n        on(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        on(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        on(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        on(event: \"streamClosed\", listener: (code: number) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n        on(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: \"wantTrailers\", listener: () => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"aborted\", listener: () => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"end\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"finish\", listener: () => void): this;\n        once(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        once(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        once(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        once(event: \"streamClosed\", listener: (code: number) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n        once(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: \"wantTrailers\", listener: () => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"aborted\", listener: () => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"end\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"finish\", listener: () => void): this;\n        prependListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        prependListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: \"streamClosed\", listener: (code: number) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n        prependListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: \"wantTrailers\", listener: () => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"aborted\", listener: () => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"end\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"finish\", listener: () => void): this;\n        prependOnceListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        prependOnceListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: \"streamClosed\", listener: (code: number) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n        prependOnceListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: \"wantTrailers\", listener: () => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    export interface ClientHttp2Stream extends Http2Stream {\n        addListener(event: \"continue\", listener: () => {}): this;\n        addListener(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        addListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        emit(event: \"continue\"): boolean;\n        emit(event: \"headers\", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;\n        emit(event: \"push\", headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: \"response\", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n\n        on(event: \"continue\", listener: () => {}): this;\n        on(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        on(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"continue\", listener: () => {}): this;\n        once(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        once(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"continue\", listener: () => {}): this;\n        prependListener(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        prependListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"continue\", listener: () => {}): this;\n        prependOnceListener(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        prependOnceListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    export interface ServerHttp2Stream extends Http2Stream {\n        readonly headersSent: boolean;\n        readonly pushAllowed: boolean;\n        additionalHeaders(headers: OutgoingHttpHeaders): void;\n        pushStream(headers: OutgoingHttpHeaders, callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void): void;\n        pushStream(headers: OutgoingHttpHeaders, options?: StreamPriorityOptions, callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void): void;\n        respond(headers?: OutgoingHttpHeaders, options?: ServerStreamResponseOptions): void;\n        respondWithFD(fd: number | fs.promises.FileHandle, headers?: OutgoingHttpHeaders, options?: ServerStreamFileResponseOptions): void;\n        respondWithFile(path: string, headers?: OutgoingHttpHeaders, options?: ServerStreamFileResponseOptionsWithError): void;\n    }\n\n    // Http2Session\n\n    export interface Settings {\n        headerTableSize?: number;\n        enablePush?: boolean;\n        initialWindowSize?: number;\n        maxFrameSize?: number;\n        maxConcurrentStreams?: number;\n        maxHeaderListSize?: number;\n        enableConnectProtocol?: boolean;\n    }\n\n    export interface ClientSessionRequestOptions {\n        endStream?: boolean;\n        exclusive?: boolean;\n        parent?: number;\n        weight?: number;\n        waitForTrailers?: boolean;\n    }\n\n    export interface SessionState {\n        effectiveLocalWindowSize?: number;\n        effectiveRecvDataLength?: number;\n        nextStreamID?: number;\n        localWindowSize?: number;\n        lastProcStreamID?: number;\n        remoteWindowSize?: number;\n        outboundQueueSize?: number;\n        deflateDynamicTableSize?: number;\n        inflateDynamicTableSize?: number;\n    }\n\n    export interface Http2Session extends events.EventEmitter {\n        readonly alpnProtocol?: string;\n        readonly closed: boolean;\n        readonly connecting: boolean;\n        readonly destroyed: boolean;\n        readonly encrypted?: boolean;\n        readonly localSettings: Settings;\n        readonly originSet?: string[];\n        readonly pendingSettingsAck: boolean;\n        readonly remoteSettings: Settings;\n        readonly socket: net.Socket | tls.TLSSocket;\n        readonly state: SessionState;\n        readonly type: number;\n\n        close(callback?: () => void): void;\n        destroy(error?: Error, code?: number): void;\n        goaway(code?: number, lastStreamID?: number, opaqueData?: NodeJS.ArrayBufferView): void;\n        ping(callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;\n        ping(payload: NodeJS.ArrayBufferView, callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;\n        ref(): void;\n        setTimeout(msecs: number, callback?: () => void): void;\n        settings(settings: Settings): void;\n        unref(): void;\n\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        addListener(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        addListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        addListener(event: \"ping\", listener: () => void): this;\n        addListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        emit(event: \"close\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"frameError\", frameType: number, errorCode: number, streamID: number): boolean;\n        emit(event: \"goaway\", errorCode: number, lastStreamID: number, opaqueData: Buffer): boolean;\n        emit(event: \"localSettings\", settings: Settings): boolean;\n        emit(event: \"ping\"): boolean;\n        emit(event: \"remoteSettings\", settings: Settings): boolean;\n        emit(event: \"timeout\"): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        on(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        on(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        on(event: \"ping\", listener: () => void): this;\n        on(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        once(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        once(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        once(event: \"ping\", listener: () => void): this;\n        once(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        prependListener(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        prependListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        prependListener(event: \"ping\", listener: () => void): this;\n        prependListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        prependOnceListener(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        prependOnceListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        prependOnceListener(event: \"ping\", listener: () => void): this;\n        prependOnceListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    export interface ClientHttp2Session extends Http2Session {\n        request(headers?: OutgoingHttpHeaders, options?: ClientSessionRequestOptions): ClientHttp2Stream;\n\n        addListener(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        addListener(event: \"origin\", listener: (origins: string[]) => void): this;\n        addListener(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        addListener(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        emit(event: \"altsvc\", alt: string, origin: string, stream: number): boolean;\n        emit(event: \"origin\", origins: string[]): boolean;\n        emit(event: \"connect\", session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;\n        emit(event: \"stream\", stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n\n        on(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        on(event: \"origin\", listener: (origins: string[]) => void): this;\n        on(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        on(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        once(event: \"origin\", listener: (origins: string[]) => void): this;\n        once(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        once(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        prependListener(event: \"origin\", listener: (origins: string[]) => void): this;\n        prependListener(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependListener(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        prependOnceListener(event: \"origin\", listener: (origins: string[]) => void): this;\n        prependOnceListener(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependOnceListener(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    export interface AlternativeServiceOptions {\n        origin: number | string | url.URL;\n    }\n\n    export interface ServerHttp2Session extends Http2Session {\n        readonly server: Http2Server | Http2SecureServer;\n\n        altsvc(alt: string, originOrStream: number | string | url.URL | AlternativeServiceOptions): void;\n        origin(...args: Array<string | url.URL | { origin: string }>): void;\n\n        addListener(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        addListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        emit(event: \"connect\", session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n\n        on(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        on(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        once(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependOnceListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    // Http2Server\n\n    export interface SessionOptions {\n        maxDeflateDynamicTableSize?: number;\n        maxSessionMemory?: number;\n        maxHeaderListPairs?: number;\n        maxOutstandingPings?: number;\n        maxSendHeaderBlockLength?: number;\n        paddingStrategy?: number;\n        peerMaxConcurrentStreams?: number;\n        settings?: Settings;\n\n        selectPadding?(frameLen: number, maxFrameLen: number): number;\n        createConnection?(authority: url.URL, option: SessionOptions): stream.Duplex;\n    }\n\n    export interface ClientSessionOptions extends SessionOptions {\n        maxReservedRemoteStreams?: number;\n        createConnection?: (authority: url.URL, option: SessionOptions) => stream.Duplex;\n        protocol?: 'http:' | 'https:';\n    }\n\n    export interface ServerSessionOptions extends SessionOptions {\n        Http1IncomingMessage?: typeof IncomingMessage;\n        Http1ServerResponse?: typeof ServerResponse;\n        Http2ServerRequest?: typeof Http2ServerRequest;\n        Http2ServerResponse?: typeof Http2ServerResponse;\n    }\n\n    export interface SecureClientSessionOptions extends ClientSessionOptions, tls.ConnectionOptions { }\n    export interface SecureServerSessionOptions extends ServerSessionOptions, tls.TlsOptions { }\n\n    export interface ServerOptions extends ServerSessionOptions { }\n\n    export interface SecureServerOptions extends SecureServerSessionOptions {\n        allowHTTP1?: boolean;\n        origins?: string[];\n    }\n\n    export interface Http2Server extends net.Server {\n        addListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: \"session\", listener: (session: ServerHttp2Session) => void): this;\n        addListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        addListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        emit(event: \"checkContinue\", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: \"request\", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: \"session\", session: ServerHttp2Session): boolean;\n        emit(event: \"sessionError\", err: Error): boolean;\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: \"timeout\"): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n\n        on(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: \"session\", listener: (session: ServerHttp2Session) => void): this;\n        on(event: \"sessionError\", listener: (err: Error) => void): this;\n        on(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: \"session\", listener: (session: ServerHttp2Session) => void): this;\n        once(event: \"sessionError\", listener: (err: Error) => void): this;\n        once(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: \"session\", listener: (session: ServerHttp2Session) => void): this;\n        prependListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: \"session\", listener: (session: ServerHttp2Session) => void): this;\n        prependOnceListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        setTimeout(msec?: number, callback?: () => void): this;\n    }\n\n    export interface Http2SecureServer extends tls.Server {\n        addListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: \"session\", listener: (session: ServerHttp2Session) => void): this;\n        addListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        addListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n        addListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        emit(event: \"checkContinue\", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: \"request\", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: \"session\", session: ServerHttp2Session): boolean;\n        emit(event: \"sessionError\", err: Error): boolean;\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: \"timeout\"): boolean;\n        emit(event: \"unknownProtocol\", socket: tls.TLSSocket): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n\n        on(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: \"session\", listener: (session: ServerHttp2Session) => void): this;\n        on(event: \"sessionError\", listener: (err: Error) => void): this;\n        on(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n        on(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: \"session\", listener: (session: ServerHttp2Session) => void): this;\n        once(event: \"sessionError\", listener: (err: Error) => void): this;\n        once(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n        once(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: \"session\", listener: (session: ServerHttp2Session) => void): this;\n        prependListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n        prependListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: \"session\", listener: (session: ServerHttp2Session) => void): this;\n        prependOnceListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n        prependOnceListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        setTimeout(msec?: number, callback?: () => void): this;\n    }\n\n    export class Http2ServerRequest extends stream.Readable {\n        constructor(stream: ServerHttp2Stream, headers: IncomingHttpHeaders, options: stream.ReadableOptions, rawHeaders: string[]);\n\n        readonly aborted: boolean;\n        readonly authority: string;\n        readonly headers: IncomingHttpHeaders;\n        readonly httpVersion: string;\n        readonly method: string;\n        readonly rawHeaders: string[];\n        readonly rawTrailers: string[];\n        readonly scheme: string;\n        readonly socket: net.Socket | tls.TLSSocket;\n        readonly stream: ServerHttp2Stream;\n        readonly trailers: IncomingHttpHeaders;\n        readonly url: string;\n\n        setTimeout(msecs: number, callback?: () => void): void;\n        read(size?: number): Buffer | string | null;\n\n        addListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        addListener(event: \"end\", listener: () => void): this;\n        addListener(event: \"readable\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        emit(event: \"aborted\", hadError: boolean, code: number): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"data\", chunk: Buffer | string): boolean;\n        emit(event: \"end\"): boolean;\n        emit(event: \"readable\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n\n        on(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        on(event: \"end\", listener: () => void): this;\n        on(event: \"readable\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        once(event: \"end\", listener: () => void): this;\n        once(event: \"readable\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependListener(event: \"end\", listener: () => void): this;\n        prependListener(event: \"readable\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependOnceListener(event: \"end\", listener: () => void): this;\n        prependOnceListener(event: \"readable\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    export class Http2ServerResponse extends stream.Stream {\n        constructor(stream: ServerHttp2Stream);\n\n        readonly connection: net.Socket | tls.TLSSocket;\n        readonly finished: boolean;\n        readonly headersSent: boolean;\n        readonly socket: net.Socket | tls.TLSSocket;\n        readonly stream: ServerHttp2Stream;\n        sendDate: boolean;\n        statusCode: number;\n        statusMessage: '';\n        addTrailers(trailers: OutgoingHttpHeaders): void;\n        end(callback?: () => void): void;\n        end(data: string | Uint8Array, callback?: () => void): void;\n        end(data: string | Uint8Array, encoding: string, callback?: () => void): void;\n        getHeader(name: string): string;\n        getHeaderNames(): string[];\n        getHeaders(): OutgoingHttpHeaders;\n        hasHeader(name: string): boolean;\n        removeHeader(name: string): void;\n        setHeader(name: string, value: number | string | string[]): void;\n        setTimeout(msecs: number, callback?: () => void): void;\n        write(chunk: string | Uint8Array, callback?: (err: Error) => void): boolean;\n        write(chunk: string | Uint8Array, encoding: string, callback?: (err: Error) => void): boolean;\n        writeContinue(): void;\n        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): this;\n        writeHead(statusCode: number, statusMessage: string, headers?: OutgoingHttpHeaders): this;\n        createPushResponse(headers: OutgoingHttpHeaders, callback: (err: Error | null, res: Http2ServerResponse) => void): void;\n\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"error\", listener: (error: Error) => void): this;\n        addListener(event: \"finish\", listener: () => void): this;\n        addListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        emit(event: \"close\"): boolean;\n        emit(event: \"drain\"): boolean;\n        emit(event: \"error\", error: Error): boolean;\n        emit(event: \"finish\"): boolean;\n        emit(event: \"pipe\", src: stream.Readable): boolean;\n        emit(event: \"unpipe\", src: stream.Readable): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"error\", listener: (error: Error) => void): this;\n        on(event: \"finish\", listener: () => void): this;\n        on(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        on(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"error\", listener: (error: Error) => void): this;\n        once(event: \"finish\", listener: () => void): this;\n        once(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        once(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\n        prependListener(event: \"finish\", listener: () => void): this;\n        prependListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\n        prependOnceListener(event: \"finish\", listener: () => void): this;\n        prependOnceListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    // Public API\n\n    export namespace constants {\n        const NGHTTP2_SESSION_SERVER: number;\n        const NGHTTP2_SESSION_CLIENT: number;\n        const NGHTTP2_STREAM_STATE_IDLE: number;\n        const NGHTTP2_STREAM_STATE_OPEN: number;\n        const NGHTTP2_STREAM_STATE_RESERVED_LOCAL: number;\n        const NGHTTP2_STREAM_STATE_RESERVED_REMOTE: number;\n        const NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: number;\n        const NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: number;\n        const NGHTTP2_STREAM_STATE_CLOSED: number;\n        const NGHTTP2_NO_ERROR: number;\n        const NGHTTP2_PROTOCOL_ERROR: number;\n        const NGHTTP2_INTERNAL_ERROR: number;\n        const NGHTTP2_FLOW_CONTROL_ERROR: number;\n        const NGHTTP2_SETTINGS_TIMEOUT: number;\n        const NGHTTP2_STREAM_CLOSED: number;\n        const NGHTTP2_FRAME_SIZE_ERROR: number;\n        const NGHTTP2_REFUSED_STREAM: number;\n        const NGHTTP2_CANCEL: number;\n        const NGHTTP2_COMPRESSION_ERROR: number;\n        const NGHTTP2_CONNECT_ERROR: number;\n        const NGHTTP2_ENHANCE_YOUR_CALM: number;\n        const NGHTTP2_INADEQUATE_SECURITY: number;\n        const NGHTTP2_HTTP_1_1_REQUIRED: number;\n        const NGHTTP2_ERR_FRAME_SIZE_ERROR: number;\n        const NGHTTP2_FLAG_NONE: number;\n        const NGHTTP2_FLAG_END_STREAM: number;\n        const NGHTTP2_FLAG_END_HEADERS: number;\n        const NGHTTP2_FLAG_ACK: number;\n        const NGHTTP2_FLAG_PADDED: number;\n        const NGHTTP2_FLAG_PRIORITY: number;\n        const DEFAULT_SETTINGS_HEADER_TABLE_SIZE: number;\n        const DEFAULT_SETTINGS_ENABLE_PUSH: number;\n        const DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: number;\n        const DEFAULT_SETTINGS_MAX_FRAME_SIZE: number;\n        const MAX_MAX_FRAME_SIZE: number;\n        const MIN_MAX_FRAME_SIZE: number;\n        const MAX_INITIAL_WINDOW_SIZE: number;\n        const NGHTTP2_DEFAULT_WEIGHT: number;\n        const NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: number;\n        const NGHTTP2_SETTINGS_ENABLE_PUSH: number;\n        const NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: number;\n        const NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: number;\n        const NGHTTP2_SETTINGS_MAX_FRAME_SIZE: number;\n        const NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: number;\n        const PADDING_STRATEGY_NONE: number;\n        const PADDING_STRATEGY_MAX: number;\n        const PADDING_STRATEGY_CALLBACK: number;\n        const HTTP2_HEADER_STATUS: string;\n        const HTTP2_HEADER_METHOD: string;\n        const HTTP2_HEADER_AUTHORITY: string;\n        const HTTP2_HEADER_SCHEME: string;\n        const HTTP2_HEADER_PATH: string;\n        const HTTP2_HEADER_ACCEPT_CHARSET: string;\n        const HTTP2_HEADER_ACCEPT_ENCODING: string;\n        const HTTP2_HEADER_ACCEPT_LANGUAGE: string;\n        const HTTP2_HEADER_ACCEPT_RANGES: string;\n        const HTTP2_HEADER_ACCEPT: string;\n        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: string;\n        const HTTP2_HEADER_AGE: string;\n        const HTTP2_HEADER_ALLOW: string;\n        const HTTP2_HEADER_AUTHORIZATION: string;\n        const HTTP2_HEADER_CACHE_CONTROL: string;\n        const HTTP2_HEADER_CONNECTION: string;\n        const HTTP2_HEADER_CONTENT_DISPOSITION: string;\n        const HTTP2_HEADER_CONTENT_ENCODING: string;\n        const HTTP2_HEADER_CONTENT_LANGUAGE: string;\n        const HTTP2_HEADER_CONTENT_LENGTH: string;\n        const HTTP2_HEADER_CONTENT_LOCATION: string;\n        const HTTP2_HEADER_CONTENT_MD5: string;\n        const HTTP2_HEADER_CONTENT_RANGE: string;\n        const HTTP2_HEADER_CONTENT_TYPE: string;\n        const HTTP2_HEADER_COOKIE: string;\n        const HTTP2_HEADER_DATE: string;\n        const HTTP2_HEADER_ETAG: string;\n        const HTTP2_HEADER_EXPECT: string;\n        const HTTP2_HEADER_EXPIRES: string;\n        const HTTP2_HEADER_FROM: string;\n        const HTTP2_HEADER_HOST: string;\n        const HTTP2_HEADER_IF_MATCH: string;\n        const HTTP2_HEADER_IF_MODIFIED_SINCE: string;\n        const HTTP2_HEADER_IF_NONE_MATCH: string;\n        const HTTP2_HEADER_IF_RANGE: string;\n        const HTTP2_HEADER_IF_UNMODIFIED_SINCE: string;\n        const HTTP2_HEADER_LAST_MODIFIED: string;\n        const HTTP2_HEADER_LINK: string;\n        const HTTP2_HEADER_LOCATION: string;\n        const HTTP2_HEADER_MAX_FORWARDS: string;\n        const HTTP2_HEADER_PREFER: string;\n        const HTTP2_HEADER_PROXY_AUTHENTICATE: string;\n        const HTTP2_HEADER_PROXY_AUTHORIZATION: string;\n        const HTTP2_HEADER_RANGE: string;\n        const HTTP2_HEADER_REFERER: string;\n        const HTTP2_HEADER_REFRESH: string;\n        const HTTP2_HEADER_RETRY_AFTER: string;\n        const HTTP2_HEADER_SERVER: string;\n        const HTTP2_HEADER_SET_COOKIE: string;\n        const HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: string;\n        const HTTP2_HEADER_TRANSFER_ENCODING: string;\n        const HTTP2_HEADER_TE: string;\n        const HTTP2_HEADER_UPGRADE: string;\n        const HTTP2_HEADER_USER_AGENT: string;\n        const HTTP2_HEADER_VARY: string;\n        const HTTP2_HEADER_VIA: string;\n        const HTTP2_HEADER_WWW_AUTHENTICATE: string;\n        const HTTP2_HEADER_HTTP2_SETTINGS: string;\n        const HTTP2_HEADER_KEEP_ALIVE: string;\n        const HTTP2_HEADER_PROXY_CONNECTION: string;\n        const HTTP2_METHOD_ACL: string;\n        const HTTP2_METHOD_BASELINE_CONTROL: string;\n        const HTTP2_METHOD_BIND: string;\n        const HTTP2_METHOD_CHECKIN: string;\n        const HTTP2_METHOD_CHECKOUT: string;\n        const HTTP2_METHOD_CONNECT: string;\n        const HTTP2_METHOD_COPY: string;\n        const HTTP2_METHOD_DELETE: string;\n        const HTTP2_METHOD_GET: string;\n        const HTTP2_METHOD_HEAD: string;\n        const HTTP2_METHOD_LABEL: string;\n        const HTTP2_METHOD_LINK: string;\n        const HTTP2_METHOD_LOCK: string;\n        const HTTP2_METHOD_MERGE: string;\n        const HTTP2_METHOD_MKACTIVITY: string;\n        const HTTP2_METHOD_MKCALENDAR: string;\n        const HTTP2_METHOD_MKCOL: string;\n        const HTTP2_METHOD_MKREDIRECTREF: string;\n        const HTTP2_METHOD_MKWORKSPACE: string;\n        const HTTP2_METHOD_MOVE: string;\n        const HTTP2_METHOD_OPTIONS: string;\n        const HTTP2_METHOD_ORDERPATCH: string;\n        const HTTP2_METHOD_PATCH: string;\n        const HTTP2_METHOD_POST: string;\n        const HTTP2_METHOD_PRI: string;\n        const HTTP2_METHOD_PROPFIND: string;\n        const HTTP2_METHOD_PROPPATCH: string;\n        const HTTP2_METHOD_PUT: string;\n        const HTTP2_METHOD_REBIND: string;\n        const HTTP2_METHOD_REPORT: string;\n        const HTTP2_METHOD_SEARCH: string;\n        const HTTP2_METHOD_TRACE: string;\n        const HTTP2_METHOD_UNBIND: string;\n        const HTTP2_METHOD_UNCHECKOUT: string;\n        const HTTP2_METHOD_UNLINK: string;\n        const HTTP2_METHOD_UNLOCK: string;\n        const HTTP2_METHOD_UPDATE: string;\n        const HTTP2_METHOD_UPDATEREDIRECTREF: string;\n        const HTTP2_METHOD_VERSION_CONTROL: string;\n        const HTTP_STATUS_CONTINUE: number;\n        const HTTP_STATUS_SWITCHING_PROTOCOLS: number;\n        const HTTP_STATUS_PROCESSING: number;\n        const HTTP_STATUS_OK: number;\n        const HTTP_STATUS_CREATED: number;\n        const HTTP_STATUS_ACCEPTED: number;\n        const HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: number;\n        const HTTP_STATUS_NO_CONTENT: number;\n        const HTTP_STATUS_RESET_CONTENT: number;\n        const HTTP_STATUS_PARTIAL_CONTENT: number;\n        const HTTP_STATUS_MULTI_STATUS: number;\n        const HTTP_STATUS_ALREADY_REPORTED: number;\n        const HTTP_STATUS_IM_USED: number;\n        const HTTP_STATUS_MULTIPLE_CHOICES: number;\n        const HTTP_STATUS_MOVED_PERMANENTLY: number;\n        const HTTP_STATUS_FOUND: number;\n        const HTTP_STATUS_SEE_OTHER: number;\n        const HTTP_STATUS_NOT_MODIFIED: number;\n        const HTTP_STATUS_USE_PROXY: number;\n        const HTTP_STATUS_TEMPORARY_REDIRECT: number;\n        const HTTP_STATUS_PERMANENT_REDIRECT: number;\n        const HTTP_STATUS_BAD_REQUEST: number;\n        const HTTP_STATUS_UNAUTHORIZED: number;\n        const HTTP_STATUS_PAYMENT_REQUIRED: number;\n        const HTTP_STATUS_FORBIDDEN: number;\n        const HTTP_STATUS_NOT_FOUND: number;\n        const HTTP_STATUS_METHOD_NOT_ALLOWED: number;\n        const HTTP_STATUS_NOT_ACCEPTABLE: number;\n        const HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: number;\n        const HTTP_STATUS_REQUEST_TIMEOUT: number;\n        const HTTP_STATUS_CONFLICT: number;\n        const HTTP_STATUS_GONE: number;\n        const HTTP_STATUS_LENGTH_REQUIRED: number;\n        const HTTP_STATUS_PRECONDITION_FAILED: number;\n        const HTTP_STATUS_PAYLOAD_TOO_LARGE: number;\n        const HTTP_STATUS_URI_TOO_LONG: number;\n        const HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: number;\n        const HTTP_STATUS_RANGE_NOT_SATISFIABLE: number;\n        const HTTP_STATUS_EXPECTATION_FAILED: number;\n        const HTTP_STATUS_TEAPOT: number;\n        const HTTP_STATUS_MISDIRECTED_REQUEST: number;\n        const HTTP_STATUS_UNPROCESSABLE_ENTITY: number;\n        const HTTP_STATUS_LOCKED: number;\n        const HTTP_STATUS_FAILED_DEPENDENCY: number;\n        const HTTP_STATUS_UNORDERED_COLLECTION: number;\n        const HTTP_STATUS_UPGRADE_REQUIRED: number;\n        const HTTP_STATUS_PRECONDITION_REQUIRED: number;\n        const HTTP_STATUS_TOO_MANY_REQUESTS: number;\n        const HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: number;\n        const HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: number;\n        const HTTP_STATUS_INTERNAL_SERVER_ERROR: number;\n        const HTTP_STATUS_NOT_IMPLEMENTED: number;\n        const HTTP_STATUS_BAD_GATEWAY: number;\n        const HTTP_STATUS_SERVICE_UNAVAILABLE: number;\n        const HTTP_STATUS_GATEWAY_TIMEOUT: number;\n        const HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: number;\n        const HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: number;\n        const HTTP_STATUS_INSUFFICIENT_STORAGE: number;\n        const HTTP_STATUS_LOOP_DETECTED: number;\n        const HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: number;\n        const HTTP_STATUS_NOT_EXTENDED: number;\n        const HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: number;\n    }\n\n    export function getDefaultSettings(): Settings;\n    export function getPackedSettings(settings: Settings): Buffer;\n    export function getUnpackedSettings(buf: Uint8Array): Settings;\n\n    export function createServer(onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2Server;\n    export function createServer(options: ServerOptions, onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2Server;\n\n    export function createSecureServer(onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2SecureServer;\n    export function createSecureServer(options: SecureServerOptions, onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2SecureServer;\n\n    export function connect(authority: string | url.URL, listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): ClientHttp2Session;\n    export function connect(\n        authority: string | url.URL,\n        options?: ClientSessionOptions | SecureClientSessionOptions,\n        listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void\n    ): ClientHttp2Session;\n}\n\n\ndeclare module \"https\" {\n    import * as tls from \"tls\";\n    import * as events from \"events\";\n    import * as http from \"http\";\n    import { URL } from \"url\";\n\n    type ServerOptions = tls.SecureContextOptions & tls.TlsOptions & http.ServerOptions;\n\n    type RequestOptions = http.RequestOptions & tls.SecureContextOptions & {\n        rejectUnauthorized?: boolean; // Defaults to true\n        servername?: string; // SNI TLS Extension\n    };\n\n    interface AgentOptions extends http.AgentOptions, tls.ConnectionOptions {\n        rejectUnauthorized?: boolean;\n        maxCachedSessions?: number;\n    }\n\n    class Agent extends http.Agent {\n        constructor(options?: AgentOptions);\n        options: AgentOptions;\n    }\n\n    interface Server extends http.HttpBase {}\n    class Server extends tls.Server {\n        constructor(requestListener?: http.RequestListener);\n        constructor(options: ServerOptions, requestListener?: http.RequestListener);\n    }\n\n    function createServer(requestListener?: http.RequestListener): Server;\n    function createServer(options: ServerOptions, requestListener?: http.RequestListener): Server;\n    function request(options: RequestOptions | string | URL, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    function request(url: string | URL, options: RequestOptions, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    function get(options: RequestOptions | string | URL, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    function get(url: string | URL, options: RequestOptions, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    let globalAgent: Agent;\n}\n\n\n// Type definitions for non-npm package Node.js 13.11\n// Project: http://nodejs.org/\n// Definitions by: Microsoft TypeScript <https://github.com/Microsoft>\n//                 DefinitelyTyped <https://github.com/DefinitelyTyped>\n//                 Alberto Schiabel <https://github.com/jkomyno>\n//                 Alexander T. <https://github.com/a-tarasyuk>\n//                 Alvis HT Tang <https://github.com/alvis>\n//                 Andrew Makarov <https://github.com/r3nya>\n//                 Benjamin Toueg <https://github.com/btoueg>\n//                 Bruno Scheufler <https://github.com/brunoscheufler>\n//                 Chigozirim C. <https://github.com/smac89>\n//                 Christian Vaagland Tellnes <https://github.com/tellnes>\n//                 David Junger <https://github.com/touffy>\n//                 Deividas Bakanas <https://github.com/DeividasBakanas>\n//                 Eugene Y. Q. Shen <https://github.com/eyqs>\n//                 Flarna <https://github.com/Flarna>\n//                 Hannes Magnusson <https://github.com/Hannes-Magnusson-CK>\n//                 Ho\u00e0ng V\u0103n Kh\u1ea3i <https://github.com/KSXGitHub>\n//                 Huw <https://github.com/hoo29>\n//                 Kelvin Jin <https://github.com/kjin>\n//                 Klaus Meinhardt <https://github.com/ajafff>\n//                 Lishude <https://github.com/islishude>\n//                 Mariusz Wiktorczyk <https://github.com/mwiktorczyk>\n//                 Mohsen Azimi <https://github.com/mohsen1>\n//                 Nicolas Even <https://github.com/n-e>\n//                 Nicolas Voigt <https://github.com/octo-sniffle>\n//                 Nikita Galkin <https://github.com/galkin>\n//                 Parambir Singh <https://github.com/parambirs>\n//                 Sebastian Silbermann <https://github.com/eps1lon>\n//                 Simon Schick <https://github.com/SimonSchick>\n//                 Thomas den Hollander <https://github.com/ThomasdenH>\n//                 Wilco Bakker <https://github.com/WilcoBakker>\n//                 wwwy3y3 <https://github.com/wwwy3y3>\n//                 Samuel Ainsworth <https://github.com/samuela>\n//                 Kyle Uehlein <https://github.com/kuehlein>\n//                 Jordi Oliveras Rovira <https://github.com/j-oliveras>\n//                 Thanik Bhongbhibhat <https://github.com/bhongy>\n//                 Marcin Kopacz <https://github.com/chyzwar>\n//                 Trivikram Kamat <https://github.com/trivikr>\n//                 Minh Son Nguyen <https://github.com/nguymin4>\n//                 Junxiao Shi <https://github.com/yoursunny>\n//                 Ilia Baryshnikov <https://github.com/qwelias>\n//                 ExE Boss <https://github.com/ExE-Boss>\n//                 Surasak Chaisurin <https://github.com/Ryan-Willpower>\n//                 Piotr B\u0142a\u017cejewicz <https://github.com/peterblazejewicz>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n// NOTE: These definitions support NodeJS and TypeScript 3.5.\n\n// NOTE: TypeScript version-specific augmentations can be found in the following paths:\n//          - ~/base.d.ts         - Shared definitions common to all TypeScript versions\n//          - ~/index.d.ts        - Definitions specific to TypeScript 2.8\n//          - ~/ts3.5/index.d.ts  - Definitions specific to TypeScript 3.5\n\n// NOTE: Augmentations for TypeScript 3.5 and later should use individual files for overrides\n//       within the respective ~/ts3.5 (or later) folder. However, this is disallowed for versions\n//       prior to TypeScript 3.5, so the older definitions will be found here.\n\n// Base definitions for all NodeJS modules that are not specific to any version of TypeScript:\n/// <reference path=\"base.d.ts\" />\n\n// Forward-declarations for needed types from es2015 and later (in case users are using `--lib es5`)\n// Empty interfaces are used here which merge fine with the real declarations in the lib XXX files\n// just to ensure the names are known and node typings can be used without importing these libs.\n// if someone really needs these types the libs need to be added via --lib or in tsconfig.json\ninterface AsyncIterable<T> { }\ninterface IterableIterator<T> { }\ninterface AsyncIterableIterator<T> {}\ninterface SymbolConstructor {\n    readonly asyncIterator: symbol;\n}\ndeclare var Symbol: SymbolConstructor;\n// even this is just a forward declaration some properties are added otherwise\n// it would be allowed to pass anything to e.g. Buffer.from()\ninterface SharedArrayBuffer {\n    readonly byteLength: number;\n    slice(begin?: number, end?: number): SharedArrayBuffer;\n}\n\ndeclare module \"util\" {\n    namespace types {\n        function isBigInt64Array(value: any): boolean;\n        function isBigUint64Array(value: any): boolean;\n    }\n}\n\n\n// tslint:disable-next-line:dt-header\n// Type definitions for inspector\n\n// These definitions are auto-generated.\n// Please see https://github.com/DefinitelyTyped/DefinitelyTyped/pull/19330\n// for more information.\n\n// tslint:disable:max-line-length\n\n/**\n * The inspector module provides an API for interacting with the V8 inspector.\n */\ndeclare module \"inspector\" {\n    import { EventEmitter } from 'events';\n\n    interface InspectorNotification<T> {\n        method: string;\n        params: T;\n    }\n\n    namespace Schema {\n        /**\n         * Description of the protocol domain.\n         */\n        interface Domain {\n            /**\n             * Domain name.\n             */\n            name: string;\n            /**\n             * Domain version.\n             */\n            version: string;\n        }\n\n        interface GetDomainsReturnType {\n            /**\n             * List of supported domains.\n             */\n            domains: Domain[];\n        }\n    }\n\n    namespace Runtime {\n        /**\n         * Unique script identifier.\n         */\n        type ScriptId = string;\n\n        /**\n         * Unique object identifier.\n         */\n        type RemoteObjectId = string;\n\n        /**\n         * Primitive value which cannot be JSON-stringified.\n         */\n        type UnserializableValue = string;\n\n        /**\n         * Mirror object referencing original JavaScript object.\n         */\n        interface RemoteObject {\n            /**\n             * Object type.\n             */\n            type: string;\n            /**\n             * Object subtype hint. Specified for <code>object</code> type values only.\n             */\n            subtype?: string;\n            /**\n             * Object class (constructor) name. Specified for <code>object</code> type values only.\n             */\n            className?: string;\n            /**\n             * Remote object value in case of primitive values or JSON values (if it was requested).\n             */\n            value?: any;\n            /**\n             * Primitive value which can not be JSON-stringified does not have <code>value</code>, but gets this property.\n             */\n            unserializableValue?: UnserializableValue;\n            /**\n             * String representation of the object.\n             */\n            description?: string;\n            /**\n             * Unique object identifier (for non-primitive values).\n             */\n            objectId?: RemoteObjectId;\n            /**\n             * Preview containing abbreviated property values. Specified for <code>object</code> type values only.\n             * @experimental\n             */\n            preview?: ObjectPreview;\n            /**\n             * @experimental\n             */\n            customPreview?: CustomPreview;\n        }\n\n        /**\n         * @experimental\n         */\n        interface CustomPreview {\n            header: string;\n            hasBody: boolean;\n            formatterObjectId: RemoteObjectId;\n            bindRemoteObjectFunctionId: RemoteObjectId;\n            configObjectId?: RemoteObjectId;\n        }\n\n        /**\n         * Object containing abbreviated remote object value.\n         * @experimental\n         */\n        interface ObjectPreview {\n            /**\n             * Object type.\n             */\n            type: string;\n            /**\n             * Object subtype hint. Specified for <code>object</code> type values only.\n             */\n            subtype?: string;\n            /**\n             * String representation of the object.\n             */\n            description?: string;\n            /**\n             * True iff some of the properties or entries of the original object did not fit.\n             */\n            overflow: boolean;\n            /**\n             * List of the properties.\n             */\n            properties: PropertyPreview[];\n            /**\n             * List of the entries. Specified for <code>map</code> and <code>set</code> subtype values only.\n             */\n            entries?: EntryPreview[];\n        }\n\n        /**\n         * @experimental\n         */\n        interface PropertyPreview {\n            /**\n             * Property name.\n             */\n            name: string;\n            /**\n             * Object type. Accessor means that the property itself is an accessor property.\n             */\n            type: string;\n            /**\n             * User-friendly property value string.\n             */\n            value?: string;\n            /**\n             * Nested value preview.\n             */\n            valuePreview?: ObjectPreview;\n            /**\n             * Object subtype hint. Specified for <code>object</code> type values only.\n             */\n            subtype?: string;\n        }\n\n        /**\n         * @experimental\n         */\n        interface EntryPreview {\n            /**\n             * Preview of the key. Specified for map-like collection entries.\n             */\n            key?: ObjectPreview;\n            /**\n             * Preview of the value.\n             */\n            value: ObjectPreview;\n        }\n\n        /**\n         * Object property descriptor.\n         */\n        interface PropertyDescriptor {\n            /**\n             * Property name or symbol description.\n             */\n            name: string;\n            /**\n             * The value associated with the property.\n             */\n            value?: RemoteObject;\n            /**\n             * True if the value associated with the property may be changed (data descriptors only).\n             */\n            writable?: boolean;\n            /**\n             * A function which serves as a getter for the property, or <code>undefined</code> if there is no getter (accessor descriptors only).\n             */\n            get?: RemoteObject;\n            /**\n             * A function which serves as a setter for the property, or <code>undefined</code> if there is no setter (accessor descriptors only).\n             */\n            set?: RemoteObject;\n            /**\n             * True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.\n             */\n            configurable: boolean;\n            /**\n             * True if this property shows up during enumeration of the properties on the corresponding object.\n             */\n            enumerable: boolean;\n            /**\n             * True if the result was thrown during the evaluation.\n             */\n            wasThrown?: boolean;\n            /**\n             * True if the property is owned for the object.\n             */\n            isOwn?: boolean;\n            /**\n             * Property symbol object, if the property is of the <code>symbol</code> type.\n             */\n            symbol?: RemoteObject;\n        }\n\n        /**\n         * Object internal property descriptor. This property isn't normally visible in JavaScript code.\n         */\n        interface InternalPropertyDescriptor {\n            /**\n             * Conventional property name.\n             */\n            name: string;\n            /**\n             * The value associated with the property.\n             */\n            value?: RemoteObject;\n        }\n\n        /**\n         * Represents function call argument. Either remote object id <code>objectId</code>, primitive <code>value</code>, unserializable primitive value or neither of (for undefined) them should be specified.\n         */\n        interface CallArgument {\n            /**\n             * Primitive value or serializable javascript object.\n             */\n            value?: any;\n            /**\n             * Primitive value which can not be JSON-stringified.\n             */\n            unserializableValue?: UnserializableValue;\n            /**\n             * Remote object handle.\n             */\n            objectId?: RemoteObjectId;\n        }\n\n        /**\n         * Id of an execution context.\n         */\n        type ExecutionContextId = number;\n\n        /**\n         * Description of an isolated world.\n         */\n        interface ExecutionContextDescription {\n            /**\n             * Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed.\n             */\n            id: ExecutionContextId;\n            /**\n             * Execution context origin.\n             */\n            origin: string;\n            /**\n             * Human readable name describing given context.\n             */\n            name: string;\n            /**\n             * Embedder-specific auxiliary data.\n             */\n            auxData?: {};\n        }\n\n        /**\n         * Detailed information about exception (or error) that was thrown during script compilation or execution.\n         */\n        interface ExceptionDetails {\n            /**\n             * Exception id.\n             */\n            exceptionId: number;\n            /**\n             * Exception text, which should be used together with exception object when available.\n             */\n            text: string;\n            /**\n             * Line number of the exception location (0-based).\n             */\n            lineNumber: number;\n            /**\n             * Column number of the exception location (0-based).\n             */\n            columnNumber: number;\n            /**\n             * Script ID of the exception location.\n             */\n            scriptId?: ScriptId;\n            /**\n             * URL of the exception location, to be used when the script was not reported.\n             */\n            url?: string;\n            /**\n             * JavaScript stack trace if available.\n             */\n            stackTrace?: StackTrace;\n            /**\n             * Exception object if available.\n             */\n            exception?: RemoteObject;\n            /**\n             * Identifier of the context where exception happened.\n             */\n            executionContextId?: ExecutionContextId;\n        }\n\n        /**\n         * Number of milliseconds since epoch.\n         */\n        type Timestamp = number;\n\n        /**\n         * Stack entry for runtime errors and assertions.\n         */\n        interface CallFrame {\n            /**\n             * JavaScript function name.\n             */\n            functionName: string;\n            /**\n             * JavaScript script id.\n             */\n            scriptId: ScriptId;\n            /**\n             * JavaScript script name or url.\n             */\n            url: string;\n            /**\n             * JavaScript script line number (0-based).\n             */\n            lineNumber: number;\n            /**\n             * JavaScript script column number (0-based).\n             */\n            columnNumber: number;\n        }\n\n        /**\n         * Call frames for assertions or error messages.\n         */\n        interface StackTrace {\n            /**\n             * String label of this stack trace. For async traces this may be a name of the function that initiated the async call.\n             */\n            description?: string;\n            /**\n             * JavaScript function name.\n             */\n            callFrames: CallFrame[];\n            /**\n             * Asynchronous JavaScript stack trace that preceded this stack, if available.\n             */\n            parent?: StackTrace;\n            /**\n             * Asynchronous JavaScript stack trace that preceded this stack, if available.\n             * @experimental\n             */\n            parentId?: StackTraceId;\n        }\n\n        /**\n         * Unique identifier of current debugger.\n         * @experimental\n         */\n        type UniqueDebuggerId = string;\n\n        /**\n         * If <code>debuggerId</code> is set stack trace comes from another debugger and can be resolved there. This allows to track cross-debugger calls. See <code>Runtime.StackTrace</code> and <code>Debugger.paused</code> for usages.\n         * @experimental\n         */\n        interface StackTraceId {\n            id: string;\n            debuggerId?: UniqueDebuggerId;\n        }\n\n        interface EvaluateParameterType {\n            /**\n             * Expression to evaluate.\n             */\n            expression: string;\n            /**\n             * Symbolic group name that can be used to release multiple objects.\n             */\n            objectGroup?: string;\n            /**\n             * Determines whether Command Line API should be available during the evaluation.\n             */\n            includeCommandLineAPI?: boolean;\n            /**\n             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.\n             */\n            silent?: boolean;\n            /**\n             * Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page.\n             */\n            contextId?: ExecutionContextId;\n            /**\n             * Whether the result is expected to be a JSON object that should be sent by value.\n             */\n            returnByValue?: boolean;\n            /**\n             * Whether preview should be generated for the result.\n             * @experimental\n             */\n            generatePreview?: boolean;\n            /**\n             * Whether execution should be treated as initiated by user in the UI.\n             */\n            userGesture?: boolean;\n            /**\n             * Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved.\n             */\n            awaitPromise?: boolean;\n        }\n\n        interface AwaitPromiseParameterType {\n            /**\n             * Identifier of the promise.\n             */\n            promiseObjectId: RemoteObjectId;\n            /**\n             * Whether the result is expected to be a JSON object that should be sent by value.\n             */\n            returnByValue?: boolean;\n            /**\n             * Whether preview should be generated for the result.\n             */\n            generatePreview?: boolean;\n        }\n\n        interface CallFunctionOnParameterType {\n            /**\n             * Declaration of the function to call.\n             */\n            functionDeclaration: string;\n            /**\n             * Identifier of the object to call function on. Either objectId or executionContextId should be specified.\n             */\n            objectId?: RemoteObjectId;\n            /**\n             * Call arguments. All call arguments must belong to the same JavaScript world as the target object.\n             */\n            arguments?: CallArgument[];\n            /**\n             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.\n             */\n            silent?: boolean;\n            /**\n             * Whether the result is expected to be a JSON object which should be sent by value.\n             */\n            returnByValue?: boolean;\n            /**\n             * Whether preview should be generated for the result.\n             * @experimental\n             */\n            generatePreview?: boolean;\n            /**\n             * Whether execution should be treated as initiated by user in the UI.\n             */\n            userGesture?: boolean;\n            /**\n             * Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved.\n             */\n            awaitPromise?: boolean;\n            /**\n             * Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.\n             */\n            executionContextId?: ExecutionContextId;\n            /**\n             * Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.\n             */\n            objectGroup?: string;\n        }\n\n        interface GetPropertiesParameterType {\n            /**\n             * Identifier of the object to return properties for.\n             */\n            objectId: RemoteObjectId;\n            /**\n             * If true, returns properties belonging only to the element itself, not to its prototype chain.\n             */\n            ownProperties?: boolean;\n            /**\n             * If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.\n             * @experimental\n             */\n            accessorPropertiesOnly?: boolean;\n            /**\n             * Whether preview should be generated for the results.\n             * @experimental\n             */\n            generatePreview?: boolean;\n        }\n\n        interface ReleaseObjectParameterType {\n            /**\n             * Identifier of the object to release.\n             */\n            objectId: RemoteObjectId;\n        }\n\n        interface ReleaseObjectGroupParameterType {\n            /**\n             * Symbolic object group name.\n             */\n            objectGroup: string;\n        }\n\n        interface SetCustomObjectFormatterEnabledParameterType {\n            enabled: boolean;\n        }\n\n        interface CompileScriptParameterType {\n            /**\n             * Expression to compile.\n             */\n            expression: string;\n            /**\n             * Source url to be set for the script.\n             */\n            sourceURL: string;\n            /**\n             * Specifies whether the compiled script should be persisted.\n             */\n            persistScript: boolean;\n            /**\n             * Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.\n             */\n            executionContextId?: ExecutionContextId;\n        }\n\n        interface RunScriptParameterType {\n            /**\n             * Id of the script to run.\n             */\n            scriptId: ScriptId;\n            /**\n             * Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.\n             */\n            executionContextId?: ExecutionContextId;\n            /**\n             * Symbolic group name that can be used to release multiple objects.\n             */\n            objectGroup?: string;\n            /**\n             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.\n             */\n            silent?: boolean;\n            /**\n             * Determines whether Command Line API should be available during the evaluation.\n             */\n            includeCommandLineAPI?: boolean;\n            /**\n             * Whether the result is expected to be a JSON object which should be sent by value.\n             */\n            returnByValue?: boolean;\n            /**\n             * Whether preview should be generated for the result.\n             */\n            generatePreview?: boolean;\n            /**\n             * Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved.\n             */\n            awaitPromise?: boolean;\n        }\n\n        interface QueryObjectsParameterType {\n            /**\n             * Identifier of the prototype to return objects for.\n             */\n            prototypeObjectId: RemoteObjectId;\n        }\n\n        interface GlobalLexicalScopeNamesParameterType {\n            /**\n             * Specifies in which execution context to lookup global scope variables.\n             */\n            executionContextId?: ExecutionContextId;\n        }\n\n        interface EvaluateReturnType {\n            /**\n             * Evaluation result.\n             */\n            result: RemoteObject;\n            /**\n             * Exception details.\n             */\n            exceptionDetails?: ExceptionDetails;\n        }\n\n        interface AwaitPromiseReturnType {\n            /**\n             * Promise result. Will contain rejected value if promise was rejected.\n             */\n            result: RemoteObject;\n            /**\n             * Exception details if stack strace is available.\n             */\n            exceptionDetails?: ExceptionDetails;\n        }\n\n        interface CallFunctionOnReturnType {\n            /**\n             * Call result.\n             */\n            result: RemoteObject;\n            /**\n             * Exception details.\n             */\n            exceptionDetails?: ExceptionDetails;\n        }\n\n        interface GetPropertiesReturnType {\n            /**\n             * Object properties.\n             */\n            result: PropertyDescriptor[];\n            /**\n             * Internal object properties (only of the element itself).\n             */\n            internalProperties?: InternalPropertyDescriptor[];\n            /**\n             * Exception details.\n             */\n            exceptionDetails?: ExceptionDetails;\n        }\n\n        interface CompileScriptReturnType {\n            /**\n             * Id of the script.\n             */\n            scriptId?: ScriptId;\n            /**\n             * Exception details.\n             */\n            exceptionDetails?: ExceptionDetails;\n        }\n\n        interface RunScriptReturnType {\n            /**\n             * Run result.\n             */\n            result: RemoteObject;\n            /**\n             * Exception details.\n             */\n            exceptionDetails?: ExceptionDetails;\n        }\n\n        interface QueryObjectsReturnType {\n            /**\n             * Array with objects.\n             */\n            objects: RemoteObject;\n        }\n\n        interface GlobalLexicalScopeNamesReturnType {\n            names: string[];\n        }\n\n        interface ExecutionContextCreatedEventDataType {\n            /**\n             * A newly created execution context.\n             */\n            context: ExecutionContextDescription;\n        }\n\n        interface ExecutionContextDestroyedEventDataType {\n            /**\n             * Id of the destroyed context\n             */\n            executionContextId: ExecutionContextId;\n        }\n\n        interface ExceptionThrownEventDataType {\n            /**\n             * Timestamp of the exception.\n             */\n            timestamp: Timestamp;\n            exceptionDetails: ExceptionDetails;\n        }\n\n        interface ExceptionRevokedEventDataType {\n            /**\n             * Reason describing why exception was revoked.\n             */\n            reason: string;\n            /**\n             * The id of revoked exception, as reported in <code>exceptionThrown</code>.\n             */\n            exceptionId: number;\n        }\n\n        interface ConsoleAPICalledEventDataType {\n            /**\n             * Type of the call.\n             */\n            type: string;\n            /**\n             * Call arguments.\n             */\n            args: RemoteObject[];\n            /**\n             * Identifier of the context where the call was made.\n             */\n            executionContextId: ExecutionContextId;\n            /**\n             * Call timestamp.\n             */\n            timestamp: Timestamp;\n            /**\n             * Stack trace captured when the call was made.\n             */\n            stackTrace?: StackTrace;\n            /**\n             * Console context descriptor for calls on non-default console context (not console.*): 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call on named context.\n             * @experimental\n             */\n            context?: string;\n        }\n\n        interface InspectRequestedEventDataType {\n            object: RemoteObject;\n            hints: {};\n        }\n    }\n\n    namespace Debugger {\n        /**\n         * Breakpoint identifier.\n         */\n        type BreakpointId = string;\n\n        /**\n         * Call frame identifier.\n         */\n        type CallFrameId = string;\n\n        /**\n         * Location in the source code.\n         */\n        interface Location {\n            /**\n             * Script identifier as reported in the <code>Debugger.scriptParsed</code>.\n             */\n            scriptId: Runtime.ScriptId;\n            /**\n             * Line number in the script (0-based).\n             */\n            lineNumber: number;\n            /**\n             * Column number in the script (0-based).\n             */\n            columnNumber?: number;\n        }\n\n        /**\n         * Location in the source code.\n         * @experimental\n         */\n        interface ScriptPosition {\n            lineNumber: number;\n            columnNumber: number;\n        }\n\n        /**\n         * JavaScript call frame. Array of call frames form the call stack.\n         */\n        interface CallFrame {\n            /**\n             * Call frame identifier. This identifier is only valid while the virtual machine is paused.\n             */\n            callFrameId: CallFrameId;\n            /**\n             * Name of the JavaScript function called on this call frame.\n             */\n            functionName: string;\n            /**\n             * Location in the source code.\n             */\n            functionLocation?: Location;\n            /**\n             * Location in the source code.\n             */\n            location: Location;\n            /**\n             * JavaScript script name or url.\n             */\n            url: string;\n            /**\n             * Scope chain for this call frame.\n             */\n            scopeChain: Scope[];\n            /**\n             * <code>this</code> object for this call frame.\n             */\n            this: Runtime.RemoteObject;\n            /**\n             * The value being returned, if the function is at return point.\n             */\n            returnValue?: Runtime.RemoteObject;\n        }\n\n        /**\n         * Scope description.\n         */\n        interface Scope {\n            /**\n             * Scope type.\n             */\n            type: string;\n            /**\n             * Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties.\n             */\n            object: Runtime.RemoteObject;\n            name?: string;\n            /**\n             * Location in the source code where scope starts\n             */\n            startLocation?: Location;\n            /**\n             * Location in the source code where scope ends\n             */\n            endLocation?: Location;\n        }\n\n        /**\n         * Search match for resource.\n         */\n        interface SearchMatch {\n            /**\n             * Line number in resource content.\n             */\n            lineNumber: number;\n            /**\n             * Line with match content.\n             */\n            lineContent: string;\n        }\n\n        interface BreakLocation {\n            /**\n             * Script identifier as reported in the <code>Debugger.scriptParsed</code>.\n             */\n            scriptId: Runtime.ScriptId;\n            /**\n             * Line number in the script (0-based).\n             */\n            lineNumber: number;\n            /**\n             * Column number in the script (0-based).\n             */\n            columnNumber?: number;\n            type?: string;\n        }\n\n        interface SetBreakpointsActiveParameterType {\n            /**\n             * New value for breakpoints active state.\n             */\n            active: boolean;\n        }\n\n        interface SetSkipAllPausesParameterType {\n            /**\n             * New value for skip pauses state.\n             */\n            skip: boolean;\n        }\n\n        interface SetBreakpointByUrlParameterType {\n            /**\n             * Line number to set breakpoint at.\n             */\n            lineNumber: number;\n            /**\n             * URL of the resources to set breakpoint on.\n             */\n            url?: string;\n            /**\n             * Regex pattern for the URLs of the resources to set breakpoints on. Either <code>url</code> or <code>urlRegex</code> must be specified.\n             */\n            urlRegex?: string;\n            /**\n             * Script hash of the resources to set breakpoint on.\n             */\n            scriptHash?: string;\n            /**\n             * Offset in the line to set breakpoint at.\n             */\n            columnNumber?: number;\n            /**\n             * Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.\n             */\n            condition?: string;\n        }\n\n        interface SetBreakpointParameterType {\n            /**\n             * Location to set breakpoint in.\n             */\n            location: Location;\n            /**\n             * Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.\n             */\n            condition?: string;\n        }\n\n        interface RemoveBreakpointParameterType {\n            breakpointId: BreakpointId;\n        }\n\n        interface GetPossibleBreakpointsParameterType {\n            /**\n             * Start of range to search possible breakpoint locations in.\n             */\n            start: Location;\n            /**\n             * End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.\n             */\n            end?: Location;\n            /**\n             * Only consider locations which are in the same (non-nested) function as start.\n             */\n            restrictToFunction?: boolean;\n        }\n\n        interface ContinueToLocationParameterType {\n            /**\n             * Location to continue to.\n             */\n            location: Location;\n            targetCallFrames?: string;\n        }\n\n        interface PauseOnAsyncCallParameterType {\n            /**\n             * Debugger will pause when async call with given stack trace is started.\n             */\n            parentStackTraceId: Runtime.StackTraceId;\n        }\n\n        interface StepIntoParameterType {\n            /**\n             * Debugger will issue additional Debugger.paused notification if any async task is scheduled before next pause.\n             * @experimental\n             */\n            breakOnAsyncCall?: boolean;\n        }\n\n        interface GetStackTraceParameterType {\n            stackTraceId: Runtime.StackTraceId;\n        }\n\n        interface SearchInContentParameterType {\n            /**\n             * Id of the script to search in.\n             */\n            scriptId: Runtime.ScriptId;\n            /**\n             * String to search for.\n             */\n            query: string;\n            /**\n             * If true, search is case sensitive.\n             */\n            caseSensitive?: boolean;\n            /**\n             * If true, treats string parameter as regex.\n             */\n            isRegex?: boolean;\n        }\n\n        interface SetScriptSourceParameterType {\n            /**\n             * Id of the script to edit.\n             */\n            scriptId: Runtime.ScriptId;\n            /**\n             * New content of the script.\n             */\n            scriptSource: string;\n            /**\n             *  If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.\n             */\n            dryRun?: boolean;\n        }\n\n        interface RestartFrameParameterType {\n            /**\n             * Call frame identifier to evaluate on.\n             */\n            callFrameId: CallFrameId;\n        }\n\n        interface GetScriptSourceParameterType {\n            /**\n             * Id of the script to get source for.\n             */\n            scriptId: Runtime.ScriptId;\n        }\n\n        interface SetPauseOnExceptionsParameterType {\n            /**\n             * Pause on exceptions mode.\n             */\n            state: string;\n        }\n\n        interface EvaluateOnCallFrameParameterType {\n            /**\n             * Call frame identifier to evaluate on.\n             */\n            callFrameId: CallFrameId;\n            /**\n             * Expression to evaluate.\n             */\n            expression: string;\n            /**\n             * String object group name to put result into (allows rapid releasing resulting object handles using <code>releaseObjectGroup</code>).\n             */\n            objectGroup?: string;\n            /**\n             * Specifies whether command line API should be available to the evaluated expression, defaults to false.\n             */\n            includeCommandLineAPI?: boolean;\n            /**\n             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.\n             */\n            silent?: boolean;\n            /**\n             * Whether the result is expected to be a JSON object that should be sent by value.\n             */\n            returnByValue?: boolean;\n            /**\n             * Whether preview should be generated for the result.\n             * @experimental\n             */\n            generatePreview?: boolean;\n            /**\n             * Whether to throw an exception if side effect cannot be ruled out during evaluation.\n             */\n            throwOnSideEffect?: boolean;\n        }\n\n        interface SetVariableValueParameterType {\n            /**\n             * 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.\n             */\n            scopeNumber: number;\n            /**\n             * Variable name.\n             */\n            variableName: string;\n            /**\n             * New variable value.\n             */\n            newValue: Runtime.CallArgument;\n            /**\n             * Id of callframe that holds variable.\n             */\n            callFrameId: CallFrameId;\n        }\n\n        interface SetReturnValueParameterType {\n            /**\n             * New return value.\n             */\n            newValue: Runtime.CallArgument;\n        }\n\n        interface SetAsyncCallStackDepthParameterType {\n            /**\n             * Maximum depth of async call stacks. Setting to <code>0</code> will effectively disable collecting async call stacks (default).\n             */\n            maxDepth: number;\n        }\n\n        interface SetBlackboxPatternsParameterType {\n            /**\n             * Array of regexps that will be used to check script url for blackbox state.\n             */\n            patterns: string[];\n        }\n\n        interface SetBlackboxedRangesParameterType {\n            /**\n             * Id of the script.\n             */\n            scriptId: Runtime.ScriptId;\n            positions: ScriptPosition[];\n        }\n\n        interface EnableReturnType {\n            /**\n             * Unique identifier of the debugger.\n             * @experimental\n             */\n            debuggerId: Runtime.UniqueDebuggerId;\n        }\n\n        interface SetBreakpointByUrlReturnType {\n            /**\n             * Id of the created breakpoint for further reference.\n             */\n            breakpointId: BreakpointId;\n            /**\n             * List of the locations this breakpoint resolved into upon addition.\n             */\n            locations: Location[];\n        }\n\n        interface SetBreakpointReturnType {\n            /**\n             * Id of the created breakpoint for further reference.\n             */\n            breakpointId: BreakpointId;\n            /**\n             * Location this breakpoint resolved into.\n             */\n            actualLocation: Location;\n        }\n\n        interface GetPossibleBreakpointsReturnType {\n            /**\n             * List of the possible breakpoint locations.\n             */\n            locations: BreakLocation[];\n        }\n\n        interface GetStackTraceReturnType {\n            stackTrace: Runtime.StackTrace;\n        }\n\n        interface SearchInContentReturnType {\n            /**\n             * List of search matches.\n             */\n            result: SearchMatch[];\n        }\n\n        interface SetScriptSourceReturnType {\n            /**\n             * New stack trace in case editing has happened while VM was stopped.\n             */\n            callFrames?: CallFrame[];\n            /**\n             * Whether current call stack  was modified after applying the changes.\n             */\n            stackChanged?: boolean;\n            /**\n             * Async stack trace, if any.\n             */\n            asyncStackTrace?: Runtime.StackTrace;\n            /**\n             * Async stack trace, if any.\n             * @experimental\n             */\n            asyncStackTraceId?: Runtime.StackTraceId;\n            /**\n             * Exception details if any.\n             */\n            exceptionDetails?: Runtime.ExceptionDetails;\n        }\n\n        interface RestartFrameReturnType {\n            /**\n             * New stack trace.\n             */\n            callFrames: CallFrame[];\n            /**\n             * Async stack trace, if any.\n             */\n            asyncStackTrace?: Runtime.StackTrace;\n            /**\n             * Async stack trace, if any.\n             * @experimental\n             */\n            asyncStackTraceId?: Runtime.StackTraceId;\n        }\n\n        interface GetScriptSourceReturnType {\n            /**\n             * Script source.\n             */\n            scriptSource: string;\n        }\n\n        interface EvaluateOnCallFrameReturnType {\n            /**\n             * Object wrapper for the evaluation result.\n             */\n            result: Runtime.RemoteObject;\n            /**\n             * Exception details.\n             */\n            exceptionDetails?: Runtime.ExceptionDetails;\n        }\n\n        interface ScriptParsedEventDataType {\n            /**\n             * Identifier of the script parsed.\n             */\n            scriptId: Runtime.ScriptId;\n            /**\n             * URL or name of the script parsed (if any).\n             */\n            url: string;\n            /**\n             * Line offset of the script within the resource with given URL (for script tags).\n             */\n            startLine: number;\n            /**\n             * Column offset of the script within the resource with given URL.\n             */\n            startColumn: number;\n            /**\n             * Last line of the script.\n             */\n            endLine: number;\n            /**\n             * Length of the last line of the script.\n             */\n            endColumn: number;\n            /**\n             * Specifies script creation context.\n             */\n            executionContextId: Runtime.ExecutionContextId;\n            /**\n             * Content hash of the script.\n             */\n            hash: string;\n            /**\n             * Embedder-specific auxiliary data.\n             */\n            executionContextAuxData?: {};\n            /**\n             * True, if this script is generated as a result of the live edit operation.\n             * @experimental\n             */\n            isLiveEdit?: boolean;\n            /**\n             * URL of source map associated with script (if any).\n             */\n            sourceMapURL?: string;\n            /**\n             * True, if this script has sourceURL.\n             */\n            hasSourceURL?: boolean;\n            /**\n             * True, if this script is ES6 module.\n             */\n            isModule?: boolean;\n            /**\n             * This script length.\n             */\n            length?: number;\n            /**\n             * JavaScript top stack frame of where the script parsed event was triggered if available.\n             * @experimental\n             */\n            stackTrace?: Runtime.StackTrace;\n        }\n\n        interface ScriptFailedToParseEventDataType {\n            /**\n             * Identifier of the script parsed.\n             */\n            scriptId: Runtime.ScriptId;\n            /**\n             * URL or name of the script parsed (if any).\n             */\n            url: string;\n            /**\n             * Line offset of the script within the resource with given URL (for script tags).\n             */\n            startLine: number;\n            /**\n             * Column offset of the script within the resource with given URL.\n             */\n            startColumn: number;\n            /**\n             * Last line of the script.\n             */\n            endLine: number;\n            /**\n             * Length of the last line of the script.\n             */\n            endColumn: number;\n            /**\n             * Specifies script creation context.\n             */\n            executionContextId: Runtime.ExecutionContextId;\n            /**\n             * Content hash of the script.\n             */\n            hash: string;\n            /**\n             * Embedder-specific auxiliary data.\n             */\n            executionContextAuxData?: {};\n            /**\n             * URL of source map associated with script (if any).\n             */\n            sourceMapURL?: string;\n            /**\n             * True, if this script has sourceURL.\n             */\n            hasSourceURL?: boolean;\n            /**\n             * True, if this script is ES6 module.\n             */\n            isModule?: boolean;\n            /**\n             * This script length.\n             */\n            length?: number;\n            /**\n             * JavaScript top stack frame of where the script parsed event was triggered if available.\n             * @experimental\n             */\n            stackTrace?: Runtime.StackTrace;\n        }\n\n        interface BreakpointResolvedEventDataType {\n            /**\n             * Breakpoint unique identifier.\n             */\n            breakpointId: BreakpointId;\n            /**\n             * Actual breakpoint location.\n             */\n            location: Location;\n        }\n\n        interface PausedEventDataType {\n            /**\n             * Call stack the virtual machine stopped on.\n             */\n            callFrames: CallFrame[];\n            /**\n             * Pause reason.\n             */\n            reason: string;\n            /**\n             * Object containing break-specific auxiliary properties.\n             */\n            data?: {};\n            /**\n             * Hit breakpoints IDs\n             */\n            hitBreakpoints?: string[];\n            /**\n             * Async stack trace, if any.\n             */\n            asyncStackTrace?: Runtime.StackTrace;\n            /**\n             * Async stack trace, if any.\n             * @experimental\n             */\n            asyncStackTraceId?: Runtime.StackTraceId;\n            /**\n             * Just scheduled async call will have this stack trace as parent stack during async execution. This field is available only after <code>Debugger.stepInto</code> call with <code>breakOnAsynCall</code> flag.\n             * @experimental\n             */\n            asyncCallStackTraceId?: Runtime.StackTraceId;\n        }\n    }\n\n    namespace Console {\n        /**\n         * Console message.\n         */\n        interface ConsoleMessage {\n            /**\n             * Message source.\n             */\n            source: string;\n            /**\n             * Message severity.\n             */\n            level: string;\n            /**\n             * Message text.\n             */\n            text: string;\n            /**\n             * URL of the message origin.\n             */\n            url?: string;\n            /**\n             * Line number in the resource that generated this message (1-based).\n             */\n            line?: number;\n            /**\n             * Column number in the resource that generated this message (1-based).\n             */\n            column?: number;\n        }\n\n        interface MessageAddedEventDataType {\n            /**\n             * Console message that has been added.\n             */\n            message: ConsoleMessage;\n        }\n    }\n\n    namespace Profiler {\n        /**\n         * Profile node. Holds callsite information, execution statistics and child nodes.\n         */\n        interface ProfileNode {\n            /**\n             * Unique id of the node.\n             */\n            id: number;\n            /**\n             * Function location.\n             */\n            callFrame: Runtime.CallFrame;\n            /**\n             * Number of samples where this node was on top of the call stack.\n             */\n            hitCount?: number;\n            /**\n             * Child node ids.\n             */\n            children?: number[];\n            /**\n             * The reason of being not optimized. The function may be deoptimized or marked as don't optimize.\n             */\n            deoptReason?: string;\n            /**\n             * An array of source position ticks.\n             */\n            positionTicks?: PositionTickInfo[];\n        }\n\n        /**\n         * Profile.\n         */\n        interface Profile {\n            /**\n             * The list of profile nodes. First item is the root node.\n             */\n            nodes: ProfileNode[];\n            /**\n             * Profiling start timestamp in microseconds.\n             */\n            startTime: number;\n            /**\n             * Profiling end timestamp in microseconds.\n             */\n            endTime: number;\n            /**\n             * Ids of samples top nodes.\n             */\n            samples?: number[];\n            /**\n             * Time intervals between adjacent samples in microseconds. The first delta is relative to the profile startTime.\n             */\n            timeDeltas?: number[];\n        }\n\n        /**\n         * Specifies a number of samples attributed to a certain source position.\n         */\n        interface PositionTickInfo {\n            /**\n             * Source line number (1-based).\n             */\n            line: number;\n            /**\n             * Number of samples attributed to the source line.\n             */\n            ticks: number;\n        }\n\n        /**\n         * Coverage data for a source range.\n         */\n        interface CoverageRange {\n            /**\n             * JavaScript script source offset for the range start.\n             */\n            startOffset: number;\n            /**\n             * JavaScript script source offset for the range end.\n             */\n            endOffset: number;\n            /**\n             * Collected execution count of the source range.\n             */\n            count: number;\n        }\n\n        /**\n         * Coverage data for a JavaScript function.\n         */\n        interface FunctionCoverage {\n            /**\n             * JavaScript function name.\n             */\n            functionName: string;\n            /**\n             * Source ranges inside the function with coverage data.\n             */\n            ranges: CoverageRange[];\n            /**\n             * Whether coverage data for this function has block granularity.\n             */\n            isBlockCoverage: boolean;\n        }\n\n        /**\n         * Coverage data for a JavaScript script.\n         */\n        interface ScriptCoverage {\n            /**\n             * JavaScript script id.\n             */\n            scriptId: Runtime.ScriptId;\n            /**\n             * JavaScript script name or url.\n             */\n            url: string;\n            /**\n             * Functions contained in the script that has coverage data.\n             */\n            functions: FunctionCoverage[];\n        }\n\n        /**\n         * Describes a type collected during runtime.\n         * @experimental\n         */\n        interface TypeObject {\n            /**\n             * Name of a type collected with type profiling.\n             */\n            name: string;\n        }\n\n        /**\n         * Source offset and types for a parameter or return value.\n         * @experimental\n         */\n        interface TypeProfileEntry {\n            /**\n             * Source offset of the parameter or end of function for return values.\n             */\n            offset: number;\n            /**\n             * The types for this parameter or return value.\n             */\n            types: TypeObject[];\n        }\n\n        /**\n         * Type profile data collected during runtime for a JavaScript script.\n         * @experimental\n         */\n        interface ScriptTypeProfile {\n            /**\n             * JavaScript script id.\n             */\n            scriptId: Runtime.ScriptId;\n            /**\n             * JavaScript script name or url.\n             */\n            url: string;\n            /**\n             * Type profile entries for parameters and return values of the functions in the script.\n             */\n            entries: TypeProfileEntry[];\n        }\n\n        interface SetSamplingIntervalParameterType {\n            /**\n             * New sampling interval in microseconds.\n             */\n            interval: number;\n        }\n\n        interface StartPreciseCoverageParameterType {\n            /**\n             * Collect accurate call counts beyond simple 'covered' or 'not covered'.\n             */\n            callCount?: boolean;\n            /**\n             * Collect block-based coverage.\n             */\n            detailed?: boolean;\n        }\n\n        interface StopReturnType {\n            /**\n             * Recorded profile.\n             */\n            profile: Profile;\n        }\n\n        interface TakePreciseCoverageReturnType {\n            /**\n             * Coverage data for the current isolate.\n             */\n            result: ScriptCoverage[];\n        }\n\n        interface GetBestEffortCoverageReturnType {\n            /**\n             * Coverage data for the current isolate.\n             */\n            result: ScriptCoverage[];\n        }\n\n        interface TakeTypeProfileReturnType {\n            /**\n             * Type profile for all scripts since startTypeProfile() was turned on.\n             */\n            result: ScriptTypeProfile[];\n        }\n\n        interface ConsoleProfileStartedEventDataType {\n            id: string;\n            /**\n             * Location of console.profile().\n             */\n            location: Debugger.Location;\n            /**\n             * Profile title passed as an argument to console.profile().\n             */\n            title?: string;\n        }\n\n        interface ConsoleProfileFinishedEventDataType {\n            id: string;\n            /**\n             * Location of console.profileEnd().\n             */\n            location: Debugger.Location;\n            profile: Profile;\n            /**\n             * Profile title passed as an argument to console.profile().\n             */\n            title?: string;\n        }\n    }\n\n    namespace HeapProfiler {\n        /**\n         * Heap snapshot object id.\n         */\n        type HeapSnapshotObjectId = string;\n\n        /**\n         * Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.\n         */\n        interface SamplingHeapProfileNode {\n            /**\n             * Function location.\n             */\n            callFrame: Runtime.CallFrame;\n            /**\n             * Allocations size in bytes for the node excluding children.\n             */\n            selfSize: number;\n            /**\n             * Child nodes.\n             */\n            children: SamplingHeapProfileNode[];\n        }\n\n        /**\n         * Profile.\n         */\n        interface SamplingHeapProfile {\n            head: SamplingHeapProfileNode;\n        }\n\n        interface StartTrackingHeapObjectsParameterType {\n            trackAllocations?: boolean;\n        }\n\n        interface StopTrackingHeapObjectsParameterType {\n            /**\n             * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped.\n             */\n            reportProgress?: boolean;\n        }\n\n        interface TakeHeapSnapshotParameterType {\n            /**\n             * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.\n             */\n            reportProgress?: boolean;\n        }\n\n        interface GetObjectByHeapObjectIdParameterType {\n            objectId: HeapSnapshotObjectId;\n            /**\n             * Symbolic group name that can be used to release multiple objects.\n             */\n            objectGroup?: string;\n        }\n\n        interface AddInspectedHeapObjectParameterType {\n            /**\n             * Heap snapshot object id to be accessible by means of $x command line API.\n             */\n            heapObjectId: HeapSnapshotObjectId;\n        }\n\n        interface GetHeapObjectIdParameterType {\n            /**\n             * Identifier of the object to get heap object id for.\n             */\n            objectId: Runtime.RemoteObjectId;\n        }\n\n        interface StartSamplingParameterType {\n            /**\n             * Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes.\n             */\n            samplingInterval?: number;\n        }\n\n        interface GetObjectByHeapObjectIdReturnType {\n            /**\n             * Evaluation result.\n             */\n            result: Runtime.RemoteObject;\n        }\n\n        interface GetHeapObjectIdReturnType {\n            /**\n             * Id of the heap snapshot object corresponding to the passed remote object id.\n             */\n            heapSnapshotObjectId: HeapSnapshotObjectId;\n        }\n\n        interface StopSamplingReturnType {\n            /**\n             * Recorded sampling heap profile.\n             */\n            profile: SamplingHeapProfile;\n        }\n\n        interface GetSamplingProfileReturnType {\n            /**\n             * Return the sampling profile being collected.\n             */\n            profile: SamplingHeapProfile;\n        }\n\n        interface AddHeapSnapshotChunkEventDataType {\n            chunk: string;\n        }\n\n        interface ReportHeapSnapshotProgressEventDataType {\n            done: number;\n            total: number;\n            finished?: boolean;\n        }\n\n        interface LastSeenObjectIdEventDataType {\n            lastSeenObjectId: number;\n            timestamp: number;\n        }\n\n        interface HeapStatsUpdateEventDataType {\n            /**\n             * An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment.\n             */\n            statsUpdate: number[];\n        }\n    }\n\n    namespace NodeTracing {\n        interface TraceConfig {\n            /**\n             * Controls how the trace buffer stores data.\n             */\n            recordMode?: string;\n            /**\n             * Included category filters.\n             */\n            includedCategories: string[];\n        }\n\n        interface StartParameterType {\n            traceConfig: TraceConfig;\n        }\n\n        interface GetCategoriesReturnType {\n            /**\n             * A list of supported tracing categories.\n             */\n            categories: string[];\n        }\n\n        interface DataCollectedEventDataType {\n            value: Array<{}>;\n        }\n    }\n\n    namespace NodeWorker {\n        type WorkerID = string;\n\n        /**\n         * Unique identifier of attached debugging session.\n         */\n        type SessionID = string;\n\n        interface WorkerInfo {\n            workerId: WorkerID;\n            type: string;\n            title: string;\n            url: string;\n        }\n\n        interface SendMessageToWorkerParameterType {\n            message: string;\n            /**\n             * Identifier of the session.\n             */\n            sessionId: SessionID;\n        }\n\n        interface EnableParameterType {\n            /**\n             * Whether to new workers should be paused until the frontend sends `Runtime.runIfWaitingForDebugger`\n             * message to run them.\n             */\n            waitForDebuggerOnStart: boolean;\n        }\n\n        interface DetachParameterType {\n            sessionId: SessionID;\n        }\n\n        interface AttachedToWorkerEventDataType {\n            /**\n             * Identifier assigned to the session used to send/receive messages.\n             */\n            sessionId: SessionID;\n            workerInfo: WorkerInfo;\n            waitingForDebugger: boolean;\n        }\n\n        interface DetachedFromWorkerEventDataType {\n            /**\n             * Detached session identifier.\n             */\n            sessionId: SessionID;\n        }\n\n        interface ReceivedMessageFromWorkerEventDataType {\n            /**\n             * Identifier of a session which sends a message.\n             */\n            sessionId: SessionID;\n            message: string;\n        }\n    }\n\n    namespace NodeRuntime {\n        interface NotifyWhenWaitingForDisconnectParameterType {\n            enabled: boolean;\n        }\n    }\n\n    /**\n     * The inspector.Session is used for dispatching messages to the V8 inspector back-end and receiving message responses and notifications.\n     */\n    class Session extends EventEmitter {\n        /**\n         * Create a new instance of the inspector.Session class.\n         * The inspector session needs to be connected through session.connect() before the messages can be dispatched to the inspector backend.\n         */\n        constructor();\n\n        /**\n         * Connects a session to the inspector back-end.\n         * An exception will be thrown if there is already a connected session established either\n         * through the API or by a front-end connected to the Inspector WebSocket port.\n         */\n        connect(): void;\n\n        /**\n         * Immediately close the session. All pending message callbacks will be called with an error.\n         * session.connect() will need to be called to be able to send messages again.\n         * Reconnected session will lose all inspector state, such as enabled agents or configured breakpoints.\n         */\n        disconnect(): void;\n\n        /**\n         * Posts a message to the inspector back-end. callback will be notified when a response is received.\n         * callback is a function that accepts two optional arguments - error and message-specific result.\n         */\n        post(method: string, params?: {}, callback?: (err: Error | null, params?: {}) => void): void;\n        post(method: string, callback?: (err: Error | null, params?: {}) => void): void;\n\n        /**\n         * Returns supported domains.\n         */\n        post(method: \"Schema.getDomains\", callback?: (err: Error | null, params: Schema.GetDomainsReturnType) => void): void;\n\n        /**\n         * Evaluates expression on global object.\n         */\n        post(method: \"Runtime.evaluate\", params?: Runtime.EvaluateParameterType, callback?: (err: Error | null, params: Runtime.EvaluateReturnType) => void): void;\n        post(method: \"Runtime.evaluate\", callback?: (err: Error | null, params: Runtime.EvaluateReturnType) => void): void;\n\n        /**\n         * Add handler to promise with given promise object id.\n         */\n        post(method: \"Runtime.awaitPromise\", params?: Runtime.AwaitPromiseParameterType, callback?: (err: Error | null, params: Runtime.AwaitPromiseReturnType) => void): void;\n        post(method: \"Runtime.awaitPromise\", callback?: (err: Error | null, params: Runtime.AwaitPromiseReturnType) => void): void;\n\n        /**\n         * Calls function with given declaration on the given object. Object group of the result is inherited from the target object.\n         */\n        post(method: \"Runtime.callFunctionOn\", params?: Runtime.CallFunctionOnParameterType, callback?: (err: Error | null, params: Runtime.CallFunctionOnReturnType) => void): void;\n        post(method: \"Runtime.callFunctionOn\", callback?: (err: Error | null, params: Runtime.CallFunctionOnReturnType) => void): void;\n\n        /**\n         * Returns properties of a given object. Object group of the result is inherited from the target object.\n         */\n        post(method: \"Runtime.getProperties\", params?: Runtime.GetPropertiesParameterType, callback?: (err: Error | null, params: Runtime.GetPropertiesReturnType) => void): void;\n        post(method: \"Runtime.getProperties\", callback?: (err: Error | null, params: Runtime.GetPropertiesReturnType) => void): void;\n\n        /**\n         * Releases remote object with given id.\n         */\n        post(method: \"Runtime.releaseObject\", params?: Runtime.ReleaseObjectParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Runtime.releaseObject\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Releases all remote objects that belong to a given group.\n         */\n        post(method: \"Runtime.releaseObjectGroup\", params?: Runtime.ReleaseObjectGroupParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Runtime.releaseObjectGroup\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Tells inspected instance to run if it was waiting for debugger to attach.\n         */\n        post(method: \"Runtime.runIfWaitingForDebugger\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.\n         */\n        post(method: \"Runtime.enable\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Disables reporting of execution contexts creation.\n         */\n        post(method: \"Runtime.disable\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Discards collected exceptions and console API calls.\n         */\n        post(method: \"Runtime.discardConsoleEntries\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * @experimental\n         */\n        post(method: \"Runtime.setCustomObjectFormatterEnabled\", params?: Runtime.SetCustomObjectFormatterEnabledParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Runtime.setCustomObjectFormatterEnabled\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Compiles expression.\n         */\n        post(method: \"Runtime.compileScript\", params?: Runtime.CompileScriptParameterType, callback?: (err: Error | null, params: Runtime.CompileScriptReturnType) => void): void;\n        post(method: \"Runtime.compileScript\", callback?: (err: Error | null, params: Runtime.CompileScriptReturnType) => void): void;\n\n        /**\n         * Runs script with given id in a given context.\n         */\n        post(method: \"Runtime.runScript\", params?: Runtime.RunScriptParameterType, callback?: (err: Error | null, params: Runtime.RunScriptReturnType) => void): void;\n        post(method: \"Runtime.runScript\", callback?: (err: Error | null, params: Runtime.RunScriptReturnType) => void): void;\n\n        post(method: \"Runtime.queryObjects\", params?: Runtime.QueryObjectsParameterType, callback?: (err: Error | null, params: Runtime.QueryObjectsReturnType) => void): void;\n        post(method: \"Runtime.queryObjects\", callback?: (err: Error | null, params: Runtime.QueryObjectsReturnType) => void): void;\n\n        /**\n         * Returns all let, const and class variables from global scope.\n         */\n        post(\n            method: \"Runtime.globalLexicalScopeNames\",\n            params?: Runtime.GlobalLexicalScopeNamesParameterType,\n            callback?: (err: Error | null, params: Runtime.GlobalLexicalScopeNamesReturnType) => void\n        ): void;\n        post(method: \"Runtime.globalLexicalScopeNames\", callback?: (err: Error | null, params: Runtime.GlobalLexicalScopeNamesReturnType) => void): void;\n\n        /**\n         * Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.\n         */\n        post(method: \"Debugger.enable\", callback?: (err: Error | null, params: Debugger.EnableReturnType) => void): void;\n\n        /**\n         * Disables debugger for given page.\n         */\n        post(method: \"Debugger.disable\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Activates / deactivates all breakpoints on the page.\n         */\n        post(method: \"Debugger.setBreakpointsActive\", params?: Debugger.SetBreakpointsActiveParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Debugger.setBreakpointsActive\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).\n         */\n        post(method: \"Debugger.setSkipAllPauses\", params?: Debugger.SetSkipAllPausesParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Debugger.setSkipAllPauses\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.\n         */\n        post(method: \"Debugger.setBreakpointByUrl\", params?: Debugger.SetBreakpointByUrlParameterType, callback?: (err: Error | null, params: Debugger.SetBreakpointByUrlReturnType) => void): void;\n        post(method: \"Debugger.setBreakpointByUrl\", callback?: (err: Error | null, params: Debugger.SetBreakpointByUrlReturnType) => void): void;\n\n        /**\n         * Sets JavaScript breakpoint at a given location.\n         */\n        post(method: \"Debugger.setBreakpoint\", params?: Debugger.SetBreakpointParameterType, callback?: (err: Error | null, params: Debugger.SetBreakpointReturnType) => void): void;\n        post(method: \"Debugger.setBreakpoint\", callback?: (err: Error | null, params: Debugger.SetBreakpointReturnType) => void): void;\n\n        /**\n         * Removes JavaScript breakpoint.\n         */\n        post(method: \"Debugger.removeBreakpoint\", params?: Debugger.RemoveBreakpointParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Debugger.removeBreakpoint\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.\n         */\n        post(\n            method: \"Debugger.getPossibleBreakpoints\",\n            params?: Debugger.GetPossibleBreakpointsParameterType,\n            callback?: (err: Error | null, params: Debugger.GetPossibleBreakpointsReturnType) => void\n        ): void;\n        post(method: \"Debugger.getPossibleBreakpoints\", callback?: (err: Error | null, params: Debugger.GetPossibleBreakpointsReturnType) => void): void;\n\n        /**\n         * Continues execution until specific location is reached.\n         */\n        post(method: \"Debugger.continueToLocation\", params?: Debugger.ContinueToLocationParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Debugger.continueToLocation\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * @experimental\n         */\n        post(method: \"Debugger.pauseOnAsyncCall\", params?: Debugger.PauseOnAsyncCallParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Debugger.pauseOnAsyncCall\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Steps over the statement.\n         */\n        post(method: \"Debugger.stepOver\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Steps into the function call.\n         */\n        post(method: \"Debugger.stepInto\", params?: Debugger.StepIntoParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Debugger.stepInto\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Steps out of the function call.\n         */\n        post(method: \"Debugger.stepOut\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Stops on the next JavaScript statement.\n         */\n        post(method: \"Debugger.pause\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.\n         * @experimental\n         */\n        post(method: \"Debugger.scheduleStepIntoAsync\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Resumes JavaScript execution.\n         */\n        post(method: \"Debugger.resume\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Returns stack trace with given <code>stackTraceId</code>.\n         * @experimental\n         */\n        post(method: \"Debugger.getStackTrace\", params?: Debugger.GetStackTraceParameterType, callback?: (err: Error | null, params: Debugger.GetStackTraceReturnType) => void): void;\n        post(method: \"Debugger.getStackTrace\", callback?: (err: Error | null, params: Debugger.GetStackTraceReturnType) => void): void;\n\n        /**\n         * Searches for given string in script content.\n         */\n        post(method: \"Debugger.searchInContent\", params?: Debugger.SearchInContentParameterType, callback?: (err: Error | null, params: Debugger.SearchInContentReturnType) => void): void;\n        post(method: \"Debugger.searchInContent\", callback?: (err: Error | null, params: Debugger.SearchInContentReturnType) => void): void;\n\n        /**\n         * Edits JavaScript source live.\n         */\n        post(method: \"Debugger.setScriptSource\", params?: Debugger.SetScriptSourceParameterType, callback?: (err: Error | null, params: Debugger.SetScriptSourceReturnType) => void): void;\n        post(method: \"Debugger.setScriptSource\", callback?: (err: Error | null, params: Debugger.SetScriptSourceReturnType) => void): void;\n\n        /**\n         * Restarts particular call frame from the beginning.\n         */\n        post(method: \"Debugger.restartFrame\", params?: Debugger.RestartFrameParameterType, callback?: (err: Error | null, params: Debugger.RestartFrameReturnType) => void): void;\n        post(method: \"Debugger.restartFrame\", callback?: (err: Error | null, params: Debugger.RestartFrameReturnType) => void): void;\n\n        /**\n         * Returns source for the script with given id.\n         */\n        post(method: \"Debugger.getScriptSource\", params?: Debugger.GetScriptSourceParameterType, callback?: (err: Error | null, params: Debugger.GetScriptSourceReturnType) => void): void;\n        post(method: \"Debugger.getScriptSource\", callback?: (err: Error | null, params: Debugger.GetScriptSourceReturnType) => void): void;\n\n        /**\n         * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.\n         */\n        post(method: \"Debugger.setPauseOnExceptions\", params?: Debugger.SetPauseOnExceptionsParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Debugger.setPauseOnExceptions\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Evaluates expression on a given call frame.\n         */\n        post(method: \"Debugger.evaluateOnCallFrame\", params?: Debugger.EvaluateOnCallFrameParameterType, callback?: (err: Error | null, params: Debugger.EvaluateOnCallFrameReturnType) => void): void;\n        post(method: \"Debugger.evaluateOnCallFrame\", callback?: (err: Error | null, params: Debugger.EvaluateOnCallFrameReturnType) => void): void;\n\n        /**\n         * Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.\n         */\n        post(method: \"Debugger.setVariableValue\", params?: Debugger.SetVariableValueParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Debugger.setVariableValue\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Changes return value in top frame. Available only at return break position.\n         * @experimental\n         */\n        post(method: \"Debugger.setReturnValue\", params?: Debugger.SetReturnValueParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Debugger.setReturnValue\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Enables or disables async call stacks tracking.\n         */\n        post(method: \"Debugger.setAsyncCallStackDepth\", params?: Debugger.SetAsyncCallStackDepthParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Debugger.setAsyncCallStackDepth\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.\n         * @experimental\n         */\n        post(method: \"Debugger.setBlackboxPatterns\", params?: Debugger.SetBlackboxPatternsParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Debugger.setBlackboxPatterns\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.\n         * @experimental\n         */\n        post(method: \"Debugger.setBlackboxedRanges\", params?: Debugger.SetBlackboxedRangesParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Debugger.setBlackboxedRanges\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.\n         */\n        post(method: \"Console.enable\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Disables console domain, prevents further console messages from being reported to the client.\n         */\n        post(method: \"Console.disable\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Does nothing.\n         */\n        post(method: \"Console.clearMessages\", callback?: (err: Error | null) => void): void;\n\n        post(method: \"Profiler.enable\", callback?: (err: Error | null) => void): void;\n\n        post(method: \"Profiler.disable\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.\n         */\n        post(method: \"Profiler.setSamplingInterval\", params?: Profiler.SetSamplingIntervalParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Profiler.setSamplingInterval\", callback?: (err: Error | null) => void): void;\n\n        post(method: \"Profiler.start\", callback?: (err: Error | null) => void): void;\n\n        post(method: \"Profiler.stop\", callback?: (err: Error | null, params: Profiler.StopReturnType) => void): void;\n\n        /**\n         * Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.\n         */\n        post(method: \"Profiler.startPreciseCoverage\", params?: Profiler.StartPreciseCoverageParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"Profiler.startPreciseCoverage\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.\n         */\n        post(method: \"Profiler.stopPreciseCoverage\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.\n         */\n        post(method: \"Profiler.takePreciseCoverage\", callback?: (err: Error | null, params: Profiler.TakePreciseCoverageReturnType) => void): void;\n\n        /**\n         * Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.\n         */\n        post(method: \"Profiler.getBestEffortCoverage\", callback?: (err: Error | null, params: Profiler.GetBestEffortCoverageReturnType) => void): void;\n\n        /**\n         * Enable type profile.\n         * @experimental\n         */\n        post(method: \"Profiler.startTypeProfile\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Disable type profile. Disabling releases type profile data collected so far.\n         * @experimental\n         */\n        post(method: \"Profiler.stopTypeProfile\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Collect type profile.\n         * @experimental\n         */\n        post(method: \"Profiler.takeTypeProfile\", callback?: (err: Error | null, params: Profiler.TakeTypeProfileReturnType) => void): void;\n\n        post(method: \"HeapProfiler.enable\", callback?: (err: Error | null) => void): void;\n\n        post(method: \"HeapProfiler.disable\", callback?: (err: Error | null) => void): void;\n\n        post(method: \"HeapProfiler.startTrackingHeapObjects\", params?: HeapProfiler.StartTrackingHeapObjectsParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"HeapProfiler.startTrackingHeapObjects\", callback?: (err: Error | null) => void): void;\n\n        post(method: \"HeapProfiler.stopTrackingHeapObjects\", params?: HeapProfiler.StopTrackingHeapObjectsParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"HeapProfiler.stopTrackingHeapObjects\", callback?: (err: Error | null) => void): void;\n\n        post(method: \"HeapProfiler.takeHeapSnapshot\", params?: HeapProfiler.TakeHeapSnapshotParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"HeapProfiler.takeHeapSnapshot\", callback?: (err: Error | null) => void): void;\n\n        post(method: \"HeapProfiler.collectGarbage\", callback?: (err: Error | null) => void): void;\n\n        post(\n            method: \"HeapProfiler.getObjectByHeapObjectId\",\n            params?: HeapProfiler.GetObjectByHeapObjectIdParameterType,\n            callback?: (err: Error | null, params: HeapProfiler.GetObjectByHeapObjectIdReturnType) => void\n        ): void;\n        post(method: \"HeapProfiler.getObjectByHeapObjectId\", callback?: (err: Error | null, params: HeapProfiler.GetObjectByHeapObjectIdReturnType) => void): void;\n\n        /**\n         * Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).\n         */\n        post(method: \"HeapProfiler.addInspectedHeapObject\", params?: HeapProfiler.AddInspectedHeapObjectParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"HeapProfiler.addInspectedHeapObject\", callback?: (err: Error | null) => void): void;\n\n        post(method: \"HeapProfiler.getHeapObjectId\", params?: HeapProfiler.GetHeapObjectIdParameterType, callback?: (err: Error | null, params: HeapProfiler.GetHeapObjectIdReturnType) => void): void;\n        post(method: \"HeapProfiler.getHeapObjectId\", callback?: (err: Error | null, params: HeapProfiler.GetHeapObjectIdReturnType) => void): void;\n\n        post(method: \"HeapProfiler.startSampling\", params?: HeapProfiler.StartSamplingParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"HeapProfiler.startSampling\", callback?: (err: Error | null) => void): void;\n\n        post(method: \"HeapProfiler.stopSampling\", callback?: (err: Error | null, params: HeapProfiler.StopSamplingReturnType) => void): void;\n\n        post(method: \"HeapProfiler.getSamplingProfile\", callback?: (err: Error | null, params: HeapProfiler.GetSamplingProfileReturnType) => void): void;\n\n        /**\n         * Gets supported tracing categories.\n         */\n        post(method: \"NodeTracing.getCategories\", callback?: (err: Error | null, params: NodeTracing.GetCategoriesReturnType) => void): void;\n\n        /**\n         * Start trace events collection.\n         */\n        post(method: \"NodeTracing.start\", params?: NodeTracing.StartParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"NodeTracing.start\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Stop trace events collection. Remaining collected events will be sent as a sequence of\n         * dataCollected events followed by tracingComplete event.\n         */\n        post(method: \"NodeTracing.stop\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Sends protocol message over session with given id.\n         */\n        post(method: \"NodeWorker.sendMessageToWorker\", params?: NodeWorker.SendMessageToWorkerParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"NodeWorker.sendMessageToWorker\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Instructs the inspector to attach to running workers. Will also attach to new workers\n         * as they start\n         */\n        post(method: \"NodeWorker.enable\", params?: NodeWorker.EnableParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"NodeWorker.enable\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Detaches from all running workers and disables attaching to new workers as they are started.\n         */\n        post(method: \"NodeWorker.disable\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Detached from the worker with given sessionId.\n         */\n        post(method: \"NodeWorker.detach\", params?: NodeWorker.DetachParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"NodeWorker.detach\", callback?: (err: Error | null) => void): void;\n\n        /**\n         * Enable the `NodeRuntime.waitingForDisconnect`.\n         */\n        post(method: \"NodeRuntime.notifyWhenWaitingForDisconnect\", params?: NodeRuntime.NotifyWhenWaitingForDisconnectParameterType, callback?: (err: Error | null) => void): void;\n        post(method: \"NodeRuntime.notifyWhenWaitingForDisconnect\", callback?: (err: Error | null) => void): void;\n\n        // Events\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n\n        /**\n         * Emitted when any notification from the V8 Inspector is received.\n         */\n        addListener(event: \"inspectorNotification\", listener: (message: InspectorNotification<{}>) => void): this;\n\n        /**\n         * Issued when new execution context is created.\n         */\n        addListener(event: \"Runtime.executionContextCreated\", listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;\n\n        /**\n         * Issued when execution context is destroyed.\n         */\n        addListener(event: \"Runtime.executionContextDestroyed\", listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;\n\n        /**\n         * Issued when all executionContexts were cleared in browser\n         */\n        addListener(event: \"Runtime.executionContextsCleared\", listener: () => void): this;\n\n        /**\n         * Issued when exception was thrown and unhandled.\n         */\n        addListener(event: \"Runtime.exceptionThrown\", listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;\n\n        /**\n         * Issued when unhandled exception was revoked.\n         */\n        addListener(event: \"Runtime.exceptionRevoked\", listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;\n\n        /**\n         * Issued when console API was called.\n         */\n        addListener(event: \"Runtime.consoleAPICalled\", listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;\n\n        /**\n         * Issued when object should be inspected (for example, as a result of inspect() command line API call).\n         */\n        addListener(event: \"Runtime.inspectRequested\", listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;\n\n        /**\n         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.\n         */\n        addListener(event: \"Debugger.scriptParsed\", listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;\n\n        /**\n         * Fired when virtual machine fails to parse the script.\n         */\n        addListener(event: \"Debugger.scriptFailedToParse\", listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;\n\n        /**\n         * Fired when breakpoint is resolved to an actual script and location.\n         */\n        addListener(event: \"Debugger.breakpointResolved\", listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;\n\n        /**\n         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.\n         */\n        addListener(event: \"Debugger.paused\", listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;\n\n        /**\n         * Fired when the virtual machine resumed execution.\n         */\n        addListener(event: \"Debugger.resumed\", listener: () => void): this;\n\n        /**\n         * Issued when new console message is added.\n         */\n        addListener(event: \"Console.messageAdded\", listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;\n\n        /**\n         * Sent when new profile recording is started using console.profile() call.\n         */\n        addListener(event: \"Profiler.consoleProfileStarted\", listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;\n\n        addListener(event: \"Profiler.consoleProfileFinished\", listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;\n        addListener(event: \"HeapProfiler.addHeapSnapshotChunk\", listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;\n        addListener(event: \"HeapProfiler.resetProfiles\", listener: () => void): this;\n        addListener(event: \"HeapProfiler.reportHeapSnapshotProgress\", listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;\n\n        /**\n         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.\n         */\n        addListener(event: \"HeapProfiler.lastSeenObjectId\", listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;\n\n        /**\n         * If heap objects tracking has been started then backend may send update for one or more fragments\n         */\n        addListener(event: \"HeapProfiler.heapStatsUpdate\", listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;\n\n        /**\n         * Contains an bucket of collected trace events.\n         */\n        addListener(event: \"NodeTracing.dataCollected\", listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;\n\n        /**\n         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were\n         * delivered via dataCollected events.\n         */\n        addListener(event: \"NodeTracing.tracingComplete\", listener: () => void): this;\n\n        /**\n         * Issued when attached to a worker.\n         */\n        addListener(event: \"NodeWorker.attachedToWorker\", listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;\n\n        /**\n         * Issued when detached from the worker.\n         */\n        addListener(event: \"NodeWorker.detachedFromWorker\", listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;\n\n        /**\n         * Notifies about a new protocol message received from the session\n         * (session ID is provided in attachedToWorker notification).\n         */\n        addListener(event: \"NodeWorker.receivedMessageFromWorker\", listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;\n\n        /**\n         * This event is fired instead of `Runtime.executionContextDestroyed` when\n         * enabled.\n         * It is fired when the Node process finished all code execution and is\n         * waiting for all frontends to disconnect.\n         */\n        addListener(event: \"NodeRuntime.waitingForDisconnect\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"inspectorNotification\", message: InspectorNotification<{}>): boolean;\n        emit(event: \"Runtime.executionContextCreated\", message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>): boolean;\n        emit(event: \"Runtime.executionContextDestroyed\", message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>): boolean;\n        emit(event: \"Runtime.executionContextsCleared\"): boolean;\n        emit(event: \"Runtime.exceptionThrown\", message: InspectorNotification<Runtime.ExceptionThrownEventDataType>): boolean;\n        emit(event: \"Runtime.exceptionRevoked\", message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>): boolean;\n        emit(event: \"Runtime.consoleAPICalled\", message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>): boolean;\n        emit(event: \"Runtime.inspectRequested\", message: InspectorNotification<Runtime.InspectRequestedEventDataType>): boolean;\n        emit(event: \"Debugger.scriptParsed\", message: InspectorNotification<Debugger.ScriptParsedEventDataType>): boolean;\n        emit(event: \"Debugger.scriptFailedToParse\", message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>): boolean;\n        emit(event: \"Debugger.breakpointResolved\", message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>): boolean;\n        emit(event: \"Debugger.paused\", message: InspectorNotification<Debugger.PausedEventDataType>): boolean;\n        emit(event: \"Debugger.resumed\"): boolean;\n        emit(event: \"Console.messageAdded\", message: InspectorNotification<Console.MessageAddedEventDataType>): boolean;\n        emit(event: \"Profiler.consoleProfileStarted\", message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>): boolean;\n        emit(event: \"Profiler.consoleProfileFinished\", message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>): boolean;\n        emit(event: \"HeapProfiler.addHeapSnapshotChunk\", message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>): boolean;\n        emit(event: \"HeapProfiler.resetProfiles\"): boolean;\n        emit(event: \"HeapProfiler.reportHeapSnapshotProgress\", message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>): boolean;\n        emit(event: \"HeapProfiler.lastSeenObjectId\", message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>): boolean;\n        emit(event: \"HeapProfiler.heapStatsUpdate\", message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>): boolean;\n        emit(event: \"NodeTracing.dataCollected\", message: InspectorNotification<NodeTracing.DataCollectedEventDataType>): boolean;\n        emit(event: \"NodeTracing.tracingComplete\"): boolean;\n        emit(event: \"NodeWorker.attachedToWorker\", message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>): boolean;\n        emit(event: \"NodeWorker.detachedFromWorker\", message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>): boolean;\n        emit(event: \"NodeWorker.receivedMessageFromWorker\", message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>): boolean;\n        emit(event: \"NodeRuntime.waitingForDisconnect\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n\n        /**\n         * Emitted when any notification from the V8 Inspector is received.\n         */\n        on(event: \"inspectorNotification\", listener: (message: InspectorNotification<{}>) => void): this;\n\n        /**\n         * Issued when new execution context is created.\n         */\n        on(event: \"Runtime.executionContextCreated\", listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;\n\n        /**\n         * Issued when execution context is destroyed.\n         */\n        on(event: \"Runtime.executionContextDestroyed\", listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;\n\n        /**\n         * Issued when all executionContexts were cleared in browser\n         */\n        on(event: \"Runtime.executionContextsCleared\", listener: () => void): this;\n\n        /**\n         * Issued when exception was thrown and unhandled.\n         */\n        on(event: \"Runtime.exceptionThrown\", listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;\n\n        /**\n         * Issued when unhandled exception was revoked.\n         */\n        on(event: \"Runtime.exceptionRevoked\", listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;\n\n        /**\n         * Issued when console API was called.\n         */\n        on(event: \"Runtime.consoleAPICalled\", listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;\n\n        /**\n         * Issued when object should be inspected (for example, as a result of inspect() command line API call).\n         */\n        on(event: \"Runtime.inspectRequested\", listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;\n\n        /**\n         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.\n         */\n        on(event: \"Debugger.scriptParsed\", listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;\n\n        /**\n         * Fired when virtual machine fails to parse the script.\n         */\n        on(event: \"Debugger.scriptFailedToParse\", listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;\n\n        /**\n         * Fired when breakpoint is resolved to an actual script and location.\n         */\n        on(event: \"Debugger.breakpointResolved\", listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;\n\n        /**\n         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.\n         */\n        on(event: \"Debugger.paused\", listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;\n\n        /**\n         * Fired when the virtual machine resumed execution.\n         */\n        on(event: \"Debugger.resumed\", listener: () => void): this;\n\n        /**\n         * Issued when new console message is added.\n         */\n        on(event: \"Console.messageAdded\", listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;\n\n        /**\n         * Sent when new profile recording is started using console.profile() call.\n         */\n        on(event: \"Profiler.consoleProfileStarted\", listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;\n\n        on(event: \"Profiler.consoleProfileFinished\", listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;\n        on(event: \"HeapProfiler.addHeapSnapshotChunk\", listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;\n        on(event: \"HeapProfiler.resetProfiles\", listener: () => void): this;\n        on(event: \"HeapProfiler.reportHeapSnapshotProgress\", listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;\n\n        /**\n         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.\n         */\n        on(event: \"HeapProfiler.lastSeenObjectId\", listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;\n\n        /**\n         * If heap objects tracking has been started then backend may send update for one or more fragments\n         */\n        on(event: \"HeapProfiler.heapStatsUpdate\", listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;\n\n        /**\n         * Contains an bucket of collected trace events.\n         */\n        on(event: \"NodeTracing.dataCollected\", listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;\n\n        /**\n         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were\n         * delivered via dataCollected events.\n         */\n        on(event: \"NodeTracing.tracingComplete\", listener: () => void): this;\n\n        /**\n         * Issued when attached to a worker.\n         */\n        on(event: \"NodeWorker.attachedToWorker\", listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;\n\n        /**\n         * Issued when detached from the worker.\n         */\n        on(event: \"NodeWorker.detachedFromWorker\", listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;\n\n        /**\n         * Notifies about a new protocol message received from the session\n         * (session ID is provided in attachedToWorker notification).\n         */\n        on(event: \"NodeWorker.receivedMessageFromWorker\", listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;\n\n        /**\n         * This event is fired instead of `Runtime.executionContextDestroyed` when\n         * enabled.\n         * It is fired when the Node process finished all code execution and is\n         * waiting for all frontends to disconnect.\n         */\n        on(event: \"NodeRuntime.waitingForDisconnect\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n\n        /**\n         * Emitted when any notification from the V8 Inspector is received.\n         */\n        once(event: \"inspectorNotification\", listener: (message: InspectorNotification<{}>) => void): this;\n\n        /**\n         * Issued when new execution context is created.\n         */\n        once(event: \"Runtime.executionContextCreated\", listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;\n\n        /**\n         * Issued when execution context is destroyed.\n         */\n        once(event: \"Runtime.executionContextDestroyed\", listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;\n\n        /**\n         * Issued when all executionContexts were cleared in browser\n         */\n        once(event: \"Runtime.executionContextsCleared\", listener: () => void): this;\n\n        /**\n         * Issued when exception was thrown and unhandled.\n         */\n        once(event: \"Runtime.exceptionThrown\", listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;\n\n        /**\n         * Issued when unhandled exception was revoked.\n         */\n        once(event: \"Runtime.exceptionRevoked\", listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;\n\n        /**\n         * Issued when console API was called.\n         */\n        once(event: \"Runtime.consoleAPICalled\", listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;\n\n        /**\n         * Issued when object should be inspected (for example, as a result of inspect() command line API call).\n         */\n        once(event: \"Runtime.inspectRequested\", listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;\n\n        /**\n         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.\n         */\n        once(event: \"Debugger.scriptParsed\", listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;\n\n        /**\n         * Fired when virtual machine fails to parse the script.\n         */\n        once(event: \"Debugger.scriptFailedToParse\", listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;\n\n        /**\n         * Fired when breakpoint is resolved to an actual script and location.\n         */\n        once(event: \"Debugger.breakpointResolved\", listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;\n\n        /**\n         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.\n         */\n        once(event: \"Debugger.paused\", listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;\n\n        /**\n         * Fired when the virtual machine resumed execution.\n         */\n        once(event: \"Debugger.resumed\", listener: () => void): this;\n\n        /**\n         * Issued when new console message is added.\n         */\n        once(event: \"Console.messageAdded\", listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;\n\n        /**\n         * Sent when new profile recording is started using console.profile() call.\n         */\n        once(event: \"Profiler.consoleProfileStarted\", listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;\n\n        once(event: \"Profiler.consoleProfileFinished\", listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;\n        once(event: \"HeapProfiler.addHeapSnapshotChunk\", listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;\n        once(event: \"HeapProfiler.resetProfiles\", listener: () => void): this;\n        once(event: \"HeapProfiler.reportHeapSnapshotProgress\", listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;\n\n        /**\n         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.\n         */\n        once(event: \"HeapProfiler.lastSeenObjectId\", listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;\n\n        /**\n         * If heap objects tracking has been started then backend may send update for one or more fragments\n         */\n        once(event: \"HeapProfiler.heapStatsUpdate\", listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;\n\n        /**\n         * Contains an bucket of collected trace events.\n         */\n        once(event: \"NodeTracing.dataCollected\", listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;\n\n        /**\n         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were\n         * delivered via dataCollected events.\n         */\n        once(event: \"NodeTracing.tracingComplete\", listener: () => void): this;\n\n        /**\n         * Issued when attached to a worker.\n         */\n        once(event: \"NodeWorker.attachedToWorker\", listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;\n\n        /**\n         * Issued when detached from the worker.\n         */\n        once(event: \"NodeWorker.detachedFromWorker\", listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;\n\n        /**\n         * Notifies about a new protocol message received from the session\n         * (session ID is provided in attachedToWorker notification).\n         */\n        once(event: \"NodeWorker.receivedMessageFromWorker\", listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;\n\n        /**\n         * This event is fired instead of `Runtime.executionContextDestroyed` when\n         * enabled.\n         * It is fired when the Node process finished all code execution and is\n         * waiting for all frontends to disconnect.\n         */\n        once(event: \"NodeRuntime.waitingForDisconnect\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n\n        /**\n         * Emitted when any notification from the V8 Inspector is received.\n         */\n        prependListener(event: \"inspectorNotification\", listener: (message: InspectorNotification<{}>) => void): this;\n\n        /**\n         * Issued when new execution context is created.\n         */\n        prependListener(event: \"Runtime.executionContextCreated\", listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;\n\n        /**\n         * Issued when execution context is destroyed.\n         */\n        prependListener(event: \"Runtime.executionContextDestroyed\", listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;\n\n        /**\n         * Issued when all executionContexts were cleared in browser\n         */\n        prependListener(event: \"Runtime.executionContextsCleared\", listener: () => void): this;\n\n        /**\n         * Issued when exception was thrown and unhandled.\n         */\n        prependListener(event: \"Runtime.exceptionThrown\", listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;\n\n        /**\n         * Issued when unhandled exception was revoked.\n         */\n        prependListener(event: \"Runtime.exceptionRevoked\", listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;\n\n        /**\n         * Issued when console API was called.\n         */\n        prependListener(event: \"Runtime.consoleAPICalled\", listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;\n\n        /**\n         * Issued when object should be inspected (for example, as a result of inspect() command line API call).\n         */\n        prependListener(event: \"Runtime.inspectRequested\", listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;\n\n        /**\n         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.\n         */\n        prependListener(event: \"Debugger.scriptParsed\", listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;\n\n        /**\n         * Fired when virtual machine fails to parse the script.\n         */\n        prependListener(event: \"Debugger.scriptFailedToParse\", listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;\n\n        /**\n         * Fired when breakpoint is resolved to an actual script and location.\n         */\n        prependListener(event: \"Debugger.breakpointResolved\", listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;\n\n        /**\n         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.\n         */\n        prependListener(event: \"Debugger.paused\", listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;\n\n        /**\n         * Fired when the virtual machine resumed execution.\n         */\n        prependListener(event: \"Debugger.resumed\", listener: () => void): this;\n\n        /**\n         * Issued when new console message is added.\n         */\n        prependListener(event: \"Console.messageAdded\", listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;\n\n        /**\n         * Sent when new profile recording is started using console.profile() call.\n         */\n        prependListener(event: \"Profiler.consoleProfileStarted\", listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;\n\n        prependListener(event: \"Profiler.consoleProfileFinished\", listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;\n        prependListener(event: \"HeapProfiler.addHeapSnapshotChunk\", listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;\n        prependListener(event: \"HeapProfiler.resetProfiles\", listener: () => void): this;\n        prependListener(event: \"HeapProfiler.reportHeapSnapshotProgress\", listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;\n\n        /**\n         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.\n         */\n        prependListener(event: \"HeapProfiler.lastSeenObjectId\", listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;\n\n        /**\n         * If heap objects tracking has been started then backend may send update for one or more fragments\n         */\n        prependListener(event: \"HeapProfiler.heapStatsUpdate\", listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;\n\n        /**\n         * Contains an bucket of collected trace events.\n         */\n        prependListener(event: \"NodeTracing.dataCollected\", listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;\n\n        /**\n         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were\n         * delivered via dataCollected events.\n         */\n        prependListener(event: \"NodeTracing.tracingComplete\", listener: () => void): this;\n\n        /**\n         * Issued when attached to a worker.\n         */\n        prependListener(event: \"NodeWorker.attachedToWorker\", listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;\n\n        /**\n         * Issued when detached from the worker.\n         */\n        prependListener(event: \"NodeWorker.detachedFromWorker\", listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;\n\n        /**\n         * Notifies about a new protocol message received from the session\n         * (session ID is provided in attachedToWorker notification).\n         */\n        prependListener(event: \"NodeWorker.receivedMessageFromWorker\", listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;\n\n        /**\n         * This event is fired instead of `Runtime.executionContextDestroyed` when\n         * enabled.\n         * It is fired when the Node process finished all code execution and is\n         * waiting for all frontends to disconnect.\n         */\n        prependListener(event: \"NodeRuntime.waitingForDisconnect\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n\n        /**\n         * Emitted when any notification from the V8 Inspector is received.\n         */\n        prependOnceListener(event: \"inspectorNotification\", listener: (message: InspectorNotification<{}>) => void): this;\n\n        /**\n         * Issued when new execution context is created.\n         */\n        prependOnceListener(event: \"Runtime.executionContextCreated\", listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;\n\n        /**\n         * Issued when execution context is destroyed.\n         */\n        prependOnceListener(event: \"Runtime.executionContextDestroyed\", listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;\n\n        /**\n         * Issued when all executionContexts were cleared in browser\n         */\n        prependOnceListener(event: \"Runtime.executionContextsCleared\", listener: () => void): this;\n\n        /**\n         * Issued when exception was thrown and unhandled.\n         */\n        prependOnceListener(event: \"Runtime.exceptionThrown\", listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;\n\n        /**\n         * Issued when unhandled exception was revoked.\n         */\n        prependOnceListener(event: \"Runtime.exceptionRevoked\", listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;\n\n        /**\n         * Issued when console API was called.\n         */\n        prependOnceListener(event: \"Runtime.consoleAPICalled\", listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;\n\n        /**\n         * Issued when object should be inspected (for example, as a result of inspect() command line API call).\n         */\n        prependOnceListener(event: \"Runtime.inspectRequested\", listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;\n\n        /**\n         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.\n         */\n        prependOnceListener(event: \"Debugger.scriptParsed\", listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;\n\n        /**\n         * Fired when virtual machine fails to parse the script.\n         */\n        prependOnceListener(event: \"Debugger.scriptFailedToParse\", listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;\n\n        /**\n         * Fired when breakpoint is resolved to an actual script and location.\n         */\n        prependOnceListener(event: \"Debugger.breakpointResolved\", listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;\n\n        /**\n         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.\n         */\n        prependOnceListener(event: \"Debugger.paused\", listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;\n\n        /**\n         * Fired when the virtual machine resumed execution.\n         */\n        prependOnceListener(event: \"Debugger.resumed\", listener: () => void): this;\n\n        /**\n         * Issued when new console message is added.\n         */\n        prependOnceListener(event: \"Console.messageAdded\", listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;\n\n        /**\n         * Sent when new profile recording is started using console.profile() call.\n         */\n        prependOnceListener(event: \"Profiler.consoleProfileStarted\", listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;\n\n        prependOnceListener(event: \"Profiler.consoleProfileFinished\", listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;\n        prependOnceListener(event: \"HeapProfiler.addHeapSnapshotChunk\", listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;\n        prependOnceListener(event: \"HeapProfiler.resetProfiles\", listener: () => void): this;\n        prependOnceListener(event: \"HeapProfiler.reportHeapSnapshotProgress\", listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;\n\n        /**\n         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.\n         */\n        prependOnceListener(event: \"HeapProfiler.lastSeenObjectId\", listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;\n\n        /**\n         * If heap objects tracking has been started then backend may send update for one or more fragments\n         */\n        prependOnceListener(event: \"HeapProfiler.heapStatsUpdate\", listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;\n\n        /**\n         * Contains an bucket of collected trace events.\n         */\n        prependOnceListener(event: \"NodeTracing.dataCollected\", listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;\n\n        /**\n         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were\n         * delivered via dataCollected events.\n         */\n        prependOnceListener(event: \"NodeTracing.tracingComplete\", listener: () => void): this;\n\n        /**\n         * Issued when attached to a worker.\n         */\n        prependOnceListener(event: \"NodeWorker.attachedToWorker\", listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;\n\n        /**\n         * Issued when detached from the worker.\n         */\n        prependOnceListener(event: \"NodeWorker.detachedFromWorker\", listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;\n\n        /**\n         * Notifies about a new protocol message received from the session\n         * (session ID is provided in attachedToWorker notification).\n         */\n        prependOnceListener(event: \"NodeWorker.receivedMessageFromWorker\", listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;\n\n        /**\n         * This event is fired instead of `Runtime.executionContextDestroyed` when\n         * enabled.\n         * It is fired when the Node process finished all code execution and is\n         * waiting for all frontends to disconnect.\n         */\n        prependOnceListener(event: \"NodeRuntime.waitingForDisconnect\", listener: () => void): this;\n    }\n\n    // Top Level API\n\n    /**\n     * Activate inspector on host and port. Equivalent to node --inspect=[[host:]port], but can be done programatically after node has started.\n     * If wait is true, will block until a client has connected to the inspect port and flow control has been passed to the debugger client.\n     * @param port Port to listen on for inspector connections. Optional, defaults to what was specified on the CLI.\n     * @param host Host to listen on for inspector connections. Optional, defaults to what was specified on the CLI.\n     * @param wait Block until a client has connected. Optional, defaults to false.\n     */\n    function open(port?: number, host?: string, wait?: boolean): void;\n\n    /**\n     * Deactivate the inspector. Blocks until there are no active connections.\n     */\n    function close(): void;\n\n    /**\n     * Return the URL of the active inspector, or `undefined` if there is none.\n     */\n    function url(): string | undefined;\n}\n\n\ndeclare module \"module\" {\n    import { URL } from \"url\";\n    namespace Module {\n        /**\n         * Updates all the live bindings for builtin ES Modules to match the properties of the CommonJS exports.\n         * It does not add or remove exported names from the ES Modules.\n         */\n        function syncBuiltinESMExports(): void;\n\n        /**\n         * @experimental\n         */\n        function findSourceMap(path: string, error?: Error): SourceMap;\n        interface SourceMapPayload {\n            file: string;\n            version: number;\n            sources: string[];\n            sourcesContent: string[];\n            names: string[];\n            mappings: string;\n            sourceRoot: string;\n        }\n\n        interface SourceMapping {\n            generatedLine: number;\n            generatedColumn: number;\n            originalSource: string;\n            originalLine: number;\n            originalColumn: number;\n        }\n\n        /**\n         * @experimental\n         */\n        class SourceMap {\n            readonly payload: SourceMapPayload;\n            constructor(payload: SourceMapPayload);\n            findEntry(line: number, column: number): SourceMapping;\n        }\n    }\n    interface Module extends NodeModule {}\n    class Module {\n        static runMain(): void;\n        static wrap(code: string): string;\n\n        /**\n         * @deprecated Deprecated since: v12.2.0. Please use createRequire() instead.\n         */\n        static createRequireFromPath(path: string): NodeRequire;\n        static createRequire(path: string | URL): NodeRequire;\n        static builtinModules: string[];\n\n        static Module: typeof Module;\n\n        constructor(id: string, parent?: Module);\n    }\n    export = Module;\n}\n\n\ndeclare module \"net\" {\n    import * as stream from \"stream\";\n    import * as events from \"events\";\n    import * as dns from \"dns\";\n\n    type LookupFunction = (hostname: string, options: dns.LookupOneOptions, callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void) => void;\n\n    interface AddressInfo {\n        address: string;\n        family: string;\n        port: number;\n    }\n\n    interface SocketConstructorOpts {\n        fd?: number;\n        allowHalfOpen?: boolean;\n        readable?: boolean;\n        writable?: boolean;\n    }\n\n    interface OnReadOpts {\n        buffer: Uint8Array | (() => Uint8Array);\n        /**\n         * This function is called for every chunk of incoming data.\n         * Two arguments are passed to it: the number of bytes written to buffer and a reference to buffer.\n         * Return false from this function to implicitly pause() the socket.\n         */\n        callback(bytesWritten: number, buf: Uint8Array): boolean;\n    }\n\n    interface ConnectOpts {\n        /**\n         * If specified, incoming data is stored in a single buffer and passed to the supplied callback when data arrives on the socket.\n         * Note: this will cause the streaming functionality to not provide any data, however events like 'error', 'end', and 'close' will\n         * still be emitted as normal and methods like pause() and resume() will also behave as expected.\n         */\n        onread?: OnReadOpts;\n    }\n\n    interface TcpSocketConnectOpts extends ConnectOpts {\n        port: number;\n        host?: string;\n        localAddress?: string;\n        localPort?: number;\n        hints?: number;\n        family?: number;\n        lookup?: LookupFunction;\n    }\n\n    interface IpcSocketConnectOpts extends ConnectOpts {\n        path: string;\n    }\n\n    type SocketConnectOpts = TcpSocketConnectOpts | IpcSocketConnectOpts;\n\n    class Socket extends stream.Duplex {\n        constructor(options?: SocketConstructorOpts);\n\n        // Extended base methods\n        write(buffer: Uint8Array | string, cb?: (err?: Error) => void): boolean;\n        write(str: Uint8Array | string, encoding?: string, cb?: (err?: Error) => void): boolean;\n\n        connect(options: SocketConnectOpts, connectionListener?: () => void): this;\n        connect(port: number, host: string, connectionListener?: () => void): this;\n        connect(port: number, connectionListener?: () => void): this;\n        connect(path: string, connectionListener?: () => void): this;\n\n        setEncoding(encoding?: string): this;\n        pause(): this;\n        resume(): this;\n        setTimeout(timeout: number, callback?: () => void): this;\n        setNoDelay(noDelay?: boolean): this;\n        setKeepAlive(enable?: boolean, initialDelay?: number): this;\n        address(): AddressInfo | string;\n        unref(): this;\n        ref(): this;\n\n        readonly bufferSize: number;\n        readonly bytesRead: number;\n        readonly bytesWritten: number;\n        readonly connecting: boolean;\n        readonly destroyed: boolean;\n        readonly localAddress: string;\n        readonly localPort: number;\n        readonly remoteAddress?: string;\n        readonly remoteFamily?: string;\n        readonly remotePort?: number;\n\n        // Extended base methods\n        end(cb?: () => void): void;\n        end(buffer: Uint8Array | string, cb?: () => void): void;\n        end(str: Uint8Array | string, encoding?: string, cb?: () => void): void;\n\n        /**\n         * events.EventEmitter\n         *   1. close\n         *   2. connect\n         *   3. data\n         *   4. drain\n         *   5. end\n         *   6. error\n         *   7. lookup\n         *   8. timeout\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: (had_error: boolean) => void): this;\n        addListener(event: \"connect\", listener: () => void): this;\n        addListener(event: \"data\", listener: (data: Buffer) => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"end\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\", had_error: boolean): boolean;\n        emit(event: \"connect\"): boolean;\n        emit(event: \"data\", data: Buffer): boolean;\n        emit(event: \"drain\"): boolean;\n        emit(event: \"end\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"lookup\", err: Error, address: string, family: string | number, host: string): boolean;\n        emit(event: \"timeout\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: (had_error: boolean) => void): this;\n        on(event: \"connect\", listener: () => void): this;\n        on(event: \"data\", listener: (data: Buffer) => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"end\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: (had_error: boolean) => void): this;\n        once(event: \"connect\", listener: () => void): this;\n        once(event: \"data\", listener: (data: Buffer) => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"end\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: (had_error: boolean) => void): this;\n        prependListener(event: \"connect\", listener: () => void): this;\n        prependListener(event: \"data\", listener: (data: Buffer) => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"end\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: (had_error: boolean) => void): this;\n        prependOnceListener(event: \"connect\", listener: () => void): this;\n        prependOnceListener(event: \"data\", listener: (data: Buffer) => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"end\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n    }\n\n    interface ListenOptions {\n        port?: number;\n        host?: string;\n        backlog?: number;\n        path?: string;\n        exclusive?: boolean;\n        readableAll?: boolean;\n        writableAll?: boolean;\n        /**\n         * @default false\n         */\n        ipv6Only?: boolean;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/net.js\n    class Server extends events.EventEmitter {\n        constructor(connectionListener?: (socket: Socket) => void);\n        constructor(options?: { allowHalfOpen?: boolean, pauseOnConnect?: boolean }, connectionListener?: (socket: Socket) => void);\n\n        listen(port?: number, hostname?: string, backlog?: number, listeningListener?: () => void): this;\n        listen(port?: number, hostname?: string, listeningListener?: () => void): this;\n        listen(port?: number, backlog?: number, listeningListener?: () => void): this;\n        listen(port?: number, listeningListener?: () => void): this;\n        listen(path: string, backlog?: number, listeningListener?: () => void): this;\n        listen(path: string, listeningListener?: () => void): this;\n        listen(options: ListenOptions, listeningListener?: () => void): this;\n        listen(handle: any, backlog?: number, listeningListener?: () => void): this;\n        listen(handle: any, listeningListener?: () => void): this;\n        close(callback?: (err?: Error) => void): this;\n        address(): AddressInfo | string | null;\n        getConnections(cb: (error: Error | null, count: number) => void): void;\n        ref(): this;\n        unref(): this;\n        maxConnections: number;\n        connections: number;\n        listening: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. close\n         *   2. connection\n         *   3. error\n         *   4. listening\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"listening\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"connection\", socket: Socket): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"listening\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"connection\", listener: (socket: Socket) => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"listening\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"connection\", listener: (socket: Socket) => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"listening\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"listening\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"listening\", listener: () => void): this;\n    }\n\n    interface TcpNetConnectOpts extends TcpSocketConnectOpts, SocketConstructorOpts {\n        timeout?: number;\n    }\n\n    interface IpcNetConnectOpts extends IpcSocketConnectOpts, SocketConstructorOpts {\n        timeout?: number;\n    }\n\n    type NetConnectOpts = TcpNetConnectOpts | IpcNetConnectOpts;\n\n    function createServer(connectionListener?: (socket: Socket) => void): Server;\n    function createServer(options?: { allowHalfOpen?: boolean, pauseOnConnect?: boolean }, connectionListener?: (socket: Socket) => void): Server;\n    function connect(options: NetConnectOpts, connectionListener?: () => void): Socket;\n    function connect(port: number, host?: string, connectionListener?: () => void): Socket;\n    function connect(path: string, connectionListener?: () => void): Socket;\n    function createConnection(options: NetConnectOpts, connectionListener?: () => void): Socket;\n    function createConnection(port: number, host?: string, connectionListener?: () => void): Socket;\n    function createConnection(path: string, connectionListener?: () => void): Socket;\n    function isIP(input: string): number;\n    function isIPv4(input: string): boolean;\n    function isIPv6(input: string): boolean;\n}\n\n\ndeclare module \"os\" {\n    interface CpuInfo {\n        model: string;\n        speed: number;\n        times: {\n            user: number;\n            nice: number;\n            sys: number;\n            idle: number;\n            irq: number;\n        };\n    }\n\n    interface NetworkInterfaceBase {\n        address: string;\n        netmask: string;\n        mac: string;\n        internal: boolean;\n        cidr: string | null;\n    }\n\n    interface NetworkInterfaceInfoIPv4 extends NetworkInterfaceBase {\n        family: \"IPv4\";\n    }\n\n    interface NetworkInterfaceInfoIPv6 extends NetworkInterfaceBase {\n        family: \"IPv6\";\n        scopeid: number;\n    }\n\n    interface UserInfo<T> {\n        username: T;\n        uid: number;\n        gid: number;\n        shell: T;\n        homedir: T;\n    }\n\n    type NetworkInterfaceInfo = NetworkInterfaceInfoIPv4 | NetworkInterfaceInfoIPv6;\n\n    function hostname(): string;\n    function loadavg(): number[];\n    function uptime(): number;\n    function freemem(): number;\n    function totalmem(): number;\n    function cpus(): CpuInfo[];\n    function type(): string;\n    function release(): string;\n    function networkInterfaces(): { [index: string]: NetworkInterfaceInfo[] };\n    function homedir(): string;\n    function userInfo(options: { encoding: 'buffer' }): UserInfo<Buffer>;\n    function userInfo(options?: { encoding: string }): UserInfo<string>;\n\n    type SignalConstants = {\n        [key in NodeJS.Signals]: number;\n    };\n\n    namespace constants {\n        const UV_UDP_REUSEADDR: number;\n        namespace signals {}\n        const signals: SignalConstants;\n        namespace errno {\n            const E2BIG: number;\n            const EACCES: number;\n            const EADDRINUSE: number;\n            const EADDRNOTAVAIL: number;\n            const EAFNOSUPPORT: number;\n            const EAGAIN: number;\n            const EALREADY: number;\n            const EBADF: number;\n            const EBADMSG: number;\n            const EBUSY: number;\n            const ECANCELED: number;\n            const ECHILD: number;\n            const ECONNABORTED: number;\n            const ECONNREFUSED: number;\n            const ECONNRESET: number;\n            const EDEADLK: number;\n            const EDESTADDRREQ: number;\n            const EDOM: number;\n            const EDQUOT: number;\n            const EEXIST: number;\n            const EFAULT: number;\n            const EFBIG: number;\n            const EHOSTUNREACH: number;\n            const EIDRM: number;\n            const EILSEQ: number;\n            const EINPROGRESS: number;\n            const EINTR: number;\n            const EINVAL: number;\n            const EIO: number;\n            const EISCONN: number;\n            const EISDIR: number;\n            const ELOOP: number;\n            const EMFILE: number;\n            const EMLINK: number;\n            const EMSGSIZE: number;\n            const EMULTIHOP: number;\n            const ENAMETOOLONG: number;\n            const ENETDOWN: number;\n            const ENETRESET: number;\n            const ENETUNREACH: number;\n            const ENFILE: number;\n            const ENOBUFS: number;\n            const ENODATA: number;\n            const ENODEV: number;\n            const ENOENT: number;\n            const ENOEXEC: number;\n            const ENOLCK: number;\n            const ENOLINK: number;\n            const ENOMEM: number;\n            const ENOMSG: number;\n            const ENOPROTOOPT: number;\n            const ENOSPC: number;\n            const ENOSR: number;\n            const ENOSTR: number;\n            const ENOSYS: number;\n            const ENOTCONN: number;\n            const ENOTDIR: number;\n            const ENOTEMPTY: number;\n            const ENOTSOCK: number;\n            const ENOTSUP: number;\n            const ENOTTY: number;\n            const ENXIO: number;\n            const EOPNOTSUPP: number;\n            const EOVERFLOW: number;\n            const EPERM: number;\n            const EPIPE: number;\n            const EPROTO: number;\n            const EPROTONOSUPPORT: number;\n            const EPROTOTYPE: number;\n            const ERANGE: number;\n            const EROFS: number;\n            const ESPIPE: number;\n            const ESRCH: number;\n            const ESTALE: number;\n            const ETIME: number;\n            const ETIMEDOUT: number;\n            const ETXTBSY: number;\n            const EWOULDBLOCK: number;\n            const EXDEV: number;\n            const WSAEINTR: number;\n            const WSAEBADF: number;\n            const WSAEACCES: number;\n            const WSAEFAULT: number;\n            const WSAEINVAL: number;\n            const WSAEMFILE: number;\n            const WSAEWOULDBLOCK: number;\n            const WSAEINPROGRESS: number;\n            const WSAEALREADY: number;\n            const WSAENOTSOCK: number;\n            const WSAEDESTADDRREQ: number;\n            const WSAEMSGSIZE: number;\n            const WSAEPROTOTYPE: number;\n            const WSAENOPROTOOPT: number;\n            const WSAEPROTONOSUPPORT: number;\n            const WSAESOCKTNOSUPPORT: number;\n            const WSAEOPNOTSUPP: number;\n            const WSAEPFNOSUPPORT: number;\n            const WSAEAFNOSUPPORT: number;\n            const WSAEADDRINUSE: number;\n            const WSAEADDRNOTAVAIL: number;\n            const WSAENETDOWN: number;\n            const WSAENETUNREACH: number;\n            const WSAENETRESET: number;\n            const WSAECONNABORTED: number;\n            const WSAECONNRESET: number;\n            const WSAENOBUFS: number;\n            const WSAEISCONN: number;\n            const WSAENOTCONN: number;\n            const WSAESHUTDOWN: number;\n            const WSAETOOMANYREFS: number;\n            const WSAETIMEDOUT: number;\n            const WSAECONNREFUSED: number;\n            const WSAELOOP: number;\n            const WSAENAMETOOLONG: number;\n            const WSAEHOSTDOWN: number;\n            const WSAEHOSTUNREACH: number;\n            const WSAENOTEMPTY: number;\n            const WSAEPROCLIM: number;\n            const WSAEUSERS: number;\n            const WSAEDQUOT: number;\n            const WSAESTALE: number;\n            const WSAEREMOTE: number;\n            const WSASYSNOTREADY: number;\n            const WSAVERNOTSUPPORTED: number;\n            const WSANOTINITIALISED: number;\n            const WSAEDISCON: number;\n            const WSAENOMORE: number;\n            const WSAECANCELLED: number;\n            const WSAEINVALIDPROCTABLE: number;\n            const WSAEINVALIDPROVIDER: number;\n            const WSAEPROVIDERFAILEDINIT: number;\n            const WSASYSCALLFAILURE: number;\n            const WSASERVICE_NOT_FOUND: number;\n            const WSATYPE_NOT_FOUND: number;\n            const WSA_E_NO_MORE: number;\n            const WSA_E_CANCELLED: number;\n            const WSAEREFUSED: number;\n        }\n        namespace priority {\n            const PRIORITY_LOW: number;\n            const PRIORITY_BELOW_NORMAL: number;\n            const PRIORITY_NORMAL: number;\n            const PRIORITY_ABOVE_NORMAL: number;\n            const PRIORITY_HIGH: number;\n            const PRIORITY_HIGHEST: number;\n        }\n    }\n\n    function arch(): string;\n    /**\n     * Returns a string identifying the kernel version.\n     * On POSIX systems, the operating system release is determined by calling\n     * [uname(3)][]. On Windows, `pRtlGetVersion` is used, and if it is not available,\n     * `GetVersionExW()` will be used. See\n     * https://en.wikipedia.org/wiki/Uname#Examples for more information.\n     */\n    function version(): string;\n    function platform(): NodeJS.Platform;\n    function tmpdir(): string;\n    const EOL: string;\n    function endianness(): \"BE\" | \"LE\";\n    /**\n     * Gets the priority of a process.\n     * Defaults to current process.\n     */\n    function getPriority(pid?: number): number;\n    /**\n     * Sets the priority of the current process.\n     * @param priority Must be in range of -20 to 19\n     */\n    function setPriority(priority: number): void;\n    /**\n     * Sets the priority of the process specified process.\n     * @param priority Must be in range of -20 to 19\n     */\n    function setPriority(pid: number, priority: number): void;\n}\n\n\ndeclare module \"path\" {\n    namespace path {\n        /**\n         * A parsed path object generated by path.parse() or consumed by path.format().\n         */\n        interface ParsedPath {\n            /**\n             * The root of the path such as '/' or 'c:\\'\n             */\n            root: string;\n            /**\n             * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'\n             */\n            dir: string;\n            /**\n             * The file name including extension (if any) such as 'index.html'\n             */\n            base: string;\n            /**\n             * The file extension (if any) such as '.html'\n             */\n            ext: string;\n            /**\n             * The file name without extension (if any) such as 'index'\n             */\n            name: string;\n        }\n\n        interface FormatInputPathObject {\n            /**\n             * The root of the path such as '/' or 'c:\\'\n             */\n            root?: string;\n            /**\n             * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'\n             */\n            dir?: string;\n            /**\n             * The file name including extension (if any) such as 'index.html'\n             */\n            base?: string;\n            /**\n             * The file extension (if any) such as '.html'\n             */\n            ext?: string;\n            /**\n             * The file name without extension (if any) such as 'index'\n             */\n            name?: string;\n        }\n\n        interface PlatformPath {\n            /**\n             * Normalize a string path, reducing '..' and '.' parts.\n             * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\n             *\n             * @param p string path to normalize.\n             */\n            normalize(p: string): string;\n            /**\n             * Join all arguments together and normalize the resulting path.\n             * Arguments must be strings. In v0.8, non-string arguments were silently ignored. In v0.10 and up, an exception is thrown.\n             *\n             * @param paths paths to join.\n             */\n            join(...paths: string[]): string;\n            /**\n             * The right-most parameter is considered {to}.  Other parameters are considered an array of {from}.\n             *\n             * Starting from leftmost {from} parameter, resolves {to} to an absolute path.\n             *\n             * If {to} isn't already absolute, {from} arguments are prepended in right to left order,\n             * until an absolute path is found. If after using all {from} paths still no absolute path is found,\n             * the current working directory is used as well. The resulting path is normalized,\n             * and trailing slashes are removed unless the path gets resolved to the root directory.\n             *\n             * @param pathSegments string paths to join.  Non-string arguments are ignored.\n             */\n            resolve(...pathSegments: string[]): string;\n            /**\n             * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.\n             *\n             * @param path path to test.\n             */\n            isAbsolute(p: string): boolean;\n            /**\n             * Solve the relative path from {from} to {to}.\n             * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.\n             */\n            relative(from: string, to: string): string;\n            /**\n             * Return the directory name of a path. Similar to the Unix dirname command.\n             *\n             * @param p the path to evaluate.\n             */\n            dirname(p: string): string;\n            /**\n             * Return the last portion of a path. Similar to the Unix basename command.\n             * Often used to extract the file name from a fully qualified path.\n             *\n             * @param p the path to evaluate.\n             * @param ext optionally, an extension to remove from the result.\n             */\n            basename(p: string, ext?: string): string;\n            /**\n             * Return the extension of the path, from the last '.' to end of string in the last portion of the path.\n             * If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string\n             *\n             * @param p the path to evaluate.\n             */\n            extname(p: string): string;\n            /**\n             * The platform-specific file separator. '\\\\' or '/'.\n             */\n            readonly sep: string;\n            /**\n             * The platform-specific file delimiter. ';' or ':'.\n             */\n            readonly delimiter: string;\n            /**\n             * Returns an object from a path string - the opposite of format().\n             *\n             * @param pathString path to evaluate.\n             */\n            parse(p: string): ParsedPath;\n            /**\n             * Returns a path string from an object - the opposite of parse().\n             *\n             * @param pathString path to evaluate.\n             */\n            format(pP: FormatInputPathObject): string;\n            /**\n             * On Windows systems only, returns an equivalent namespace-prefixed path for the given path.\n             * If path is not a string, path will be returned without modifications.\n             * This method is meaningful only on Windows system.\n             * On POSIX systems, the method is non-operational and always returns path without modifications.\n             */\n            toNamespacedPath(path: string): string;\n            /**\n             * Posix specific pathing.\n             * Same as parent object on posix.\n             */\n            readonly posix: PlatformPath;\n            /**\n             * Windows specific pathing.\n             * Same as parent object on windows\n             */\n            readonly win32: PlatformPath;\n        }\n    }\n    const path: path.PlatformPath;\n    export = path;\n}\n\n\ndeclare module 'perf_hooks' {\n    import { AsyncResource } from 'async_hooks';\n\n    type EntryType = 'node' | 'mark' | 'measure' | 'gc' | 'function' | 'http2' | 'http';\n\n    interface PerformanceEntry {\n        /**\n         * The total number of milliseconds elapsed for this entry.\n         * This value will not be meaningful for all Performance Entry types.\n         */\n        readonly duration: number;\n\n        /**\n         * The name of the performance entry.\n         */\n        readonly name: string;\n\n        /**\n         * The high resolution millisecond timestamp marking the starting time of the Performance Entry.\n         */\n        readonly startTime: number;\n\n        /**\n         * The type of the performance entry.\n         * Currently it may be one of: 'node', 'mark', 'measure', 'gc', or 'function'.\n         */\n        readonly entryType: EntryType;\n\n        /**\n         * When `performanceEntry.entryType` is equal to 'gc', `the performance.kind` property identifies\n         * the type of garbage collection operation that occurred.\n         * See perf_hooks.constants for valid values.\n         */\n        readonly kind?: number;\n\n        /**\n         * When `performanceEntry.entryType` is equal to 'gc', the `performance.flags`\n         * property contains additional information about garbage collection operation.\n         * See perf_hooks.constants for valid values.\n         */\n        readonly flags?: number;\n    }\n\n    interface PerformanceNodeTiming extends PerformanceEntry {\n        /**\n         * The high resolution millisecond timestamp at which the Node.js process completed bootstrap.\n         */\n        readonly bootstrapComplete: number;\n\n        /**\n         * The high resolution millisecond timestamp at which cluster processing ended.\n         */\n        readonly clusterSetupEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which cluster processing started.\n         */\n        readonly clusterSetupStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the Node.js event loop exited.\n         */\n        readonly loopExit: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the Node.js event loop started.\n         */\n        readonly loopStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which main module load ended.\n         */\n        readonly moduleLoadEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which main module load started.\n         */\n        readonly moduleLoadStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the Node.js process was initialized.\n         */\n        readonly nodeStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which preload module load ended.\n         */\n        readonly preloadModuleLoadEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which preload module load started.\n         */\n        readonly preloadModuleLoadStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which third_party_main processing ended.\n         */\n        readonly thirdPartyMainEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which third_party_main processing started.\n         */\n        readonly thirdPartyMainStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the V8 platform was initialized.\n         */\n        readonly v8Start: number;\n    }\n\n    interface Performance {\n        /**\n         * If name is not provided, removes all PerformanceFunction objects from the Performance Timeline.\n         * If name is provided, removes entries with name.\n         * @param name\n         */\n        clearFunctions(name?: string): void;\n\n        /**\n         * If name is not provided, removes all PerformanceMark objects from the Performance Timeline.\n         * If name is provided, removes only the named mark.\n         * @param name\n         */\n        clearMarks(name?: string): void;\n\n        /**\n         * If name is not provided, removes all PerformanceMeasure objects from the Performance Timeline.\n         * If name is provided, removes only objects whose performanceEntry.name matches name.\n         */\n        clearMeasures(name?: string): void;\n\n        /**\n         * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime.\n         * @return list of all PerformanceEntry objects\n         */\n        getEntries(): PerformanceEntry[];\n\n        /**\n         * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.name is equal to name, and optionally, whose performanceEntry.entryType is equal to type.\n         * @param name\n         * @param type\n         * @return list of all PerformanceEntry objects\n         */\n        getEntriesByName(name: string, type?: EntryType): PerformanceEntry[];\n\n        /**\n         * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.entryType is equal to type.\n         * @param type\n         * @return list of all PerformanceEntry objects\n         */\n        getEntriesByType(type: EntryType): PerformanceEntry[];\n\n        /**\n         * Creates a new PerformanceMark entry in the Performance Timeline.\n         * A PerformanceMark is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'mark',\n         * and whose performanceEntry.duration is always 0.\n         * Performance marks are used to mark specific significant moments in the Performance Timeline.\n         * @param name\n         */\n        mark(name?: string): void;\n\n        /**\n         * Creates a new PerformanceMeasure entry in the Performance Timeline.\n         * A PerformanceMeasure is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'measure',\n         * and whose performanceEntry.duration measures the number of milliseconds elapsed since startMark and endMark.\n         *\n         * The startMark argument may identify any existing PerformanceMark in the the Performance Timeline, or may identify\n         * any of the timestamp properties provided by the PerformanceNodeTiming class. If the named startMark does not exist,\n         * then startMark is set to timeOrigin by default.\n         *\n         * The endMark argument must identify any existing PerformanceMark in the the Performance Timeline or any of the timestamp\n         * properties provided by the PerformanceNodeTiming class. If the named endMark does not exist, an error will be thrown.\n         * @param name\n         * @param startMark\n         * @param endMark\n         */\n        measure(name: string, startMark: string, endMark: string): void;\n\n        /**\n         * An instance of the PerformanceNodeTiming class that provides performance metrics for specific Node.js operational milestones.\n         */\n        readonly nodeTiming: PerformanceNodeTiming;\n\n        /**\n         * @return the current high resolution millisecond timestamp\n         */\n        now(): number;\n\n        /**\n         * The timeOrigin specifies the high resolution millisecond timestamp from which all performance metric durations are measured.\n         */\n        readonly timeOrigin: number;\n\n        /**\n         * Wraps a function within a new function that measures the running time of the wrapped function.\n         * A PerformanceObserver must be subscribed to the 'function' event type in order for the timing details to be accessed.\n         * @param fn\n         */\n        timerify<T extends (...optionalParams: any[]) => any>(fn: T): T;\n    }\n\n    interface PerformanceObserverEntryList {\n        /**\n         * @return a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime.\n         */\n        getEntries(): PerformanceEntry[];\n\n        /**\n         * @return a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.name is equal to name, and optionally, whose performanceEntry.entryType is equal to type.\n         */\n        getEntriesByName(name: string, type?: EntryType): PerformanceEntry[];\n\n        /**\n         * @return Returns a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.entryType is equal to type.\n         */\n        getEntriesByType(type: EntryType): PerformanceEntry[];\n    }\n\n    type PerformanceObserverCallback = (list: PerformanceObserverEntryList, observer: PerformanceObserver) => void;\n\n    class PerformanceObserver extends AsyncResource {\n        constructor(callback: PerformanceObserverCallback);\n\n        /**\n         * Disconnects the PerformanceObserver instance from all notifications.\n         */\n        disconnect(): void;\n\n        /**\n         * Subscribes the PerformanceObserver instance to notifications of new PerformanceEntry instances identified by options.entryTypes.\n         * When options.buffered is false, the callback will be invoked once for every PerformanceEntry instance.\n         * Property buffered defaults to false.\n         * @param options\n         */\n        observe(options: { entryTypes: EntryType[]; buffered?: boolean }): void;\n    }\n\n    namespace constants {\n        const NODE_PERFORMANCE_GC_MAJOR: number;\n        const NODE_PERFORMANCE_GC_MINOR: number;\n        const NODE_PERFORMANCE_GC_INCREMENTAL: number;\n        const NODE_PERFORMANCE_GC_WEAKCB: number;\n\n        const NODE_PERFORMANCE_GC_FLAGS_NO: number;\n        const NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED: number;\n        const NODE_PERFORMANCE_GC_FLAGS_FORCED: number;\n        const NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING: number;\n        const NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE: number;\n        const NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY: number;\n        const NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE: number;\n    }\n\n    const performance: Performance;\n\n    interface EventLoopMonitorOptions {\n        /**\n         * The sampling rate in milliseconds.\n         * Must be greater than zero.\n         * @default 10\n         */\n        resolution?: number;\n    }\n\n    interface EventLoopDelayMonitor {\n        /**\n         * Enables the event loop delay sample timer. Returns `true` if the timer was started, `false` if it was already started.\n         */\n        enable(): boolean;\n        /**\n         * Disables the event loop delay sample timer. Returns `true` if the timer was stopped, `false` if it was already stopped.\n         */\n        disable(): boolean;\n\n        /**\n         * Resets the collected histogram data.\n         */\n        reset(): void;\n\n        /**\n         * Returns the value at the given percentile.\n         * @param percentile A percentile value between 1 and 100.\n         */\n        percentile(percentile: number): number;\n\n        /**\n         * A `Map` object detailing the accumulated percentile distribution.\n         */\n        readonly percentiles: Map<number, number>;\n\n        /**\n         * The number of times the event loop delay exceeded the maximum 1 hour eventloop delay threshold.\n         */\n        readonly exceeds: number;\n\n        /**\n         * The minimum recorded event loop delay.\n         */\n        readonly min: number;\n\n        /**\n         * The maximum recorded event loop delay.\n         */\n        readonly max: number;\n\n        /**\n         * The mean of the recorded event loop delays.\n         */\n        readonly mean: number;\n\n        /**\n         * The standard deviation of the recorded event loop delays.\n         */\n        readonly stddev: number;\n    }\n\n    function monitorEventLoopDelay(options?: EventLoopMonitorOptions): EventLoopDelayMonitor;\n}\n\n\ndeclare module \"process\" {\n    import * as tty from \"tty\";\n\n    global {\n        namespace NodeJS {\n            // this namespace merge is here because these are specifically used\n            // as the type for process.stdin, process.stdout, and process.stderr.\n            // they can't live in tty.d.ts because we need to disambiguate the imported name.\n            interface ReadStream extends tty.ReadStream {}\n            interface WriteStream extends tty.WriteStream {}\n        }\n    }\n\n    export = process;\n}\n\n\ndeclare module \"punycode\" {\n    function decode(string: string): string;\n    function encode(string: string): string;\n    function toUnicode(domain: string): string;\n    function toASCII(domain: string): string;\n    const ucs2: ucs2;\n    interface ucs2 {\n        decode(string: string): number[];\n        encode(codePoints: number[]): string;\n    }\n    const version: string;\n}\n\n\ndeclare module \"querystring\" {\n    interface StringifyOptions {\n        encodeURIComponent?: (str: string) => string;\n    }\n\n    interface ParseOptions {\n        maxKeys?: number;\n        decodeURIComponent?: (str: string) => string;\n    }\n\n    interface ParsedUrlQuery { [key: string]: string | string[]; }\n\n    interface ParsedUrlQueryInput {\n        [key: string]: string | number | boolean | string[] | number[] | boolean[] | undefined | null;\n    }\n\n    function stringify(obj?: ParsedUrlQueryInput, sep?: string, eq?: string, options?: StringifyOptions): string;\n    function parse(str: string, sep?: string, eq?: string, options?: ParseOptions): ParsedUrlQuery;\n    /**\n     * The querystring.encode() function is an alias for querystring.stringify().\n     */\n    const encode: typeof stringify;\n    /**\n     * The querystring.decode() function is an alias for querystring.parse().\n     */\n    const decode: typeof parse;\n    function escape(str: string): string;\n    function unescape(str: string): string;\n}\n\n\ndeclare module \"readline\" {\n    import * as events from \"events\";\n    import * as stream from \"stream\";\n\n    interface Key {\n        sequence?: string;\n        name?: string;\n        ctrl?: boolean;\n        meta?: boolean;\n        shift?: boolean;\n    }\n\n    class Interface extends events.EventEmitter {\n        readonly terminal: boolean;\n\n        // Need direct access to line/cursor data, for use in external processes\n        // see: https://github.com/nodejs/node/issues/30347\n        /** The current input data */\n        readonly line: string;\n        /** The current cursor position in the input line */\n        readonly cursor: number;\n\n        /**\n         * NOTE: According to the documentation:\n         *\n         * > Instances of the `readline.Interface` class are constructed using the\n         * > `readline.createInterface()` method.\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/readline.html#readline_class_interface\n         */\n        protected constructor(input: NodeJS.ReadableStream, output?: NodeJS.WritableStream, completer?: Completer | AsyncCompleter, terminal?: boolean);\n        /**\n         * NOTE: According to the documentation:\n         *\n         * > Instances of the `readline.Interface` class are constructed using the\n         * > `readline.createInterface()` method.\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/readline.html#readline_class_interface\n         */\n        protected constructor(options: ReadLineOptions);\n\n        setPrompt(prompt: string): void;\n        prompt(preserveCursor?: boolean): void;\n        question(query: string, callback: (answer: string) => void): void;\n        pause(): this;\n        resume(): this;\n        close(): void;\n        write(data: string | Buffer, key?: Key): void;\n\n        /**\n         * Returns the real position of the cursor in relation to the input\n         * prompt + string.  Long input (wrapping) strings, as well as multiple\n         * line prompts are included in the calculations.\n         */\n        getCursorPos(): CursorPos;\n\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. line\n         * 3. pause\n         * 4. resume\n         * 5. SIGCONT\n         * 6. SIGINT\n         * 7. SIGTSTP\n         */\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"line\", listener: (input: string) => void): this;\n        addListener(event: \"pause\", listener: () => void): this;\n        addListener(event: \"resume\", listener: () => void): this;\n        addListener(event: \"SIGCONT\", listener: () => void): this;\n        addListener(event: \"SIGINT\", listener: () => void): this;\n        addListener(event: \"SIGTSTP\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"line\", input: string): boolean;\n        emit(event: \"pause\"): boolean;\n        emit(event: \"resume\"): boolean;\n        emit(event: \"SIGCONT\"): boolean;\n        emit(event: \"SIGINT\"): boolean;\n        emit(event: \"SIGTSTP\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"line\", listener: (input: string) => void): this;\n        on(event: \"pause\", listener: () => void): this;\n        on(event: \"resume\", listener: () => void): this;\n        on(event: \"SIGCONT\", listener: () => void): this;\n        on(event: \"SIGINT\", listener: () => void): this;\n        on(event: \"SIGTSTP\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"line\", listener: (input: string) => void): this;\n        once(event: \"pause\", listener: () => void): this;\n        once(event: \"resume\", listener: () => void): this;\n        once(event: \"SIGCONT\", listener: () => void): this;\n        once(event: \"SIGINT\", listener: () => void): this;\n        once(event: \"SIGTSTP\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"line\", listener: (input: string) => void): this;\n        prependListener(event: \"pause\", listener: () => void): this;\n        prependListener(event: \"resume\", listener: () => void): this;\n        prependListener(event: \"SIGCONT\", listener: () => void): this;\n        prependListener(event: \"SIGINT\", listener: () => void): this;\n        prependListener(event: \"SIGTSTP\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"line\", listener: (input: string) => void): this;\n        prependOnceListener(event: \"pause\", listener: () => void): this;\n        prependOnceListener(event: \"resume\", listener: () => void): this;\n        prependOnceListener(event: \"SIGCONT\", listener: () => void): this;\n        prependOnceListener(event: \"SIGINT\", listener: () => void): this;\n        prependOnceListener(event: \"SIGTSTP\", listener: () => void): this;\n        [Symbol.asyncIterator](): AsyncIterableIterator<string>;\n    }\n\n    type ReadLine = Interface; // type forwarded for backwards compatiblity\n\n    type Completer = (line: string) => CompleterResult;\n    type AsyncCompleter = (line: string, callback: (err?: null | Error, result?: CompleterResult) => void) => any;\n\n    type CompleterResult = [string[], string];\n\n    interface ReadLineOptions {\n        input: NodeJS.ReadableStream;\n        output?: NodeJS.WritableStream;\n        completer?: Completer | AsyncCompleter;\n        terminal?: boolean;\n        historySize?: number;\n        prompt?: string;\n        crlfDelay?: number;\n        removeHistoryDuplicates?: boolean;\n        escapeCodeTimeout?: number;\n        tabSize?: number;\n    }\n\n    function createInterface(input: NodeJS.ReadableStream, output?: NodeJS.WritableStream, completer?: Completer | AsyncCompleter, terminal?: boolean): Interface;\n    function createInterface(options: ReadLineOptions): Interface;\n    function emitKeypressEvents(stream: NodeJS.ReadableStream, readlineInterface?: Interface): void;\n\n    type Direction = -1 | 0 | 1;\n\n    interface CursorPos {\n        rows: number;\n        cols: number;\n    }\n\n    /**\n     * Clears the current line of this WriteStream in a direction identified by `dir`.\n     */\n    function clearLine(stream: NodeJS.WritableStream, dir: Direction, callback?: () => void): boolean;\n    /**\n     * Clears this `WriteStream` from the current cursor down.\n     */\n    function clearScreenDown(stream: NodeJS.WritableStream, callback?: () => void): boolean;\n    /**\n     * Moves this WriteStream's cursor to the specified position.\n     */\n    function cursorTo(stream: NodeJS.WritableStream, x: number, y?: number, callback?: () => void): boolean;\n    /**\n     * Moves this WriteStream's cursor relative to its current position.\n     */\n    function moveCursor(stream: NodeJS.WritableStream, dx: number, dy: number, callback?: () => void): boolean;\n}\n\n\ndeclare module \"repl\" {\n    import { Interface, Completer, AsyncCompleter } from \"readline\";\n    import { Context } from \"vm\";\n    import { InspectOptions } from \"util\";\n\n    interface ReplOptions {\n        /**\n         * The input prompt to display.\n         * Default: `\"> \"`\n         */\n        prompt?: string;\n        /**\n         * The `Readable` stream from which REPL input will be read.\n         * Default: `process.stdin`\n         */\n        input?: NodeJS.ReadableStream;\n        /**\n         * The `Writable` stream to which REPL output will be written.\n         * Default: `process.stdout`\n         */\n        output?: NodeJS.WritableStream;\n        /**\n         * If `true`, specifies that the output should be treated as a TTY terminal, and have\n         * ANSI/VT100 escape codes written to it.\n         * Default: checking the value of the `isTTY` property on the output stream upon\n         * instantiation.\n         */\n        terminal?: boolean;\n        /**\n         * The function to be used when evaluating each given line of input.\n         * Default: an async wrapper for the JavaScript `eval()` function. An `eval` function can\n         * error with `repl.Recoverable` to indicate the input was incomplete and prompt for\n         * additional lines.\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_default_evaluation\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_custom_evaluation_functions\n         */\n        eval?: REPLEval;\n        /**\n         * Defines if the repl prints output previews or not.\n         * @default `true` Always `false` in case `terminal` is falsy.\n         */\n        preview?: boolean;\n        /**\n         * If `true`, specifies that the default `writer` function should include ANSI color\n         * styling to REPL output. If a custom `writer` function is provided then this has no\n         * effect.\n         * Default: the REPL instance's `terminal` value.\n         */\n        useColors?: boolean;\n        /**\n         * If `true`, specifies that the default evaluation function will use the JavaScript\n         * `global` as the context as opposed to creating a new separate context for the REPL\n         * instance. The node CLI REPL sets this value to `true`.\n         * Default: `false`.\n         */\n        useGlobal?: boolean;\n        /**\n         * If `true`, specifies that the default writer will not output the return value of a\n         * command if it evaluates to `undefined`.\n         * Default: `false`.\n         */\n        ignoreUndefined?: boolean;\n        /**\n         * The function to invoke to format the output of each command before writing to `output`.\n         * Default: a wrapper for `util.inspect`.\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_customizing_repl_output\n         */\n        writer?: REPLWriter;\n        /**\n         * An optional function used for custom Tab auto completion.\n         *\n         * @see https://nodejs.org/dist/latest-v11.x/docs/api/readline.html#readline_use_of_the_completer_function\n         */\n        completer?: Completer | AsyncCompleter;\n        /**\n         * A flag that specifies whether the default evaluator executes all JavaScript commands in\n         * strict mode or default (sloppy) mode.\n         * Accepted values are:\n         * - `repl.REPL_MODE_SLOPPY` - evaluates expressions in sloppy mode.\n         * - `repl.REPL_MODE_STRICT` - evaluates expressions in strict mode. This is equivalent to\n         *   prefacing every repl statement with `'use strict'`.\n         */\n        replMode?: typeof REPL_MODE_SLOPPY | typeof REPL_MODE_STRICT;\n        /**\n         * Stop evaluating the current piece of code when `SIGINT` is received, i.e. `Ctrl+C` is\n         * pressed. This cannot be used together with a custom `eval` function.\n         * Default: `false`.\n         */\n        breakEvalOnSigint?: boolean;\n    }\n\n    type REPLEval = (this: REPLServer, evalCmd: string, context: Context, file: string, cb: (err: Error | null, result: any) => void) => void;\n    type REPLWriter = (this: REPLServer, obj: any) => string;\n\n    /**\n     * This is the default \"writer\" value, if none is passed in the REPL options,\n     * and it can be overridden by custom print functions.\n     */\n    const writer: REPLWriter & { options: InspectOptions };\n\n    type REPLCommandAction = (this: REPLServer, text: string) => void;\n\n    interface REPLCommand {\n        /**\n         * Help text to be displayed when `.help` is entered.\n         */\n        help?: string;\n        /**\n         * The function to execute, optionally accepting a single string argument.\n         */\n        action: REPLCommandAction;\n    }\n\n    /**\n     * Provides a customizable Read-Eval-Print-Loop (REPL).\n     *\n     * Instances of `repl.REPLServer` will accept individual lines of user input, evaluate those\n     * according to a user-defined evaluation function, then output the result. Input and output\n     * may be from `stdin` and `stdout`, respectively, or may be connected to any Node.js `stream`.\n     *\n     * Instances of `repl.REPLServer` support automatic completion of inputs, simplistic Emacs-style\n     * line editing, multi-line inputs, ANSI-styled output, saving and restoring current REPL session\n     * state, error recovery, and customizable evaluation functions.\n     *\n     * Instances of `repl.REPLServer` are created using the `repl.start()` method and _should not_\n     * be created directly using the JavaScript `new` keyword.\n     *\n     * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_repl\n     */\n    class REPLServer extends Interface {\n        /**\n         * The `vm.Context` provided to the `eval` function to be used for JavaScript\n         * evaluation.\n         */\n        readonly context: Context;\n        /**\n         * The `Readable` stream from which REPL input will be read.\n         */\n        readonly inputStream: NodeJS.ReadableStream;\n        /**\n         * The `Writable` stream to which REPL output will be written.\n         */\n        readonly outputStream: NodeJS.WritableStream;\n        /**\n         * The commands registered via `replServer.defineCommand()`.\n         */\n        readonly commands: { readonly [name: string]: REPLCommand | undefined };\n        /**\n         * A value indicating whether the REPL is currently in \"editor mode\".\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_commands_and_special_keys\n         */\n        readonly editorMode: boolean;\n        /**\n         * A value indicating whether the `_` variable has been assigned.\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable\n         */\n        readonly underscoreAssigned: boolean;\n        /**\n         * The last evaluation result from the REPL (assigned to the `_` variable inside of the REPL).\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable\n         */\n        readonly last: any;\n        /**\n         * A value indicating whether the `_error` variable has been assigned.\n         *\n         * @since v9.8.0\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable\n         */\n        readonly underscoreErrAssigned: boolean;\n        /**\n         * The last error raised inside the REPL (assigned to the `_error` variable inside of the REPL).\n         *\n         * @since v9.8.0\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable\n         */\n        readonly lastError: any;\n        /**\n         * Specified in the REPL options, this is the function to be used when evaluating each\n         * given line of input. If not specified in the REPL options, this is an async wrapper\n         * for the JavaScript `eval()` function.\n         */\n        readonly eval: REPLEval;\n        /**\n         * Specified in the REPL options, this is a value indicating whether the default\n         * `writer` function should include ANSI color styling to REPL output.\n         */\n        readonly useColors: boolean;\n        /**\n         * Specified in the REPL options, this is a value indicating whether the default `eval`\n         * function will use the JavaScript `global` as the context as opposed to creating a new\n         * separate context for the REPL instance.\n         */\n        readonly useGlobal: boolean;\n        /**\n         * Specified in the REPL options, this is a value indicating whether the default `writer`\n         * function should output the result of a command if it evaluates to `undefined`.\n         */\n        readonly ignoreUndefined: boolean;\n        /**\n         * Specified in the REPL options, this is the function to invoke to format the output of\n         * each command before writing to `outputStream`. If not specified in the REPL options,\n         * this will be a wrapper for `util.inspect`.\n         */\n        readonly writer: REPLWriter;\n        /**\n         * Specified in the REPL options, this is the function to use for custom Tab auto-completion.\n         */\n        readonly completer: Completer | AsyncCompleter;\n        /**\n         * Specified in the REPL options, this is a flag that specifies whether the default `eval`\n         * function should execute all JavaScript commands in strict mode or default (sloppy) mode.\n         * Possible values are:\n         * - `repl.REPL_MODE_SLOPPY` - evaluates expressions in sloppy mode.\n         * - `repl.REPL_MODE_STRICT` - evaluates expressions in strict mode. This is equivalent to\n         *    prefacing every repl statement with `'use strict'`.\n         */\n        readonly replMode: typeof REPL_MODE_SLOPPY | typeof REPL_MODE_STRICT;\n\n        /**\n         * NOTE: According to the documentation:\n         *\n         * > Instances of `repl.REPLServer` are created using the `repl.start()` method and\n         * > _should not_ be created directly using the JavaScript `new` keyword.\n         *\n         * `REPLServer` cannot be subclassed due to implementation specifics in NodeJS.\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_class_replserver\n         */\n        private constructor();\n\n        /**\n         * Used to add new `.`-prefixed commands to the REPL instance. Such commands are invoked\n         * by typing a `.` followed by the `keyword`.\n         *\n         * @param keyword The command keyword (_without_ a leading `.` character).\n         * @param cmd The function to invoke when the command is processed.\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_replserver_definecommand_keyword_cmd\n         */\n        defineCommand(keyword: string, cmd: REPLCommandAction | REPLCommand): void;\n        /**\n         * Readies the REPL instance for input from the user, printing the configured `prompt` to a\n         * new line in the `output` and resuming the `input` to accept new input.\n         *\n         * When multi-line input is being entered, an ellipsis is printed rather than the 'prompt'.\n         *\n         * This method is primarily intended to be called from within the action function for\n         * commands registered using the `replServer.defineCommand()` method.\n         *\n         * @param preserveCursor When `true`, the cursor placement will not be reset to `0`.\n         */\n        displayPrompt(preserveCursor?: boolean): void;\n        /**\n         * Clears any command that has been buffered but not yet executed.\n         *\n         * This method is primarily intended to be called from within the action function for\n         * commands registered using the `replServer.defineCommand()` method.\n         *\n         * @since v9.0.0\n         */\n        clearBufferedCommand(): void;\n\n        /**\n         * Initializes a history log file for the REPL instance. When executing the\n         * Node.js binary and using the command line REPL, a history file is initialized\n         * by default. However, this is not the case when creating a REPL\n         * programmatically. Use this method to initialize a history log file when working\n         * with REPL instances programmatically.\n         * @param path The path to the history file\n         */\n        setupHistory(path: string, cb: (err: Error | null, repl: this) => void): void;\n\n        /**\n         * events.EventEmitter\n         * 1. close - inherited from `readline.Interface`\n         * 2. line - inherited from `readline.Interface`\n         * 3. pause - inherited from `readline.Interface`\n         * 4. resume - inherited from `readline.Interface`\n         * 5. SIGCONT - inherited from `readline.Interface`\n         * 6. SIGINT - inherited from `readline.Interface`\n         * 7. SIGTSTP - inherited from `readline.Interface`\n         * 8. exit\n         * 9. reset\n         */\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"line\", listener: (input: string) => void): this;\n        addListener(event: \"pause\", listener: () => void): this;\n        addListener(event: \"resume\", listener: () => void): this;\n        addListener(event: \"SIGCONT\", listener: () => void): this;\n        addListener(event: \"SIGINT\", listener: () => void): this;\n        addListener(event: \"SIGTSTP\", listener: () => void): this;\n        addListener(event: \"exit\", listener: () => void): this;\n        addListener(event: \"reset\", listener: (context: Context) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"line\", input: string): boolean;\n        emit(event: \"pause\"): boolean;\n        emit(event: \"resume\"): boolean;\n        emit(event: \"SIGCONT\"): boolean;\n        emit(event: \"SIGINT\"): boolean;\n        emit(event: \"SIGTSTP\"): boolean;\n        emit(event: \"exit\"): boolean;\n        emit(event: \"reset\", context: Context): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"line\", listener: (input: string) => void): this;\n        on(event: \"pause\", listener: () => void): this;\n        on(event: \"resume\", listener: () => void): this;\n        on(event: \"SIGCONT\", listener: () => void): this;\n        on(event: \"SIGINT\", listener: () => void): this;\n        on(event: \"SIGTSTP\", listener: () => void): this;\n        on(event: \"exit\", listener: () => void): this;\n        on(event: \"reset\", listener: (context: Context) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"line\", listener: (input: string) => void): this;\n        once(event: \"pause\", listener: () => void): this;\n        once(event: \"resume\", listener: () => void): this;\n        once(event: \"SIGCONT\", listener: () => void): this;\n        once(event: \"SIGINT\", listener: () => void): this;\n        once(event: \"SIGTSTP\", listener: () => void): this;\n        once(event: \"exit\", listener: () => void): this;\n        once(event: \"reset\", listener: (context: Context) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"line\", listener: (input: string) => void): this;\n        prependListener(event: \"pause\", listener: () => void): this;\n        prependListener(event: \"resume\", listener: () => void): this;\n        prependListener(event: \"SIGCONT\", listener: () => void): this;\n        prependListener(event: \"SIGINT\", listener: () => void): this;\n        prependListener(event: \"SIGTSTP\", listener: () => void): this;\n        prependListener(event: \"exit\", listener: () => void): this;\n        prependListener(event: \"reset\", listener: (context: Context) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"line\", listener: (input: string) => void): this;\n        prependOnceListener(event: \"pause\", listener: () => void): this;\n        prependOnceListener(event: \"resume\", listener: () => void): this;\n        prependOnceListener(event: \"SIGCONT\", listener: () => void): this;\n        prependOnceListener(event: \"SIGINT\", listener: () => void): this;\n        prependOnceListener(event: \"SIGTSTP\", listener: () => void): this;\n        prependOnceListener(event: \"exit\", listener: () => void): this;\n        prependOnceListener(event: \"reset\", listener: (context: Context) => void): this;\n    }\n\n    /**\n     * A flag passed in the REPL options. Evaluates expressions in sloppy mode.\n     */\n    const REPL_MODE_SLOPPY: unique symbol;\n\n    /**\n     * A flag passed in the REPL options. Evaluates expressions in strict mode.\n     * This is equivalent to prefacing every repl statement with `'use strict'`.\n     */\n    const REPL_MODE_STRICT: unique symbol;\n\n    /**\n     * Creates and starts a `repl.REPLServer` instance.\n     *\n     * @param options The options for the `REPLServer`. If `options` is a string, then it specifies\n     * the input prompt.\n     */\n    function start(options?: string | ReplOptions): REPLServer;\n\n    /**\n     * Indicates a recoverable error that a `REPLServer` can use to support multi-line input.\n     *\n     * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_recoverable_errors\n     */\n    class Recoverable extends SyntaxError {\n        err: Error;\n\n        constructor(err: Error);\n    }\n}\n\n\ndeclare module \"stream\" {\n    import * as events from \"events\";\n\n    class internal extends events.EventEmitter {\n        pipe<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }): T;\n    }\n\n    namespace internal {\n        class Stream extends internal {\n            constructor(opts?: ReadableOptions);\n        }\n\n        interface ReadableOptions {\n            highWaterMark?: number;\n            encoding?: string;\n            objectMode?: boolean;\n            read?(this: Readable, size: number): void;\n            destroy?(this: Readable, error: Error | null, callback: (error: Error | null) => void): void;\n            autoDestroy?: boolean;\n        }\n\n        class Readable extends Stream implements NodeJS.ReadableStream {\n            /**\n             * A utility method for creating Readable Streams out of iterators.\n             */\n            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;\n\n            readable: boolean;\n            readonly readableHighWaterMark: number;\n            readonly readableLength: number;\n            readonly readableObjectMode: boolean;\n            destroyed: boolean;\n            constructor(opts?: ReadableOptions);\n            _read(size: number): void;\n            read(size?: number): any;\n            setEncoding(encoding: string): this;\n            pause(): this;\n            resume(): this;\n            isPaused(): boolean;\n            unpipe(destination?: NodeJS.WritableStream): this;\n            unshift(chunk: any, encoding?: BufferEncoding): void;\n            wrap(oldStream: NodeJS.ReadableStream): this;\n            push(chunk: any, encoding?: string): boolean;\n            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;\n            destroy(error?: Error): void;\n\n            /**\n             * Event emitter\n             * The defined events on documents including:\n             * 1. close\n             * 2. data\n             * 3. end\n             * 4. error\n             * 5. pause\n             * 6. readable\n             * 7. resume\n             */\n            addListener(event: \"close\", listener: () => void): this;\n            addListener(event: \"data\", listener: (chunk: any) => void): this;\n            addListener(event: \"end\", listener: () => void): this;\n            addListener(event: \"error\", listener: (err: Error) => void): this;\n            addListener(event: \"pause\", listener: () => void): this;\n            addListener(event: \"readable\", listener: () => void): this;\n            addListener(event: \"resume\", listener: () => void): this;\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            emit(event: \"close\"): boolean;\n            emit(event: \"data\", chunk: any): boolean;\n            emit(event: \"end\"): boolean;\n            emit(event: \"error\", err: Error): boolean;\n            emit(event: \"pause\"): boolean;\n            emit(event: \"readable\"): boolean;\n            emit(event: \"resume\"): boolean;\n            emit(event: string | symbol, ...args: any[]): boolean;\n\n            on(event: \"close\", listener: () => void): this;\n            on(event: \"data\", listener: (chunk: any) => void): this;\n            on(event: \"end\", listener: () => void): this;\n            on(event: \"error\", listener: (err: Error) => void): this;\n            on(event: \"pause\", listener: () => void): this;\n            on(event: \"readable\", listener: () => void): this;\n            on(event: \"resume\", listener: () => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            once(event: \"close\", listener: () => void): this;\n            once(event: \"data\", listener: (chunk: any) => void): this;\n            once(event: \"end\", listener: () => void): this;\n            once(event: \"error\", listener: (err: Error) => void): this;\n            once(event: \"pause\", listener: () => void): this;\n            once(event: \"readable\", listener: () => void): this;\n            once(event: \"resume\", listener: () => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependListener(event: \"close\", listener: () => void): this;\n            prependListener(event: \"data\", listener: (chunk: any) => void): this;\n            prependListener(event: \"end\", listener: () => void): this;\n            prependListener(event: \"error\", listener: (err: Error) => void): this;\n            prependListener(event: \"pause\", listener: () => void): this;\n            prependListener(event: \"readable\", listener: () => void): this;\n            prependListener(event: \"resume\", listener: () => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependOnceListener(event: \"close\", listener: () => void): this;\n            prependOnceListener(event: \"data\", listener: (chunk: any) => void): this;\n            prependOnceListener(event: \"end\", listener: () => void): this;\n            prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n            prependOnceListener(event: \"pause\", listener: () => void): this;\n            prependOnceListener(event: \"readable\", listener: () => void): this;\n            prependOnceListener(event: \"resume\", listener: () => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            removeListener(event: \"close\", listener: () => void): this;\n            removeListener(event: \"data\", listener: (chunk: any) => void): this;\n            removeListener(event: \"end\", listener: () => void): this;\n            removeListener(event: \"error\", listener: (err: Error) => void): this;\n            removeListener(event: \"pause\", listener: () => void): this;\n            removeListener(event: \"readable\", listener: () => void): this;\n            removeListener(event: \"resume\", listener: () => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            [Symbol.asyncIterator](): AsyncIterableIterator<any>;\n        }\n\n        interface WritableOptions {\n            highWaterMark?: number;\n            decodeStrings?: boolean;\n            defaultEncoding?: string;\n            objectMode?: boolean;\n            emitClose?: boolean;\n            write?(this: Writable, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Writable, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            destroy?(this: Writable, error: Error | null, callback: (error: Error | null) => void): void;\n            final?(this: Writable, callback: (error?: Error | null) => void): void;\n            autoDestroy?: boolean;\n        }\n\n        class Writable extends Stream implements NodeJS.WritableStream {\n            readonly writable: boolean;\n            readonly writableEnded: boolean;\n            readonly writableFinished: boolean;\n            readonly writableHighWaterMark: number;\n            readonly writableLength: number;\n            readonly writableObjectMode: boolean;\n            readonly writableCorked: number;\n            destroyed: boolean;\n            constructor(opts?: WritableOptions);\n            _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            _writev?(chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;\n            _final(callback: (error?: Error | null) => void): void;\n            write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;\n            write(chunk: any, encoding: string, cb?: (error: Error | null | undefined) => void): boolean;\n            setDefaultEncoding(encoding: string): this;\n            end(cb?: () => void): void;\n            end(chunk: any, cb?: () => void): void;\n            end(chunk: any, encoding: string, cb?: () => void): void;\n            cork(): void;\n            uncork(): void;\n            destroy(error?: Error): void;\n\n            /**\n             * Event emitter\n             * The defined events on documents including:\n             * 1. close\n             * 2. drain\n             * 3. error\n             * 4. finish\n             * 5. pipe\n             * 6. unpipe\n             */\n            addListener(event: \"close\", listener: () => void): this;\n            addListener(event: \"drain\", listener: () => void): this;\n            addListener(event: \"error\", listener: (err: Error) => void): this;\n            addListener(event: \"finish\", listener: () => void): this;\n            addListener(event: \"pipe\", listener: (src: Readable) => void): this;\n            addListener(event: \"unpipe\", listener: (src: Readable) => void): this;\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            emit(event: \"close\"): boolean;\n            emit(event: \"drain\"): boolean;\n            emit(event: \"error\", err: Error): boolean;\n            emit(event: \"finish\"): boolean;\n            emit(event: \"pipe\", src: Readable): boolean;\n            emit(event: \"unpipe\", src: Readable): boolean;\n            emit(event: string | symbol, ...args: any[]): boolean;\n\n            on(event: \"close\", listener: () => void): this;\n            on(event: \"drain\", listener: () => void): this;\n            on(event: \"error\", listener: (err: Error) => void): this;\n            on(event: \"finish\", listener: () => void): this;\n            on(event: \"pipe\", listener: (src: Readable) => void): this;\n            on(event: \"unpipe\", listener: (src: Readable) => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            once(event: \"close\", listener: () => void): this;\n            once(event: \"drain\", listener: () => void): this;\n            once(event: \"error\", listener: (err: Error) => void): this;\n            once(event: \"finish\", listener: () => void): this;\n            once(event: \"pipe\", listener: (src: Readable) => void): this;\n            once(event: \"unpipe\", listener: (src: Readable) => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependListener(event: \"close\", listener: () => void): this;\n            prependListener(event: \"drain\", listener: () => void): this;\n            prependListener(event: \"error\", listener: (err: Error) => void): this;\n            prependListener(event: \"finish\", listener: () => void): this;\n            prependListener(event: \"pipe\", listener: (src: Readable) => void): this;\n            prependListener(event: \"unpipe\", listener: (src: Readable) => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependOnceListener(event: \"close\", listener: () => void): this;\n            prependOnceListener(event: \"drain\", listener: () => void): this;\n            prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n            prependOnceListener(event: \"finish\", listener: () => void): this;\n            prependOnceListener(event: \"pipe\", listener: (src: Readable) => void): this;\n            prependOnceListener(event: \"unpipe\", listener: (src: Readable) => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            removeListener(event: \"close\", listener: () => void): this;\n            removeListener(event: \"drain\", listener: () => void): this;\n            removeListener(event: \"error\", listener: (err: Error) => void): this;\n            removeListener(event: \"finish\", listener: () => void): this;\n            removeListener(event: \"pipe\", listener: (src: Readable) => void): this;\n            removeListener(event: \"unpipe\", listener: (src: Readable) => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        }\n\n        interface DuplexOptions extends ReadableOptions, WritableOptions {\n            allowHalfOpen?: boolean;\n            readableObjectMode?: boolean;\n            writableObjectMode?: boolean;\n            readableHighWaterMark?: number;\n            writableHighWaterMark?: number;\n            writableCorked?: number;\n            read?(this: Duplex, size: number): void;\n            write?(this: Duplex, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Duplex, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            final?(this: Duplex, callback: (error?: Error | null) => void): void;\n            destroy?(this: Duplex, error: Error | null, callback: (error: Error | null) => void): void;\n        }\n\n        // Note: Duplex extends both Readable and Writable.\n        class Duplex extends Readable implements Writable {\n            readonly writable: boolean;\n            readonly writableEnded: boolean;\n            readonly writableFinished: boolean;\n            readonly writableHighWaterMark: number;\n            readonly writableLength: number;\n            readonly writableObjectMode: boolean;\n            readonly writableCorked: number;\n            constructor(opts?: DuplexOptions);\n            _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            _writev?(chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            _destroy(error: Error | null, callback: (error: Error | null) => void): void;\n            _final(callback: (error?: Error | null) => void): void;\n            write(chunk: any, encoding?: string, cb?: (error: Error | null | undefined) => void): boolean;\n            write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;\n            setDefaultEncoding(encoding: string): this;\n            end(cb?: () => void): void;\n            end(chunk: any, cb?: () => void): void;\n            end(chunk: any, encoding?: string, cb?: () => void): void;\n            cork(): void;\n            uncork(): void;\n        }\n\n        type TransformCallback = (error?: Error | null, data?: any) => void;\n\n        interface TransformOptions extends DuplexOptions {\n            read?(this: Transform, size: number): void;\n            write?(this: Transform, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Transform, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            final?(this: Transform, callback: (error?: Error | null) => void): void;\n            destroy?(this: Transform, error: Error | null, callback: (error: Error | null) => void): void;\n            transform?(this: Transform, chunk: any, encoding: string, callback: TransformCallback): void;\n            flush?(this: Transform, callback: TransformCallback): void;\n        }\n\n        class Transform extends Duplex {\n            constructor(opts?: TransformOptions);\n            _transform(chunk: any, encoding: string, callback: TransformCallback): void;\n            _flush(callback: TransformCallback): void;\n        }\n\n        class PassThrough extends Transform { }\n\n        interface FinishedOptions {\n            error?: boolean;\n            readable?: boolean;\n            writable?: boolean;\n        }\n        function finished(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream, options: FinishedOptions, callback: (err?: NodeJS.ErrnoException | null) => void): () => void;\n        function finished(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream, callback: (err?: NodeJS.ErrnoException | null) => void): () => void;\n        namespace finished {\n            function __promisify__(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream, options?: FinishedOptions): Promise<void>;\n        }\n\n        function pipeline<T extends NodeJS.WritableStream>(stream1: NodeJS.ReadableStream, stream2: T, callback?: (err: NodeJS.ErrnoException | null) => void): T;\n        function pipeline<T extends NodeJS.WritableStream>(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: T, callback?: (err: NodeJS.ErrnoException | null) => void): T;\n        function pipeline<T extends NodeJS.WritableStream>(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream,\n            stream3: NodeJS.ReadWriteStream,\n            stream4: T,\n            callback?: (err: NodeJS.ErrnoException | null) => void,\n        ): T;\n        function pipeline<T extends NodeJS.WritableStream>(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream,\n            stream3: NodeJS.ReadWriteStream,\n            stream4: NodeJS.ReadWriteStream,\n            stream5: T,\n            callback?: (err: NodeJS.ErrnoException | null) => void,\n        ): T;\n        function pipeline(streams: Array<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>, callback?: (err: NodeJS.ErrnoException | null) => void): NodeJS.WritableStream;\n        function pipeline(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,\n            ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream | ((err: NodeJS.ErrnoException | null) => void)>,\n        ): NodeJS.WritableStream;\n        namespace pipeline {\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: NodeJS.ReadWriteStream, stream4: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(\n                stream1: NodeJS.ReadableStream,\n                stream2: NodeJS.ReadWriteStream,\n                stream3: NodeJS.ReadWriteStream,\n                stream4: NodeJS.ReadWriteStream,\n                stream5: NodeJS.WritableStream,\n            ): Promise<void>;\n            function __promisify__(streams: Array<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>): Promise<void>;\n            function __promisify__(\n                stream1: NodeJS.ReadableStream,\n                stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,\n                ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream>,\n            ): Promise<void>;\n        }\n\n        interface Pipe {\n            close(): void;\n            hasRef(): boolean;\n            ref(): void;\n            unref(): void;\n        }\n    }\n\n    export = internal;\n}\n\n\ndeclare module \"string_decoder\" {\n    class StringDecoder {\n        constructor(encoding?: string);\n        write(buffer: Buffer): string;\n        end(buffer?: Buffer): string;\n    }\n}\n\n\ndeclare module \"timers\" {\n    function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\n    namespace setTimeout {\n        function __promisify__(ms: number): Promise<void>;\n        function __promisify__<T>(ms: number, value: T): Promise<T>;\n    }\n    function clearTimeout(timeoutId: NodeJS.Timeout): void;\n    function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\n    function clearInterval(intervalId: NodeJS.Timeout): void;\n    function setImmediate(callback: (...args: any[]) => void, ...args: any[]): NodeJS.Immediate;\n    namespace setImmediate {\n        function __promisify__(): Promise<void>;\n        function __promisify__<T>(value: T): Promise<T>;\n    }\n    function clearImmediate(immediateId: NodeJS.Immediate): void;\n}\n\n\ndeclare module \"tls\" {\n    import * as crypto from \"crypto\";\n    import * as dns from \"dns\";\n    import * as net from \"net\";\n    import * as stream from \"stream\";\n\n    const CLIENT_RENEG_LIMIT: number;\n    const CLIENT_RENEG_WINDOW: number;\n\n    interface Certificate {\n        /**\n         * Country code.\n         */\n        C: string;\n        /**\n         * Street.\n         */\n        ST: string;\n        /**\n         * Locality.\n         */\n        L: string;\n        /**\n         * Organization.\n         */\n        O: string;\n        /**\n         * Organizational unit.\n         */\n        OU: string;\n        /**\n         * Common name.\n         */\n        CN: string;\n    }\n\n    interface PeerCertificate {\n        subject: Certificate;\n        issuer: Certificate;\n        subjectaltname: string;\n        infoAccess: { [index: string]: string[] | undefined };\n        modulus: string;\n        exponent: string;\n        valid_from: string;\n        valid_to: string;\n        fingerprint: string;\n        fingerprint256: string;\n        ext_key_usage: string[];\n        serialNumber: string;\n        raw: Buffer;\n    }\n\n    interface DetailedPeerCertificate extends PeerCertificate {\n        issuerCertificate: DetailedPeerCertificate;\n    }\n\n    interface CipherNameAndProtocol {\n        /**\n         * The cipher name.\n         */\n        name: string;\n        /**\n         * SSL/TLS protocol version.\n         */\n        version: string;\n\n        /**\n         * IETF name for the cipher suite.\n         */\n        standardName: string;\n    }\n\n    interface EphemeralKeyInfo {\n        /**\n         * The supported types are 'DH' and 'ECDH'.\n         */\n        type: string;\n        /**\n         * The name property is available only when type is 'ECDH'.\n         */\n        name?: string;\n        /**\n         * The size of parameter of an ephemeral key exchange.\n         */\n        size: number;\n    }\n\n    interface KeyObject {\n        /**\n         * Private keys in PEM format.\n         */\n        pem: string | Buffer;\n        /**\n         * Optional passphrase.\n         */\n        passphrase?: string;\n    }\n\n    interface PxfObject {\n        /**\n         * PFX or PKCS12 encoded private key and certificate chain.\n         */\n        buf: string | Buffer;\n        /**\n         * Optional passphrase.\n         */\n        passphrase?: string;\n    }\n\n    interface TLSSocketOptions extends SecureContextOptions, CommonConnectionOptions {\n        /**\n         * If true the TLS socket will be instantiated in server-mode.\n         * Defaults to false.\n         */\n        isServer?: boolean;\n        /**\n         * An optional net.Server instance.\n         */\n        server?: net.Server;\n\n        /**\n         * An optional Buffer instance containing a TLS session.\n         */\n        session?: Buffer;\n        /**\n         * If true, specifies that the OCSP status request extension will be\n         * added to the client hello and an 'OCSPResponse' event will be\n         * emitted on the socket before establishing a secure communication\n         */\n        requestOCSP?: boolean;\n    }\n\n    class TLSSocket extends net.Socket {\n        /**\n         * Construct a new tls.TLSSocket object from an existing TCP socket.\n         */\n        constructor(socket: net.Socket, options?: TLSSocketOptions);\n\n        /**\n         * A boolean that is true if the peer certificate was signed by one of the specified CAs, otherwise false.\n         */\n        authorized: boolean;\n        /**\n         * The reason why the peer's certificate has not been verified.\n         * This property becomes available only when tlsSocket.authorized === false.\n         */\n        authorizationError: Error;\n        /**\n         * Static boolean value, always true.\n         * May be used to distinguish TLS sockets from regular ones.\n         */\n        encrypted: boolean;\n\n        /**\n         * String containing the selected ALPN protocol.\n         * When ALPN has no selected protocol, tlsSocket.alpnProtocol equals false.\n         */\n        alpnProtocol?: string;\n\n        /**\n         * Returns an object representing the local certificate. The returned\n         * object has some properties corresponding to the fields of the\n         * certificate.\n         *\n         * See tls.TLSSocket.getPeerCertificate() for an example of the\n         * certificate structure.\n         *\n         * If there is no local certificate, an empty object will be returned.\n         * If the socket has been destroyed, null will be returned.\n         */\n        getCertificate(): PeerCertificate | object | null;\n        /**\n         * Returns an object representing the cipher name and the SSL/TLS protocol version of the current connection.\n         * @returns Returns an object representing the cipher name\n         * and the SSL/TLS protocol version of the current connection.\n         */\n        getCipher(): CipherNameAndProtocol;\n        /**\n         * Returns an object representing the type, name, and size of parameter\n         * of an ephemeral key exchange in Perfect Forward Secrecy on a client\n         * connection. It returns an empty object when the key exchange is not\n         * ephemeral. As this is only supported on a client socket; null is\n         * returned if called on a server socket. The supported types are 'DH'\n         * and 'ECDH'. The name property is available only when type is 'ECDH'.\n         *\n         * For example: { type: 'ECDH', name: 'prime256v1', size: 256 }.\n         */\n        getEphemeralKeyInfo(): EphemeralKeyInfo | object | null;\n        /**\n         * Returns the latest Finished message that has\n         * been sent to the socket as part of a SSL/TLS handshake, or undefined\n         * if no Finished message has been sent yet.\n         *\n         * As the Finished messages are message digests of the complete\n         * handshake (with a total of 192 bits for TLS 1.0 and more for SSL\n         * 3.0), they can be used for external authentication procedures when\n         * the authentication provided by SSL/TLS is not desired or is not\n         * enough.\n         *\n         * Corresponds to the SSL_get_finished routine in OpenSSL and may be\n         * used to implement the tls-unique channel binding from RFC 5929.\n         */\n        getFinished(): Buffer | undefined;\n        /**\n         * Returns an object representing the peer's certificate.\n         * The returned object has some properties corresponding to the field of the certificate.\n         * If detailed argument is true the full chain with issuer property will be returned,\n         * if false only the top certificate without issuer property.\n         * If the peer does not provide a certificate, it returns null or an empty object.\n         * @param detailed - If true; the full chain with issuer property will be returned.\n         * @returns An object representing the peer's certificate.\n         */\n        getPeerCertificate(detailed: true): DetailedPeerCertificate;\n        getPeerCertificate(detailed?: false): PeerCertificate;\n        getPeerCertificate(detailed?: boolean): PeerCertificate | DetailedPeerCertificate;\n        /**\n         * Returns the latest Finished message that is expected or has actually\n         * been received from the socket as part of a SSL/TLS handshake, or\n         * undefined if there is no Finished message so far.\n         *\n         * As the Finished messages are message digests of the complete\n         * handshake (with a total of 192 bits for TLS 1.0 and more for SSL\n         * 3.0), they can be used for external authentication procedures when\n         * the authentication provided by SSL/TLS is not desired or is not\n         * enough.\n         *\n         * Corresponds to the SSL_get_peer_finished routine in OpenSSL and may\n         * be used to implement the tls-unique channel binding from RFC 5929.\n         */\n        getPeerFinished(): Buffer | undefined;\n        /**\n         * Returns a string containing the negotiated SSL/TLS protocol version of the current connection.\n         * The value `'unknown'` will be returned for connected sockets that have not completed the handshaking process.\n         * The value `null` will be returned for server sockets or disconnected client sockets.\n         * See https://www.openssl.org/docs/man1.0.2/ssl/SSL_get_version.html for more information.\n         * @returns negotiated SSL/TLS protocol version of the current connection\n         */\n        getProtocol(): string | null;\n        /**\n         * Could be used to speed up handshake establishment when reconnecting to the server.\n         * @returns ASN.1 encoded TLS session or undefined if none was negotiated.\n         */\n        getSession(): Buffer | undefined;\n        /**\n         * Returns a list of signature algorithms shared between the server and\n         * the client in the order of decreasing preference.\n         */\n        getSharedSigalgs(): string[];\n        /**\n         * NOTE: Works only with client TLS sockets.\n         * Useful only for debugging, for session reuse provide session option to tls.connect().\n         * @returns TLS session ticket or undefined if none was negotiated.\n         */\n        getTLSTicket(): Buffer | undefined;\n        /**\n         * Returns true if the session was reused, false otherwise.\n         */\n        isSessionReused(): boolean;\n        /**\n         * Initiate TLS renegotiation process.\n         *\n         * NOTE: Can be used to request peer's certificate after the secure connection has been established.\n         * ANOTHER NOTE: When running as the server, socket will be destroyed with an error after handshakeTimeout timeout.\n         * @param options - The options may contain the following fields: rejectUnauthorized,\n         * requestCert (See tls.createServer() for details).\n         * @param callback - callback(err) will be executed with null as err, once the renegotiation\n         * is successfully completed.\n         * @return `undefined` when socket is destroy, `false` if negotiaion can't be initiated.\n         */\n        renegotiate(options: { rejectUnauthorized?: boolean, requestCert?: boolean }, callback: (err: Error | null) => void): undefined | boolean;\n        /**\n         * Set maximum TLS fragment size (default and maximum value is: 16384, minimum is: 512).\n         * Smaller fragment size decreases buffering latency on the client: large fragments are buffered by\n         * the TLS layer until the entire fragment is received and its integrity is verified;\n         * large fragments can span multiple roundtrips, and their processing can be delayed due to packet\n         * loss or reordering. However, smaller fragments add extra TLS framing bytes and CPU overhead,\n         * which may decrease overall server throughput.\n         * @param size - TLS fragment size (default and maximum value is: 16384, minimum is: 512).\n         * @returns Returns true on success, false otherwise.\n         */\n        setMaxSendFragment(size: number): boolean;\n\n        /**\n         * Disables TLS renegotiation for this TLSSocket instance. Once called,\n         * attempts to renegotiate will trigger an 'error' event on the\n         * TLSSocket.\n         */\n        disableRenegotiation(): void;\n\n        /**\n         * When enabled, TLS packet trace information is written to `stderr`. This can be\n         * used to debug TLS connection problems.\n         *\n         * Note: The format of the output is identical to the output of `openssl s_client\n         * -trace` or `openssl s_server -trace`. While it is produced by OpenSSL's\n         * `SSL_trace()` function, the format is undocumented, can change without notice,\n         * and should not be relied on.\n         */\n        enableTrace(): void;\n\n        /**\n         * @param length number of bytes to retrieve from keying material\n         * @param label an application specific label, typically this will be a value from the\n         * [IANA Exporter Label Registry](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#exporter-labels).\n         * @param context optionally provide a context.\n         */\n        exportKeyingMaterial(length: number, label: string, context: Buffer): Buffer;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        addListener(event: \"secureConnect\", listener: () => void): this;\n        addListener(event: \"session\", listener: (session: Buffer) => void): this;\n        addListener(event: \"keylog\", listener: (line: Buffer) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"OCSPResponse\", response: Buffer): boolean;\n        emit(event: \"secureConnect\"): boolean;\n        emit(event: \"session\", session: Buffer): boolean;\n        emit(event: \"keylog\", line: Buffer): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        on(event: \"secureConnect\", listener: () => void): this;\n        on(event: \"session\", listener: (session: Buffer) => void): this;\n        on(event: \"keylog\", listener: (line: Buffer) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        once(event: \"secureConnect\", listener: () => void): this;\n        once(event: \"session\", listener: (session: Buffer) => void): this;\n        once(event: \"keylog\", listener: (line: Buffer) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        prependListener(event: \"secureConnect\", listener: () => void): this;\n        prependListener(event: \"session\", listener: (session: Buffer) => void): this;\n        prependListener(event: \"keylog\", listener: (line: Buffer) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        prependOnceListener(event: \"secureConnect\", listener: () => void): this;\n        prependOnceListener(event: \"session\", listener: (session: Buffer) => void): this;\n        prependOnceListener(event: \"keylog\", listener: (line: Buffer) => void): this;\n    }\n\n    interface CommonConnectionOptions {\n        /**\n         * An optional TLS context object from tls.createSecureContext()\n         */\n        secureContext?: SecureContext;\n\n        /**\n         * When enabled, TLS packet trace information is written to `stderr`. This can be\n         * used to debug TLS connection problems.\n         * @default false\n         */\n        enableTrace?: boolean;\n        /**\n         * If true the server will request a certificate from clients that\n         * connect and attempt to verify that certificate. Defaults to\n         * false.\n         */\n        requestCert?: boolean;\n        /**\n         * An array of strings or a Buffer naming possible ALPN protocols.\n         * (Protocols should be ordered by their priority.)\n         */\n        ALPNProtocols?: string[] | Uint8Array[] | Uint8Array;\n        /**\n         * SNICallback(servername, cb) <Function> A function that will be\n         * called if the client supports SNI TLS extension. Two arguments\n         * will be passed when called: servername and cb. SNICallback should\n         * invoke cb(null, ctx), where ctx is a SecureContext instance.\n         * (tls.createSecureContext(...) can be used to get a proper\n         * SecureContext.) If SNICallback wasn't provided the default callback\n         * with high-level API will be used (see below).\n         */\n        SNICallback?: (servername: string, cb: (err: Error | null, ctx: SecureContext) => void) => void;\n        /**\n         * If true the server will reject any connection which is not\n         * authorized with the list of supplied CAs. This option only has an\n         * effect if requestCert is true.\n         * @default true\n         */\n        rejectUnauthorized?: boolean;\n    }\n\n    interface TlsOptions extends SecureContextOptions, CommonConnectionOptions {\n        /**\n         * Abort the connection if the SSL/TLS handshake does not finish in the\n         * specified number of milliseconds. A 'tlsClientError' is emitted on\n         * the tls.Server object whenever a handshake times out. Default:\n         * 120000 (120 seconds).\n         */\n        handshakeTimeout?: number;\n        /**\n         * The number of seconds after which a TLS session created by the\n         * server will no longer be resumable. See Session Resumption for more\n         * information. Default: 300.\n         */\n        sessionTimeout?: number;\n        /**\n         * 48-bytes of cryptographically strong pseudo-random data.\n         */\n        ticketKeys?: Buffer;\n\n        /**\n         *\n         * @param socket\n         * @param identity identity parameter sent from the client.\n         * @return pre-shared key that must either be\n         * a buffer or `null` to stop the negotiation process. Returned PSK must be\n         * compatible with the selected cipher's digest.\n         *\n         * When negotiating TLS-PSK (pre-shared keys), this function is called\n         * with the identity provided by the client.\n         * If the return value is `null` the negotiation process will stop and an\n         * \"unknown_psk_identity\" alert message will be sent to the other party.\n         * If the server wishes to hide the fact that the PSK identity was not known,\n         * the callback must provide some random data as `psk` to make the connection\n         * fail with \"decrypt_error\" before negotiation is finished.\n         * PSK ciphers are disabled by default, and using TLS-PSK thus\n         * requires explicitly specifying a cipher suite with the `ciphers` option.\n         * More information can be found in the RFC 4279.\n         */\n\n        pskCallback?(socket: TLSSocket, identity: string): DataView | NodeJS.TypedArray | null;\n        /**\n         * hint to send to a client to help\n         * with selecting the identity during TLS-PSK negotiation. Will be ignored\n         * in TLS 1.3. Upon failing to set pskIdentityHint `tlsClientError` will be\n         * emitted with `ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED` code.\n         */\n        pskIdentityHint?: string;\n    }\n\n    interface PSKCallbackNegotation {\n        psk: DataView | NodeJS.TypedArray;\n        identitty: string;\n    }\n\n    interface ConnectionOptions extends SecureContextOptions, CommonConnectionOptions {\n        host?: string;\n        port?: number;\n        path?: string; // Creates unix socket connection to path. If this option is specified, `host` and `port` are ignored.\n        socket?: net.Socket; // Establish secure connection on a given socket rather than creating a new socket\n        checkServerIdentity?: typeof checkServerIdentity;\n        servername?: string; // SNI TLS Extension\n        session?: Buffer;\n        minDHSize?: number;\n        lookup?: net.LookupFunction;\n        timeout?: number;\n        /**\n         * When negotiating TLS-PSK (pre-shared keys), this function is called\n         * with optional identity `hint` provided by the server or `null`\n         * in case of TLS 1.3 where `hint` was removed.\n         * It will be necessary to provide a custom `tls.checkServerIdentity()`\n         * for the connection as the default one will try to check hostname/IP\n         * of the server against the certificate but that's not applicable for PSK\n         * because there won't be a certificate present.\n         * More information can be found in the RFC 4279.\n         *\n         * @param hint message sent from the server to help client\n         * decide which identity to use during negotiation.\n         * Always `null` if TLS 1.3 is used.\n         * @returns Return `null` to stop the negotiation process. `psk` must be\n         * compatible with the selected cipher's digest.\n         * `identity` must use UTF-8 encoding.\n         */\n        pskCallback?(hint: string | null): PSKCallbackNegotation | null;\n    }\n\n    class Server extends net.Server {\n        /**\n         * The server.addContext() method adds a secure context that will be\n         * used if the client request's SNI name matches the supplied hostname\n         * (or wildcard).\n         */\n        addContext(hostName: string, credentials: SecureContextOptions): void;\n        /**\n         * Returns the session ticket keys.\n         */\n        getTicketKeys(): Buffer;\n        /**\n         *\n         * The server.setSecureContext() method replaces the\n         * secure context of an existing server. Existing connections to the\n         * server are not interrupted.\n         */\n        setSecureContext(details: SecureContextOptions): void;\n        /**\n         * The server.setSecureContext() method replaces the secure context of\n         * an existing server. Existing connections to the server are not\n         * interrupted.\n         */\n        setTicketKeys(keys: Buffer): void;\n\n        /**\n         * events.EventEmitter\n         * 1. tlsClientError\n         * 2. newSession\n         * 3. OCSPRequest\n         * 4. resumeSession\n         * 5. secureConnection\n         * 6. keylog\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        addListener(event: \"newSession\", listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void): this;\n        addListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;\n        addListener(event: \"resumeSession\", listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void): this;\n        addListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n        addListener(event: \"keylog\", listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"tlsClientError\", err: Error, tlsSocket: TLSSocket): boolean;\n        emit(event: \"newSession\", sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void): boolean;\n        emit(event: \"OCSPRequest\", certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void): boolean;\n        emit(event: \"resumeSession\", sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void): boolean;\n        emit(event: \"secureConnection\", tlsSocket: TLSSocket): boolean;\n        emit(event: \"keylog\", line: Buffer, tlsSocket: TLSSocket): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        on(event: \"newSession\", listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void): this;\n        on(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;\n        on(event: \"resumeSession\", listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void): this;\n        on(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n        on(event: \"keylog\", listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        once(event: \"newSession\", listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void): this;\n        once(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;\n        once(event: \"resumeSession\", listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void): this;\n        once(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n        once(event: \"keylog\", listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        prependListener(event: \"newSession\", listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void): this;\n        prependListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;\n        prependListener(event: \"resumeSession\", listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void): this;\n        prependListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n        prependListener(event: \"keylog\", listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        prependOnceListener(event: \"newSession\", listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void): this;\n        prependOnceListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;\n        prependOnceListener(event: \"resumeSession\", listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void): this;\n        prependOnceListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n        prependOnceListener(event: \"keylog\", listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;\n    }\n\n    interface SecurePair {\n        encrypted: TLSSocket;\n        cleartext: TLSSocket;\n    }\n\n    type SecureVersion = 'TLSv1.3' | 'TLSv1.2' | 'TLSv1.1' | 'TLSv1';\n\n    interface SecureContextOptions {\n        /**\n         * Optionally override the trusted CA certificates. Default is to trust\n         * the well-known CAs curated by Mozilla. Mozilla's CAs are completely\n         * replaced when CAs are explicitly specified using this option.\n         */\n        ca?: string | Buffer | Array<string | Buffer>;\n        /**\n         *  Cert chains in PEM format. One cert chain should be provided per\n         *  private key. Each cert chain should consist of the PEM formatted\n         *  certificate for a provided private key, followed by the PEM\n         *  formatted intermediate certificates (if any), in order, and not\n         *  including the root CA (the root CA must be pre-known to the peer,\n         *  see ca). When providing multiple cert chains, they do not have to\n         *  be in the same order as their private keys in key. If the\n         *  intermediate certificates are not provided, the peer will not be\n         *  able to validate the certificate, and the handshake will fail.\n         */\n        cert?: string | Buffer | Array<string | Buffer>;\n        /**\n         *  Colon-separated list of supported signature algorithms. The list\n         *  can contain digest algorithms (SHA256, MD5 etc.), public key\n         *  algorithms (RSA-PSS, ECDSA etc.), combination of both (e.g\n         *  'RSA+SHA384') or TLS v1.3 scheme names (e.g. rsa_pss_pss_sha512).\n         */\n        sigalgs?: string;\n        /**\n         * Cipher suite specification, replacing the default. For more\n         * information, see modifying the default cipher suite. Permitted\n         * ciphers can be obtained via tls.getCiphers(). Cipher names must be\n         * uppercased in order for OpenSSL to accept them.\n         */\n        ciphers?: string;\n        /**\n         * Name of an OpenSSL engine which can provide the client certificate.\n         */\n        clientCertEngine?: string;\n        /**\n         * PEM formatted CRLs (Certificate Revocation Lists).\n         */\n        crl?: string | Buffer | Array<string | Buffer>;\n        /**\n         * Diffie Hellman parameters, required for Perfect Forward Secrecy. Use\n         * openssl dhparam to create the parameters. The key length must be\n         * greater than or equal to 1024 bits or else an error will be thrown.\n         * Although 1024 bits is permissible, use 2048 bits or larger for\n         * stronger security. If omitted or invalid, the parameters are\n         * silently discarded and DHE ciphers will not be available.\n         */\n        dhparam?: string | Buffer;\n        /**\n         * A string describing a named curve or a colon separated list of curve\n         * NIDs or names, for example P-521:P-384:P-256, to use for ECDH key\n         * agreement. Set to auto to select the curve automatically. Use\n         * crypto.getCurves() to obtain a list of available curve names. On\n         * recent releases, openssl ecparam -list_curves will also display the\n         * name and description of each available elliptic curve. Default:\n         * tls.DEFAULT_ECDH_CURVE.\n         */\n        ecdhCurve?: string;\n        /**\n         * Attempt to use the server's cipher suite preferences instead of the\n         * client's. When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be\n         * set in secureOptions\n         */\n        honorCipherOrder?: boolean;\n        /**\n         * Private keys in PEM format. PEM allows the option of private keys\n         * being encrypted. Encrypted keys will be decrypted with\n         * options.passphrase. Multiple keys using different algorithms can be\n         * provided either as an array of unencrypted key strings or buffers,\n         * or an array of objects in the form {pem: <string|buffer>[,\n         * passphrase: <string>]}. The object form can only occur in an array.\n         * object.passphrase is optional. Encrypted keys will be decrypted with\n         * object.passphrase if provided, or options.passphrase if it is not.\n         */\n        key?: string | Buffer | Array<Buffer | KeyObject>;\n        /**\n         * Name of an OpenSSL engine to get private key from. Should be used\n         * together with privateKeyIdentifier.\n         */\n        privateKeyEngine?: string;\n        /**\n         * Identifier of a private key managed by an OpenSSL engine. Should be\n         * used together with privateKeyEngine. Should not be set together with\n         * key, because both options define a private key in different ways.\n         */\n        privateKeyIdentifier?: string;\n        /**\n         * Optionally set the maximum TLS version to allow. One\n         * of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the\n         * `secureProtocol` option, use one or the other.\n         * **Default:** `'TLSv1.3'`, unless changed using CLI options. Using\n         * `--tls-max-v1.2` sets the default to `'TLSv1.2'`. Using `--tls-max-v1.3` sets the default to\n         * `'TLSv1.3'`. If multiple of the options are provided, the highest maximum is used.\n         */\n        maxVersion?: SecureVersion;\n        /**\n         * Optionally set the minimum TLS version to allow. One\n         * of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the\n         * `secureProtocol` option, use one or the other.  It is not recommended to use\n         * less than TLSv1.2, but it may be required for interoperability.\n         * **Default:** `'TLSv1.2'`, unless changed using CLI options. Using\n         * `--tls-v1.0` sets the default to `'TLSv1'`. Using `--tls-v1.1` sets the default to\n         * `'TLSv1.1'`. Using `--tls-min-v1.3` sets the default to\n         * 'TLSv1.3'. If multiple of the options are provided, the lowest minimum is used.\n         */\n        minVersion?: SecureVersion;\n        /**\n         * Shared passphrase used for a single private key and/or a PFX.\n         */\n        passphrase?: string;\n        /**\n         * PFX or PKCS12 encoded private key and certificate chain. pfx is an\n         * alternative to providing key and cert individually. PFX is usually\n         * encrypted, if it is, passphrase will be used to decrypt it. Multiple\n         * PFX can be provided either as an array of unencrypted PFX buffers,\n         * or an array of objects in the form {buf: <string|buffer>[,\n         * passphrase: <string>]}. The object form can only occur in an array.\n         * object.passphrase is optional. Encrypted PFX will be decrypted with\n         * object.passphrase if provided, or options.passphrase if it is not.\n         */\n        pfx?: string | Buffer | Array<string | Buffer | PxfObject>;\n        /**\n         * Optionally affect the OpenSSL protocol behavior, which is not\n         * usually necessary. This should be used carefully if at all! Value is\n         * a numeric bitmask of the SSL_OP_* options from OpenSSL Options\n         */\n        secureOptions?: number; // Value is a numeric bitmask of the `SSL_OP_*` options\n        /**\n         * Legacy mechanism to select the TLS protocol version to use, it does\n         * not support independent control of the minimum and maximum version,\n         * and does not support limiting the protocol to TLSv1.3. Use\n         * minVersion and maxVersion instead. The possible values are listed as\n         * SSL_METHODS, use the function names as strings. For example, use\n         * 'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow\n         * any TLS protocol version up to TLSv1.3. It is not recommended to use\n         * TLS versions less than 1.2, but it may be required for\n         * interoperability. Default: none, see minVersion.\n         */\n        secureProtocol?: string;\n        /**\n         * Opaque identifier used by servers to ensure session state is not\n         * shared between applications. Unused by clients.\n         */\n        sessionIdContext?: string;\n    }\n\n    interface SecureContext {\n        context: any;\n    }\n\n    /*\n     * Verifies the certificate `cert` is issued to host `host`.\n     * @host The hostname to verify the certificate against\n     * @cert PeerCertificate representing the peer's certificate\n     *\n     * Returns Error object, populating it with the reason, host and cert on failure.  On success, returns undefined.\n     */\n    function checkServerIdentity(host: string, cert: PeerCertificate): Error | undefined;\n    function createServer(secureConnectionListener?: (socket: TLSSocket) => void): Server;\n    function createServer(options: TlsOptions, secureConnectionListener?: (socket: TLSSocket) => void): Server;\n    function connect(options: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n    function connect(port: number, host?: string, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n    function connect(port: number, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n    /**\n     * @deprecated\n     */\n    function createSecurePair(credentials?: SecureContext, isServer?: boolean, requestCert?: boolean, rejectUnauthorized?: boolean): SecurePair;\n    function createSecureContext(details: SecureContextOptions): SecureContext;\n    function getCiphers(): string[];\n\n    /**\n     * The default curve name to use for ECDH key agreement in a tls server.\n     * The default value is 'auto'. See tls.createSecureContext() for further\n     * information.\n     */\n    let DEFAULT_ECDH_CURVE: string;\n    /**\n     * The default value of the maxVersion option of\n     * tls.createSecureContext(). It can be assigned any of the supported TLS\n     * protocol versions, 'TLSv1.3', 'TLSv1.2', 'TLSv1.1', or 'TLSv1'. Default:\n     * 'TLSv1.3', unless changed using CLI options. Using --tls-max-v1.2 sets\n     * the default to 'TLSv1.2'. Using --tls-max-v1.3 sets the default to\n     * 'TLSv1.3'. If multiple of the options are provided, the highest maximum\n     * is used.\n     */\n    let DEFAULT_MAX_VERSION: SecureVersion;\n    /**\n     * The default value of the minVersion option of tls.createSecureContext().\n     * It can be assigned any of the supported TLS protocol versions,\n     * 'TLSv1.3', 'TLSv1.2', 'TLSv1.1', or 'TLSv1'. Default: 'TLSv1.2', unless\n     * changed using CLI options. Using --tls-min-v1.0 sets the default to\n     * 'TLSv1'. Using --tls-min-v1.1 sets the default to 'TLSv1.1'. Using\n     * --tls-min-v1.3 sets the default to 'TLSv1.3'. If multiple of the options\n     * are provided, the lowest minimum is used.\n     */\n    let DEFAULT_MIN_VERSION: SecureVersion;\n\n    /**\n     * An immutable array of strings representing the root certificates (in PEM\n     * format) used for verifying peer certificates. This is the default value\n     * of the ca option to tls.createSecureContext().\n     */\n    const rootCertificates: ReadonlyArray<string>;\n}\n\n\ndeclare module \"trace_events\" {\n    /**\n     * The `Tracing` object is used to enable or disable tracing for sets of\n     * categories. Instances are created using the\n     * `trace_events.createTracing()` method.\n     *\n     * When created, the `Tracing` object is disabled. Calling the\n     * `tracing.enable()` method adds the categories to the set of enabled trace\n     * event categories. Calling `tracing.disable()` will remove the categories\n     * from the set of enabled trace event categories.\n     */\n    interface Tracing {\n        /**\n         * A comma-separated list of the trace event categories covered by this\n         * `Tracing` object.\n         */\n        readonly categories: string;\n\n        /**\n         * Disables this `Tracing` object.\n         *\n         * Only trace event categories _not_ covered by other enabled `Tracing`\n         * objects and _not_ specified by the `--trace-event-categories` flag\n         * will be disabled.\n         */\n        disable(): void;\n\n        /**\n         * Enables this `Tracing` object for the set of categories covered by\n         * the `Tracing` object.\n         */\n        enable(): void;\n\n        /**\n         * `true` only if the `Tracing` object has been enabled.\n         */\n        readonly enabled: boolean;\n    }\n\n    interface CreateTracingOptions {\n        /**\n         * An array of trace category names. Values included in the array are\n         * coerced to a string when possible. An error will be thrown if the\n         * value cannot be coerced.\n         */\n        categories: string[];\n    }\n\n    /**\n     * Creates and returns a Tracing object for the given set of categories.\n     */\n    function createTracing(options: CreateTracingOptions): Tracing;\n\n    /**\n     * Returns a comma-separated list of all currently-enabled trace event\n     * categories. The current set of enabled trace event categories is\n     * determined by the union of all currently-enabled `Tracing` objects and\n     * any categories enabled using the `--trace-event-categories` flag.\n     */\n    function getEnabledCategories(): string | undefined;\n}\n\n\n// tslint:disable-next-line:no-bad-reference\n/// <reference path=\"../fs.d.ts\" />\n\ndeclare module 'fs' {\n    interface BigIntStats extends StatsBase<bigint> {\n    }\n\n    class BigIntStats {\n        atimeNs: bigint;\n        mtimeNs: bigint;\n        ctimeNs: bigint;\n        birthtimeNs: bigint;\n    }\n\n    interface BigIntOptions {\n        bigint: true;\n    }\n\n    interface StatOptions {\n        bigint: boolean;\n    }\n\n    function stat(path: PathLike, options: BigIntOptions, callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void): void;\n    function stat(path: PathLike, options: StatOptions, callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void): void;\n\n    namespace stat {\n        function __promisify__(path: PathLike, options: BigIntOptions): Promise<BigIntStats>;\n        function __promisify__(path: PathLike, options: StatOptions): Promise<Stats | BigIntStats>;\n    }\n\n    function statSync(path: PathLike, options: BigIntOptions): BigIntStats;\n    function statSync(path: PathLike, options: StatOptions): Stats | BigIntStats;\n}\n\n\n// tslint:disable-next-line:no-bad-reference\n/// <reference path=\"../globals.d.ts\" />\n\ndeclare namespace NodeJS {\n    interface HRTime {\n        bigint(): bigint;\n    }\n}\n\ninterface Buffer extends Uint8Array {\n    readBigUInt64BE(offset?: number): bigint;\n    readBigUInt64LE(offset?: number): bigint;\n    readBigInt64BE(offset?: number): bigint;\n    readBigInt64LE(offset?: number): bigint;\n    writeBigInt64BE(value: bigint, offset?: number): number;\n    writeBigInt64LE(value: bigint, offset?: number): number;\n    writeBigUInt64BE(value: bigint, offset?: number): number;\n    writeBigUInt64LE(value: bigint, offset?: number): number;\n}\n\n\n// NOTE: These definitions support NodeJS and TypeScript 3.2.\n\n// Reference required types from the default lib:\n/// <reference lib=\"es2018\" />\n/// <reference lib=\"esnext.asynciterable\" />\n/// <reference lib=\"esnext.intl\" />\n/// <reference lib=\"esnext.bigint\" />\n\n// Base definitions for all NodeJS modules that are not specific to any version of TypeScript:\n// tslint:disable-next-line:no-bad-reference\n/// <reference path=\"../base.d.ts\" />\n\n// TypeScript 3.2-specific augmentations:\n/// <reference path=\"fs.d.ts\" />\n/// <reference path=\"util.d.ts\" />\n/// <reference path=\"globals.d.ts\" />\n\n\n// tslint:disable-next-line:no-bad-reference\n/// <reference path=\"../util.d.ts\" />\n\ndeclare module \"util\" {\n    namespace types {\n        function isBigInt64Array(value: any): value is BigInt64Array;\n        function isBigUint64Array(value: any): value is BigUint64Array;\n    }\n}\n\n\n// NOTE: These definitions support NodeJS and TypeScript 3.5.\n\n// Reference required types from the default lib:\n/// <reference lib=\"es2018\" />\n/// <reference lib=\"esnext.asynciterable\" />\n/// <reference lib=\"esnext.intl\" />\n/// <reference lib=\"esnext.bigint\" />\n\n// Base definitions for all NodeJS modules that are not specific to any version of TypeScript:\n// tslint:disable-next-line:no-bad-reference\n/// <reference path=\"../ts3.2/index.d.ts\" />\n\n// TypeScript 3.5-specific augmentations:\n/// <reference path=\"wasi.d.ts\" />\n\n\ndeclare module 'wasi' {\n    interface WASIOptions {\n        /**\n         * An array of strings that the WebAssembly application will\n         * see as command line arguments. The first argument is the virtual path to the\n         * WASI command itself.\n         */\n        args?: string[];\n        /**\n         * An object similar to `process.env` that the WebAssembly\n         * application will see as its environment.\n         */\n        env?: object;\n        /**\n         * This object represents the WebAssembly application's\n         * sandbox directory structure. The string keys of `preopens` are treated as\n         * directories within the sandbox. The corresponding values in `preopens` are\n         * the real paths to those directories on the host machine.\n         */\n        preopens?: {\n            [key: string]: string;\n        };\n\n        /**\n         * By default, WASI applications terminate the Node.js\n         * process via the `__wasi_proc_exit()` function. Setting this option to `true`\n         * causes `wasi.start()` to return the exit code rather than terminate the\n         * process.\n         * @default false\n         */\n        returnOnExit?: boolean;\n    }\n\n    class WASI {\n        constructor(options?: WASIOptions);\n        /**\n         *\n         * Attempt to begin execution of `instance` by invoking its `_start()` export.\n         * If `instance` does not contain a `_start()` export, then `start()` attempts to\n         * invoke the `__wasi_unstable_reactor_start()` export. If neither of those exports\n         * is present on `instance`, then `start()` does nothing.\n         *\n         * `start()` requires that `instance` exports a [`WebAssembly.Memory`][] named\n         * `memory`. If `instance` does not have a `memory` export an exception is thrown.\n         */\n        start(instance: object): void; // TODO: avoid DOM dependency until WASM moved to own lib.\n        /**\n         * Is an object that implements the WASI system call API. This object\n         * should be passed as the `wasi_unstable` import during the instantiation of a\n         * [`WebAssembly.Instance`][].\n         */\n        readonly wasiImport: { [key: string]: any }; // TODO: Narrow to DOM types\n    }\n}\n\n\ndeclare module \"tty\" {\n    import * as net from \"net\";\n\n    function isatty(fd: number): boolean;\n    class ReadStream extends net.Socket {\n        constructor(fd: number, options?: net.SocketConstructorOpts);\n        isRaw: boolean;\n        setRawMode(mode: boolean): this;\n        isTTY: boolean;\n    }\n    /**\n     * -1 - to the left from cursor\n     *  0 - the entire line\n     *  1 - to the right from cursor\n     */\n    type Direction = -1 | 0 | 1;\n    class WriteStream extends net.Socket {\n        constructor(fd: number);\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"resize\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"resize\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"resize\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"resize\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"resize\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"resize\", listener: () => void): this;\n\n        /**\n         * Clears the current line of this WriteStream in a direction identified by `dir`.\n         */\n        clearLine(dir: Direction, callback?: () => void): boolean;\n        /**\n         * Clears this `WriteStream` from the current cursor down.\n         */\n        clearScreenDown(callback?: () => void): boolean;\n        /**\n         * Moves this WriteStream's cursor to the specified position.\n         */\n        cursorTo(x: number, y?: number, callback?: () => void): boolean;\n        cursorTo(x: number, callback: () => void): boolean;\n        /**\n         * Moves this WriteStream's cursor relative to its current position.\n         */\n        moveCursor(dx: number, dy: number, callback?: () => void): boolean;\n        /**\n         * @default `process.env`\n         */\n        getColorDepth(env?: {}): number;\n        hasColors(depth?: number): boolean;\n        hasColors(env?: {}): boolean;\n        hasColors(depth: number, env?: {}): boolean;\n        getWindowSize(): [number, number];\n        columns: number;\n        rows: number;\n        isTTY: boolean;\n    }\n}\n\n\ndeclare module \"url\" {\n    import { ParsedUrlQuery, ParsedUrlQueryInput } from 'querystring';\n\n    // Input to `url.format`\n    interface UrlObject {\n        auth?: string | null;\n        hash?: string | null;\n        host?: string | null;\n        hostname?: string | null;\n        href?: string | null;\n        pathname?: string | null;\n        protocol?: string | null;\n        search?: string | null;\n        slashes?: boolean | null;\n        port?: string | number | null;\n        query?: string | null | ParsedUrlQueryInput;\n    }\n\n    // Output of `url.parse`\n    interface Url {\n        auth: string | null;\n        hash: string | null;\n        host: string | null;\n        hostname: string | null;\n        href: string;\n        path: string | null;\n        pathname: string | null;\n        protocol: string | null;\n        search: string | null;\n        slashes: boolean | null;\n        port: string | null;\n        query: string | null | ParsedUrlQuery;\n    }\n\n    interface UrlWithParsedQuery extends Url {\n        query: ParsedUrlQuery;\n    }\n\n    interface UrlWithStringQuery extends Url {\n        query: string | null;\n    }\n\n    function parse(urlStr: string): UrlWithStringQuery;\n    function parse(urlStr: string, parseQueryString: false | undefined, slashesDenoteHost?: boolean): UrlWithStringQuery;\n    function parse(urlStr: string, parseQueryString: true, slashesDenoteHost?: boolean): UrlWithParsedQuery;\n    function parse(urlStr: string, parseQueryString: boolean, slashesDenoteHost?: boolean): Url;\n\n    function format(URL: URL, options?: URLFormatOptions): string;\n    function format(urlObject: UrlObject | string): string;\n    function resolve(from: string, to: string): string;\n\n    function domainToASCII(domain: string): string;\n    function domainToUnicode(domain: string): string;\n\n    /**\n     * This function ensures the correct decodings of percent-encoded characters as\n     * well as ensuring a cross-platform valid absolute path string.\n     * @param url The file URL string or URL object to convert to a path.\n     */\n    function fileURLToPath(url: string | URL): string;\n\n    /**\n     * This function ensures that path is resolved absolutely, and that the URL\n     * control characters are correctly encoded when converting into a File URL.\n     * @param url The path to convert to a File URL.\n     */\n    function pathToFileURL(url: string): URL;\n\n    interface URLFormatOptions {\n        auth?: boolean;\n        fragment?: boolean;\n        search?: boolean;\n        unicode?: boolean;\n    }\n\n    class URL {\n        constructor(input: string, base?: string | URL);\n        hash: string;\n        host: string;\n        hostname: string;\n        href: string;\n        readonly origin: string;\n        password: string;\n        pathname: string;\n        port: string;\n        protocol: string;\n        search: string;\n        readonly searchParams: URLSearchParams;\n        username: string;\n        toString(): string;\n        toJSON(): string;\n    }\n\n    class URLSearchParams implements Iterable<[string, string]> {\n        constructor(init?: URLSearchParams | string | { [key: string]: string | string[] | undefined } | Iterable<[string, string]> | Array<[string, string]>);\n        append(name: string, value: string): void;\n        delete(name: string): void;\n        entries(): IterableIterator<[string, string]>;\n        forEach(callback: (value: string, name: string, searchParams: this) => void): void;\n        get(name: string): string | null;\n        getAll(name: string): string[];\n        has(name: string): boolean;\n        keys(): IterableIterator<string>;\n        set(name: string, value: string): void;\n        sort(): void;\n        toString(): string;\n        values(): IterableIterator<string>;\n        [Symbol.iterator](): IterableIterator<[string, string]>;\n    }\n}\n\n\ndeclare module \"util\" {\n    interface InspectOptions extends NodeJS.InspectOptions { }\n    type Style = 'special' | 'number' | 'bigint' | 'boolean' | 'undefined' | 'null' | 'string' | 'symbol' | 'date' | 'regexp' | 'module';\n    type CustomInspectFunction = (depth: number, options: InspectOptionsStylized) => string;\n    interface InspectOptionsStylized extends InspectOptions {\n        stylize(text: string, styleType: Style): string;\n    }\n    function format(format: any, ...param: any[]): string;\n    function formatWithOptions(inspectOptions: InspectOptions, format: string, ...param: any[]): string;\n    /** @deprecated since v0.11.3 - use a third party module instead. */\n    function log(string: string): void;\n    function inspect(object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string;\n    function inspect(object: any, options: InspectOptions): string;\n    namespace inspect {\n        let colors: {\n            [color: string]: [number, number] | undefined\n        };\n        let styles: {\n            [K in Style]: string\n        };\n        let defaultOptions: InspectOptions;\n        /**\n         * Allows changing inspect settings from the repl.\n         */\n        let replDefaults: InspectOptions;\n        const custom: unique symbol;\n    }\n    /** @deprecated since v4.0.0 - use `Array.isArray()` instead. */\n    function isArray(object: any): object is any[];\n    /** @deprecated since v4.0.0 - use `util.types.isRegExp()` instead. */\n    function isRegExp(object: any): object is RegExp;\n    /** @deprecated since v4.0.0 - use `util.types.isDate()` instead. */\n    function isDate(object: any): object is Date;\n    /** @deprecated since v4.0.0 - use `util.types.isNativeError()` instead. */\n    function isError(object: any): object is Error;\n    function inherits(constructor: any, superConstructor: any): void;\n    function debuglog(key: string): (msg: string, ...param: any[]) => void;\n    /** @deprecated since v4.0.0 - use `typeof value === 'boolean'` instead. */\n    function isBoolean(object: any): object is boolean;\n    /** @deprecated since v4.0.0 - use `Buffer.isBuffer()` instead. */\n    function isBuffer(object: any): object is Buffer;\n    /** @deprecated since v4.0.0 - use `typeof value === 'function'` instead. */\n    function isFunction(object: any): boolean;\n    /** @deprecated since v4.0.0 - use `value === null` instead. */\n    function isNull(object: any): object is null;\n    /** @deprecated since v4.0.0 - use `value === null || value === undefined` instead. */\n    function isNullOrUndefined(object: any): object is null | undefined;\n    /** @deprecated since v4.0.0 - use `typeof value === 'number'` instead. */\n    function isNumber(object: any): object is number;\n    /** @deprecated since v4.0.0 - use `value !== null && typeof value === 'object'` instead. */\n    function isObject(object: any): boolean;\n    /** @deprecated since v4.0.0 - use `(typeof value !== 'object' && typeof value !== 'function') || value === null` instead. */\n    function isPrimitive(object: any): boolean;\n    /** @deprecated since v4.0.0 - use `typeof value === 'string'` instead. */\n    function isString(object: any): object is string;\n    /** @deprecated since v4.0.0 - use `typeof value === 'symbol'` instead. */\n    function isSymbol(object: any): object is symbol;\n    /** @deprecated since v4.0.0 - use `value === undefined` instead. */\n    function isUndefined(object: any): object is undefined;\n    function deprecate<T extends Function>(fn: T, message: string, code?: string): T;\n    function isDeepStrictEqual(val1: any, val2: any): boolean;\n\n    function callbackify(fn: () => Promise<void>): (callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<TResult>(fn: () => Promise<TResult>): (callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1>(fn: (arg1: T1) => Promise<void>): (arg1: T1, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, TResult>(fn: (arg1: T1) => Promise<TResult>): (arg1: T1, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2>(fn: (arg1: T1, arg2: T2) => Promise<void>): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, TResult>(fn: (arg1: T1, arg2: T2) => Promise<TResult>): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException | null, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3>(fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException | null, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3, T4>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, T4, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: NodeJS.ErrnoException | null, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: NodeJS.ErrnoException | null, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5, T6>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<void>,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5, T6, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<TResult>\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, callback: (err: NodeJS.ErrnoException | null, result: TResult) => void) => void;\n\n    interface CustomPromisifyLegacy<TCustom extends Function> extends Function {\n        __promisify__: TCustom;\n    }\n\n    interface CustomPromisifySymbol<TCustom extends Function> extends Function {\n        [promisify.custom]: TCustom;\n    }\n\n    type CustomPromisify<TCustom extends Function> = CustomPromisifySymbol<TCustom> | CustomPromisifyLegacy<TCustom>;\n\n    function promisify<TCustom extends Function>(fn: CustomPromisify<TCustom>): TCustom;\n    function promisify<TResult>(fn: (callback: (err: any, result: TResult) => void) => void): () => Promise<TResult>;\n    function promisify(fn: (callback: (err?: any) => void) => void): () => Promise<void>;\n    function promisify<T1, TResult>(fn: (arg1: T1, callback: (err: any, result: TResult) => void) => void): (arg1: T1) => Promise<TResult>;\n    function promisify<T1>(fn: (arg1: T1, callback: (err?: any) => void) => void): (arg1: T1) => Promise<void>;\n    function promisify<T1, T2, TResult>(fn: (arg1: T1, arg2: T2, callback: (err: any, result: TResult) => void) => void): (arg1: T1, arg2: T2) => Promise<TResult>;\n    function promisify<T1, T2>(fn: (arg1: T1, arg2: T2, callback: (err?: any) => void) => void): (arg1: T1, arg2: T2) => Promise<void>;\n    function promisify<T1, T2, T3, TResult>(fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err: any, result: TResult) => void) => void):\n        (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>;\n    function promisify<T1, T2, T3>(fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err?: any) => void) => void): (arg1: T1, arg2: T2, arg3: T3) => Promise<void>;\n    function promisify<T1, T2, T3, T4, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: any, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>;\n    function promisify<T1, T2, T3, T4>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err?: any) => void) => void):\n        (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>;\n    function promisify<T1, T2, T3, T4, T5, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: any, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>;\n    function promisify<T1, T2, T3, T4, T5>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err?: any) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>;\n    function promisify(fn: Function): Function;\n    namespace promisify {\n        const custom: unique symbol;\n    }\n\n    namespace types {\n        function isAnyArrayBuffer(object: any): boolean;\n        function isArgumentsObject(object: any): object is IArguments;\n        function isArrayBuffer(object: any): object is ArrayBuffer;\n        function isAsyncFunction(object: any): boolean;\n        function isBooleanObject(object: any): object is Boolean;\n        function isBoxedPrimitive(object: any): object is (Number | Boolean | String | Symbol /* | Object(BigInt) | Object(Symbol) */);\n        function isDataView(object: any): object is DataView;\n        function isDate(object: any): object is Date;\n        function isExternal(object: any): boolean;\n        function isFloat32Array(object: any): object is Float32Array;\n        function isFloat64Array(object: any): object is Float64Array;\n        function isGeneratorFunction(object: any): boolean;\n        function isGeneratorObject(object: any): boolean;\n        function isInt8Array(object: any): object is Int8Array;\n        function isInt16Array(object: any): object is Int16Array;\n        function isInt32Array(object: any): object is Int32Array;\n        function isMap(object: any): boolean;\n        function isMapIterator(object: any): boolean;\n        function isModuleNamespaceObject(value: any): boolean;\n        function isNativeError(object: any): object is Error;\n        function isNumberObject(object: any): object is Number;\n        function isPromise(object: any): boolean;\n        function isProxy(object: any): boolean;\n        function isRegExp(object: any): object is RegExp;\n        function isSet(object: any): boolean;\n        function isSetIterator(object: any): boolean;\n        function isSharedArrayBuffer(object: any): boolean;\n        function isStringObject(object: any): boolean;\n        function isSymbolObject(object: any): boolean;\n        function isTypedArray(object: any): object is NodeJS.TypedArray;\n        function isUint8Array(object: any): object is Uint8Array;\n        function isUint8ClampedArray(object: any): object is Uint8ClampedArray;\n        function isUint16Array(object: any): object is Uint16Array;\n        function isUint32Array(object: any): object is Uint32Array;\n        function isWeakMap(object: any): boolean;\n        function isWeakSet(object: any): boolean;\n        function isWebAssemblyCompiledModule(object: any): boolean;\n    }\n\n    class TextDecoder {\n        readonly encoding: string;\n        readonly fatal: boolean;\n        readonly ignoreBOM: boolean;\n        constructor(\n          encoding?: string,\n          options?: { fatal?: boolean; ignoreBOM?: boolean }\n        );\n        decode(\n          input?: NodeJS.ArrayBufferView | ArrayBuffer | null,\n          options?: { stream?: boolean }\n        ): string;\n    }\n\n    interface EncodeIntoResult {\n        /**\n         * The read Unicode code units of input.\n         */\n\n        read: number;\n        /**\n         * The written UTF-8 bytes of output.\n         */\n        written: number;\n    }\n\n    class TextEncoder {\n        readonly encoding: string;\n        encode(input?: string): Uint8Array;\n        encodeInto(input: string, output: Uint8Array): EncodeIntoResult;\n    }\n}\n\n\ndeclare module \"v8\" {\n    import { Readable } from \"stream\";\n\n    interface HeapSpaceInfo {\n        space_name: string;\n        space_size: number;\n        space_used_size: number;\n        space_available_size: number;\n        physical_space_size: number;\n    }\n\n    // ** Signifies if the --zap_code_space option is enabled or not.  1 == enabled, 0 == disabled. */\n    type DoesZapCodeSpaceFlag = 0 | 1;\n\n    interface HeapInfo {\n        total_heap_size: number;\n        total_heap_size_executable: number;\n        total_physical_size: number;\n        total_available_size: number;\n        used_heap_size: number;\n        heap_size_limit: number;\n        malloced_memory: number;\n        peak_malloced_memory: number;\n        does_zap_garbage: DoesZapCodeSpaceFlag;\n        number_of_native_contexts: number;\n        number_of_detached_contexts: number;\n    }\n\n    interface HeapCodeStatistics {\n        code_and_metadata_size: number;\n        bytecode_and_metadata_size: number;\n        external_script_source_size: number;\n    }\n\n    /**\n     * Returns an integer representing a \"version tag\" derived from the V8 version, command line flags and detected CPU features.\n     * This is useful for determining whether a vm.Script cachedData buffer is compatible with this instance of V8.\n     */\n    function cachedDataVersionTag(): number;\n\n    function getHeapStatistics(): HeapInfo;\n    function getHeapSpaceStatistics(): HeapSpaceInfo[];\n    function setFlagsFromString(flags: string): void;\n    /**\n     * Generates a snapshot of the current V8 heap and returns a Readable\n     * Stream that may be used to read the JSON serialized representation.\n     * This conversation was marked as resolved by joyeecheung\n     * This JSON stream format is intended to be used with tools such as\n     * Chrome DevTools. The JSON schema is undocumented and specific to the\n     * V8 engine, and may change from one version of V8 to the next.\n     */\n    function getHeapSnapshot(): Readable;\n\n    /**\n     *\n     * @param fileName The file path where the V8 heap snapshot is to be\n     * saved. If not specified, a file name with the pattern\n     * `'Heap-${yyyymmdd}-${hhmmss}-${pid}-${thread_id}.heapsnapshot'` will be\n     * generated, where `{pid}` will be the PID of the Node.js process,\n     * `{thread_id}` will be `0` when `writeHeapSnapshot()` is called from\n     * the main Node.js thread or the id of a worker thread.\n     */\n    function writeHeapSnapshot(fileName?: string): string;\n\n    function getHeapCodeStatistics(): HeapCodeStatistics;\n\n    class Serializer {\n        /**\n         * Writes out a header, which includes the serialization format version.\n         */\n        writeHeader(): void;\n\n        /**\n         * Serializes a JavaScript value and adds the serialized representation to the internal buffer.\n         * This throws an error if value cannot be serialized.\n         */\n        writeValue(val: any): boolean;\n\n        /**\n         * Returns the stored internal buffer.\n         * This serializer should not be used once the buffer is released.\n         * Calling this method results in undefined behavior if a previous write has failed.\n         */\n        releaseBuffer(): Buffer;\n\n        /**\n         * Marks an ArrayBuffer as having its contents transferred out of band.\\\n         * Pass the corresponding ArrayBuffer in the deserializing context to deserializer.transferArrayBuffer().\n         */\n        transferArrayBuffer(id: number, arrayBuffer: ArrayBuffer): void;\n\n        /**\n         * Write a raw 32-bit unsigned integer.\n         */\n        writeUint32(value: number): void;\n\n        /**\n         * Write a raw 64-bit unsigned integer, split into high and low 32-bit parts.\n         */\n        writeUint64(hi: number, lo: number): void;\n\n        /**\n         * Write a JS number value.\n         */\n        writeDouble(value: number): void;\n\n        /**\n         * Write raw bytes into the serializer\u2019s internal buffer.\n         * The deserializer will require a way to compute the length of the buffer.\n         */\n        writeRawBytes(buffer: NodeJS.TypedArray): void;\n    }\n\n    /**\n     * A subclass of `Serializer` that serializes `TypedArray` (in particular `Buffer`) and `DataView` objects as host objects,\n     * and only stores the part of their underlying `ArrayBuffers` that they are referring to.\n     */\n    class DefaultSerializer extends Serializer {\n    }\n\n    class Deserializer {\n        constructor(data: NodeJS.TypedArray);\n        /**\n         * Reads and validates a header (including the format version).\n         * May, for example, reject an invalid or unsupported wire format.\n         * In that case, an Error is thrown.\n         */\n        readHeader(): boolean;\n\n        /**\n         * Deserializes a JavaScript value from the buffer and returns it.\n         */\n        readValue(): any;\n\n        /**\n         * Marks an ArrayBuffer as having its contents transferred out of band.\n         * Pass the corresponding `ArrayBuffer` in the serializing context to serializer.transferArrayBuffer()\n         * (or return the id from serializer._getSharedArrayBufferId() in the case of SharedArrayBuffers).\n         */\n        transferArrayBuffer(id: number, arrayBuffer: ArrayBuffer): void;\n\n        /**\n         * Reads the underlying wire format version.\n         * Likely mostly to be useful to legacy code reading old wire format versions.\n         * May not be called before .readHeader().\n         */\n        getWireFormatVersion(): number;\n\n        /**\n         * Read a raw 32-bit unsigned integer and return it.\n         */\n        readUint32(): number;\n\n        /**\n         * Read a raw 64-bit unsigned integer and return it as an array [hi, lo] with two 32-bit unsigned integer entries.\n         */\n        readUint64(): [number, number];\n\n        /**\n         * Read a JS number value.\n         */\n        readDouble(): number;\n\n        /**\n         * Read raw bytes from the deserializer\u2019s internal buffer.\n         * The length parameter must correspond to the length of the buffer that was passed to serializer.writeRawBytes().\n         */\n        readRawBytes(length: number): Buffer;\n    }\n\n    /**\n     * A subclass of `Serializer` that serializes `TypedArray` (in particular `Buffer`) and `DataView` objects as host objects,\n     * and only stores the part of their underlying `ArrayBuffers` that they are referring to.\n     */\n    class DefaultDeserializer extends Deserializer {\n    }\n\n    /**\n     * Uses a `DefaultSerializer` to serialize value into a buffer.\n     */\n    function serialize(value: any): Buffer;\n\n    /**\n     * Uses a `DefaultDeserializer` with default options to read a JS value from a buffer.\n     */\n    function deserialize(data: NodeJS.TypedArray): any;\n}\n\n\ndeclare module \"vm\" {\n    interface Context {\n        [key: string]: any;\n    }\n    interface BaseOptions {\n        /**\n         * Specifies the filename used in stack traces produced by this script.\n         * Default: `''`.\n         */\n        filename?: string;\n        /**\n         * Specifies the line number offset that is displayed in stack traces produced by this script.\n         * Default: `0`.\n         */\n        lineOffset?: number;\n        /**\n         * Specifies the column number offset that is displayed in stack traces produced by this script.\n         * Default: `0`\n         */\n        columnOffset?: number;\n    }\n    interface ScriptOptions extends BaseOptions {\n        displayErrors?: boolean;\n        timeout?: number;\n        cachedData?: Buffer;\n        produceCachedData?: boolean;\n    }\n    interface RunningScriptOptions extends BaseOptions {\n        /**\n         * When `true`, if an `Error` occurs while compiling the `code`, the line of code causing the error is attached to the stack trace.\n         * Default: `true`.\n         */\n        displayErrors?: boolean;\n        /**\n         * Specifies the number of milliseconds to execute code before terminating execution.\n         * If execution is terminated, an `Error` will be thrown. This value must be a strictly positive integer.\n         */\n        timeout?: number;\n        /**\n         * If `true`, the execution will be terminated when `SIGINT` (Ctrl+C) is received.\n         * Existing handlers for the event that have been attached via `process.on('SIGINT')` will be disabled during script execution, but will continue to work after that.\n         * If execution is terminated, an `Error` will be thrown.\n         * Default: `false`.\n         */\n        breakOnSigint?: boolean;\n    }\n    interface CompileFunctionOptions extends BaseOptions {\n        /**\n         * Provides an optional data with V8's code cache data for the supplied source.\n         */\n        cachedData?: Buffer;\n        /**\n         * Specifies whether to produce new cache data.\n         * Default: `false`,\n         */\n        produceCachedData?: boolean;\n        /**\n         * The sandbox/context in which the said function should be compiled in.\n         */\n        parsingContext?: Context;\n\n        /**\n         * An array containing a collection of context extensions (objects wrapping the current scope) to be applied while compiling\n         */\n        contextExtensions?: Object[];\n    }\n\n    interface CreateContextOptions {\n        /**\n         * Human-readable name of the newly created context.\n         * @default 'VM Context i' Where i is an ascending numerical index of the created context.\n         */\n        name?: string;\n        /**\n         * Corresponds to the newly created context for display purposes.\n         * The origin should be formatted like a `URL`, but with only the scheme, host, and port (if necessary),\n         * like the value of the `url.origin` property of a URL object.\n         * Most notably, this string should omit the trailing slash, as that denotes a path.\n         * @default ''\n         */\n        origin?: string;\n        codeGeneration?: {\n            /**\n             * If set to false any calls to eval or function constructors (Function, GeneratorFunction, etc)\n             * will throw an EvalError.\n             * @default true\n             */\n            strings?: boolean;\n            /**\n             * If set to false any attempt to compile a WebAssembly module will throw a WebAssembly.CompileError.\n             * @default true\n             */\n            wasm?: boolean;\n        };\n    }\n\n    type MeasureMemoryMode = 'summary' | 'detailed';\n\n    interface MeasureMemoryOptions {\n        /**\n         * @default 'summary'\n         */\n        mode?: MeasureMemoryMode;\n        context?: Context;\n    }\n\n    interface MemoryMeasurement {\n        total: {\n            jsMemoryEstimate: number;\n            jsMemoryRange: [number, number];\n        };\n    }\n\n    class Script {\n        constructor(code: string, options?: ScriptOptions);\n        runInContext(contextifiedSandbox: Context, options?: RunningScriptOptions): any;\n        runInNewContext(sandbox?: Context, options?: RunningScriptOptions): any;\n        runInThisContext(options?: RunningScriptOptions): any;\n        createCachedData(): Buffer;\n    }\n    function createContext(sandbox?: Context, options?: CreateContextOptions): Context;\n    function isContext(sandbox: Context): boolean;\n    function runInContext(code: string, contextifiedSandbox: Context, options?: RunningScriptOptions | string): any;\n    function runInNewContext(code: string, sandbox?: Context, options?: RunningScriptOptions | string): any;\n    function runInThisContext(code: string, options?: RunningScriptOptions | string): any;\n    function compileFunction(code: string, params?: string[], options?: CompileFunctionOptions): Function;\n\n    /**\n     * Measure the memory known to V8 and used by the current execution context or a specified context.\n     *\n     * The format of the object that the returned Promise may resolve with is\n     * specific to the V8 engine and may change from one version of V8 to the next.\n     *\n     * The returned result is different from the statistics returned by\n     * `v8.getHeapSpaceStatistics()` in that `vm.measureMemory()` measures\n     * the memory reachable by V8 from a specific context, while\n     * `v8.getHeapSpaceStatistics()` measures the memory used by an instance\n     * of V8 engine, which can switch among multiple contexts that reference\n     * objects in the heap of one engine.\n     *\n     * @experimental\n     */\n    function measureMemory(options?: MeasureMemoryOptions): Promise<MemoryMeasurement>;\n}\n\n\ndeclare module \"worker_threads\" {\n    import { Context } from \"vm\";\n    import { EventEmitter } from \"events\";\n    import { Readable, Writable } from \"stream\";\n\n    const isMainThread: boolean;\n    const parentPort: null | MessagePort;\n    const SHARE_ENV: unique symbol;\n    const threadId: number;\n    const workerData: any;\n\n    class MessageChannel {\n        readonly port1: MessagePort;\n        readonly port2: MessagePort;\n    }\n\n    class MessagePort extends EventEmitter {\n        close(): void;\n        postMessage(value: any, transferList?: Array<ArrayBuffer | MessagePort>): void;\n        ref(): void;\n        unref(): void;\n        start(): void;\n\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"message\", listener: (value: any) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        emit(event: \"close\"): boolean;\n        emit(event: \"message\", value: any): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"message\", listener: (value: any) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"message\", listener: (value: any) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"message\", listener: (value: any) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"message\", listener: (value: any) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        removeListener(event: \"close\", listener: () => void): this;\n        removeListener(event: \"message\", listener: (value: any) => void): this;\n        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        off(event: \"close\", listener: () => void): this;\n        off(event: \"message\", listener: (value: any) => void): this;\n        off(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    interface WorkerOptions {\n        /**\n         * List of arguments which would be stringified and appended to\n         * `process.argv` in the worker. This is mostly similar to the `workerData`\n         * but the values will be available on the global `process.argv` as if they\n         * were passed as CLI options to the script.\n         */\n        argv?: any[];\n        env?: NodeJS.ProcessEnv | typeof SHARE_ENV;\n        eval?: boolean;\n        workerData?: any;\n        stdin?: boolean;\n        stdout?: boolean;\n        stderr?: boolean;\n        execArgv?: string[];\n        resourceLimits?: ResourceLimits;\n    }\n\n    interface ResourceLimits {\n        maxYoungGenerationSizeMb?: number;\n        maxOldGenerationSizeMb?: number;\n        codeRangeSizeMb?: number;\n    }\n\n    class Worker extends EventEmitter {\n        readonly stdin: Writable | null;\n        readonly stdout: Readable;\n        readonly stderr: Readable;\n        readonly threadId: number;\n        readonly resourceLimits?: ResourceLimits;\n\n        constructor(filename: string, options?: WorkerOptions);\n\n        postMessage(value: any, transferList?: Array<ArrayBuffer | MessagePort>): void;\n        ref(): void;\n        unref(): void;\n        /**\n         * Stop all JavaScript execution in the worker thread as soon as possible.\n         * Returns a Promise for the exit code that is fulfilled when the `exit` event is emitted.\n         */\n        terminate(): Promise<number>;\n        /**\n         * Transfer a `MessagePort` to a different `vm` Context. The original `port`\n         * object will be rendered unusable, and the returned `MessagePort` instance will\n         * take its place.\n         *\n         * The returned `MessagePort` will be an object in the target context, and will\n         * inherit from its global `Object` class. Objects passed to the\n         * `port.onmessage()` listener will also be created in the target context\n         * and inherit from its global `Object` class.\n         *\n         * However, the created `MessagePort` will no longer inherit from\n         * `EventEmitter`, and only `port.onmessage()` can be used to receive\n         * events using it.\n         */\n        moveMessagePortToContext(port: MessagePort, context: Context): MessagePort;\n\n        /**\n         * Receive a single message from a given `MessagePort`. If no message is available,\n         * `undefined` is returned, otherwise an object with a single `message` property\n         * that contains the message payload, corresponding to the oldest message in the\n         * `MessagePort`\u2019s queue.\n         */\n        receiveMessageOnPort(port: MessagePort): {} | undefined;\n\n        /**\n         * Returns a readable stream for a V8 snapshot of the current state of the Worker.\n         * See [`v8.getHeapSnapshot()`][] for more details.\n         *\n         * If the Worker thread is no longer running, which may occur before the\n         * [`'exit'` event][] is emitted, the returned `Promise` will be rejected\n         * immediately with an [`ERR_WORKER_NOT_RUNNING`][] error\n         */\n        getHeapSnapshot(): Promise<Readable>;\n\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"exit\", listener: (exitCode: number) => void): this;\n        addListener(event: \"message\", listener: (value: any) => void): this;\n        addListener(event: \"online\", listener: () => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"exit\", exitCode: number): boolean;\n        emit(event: \"message\", value: any): boolean;\n        emit(event: \"online\"): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"exit\", listener: (exitCode: number) => void): this;\n        on(event: \"message\", listener: (value: any) => void): this;\n        on(event: \"online\", listener: () => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"exit\", listener: (exitCode: number) => void): this;\n        once(event: \"message\", listener: (value: any) => void): this;\n        once(event: \"online\", listener: () => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"exit\", listener: (exitCode: number) => void): this;\n        prependListener(event: \"message\", listener: (value: any) => void): this;\n        prependListener(event: \"online\", listener: () => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"exit\", listener: (exitCode: number) => void): this;\n        prependOnceListener(event: \"message\", listener: (value: any) => void): this;\n        prependOnceListener(event: \"online\", listener: () => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        removeListener(event: \"error\", listener: (err: Error) => void): this;\n        removeListener(event: \"exit\", listener: (exitCode: number) => void): this;\n        removeListener(event: \"message\", listener: (value: any) => void): this;\n        removeListener(event: \"online\", listener: () => void): this;\n        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        off(event: \"error\", listener: (err: Error) => void): this;\n        off(event: \"exit\", listener: (exitCode: number) => void): this;\n        off(event: \"message\", listener: (value: any) => void): this;\n        off(event: \"online\", listener: () => void): this;\n        off(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n}\n\n\ndeclare module \"zlib\" {\n    import * as stream from \"stream\";\n\n    interface ZlibOptions {\n        /**\n         * @default constants.Z_NO_FLUSH\n         */\n        flush?: number;\n        /**\n         * @default constants.Z_FINISH\n         */\n        finishFlush?: number;\n        /**\n         * @default 16*1024\n         */\n        chunkSize?: number;\n        windowBits?: number;\n        level?: number; // compression only\n        memLevel?: number; // compression only\n        strategy?: number; // compression only\n        dictionary?: NodeJS.ArrayBufferView | ArrayBuffer; // deflate/inflate only, empty dictionary by default\n    }\n\n    interface BrotliOptions {\n        /**\n         * @default constants.BROTLI_OPERATION_PROCESS\n         */\n        flush?: number;\n        /**\n         * @default constants.BROTLI_OPERATION_FINISH\n         */\n        finishFlush?: number;\n        /**\n         * @default 16*1024\n         */\n        chunkSize?: number;\n        params?: {\n            /**\n             * Each key is a `constants.BROTLI_*` constant.\n             */\n            [key: number]: boolean | number;\n        };\n    }\n\n    interface Zlib {\n        /** @deprecated Use bytesWritten instead. */\n        readonly bytesRead: number;\n        readonly bytesWritten: number;\n        shell?: boolean | string;\n        close(callback?: () => void): void;\n        flush(kind?: number | (() => void), callback?: () => void): void;\n    }\n\n    interface ZlibParams {\n        params(level: number, strategy: number, callback: () => void): void;\n    }\n\n    interface ZlibReset {\n        reset(): void;\n    }\n\n    interface BrotliCompress extends stream.Transform, Zlib { }\n    interface BrotliDecompress extends stream.Transform, Zlib { }\n    interface Gzip extends stream.Transform, Zlib { }\n    interface Gunzip extends stream.Transform, Zlib { }\n    interface Deflate extends stream.Transform, Zlib, ZlibReset, ZlibParams { }\n    interface Inflate extends stream.Transform, Zlib, ZlibReset { }\n    interface DeflateRaw extends stream.Transform, Zlib, ZlibReset, ZlibParams { }\n    interface InflateRaw extends stream.Transform, Zlib, ZlibReset { }\n    interface Unzip extends stream.Transform, Zlib { }\n\n    function createBrotliCompress(options?: BrotliOptions): BrotliCompress;\n    function createBrotliDecompress(options?: BrotliOptions): BrotliDecompress;\n    function createGzip(options?: ZlibOptions): Gzip;\n    function createGunzip(options?: ZlibOptions): Gunzip;\n    function createDeflate(options?: ZlibOptions): Deflate;\n    function createInflate(options?: ZlibOptions): Inflate;\n    function createDeflateRaw(options?: ZlibOptions): DeflateRaw;\n    function createInflateRaw(options?: ZlibOptions): InflateRaw;\n    function createUnzip(options?: ZlibOptions): Unzip;\n\n    type InputType = string | ArrayBuffer | NodeJS.ArrayBufferView;\n\n    type CompressCallback = (error: Error | null, result: Buffer) => void;\n\n    function brotliCompress(buf: InputType, options: BrotliOptions, callback: CompressCallback): void;\n    function brotliCompress(buf: InputType, callback: CompressCallback): void;\n    function brotliCompressSync(buf: InputType, options?: BrotliOptions): Buffer;\n    function brotliDecompress(buf: InputType, options: BrotliOptions, callback: CompressCallback): void;\n    function brotliDecompress(buf: InputType, callback: CompressCallback): void;\n    function brotliDecompressSync(buf: InputType, options?: BrotliOptions): Buffer;\n    function deflate(buf: InputType, callback: CompressCallback): void;\n    function deflate(buf: InputType, options: ZlibOptions, callback: CompressCallback): void;\n    function deflateSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function deflateRaw(buf: InputType, callback: CompressCallback): void;\n    function deflateRaw(buf: InputType, options: ZlibOptions, callback: CompressCallback): void;\n    function deflateRawSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function gzip(buf: InputType, callback: CompressCallback): void;\n    function gzip(buf: InputType, options: ZlibOptions, callback: CompressCallback): void;\n    function gzipSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function gunzip(buf: InputType, callback: CompressCallback): void;\n    function gunzip(buf: InputType, options: ZlibOptions, callback: CompressCallback): void;\n    function gunzipSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function inflate(buf: InputType, callback: CompressCallback): void;\n    function inflate(buf: InputType, options: ZlibOptions, callback: CompressCallback): void;\n    function inflateSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function inflateRaw(buf: InputType, callback: CompressCallback): void;\n    function inflateRaw(buf: InputType, options: ZlibOptions, callback: CompressCallback): void;\n    function inflateRawSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function unzip(buf: InputType, callback: CompressCallback): void;\n    function unzip(buf: InputType, options: ZlibOptions, callback: CompressCallback): void;\n    function unzipSync(buf: InputType, options?: ZlibOptions): Buffer;\n\n    namespace constants {\n        const BROTLI_DECODE: number;\n        const BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: number;\n        const BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: number;\n        const BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: number;\n        const BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: number;\n        const BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: number;\n        const BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: number;\n        const BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: number;\n        const BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: number;\n        const BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: number;\n        const BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: number;\n        const BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: number;\n        const BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: number;\n        const BROTLI_DECODER_ERROR_FORMAT_DISTANCE: number;\n        const BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: number;\n        const BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: number;\n        const BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: number;\n        const BROTLI_DECODER_ERROR_FORMAT_PADDING_1: number;\n        const BROTLI_DECODER_ERROR_FORMAT_PADDING_2: number;\n        const BROTLI_DECODER_ERROR_FORMAT_RESERVED: number;\n        const BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: number;\n        const BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: number;\n        const BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: number;\n        const BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: number;\n        const BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: number;\n        const BROTLI_DECODER_ERROR_UNREACHABLE: number;\n        const BROTLI_DECODER_NEEDS_MORE_INPUT: number;\n        const BROTLI_DECODER_NEEDS_MORE_OUTPUT: number;\n        const BROTLI_DECODER_NO_ERROR: number;\n        const BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: number;\n        const BROTLI_DECODER_PARAM_LARGE_WINDOW: number;\n        const BROTLI_DECODER_RESULT_ERROR: number;\n        const BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: number;\n        const BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: number;\n        const BROTLI_DECODER_RESULT_SUCCESS: number;\n        const BROTLI_DECODER_SUCCESS: number;\n\n        const BROTLI_DEFAULT_MODE: number;\n        const BROTLI_DEFAULT_QUALITY: number;\n        const BROTLI_DEFAULT_WINDOW: number;\n        const BROTLI_ENCODE: number;\n        const BROTLI_LARGE_MAX_WINDOW_BITS: number;\n        const BROTLI_MAX_INPUT_BLOCK_BITS: number;\n        const BROTLI_MAX_QUALITY: number;\n        const BROTLI_MAX_WINDOW_BITS: number;\n        const BROTLI_MIN_INPUT_BLOCK_BITS: number;\n        const BROTLI_MIN_QUALITY: number;\n        const BROTLI_MIN_WINDOW_BITS: number;\n\n        const BROTLI_MODE_FONT: number;\n        const BROTLI_MODE_GENERIC: number;\n        const BROTLI_MODE_TEXT: number;\n\n        const BROTLI_OPERATION_EMIT_METADATA: number;\n        const BROTLI_OPERATION_FINISH: number;\n        const BROTLI_OPERATION_FLUSH: number;\n        const BROTLI_OPERATION_PROCESS: number;\n\n        const BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: number;\n        const BROTLI_PARAM_LARGE_WINDOW: number;\n        const BROTLI_PARAM_LGBLOCK: number;\n        const BROTLI_PARAM_LGWIN: number;\n        const BROTLI_PARAM_MODE: number;\n        const BROTLI_PARAM_NDIRECT: number;\n        const BROTLI_PARAM_NPOSTFIX: number;\n        const BROTLI_PARAM_QUALITY: number;\n        const BROTLI_PARAM_SIZE_HINT: number;\n\n        const DEFLATE: number;\n        const DEFLATERAW: number;\n        const GUNZIP: number;\n        const GZIP: number;\n        const INFLATE: number;\n        const INFLATERAW: number;\n        const UNZIP: number;\n\n        const Z_BEST_COMPRESSION: number;\n        const Z_BEST_SPEED: number;\n        const Z_BLOCK: number;\n        const Z_BUF_ERROR: number;\n        const Z_DATA_ERROR: number;\n\n        const Z_DEFAULT_CHUNK: number;\n        const Z_DEFAULT_COMPRESSION: number;\n        const Z_DEFAULT_LEVEL: number;\n        const Z_DEFAULT_MEMLEVEL: number;\n        const Z_DEFAULT_STRATEGY: number;\n        const Z_DEFAULT_WINDOWBITS: number;\n\n        const Z_ERRNO: number;\n        const Z_FILTERED: number;\n        const Z_FINISH: number;\n        const Z_FIXED: number;\n        const Z_FULL_FLUSH: number;\n        const Z_HUFFMAN_ONLY: number;\n        const Z_MAX_CHUNK: number;\n        const Z_MAX_LEVEL: number;\n        const Z_MAX_MEMLEVEL: number;\n        const Z_MAX_WINDOWBITS: number;\n        const Z_MEM_ERROR: number;\n        const Z_MIN_CHUNK: number;\n        const Z_MIN_LEVEL: number;\n        const Z_MIN_MEMLEVEL: number;\n        const Z_MIN_WINDOWBITS: number;\n        const Z_NEED_DICT: number;\n        const Z_NO_COMPRESSION: number;\n        const Z_NO_FLUSH: number;\n        const Z_OK: number;\n        const Z_PARTIAL_FLUSH: number;\n        const Z_RLE: number;\n        const Z_STREAM_END: number;\n        const Z_STREAM_ERROR: number;\n        const Z_SYNC_FLUSH: number;\n        const Z_VERSION_ERROR: number;\n        const ZLIB_VERNUM: number;\n    }\n\n    /**\n     * @deprecated\n     */\n    const Z_NO_FLUSH: number;\n    /**\n     * @deprecated\n     */\n    const Z_PARTIAL_FLUSH: number;\n    /**\n     * @deprecated\n     */\n    const Z_SYNC_FLUSH: number;\n    /**\n     * @deprecated\n     */\n    const Z_FULL_FLUSH: number;\n    /**\n     * @deprecated\n     */\n    const Z_FINISH: number;\n    /**\n     * @deprecated\n     */\n    const Z_BLOCK: number;\n    /**\n     * @deprecated\n     */\n    const Z_TREES: number;\n    /**\n     * @deprecated\n     */\n    const Z_OK: number;\n    /**\n     * @deprecated\n     */\n    const Z_STREAM_END: number;\n    /**\n     * @deprecated\n     */\n    const Z_NEED_DICT: number;\n    /**\n     * @deprecated\n     */\n    const Z_ERRNO: number;\n    /**\n     * @deprecated\n     */\n    const Z_STREAM_ERROR: number;\n    /**\n     * @deprecated\n     */\n    const Z_DATA_ERROR: number;\n    /**\n     * @deprecated\n     */\n    const Z_MEM_ERROR: number;\n    /**\n     * @deprecated\n     */\n    const Z_BUF_ERROR: number;\n    /**\n     * @deprecated\n     */\n    const Z_VERSION_ERROR: number;\n    /**\n     * @deprecated\n     */\n    const Z_NO_COMPRESSION: number;\n    /**\n     * @deprecated\n     */\n    const Z_BEST_SPEED: number;\n    /**\n     * @deprecated\n     */\n    const Z_BEST_COMPRESSION: number;\n    /**\n     * @deprecated\n     */\n    const Z_DEFAULT_COMPRESSION: number;\n    /**\n     * @deprecated\n     */\n    const Z_FILTERED: number;\n    /**\n     * @deprecated\n     */\n    const Z_HUFFMAN_ONLY: number;\n    /**\n     * @deprecated\n     */\n    const Z_RLE: number;\n    /**\n     * @deprecated\n     */\n    const Z_FIXED: number;\n    /**\n     * @deprecated\n     */\n    const Z_DEFAULT_STRATEGY: number;\n    /**\n     * @deprecated\n     */\n    const Z_BINARY: number;\n    /**\n     * @deprecated\n     */\n    const Z_TEXT: number;\n    /**\n     * @deprecated\n     */\n    const Z_ASCII: number;\n    /**\n     * @deprecated\n     */\n    const Z_UNKNOWN: number;\n    /**\n     * @deprecated\n     */\n    const Z_DEFLATED: number;\n}\n\n\ndeclare var ajv: {\n  (options?: ajv.Options): ajv.Ajv;\n  new(options?: ajv.Options): ajv.Ajv;\n  ValidationError: typeof AjvErrors.ValidationError;\n  MissingRefError: typeof AjvErrors.MissingRefError;\n  $dataMetaSchema: object;\n}\n\ndeclare namespace AjvErrors {\n  class ValidationError extends Error {\n    constructor(errors: Array<ajv.ErrorObject>);\n\n    message: string;\n    errors: Array<ajv.ErrorObject>;\n    ajv: true;\n    validation: true;\n  }\n\n  class MissingRefError extends Error {\n    constructor(baseId: string, ref: string, message?: string);\n    static message: (baseId: string, ref: string) => string;\n\n    message: string;\n    missingRef: string;\n    missingSchema: string;\n  }\n}\n\ndeclare namespace ajv {\n  type ValidationError = AjvErrors.ValidationError;\n\n  type MissingRefError = AjvErrors.MissingRefError;\n\n  interface Ajv {\n    /**\n    * Validate data using schema\n    * Schema will be compiled and cached (using serialized JSON as key, [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize by default).\n    * @param  {string|object|Boolean} schemaKeyRef key, ref or schema object\n    * @param  {Any} data to be validated\n    * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).\n    */\n    validate(schemaKeyRef: object | string | boolean, data: any): boolean | PromiseLike<any>;\n    /**\n    * Create validating function for passed schema.\n    * @param  {object|Boolean} schema schema object\n    * @return {Function} validating function\n    */\n    compile(schema: object | boolean): ValidateFunction;\n    /**\n    * Creates validating function for passed schema with asynchronous loading of missing schemas.\n    * `loadSchema` option should be a function that accepts schema uri and node-style callback.\n    * @this  Ajv\n    * @param {object|Boolean} schema schema object\n    * @param {Boolean} meta optional true to compile meta-schema; this parameter can be skipped\n    * @param {Function} callback optional node-style callback, it is always called with 2 parameters: error (or null) and validating function.\n    * @return {PromiseLike<ValidateFunction>} validating function\n    */\n    compileAsync(schema: object | boolean, meta?: Boolean, callback?: (err: Error, validate: ValidateFunction) => any): PromiseLike<ValidateFunction>;\n    /**\n    * Adds schema to the instance.\n    * @param {object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.\n    * @param {string} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    * @return {Ajv} this for method chaining\n    */\n    addSchema(schema: Array<object> | object, key?: string): Ajv;\n    /**\n    * Add schema that will be used to validate other schemas\n    * options in META_IGNORE_OPTIONS are alway set to false\n    * @param {object} schema schema object\n    * @param {string} key optional schema key\n    * @return {Ajv} this for method chaining\n    */\n    addMetaSchema(schema: object, key?: string): Ajv;\n    /**\n    * Validate schema\n    * @param {object|Boolean} schema schema to validate\n    * @return {Boolean} true if schema is valid\n    */\n    validateSchema(schema: object | boolean): boolean;\n    /**\n    * Get compiled schema from the instance by `key` or `ref`.\n    * @param  {string} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).\n    * @return {Function} schema validating function (with property `schema`). Returns undefined if keyRef can't be resolved to an existing schema.\n    */\n    getSchema(keyRef: string): ValidateFunction | undefined;\n    /**\n    * Remove cached schema(s).\n    * If no parameter is passed all schemas but meta-schemas are removed.\n    * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    * @param  {string|object|RegExp|Boolean} schemaKeyRef key, ref, pattern to match key/ref or schema object\n    * @return {Ajv} this for method chaining\n    */\n    removeSchema(schemaKeyRef?: object | string | RegExp | boolean): Ajv;\n    /**\n    * Add custom format\n    * @param {string} name format name\n    * @param {string|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)\n    * @return {Ajv} this for method chaining\n    */\n    addFormat(name: string, format: FormatValidator | FormatDefinition): Ajv;\n    /**\n    * Define custom keyword\n    * @this  Ajv\n    * @param {string} keyword custom keyword, should be a valid identifier, should be different from all standard, custom and macro keywords.\n    * @param {object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.\n    * @return {Ajv} this for method chaining\n    */\n    addKeyword(keyword: string, definition: KeywordDefinition): Ajv;\n    /**\n    * Get keyword definition\n    * @this  Ajv\n    * @param {string} keyword pre-defined or custom keyword.\n    * @return {object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.\n    */\n    getKeyword(keyword: string): object | boolean;\n    /**\n    * Remove keyword\n    * @this  Ajv\n    * @param {string} keyword pre-defined or custom keyword.\n    * @return {Ajv} this for method chaining\n    */\n    removeKeyword(keyword: string): Ajv;\n    /**\n    * Validate keyword\n    * @this  Ajv\n    * @param {object} definition keyword definition object\n    * @param {boolean} throwError true to throw exception if definition is invalid\n    * @return {boolean} validation result\n    */\n    validateKeyword(definition: KeywordDefinition, throwError: boolean): boolean;\n    /**\n    * Convert array of error message objects to string\n    * @param  {Array<object>} errors optional array of validation errors, if not passed errors from the instance are used.\n    * @param  {object} options optional options with properties `separator` and `dataVar`.\n    * @return {string} human readable string with all errors descriptions\n    */\n    errorsText(errors?: Array<ErrorObject> | null, options?: ErrorsTextOptions): string;\n    errors?: Array<ErrorObject> | null;\n    _opts: Options;\n  }\n\n  interface CustomLogger {\n    log(...args: any[]): any;\n    warn(...args: any[]): any;\n    error(...args: any[]): any;\n  }\n\n  interface ValidateFunction {\n    (\n      data: any,\n      dataPath?: string,\n      parentData?: object | Array<any>,\n      parentDataProperty?: string | number,\n      rootData?: object | Array<any>\n    ): boolean | PromiseLike<any>;\n    schema?: object | boolean;\n    errors?: null | Array<ErrorObject>;\n    refs?: object;\n    refVal?: Array<any>;\n    root?: ValidateFunction | object;\n    $async?: true;\n    source?: object;\n  }\n\n  interface Options {\n    $data?: boolean;\n    allErrors?: boolean;\n    verbose?: boolean;\n    jsonPointers?: boolean;\n    uniqueItems?: boolean;\n    unicode?: boolean;\n    format?: false | string;\n    formats?: object;\n    keywords?: object;\n    unknownFormats?: true | string[] | 'ignore';\n    schemas?: Array<object> | object;\n    schemaId?: '$id' | 'id' | 'auto';\n    missingRefs?: true | 'ignore' | 'fail';\n    extendRefs?: true | 'ignore' | 'fail';\n    loadSchema?: (uri: string, cb?: (err: Error, schema: object) => void) => PromiseLike<object | boolean>;\n    removeAdditional?: boolean | 'all' | 'failing';\n    useDefaults?: boolean | 'empty' | 'shared';\n    coerceTypes?: boolean | 'array';\n    strictDefaults?: boolean | 'log';\n    strictKeywords?: boolean | 'log';\n    strictNumbers?: boolean;\n    async?: boolean | string;\n    transpile?: string | ((code: string) => string);\n    meta?: boolean | object;\n    validateSchema?: boolean | 'log';\n    addUsedSchema?: boolean;\n    inlineRefs?: boolean | number;\n    passContext?: boolean;\n    loopRequired?: number;\n    ownProperties?: boolean;\n    multipleOfPrecision?: boolean | number;\n    errorDataPath?: string,\n    messages?: boolean;\n    sourceCode?: boolean;\n    processCode?: (code: string, schema: object) => string;\n    cache?: object;\n    logger?: CustomLogger | false;\n    nullable?: boolean;\n    serialize?: ((schema: object | boolean) => any) | false;\n  }\n\n  type FormatValidator = string | RegExp | ((data: string) => boolean | PromiseLike<any>);\n  type NumberFormatValidator = ((data: number) => boolean | PromiseLike<any>);\n\n  interface NumberFormatDefinition {\n    type: \"number\",\n    validate: NumberFormatValidator;\n    compare?: (data1: number, data2: number) => number;\n    async?: boolean;\n  }\n\n  interface StringFormatDefinition {\n    type?: \"string\",\n    validate: FormatValidator;\n    compare?: (data1: string, data2: string) => number;\n    async?: boolean;\n  }\n\n  type FormatDefinition = NumberFormatDefinition | StringFormatDefinition;\n\n  interface KeywordDefinition {\n    type?: string | Array<string>;\n    async?: boolean;\n    $data?: boolean;\n    errors?: boolean | string;\n    metaSchema?: object;\n    // schema: false makes validate not to expect schema (ValidateFunction)\n    schema?: boolean;\n    statements?: boolean;\n    dependencies?: Array<string>;\n    modifying?: boolean;\n    valid?: boolean;\n    // one and only one of the following properties should be present\n    validate?: SchemaValidateFunction | ValidateFunction;\n    compile?: (schema: any, parentSchema: object, it: CompilationContext) => ValidateFunction;\n    macro?: (schema: any, parentSchema: object, it: CompilationContext) => object | boolean;\n    inline?: (it: CompilationContext, keyword: string, schema: any, parentSchema: object) => string;\n  }\n\n  interface CompilationContext {\n    level: number;\n    dataLevel: number;\n    dataPathArr: string[];\n    schema: any;\n    schemaPath: string;\n    baseId: string;\n    async: boolean;\n    opts: Options;\n    formats: {\n      [index: string]: FormatDefinition | undefined;\n    };\n    keywords: {\n      [index: string]: KeywordDefinition | undefined;\n    };\n    compositeRule: boolean;\n    validate: (schema: object) => boolean;\n    util: {\n      copy(obj: any, target?: any): any;\n      toHash(source: string[]): { [index: string]: true | undefined };\n      equal(obj: any, target: any): boolean;\n      getProperty(str: string): string;\n      schemaHasRules(schema: object, rules: any): string;\n      escapeQuotes(str: string): string;\n      toQuotedString(str: string): string;\n      getData(jsonPointer: string, dataLevel: number, paths: string[]): string;\n      escapeJsonPointer(str: string): string;\n      unescapeJsonPointer(str: string): string;\n      escapeFragment(str: string): string;\n      unescapeFragment(str: string): string;\n    };\n    self: Ajv;\n  }\n\n  interface SchemaValidateFunction {\n    (\n      schema: any,\n      data: any,\n      parentSchema?: object,\n      dataPath?: string,\n      parentData?: object | Array<any>,\n      parentDataProperty?: string | number,\n      rootData?: object | Array<any>\n    ): boolean | PromiseLike<any>;\n    errors?: Array<ErrorObject>;\n  }\n\n  interface ErrorsTextOptions {\n    separator?: string;\n    dataVar?: string;\n  }\n\n  interface ErrorObject {\n    keyword: string;\n    dataPath: string;\n    schemaPath: string;\n    params: ErrorParameters;\n    // Added to validation errors of propertyNames keyword schema\n    propertyName?: string;\n    // Excluded if messages set to false.\n    message?: string;\n    // These are added with the `verbose` option.\n    schema?: any;\n    parentSchema?: object;\n    data?: any;\n  }\n\n  type ErrorParameters = RefParams | LimitParams | AdditionalPropertiesParams |\n    DependenciesParams | FormatParams | ComparisonParams |\n    MultipleOfParams | PatternParams | RequiredParams |\n    TypeParams | UniqueItemsParams | CustomParams |\n    PatternRequiredParams | PropertyNamesParams |\n    IfParams | SwitchParams | NoParams | EnumParams;\n\n  interface RefParams {\n    ref: string;\n  }\n\n  interface LimitParams {\n    limit: number;\n  }\n\n  interface AdditionalPropertiesParams {\n    additionalProperty: string;\n  }\n\n  interface DependenciesParams {\n    property: string;\n    missingProperty: string;\n    depsCount: number;\n    deps: string;\n  }\n\n  interface FormatParams {\n    format: string\n  }\n\n  interface ComparisonParams {\n    comparison: string;\n    limit: number | string;\n    exclusive: boolean;\n  }\n\n  interface MultipleOfParams {\n    multipleOf: number;\n  }\n\n  interface PatternParams {\n    pattern: string;\n  }\n\n  interface RequiredParams {\n    missingProperty: string;\n  }\n\n  interface TypeParams {\n    type: string;\n  }\n\n  interface UniqueItemsParams {\n    i: number;\n    j: number;\n  }\n\n  interface CustomParams {\n    keyword: string;\n  }\n\n  interface PatternRequiredParams {\n    missingPattern: string;\n  }\n\n  interface PropertyNamesParams {\n    propertyName: string;\n  }\n\n  interface IfParams {\n    failingKeyword: string;\n  }\n\n  interface SwitchParams {\n    caseIndex: number;\n  }\n\n  interface NoParams { }\n\n  interface EnumParams {\n    allowedValues: Array<any>;\n  }\n}\n\nexport = ajv;\n\n\n// Original definitions in https://github.com/DefinitelyTyped/DefinitelyTyped by: David Muller <https://github.com/davidm77>\n\n/// <reference types=\"node\" />\n\nimport * as stream from \"stream\";\n\nexport = parse;\n\ndeclare function parse(input: Buffer | string, options?: parse.Options, callback?: parse.Callback): parse.Parser;\ndeclare function parse(input: Buffer | string, callback?: parse.Callback): parse.Parser;\ndeclare function parse(options?: parse.Options, callback?: parse.Callback): parse.Parser;\ndeclare function parse(callback?: parse.Callback): parse.Parser;\ndeclare namespace parse {\n\n    type Callback = (err: Error | undefined, records: any | undefined, info: Info) => void;\n\n    interface Parser extends stream.Transform {}\n\n    class Parser {\n        constructor(options: Options);\n        \n        __push(line: any): any;\n        \n        __write(chars: any, end: any, callback: any): any;\n        \n        readonly options: Options\n        \n        readonly info: Info;\n    }\n\n    interface CastingContext {\n        readonly column: number | string;\n        readonly empty_lines: number;\n        readonly header: boolean;\n        readonly index: number;\n        readonly quoting: boolean;\n        readonly lines: number;\n        readonly records: number;\n        readonly invalid_field_length: number;\n    }\n\n    type CastingFunction = (value: string, context: CastingContext) => any;\n\n    type CastingDateFunction = (value: string, context: CastingContext) => Date;\n\n    type ColumnOption = string | undefined | null | false | { name: string };\n\n    interface Options {\n        /**\n         * If true, the parser will attempt to convert read data types to native types.\n         * @deprecated Use {@link cast}\n         */\n        auto_parse?: boolean | CastingFunction;\n        /**\n         * If true, the parser will attempt to convert read data types to dates. It requires the \"auto_parse\" option.\n         * @deprecated Use {@link cast_date}\n         */\n        auto_parse_date?: boolean | CastingDateFunction;\n        /**\n         * If true, detect and exclude the byte order mark (BOM) from the CSV input if present.\n         */\n        bom?: boolean;\n        /**\n         * If true, the parser will attempt to convert input string to native types.\n         * If a function, receive the value as first argument, a context as second argument and return a new value. More information about the context properties is available below.\n         */\n        cast?: boolean | CastingFunction;\n        /**\n         * If true, the parser will attempt to convert input string to dates.\n         * If a function, receive the value as argument and return a new value. It requires the \"auto_parse\" option. Be careful, it relies on Date.parse.\n         */\n        cast_date?: boolean | CastingDateFunction;\n        /**\n         * List of fields as an array,\n         * a user defined callback accepting the first line and returning the column names or true if autodiscovered in the first CSV line,\n         * default to null,\n         * affect the result data set in the sense that records will be objects instead of arrays.\n         */\n        columns?: ColumnOption[] | boolean | ((record: any) => ColumnOption[]);\n        /**\n         * Convert values into an array of values when columns are activated and\n         * when multiple columns of the same name are found.\n         */\n        columns_duplicates_to_array?: boolean;\n        /**\n         * Treat all the characters after this one as a comment, default to '' (disabled).\n         */\n        comment?: string;\n        /**\n         * Set the field delimiter. One character only, defaults to comma.\n         */\n        delimiter?: string | string[] | Buffer;\n        /**\n         * Set the escape character, one character only, defaults to double quotes.\n         */\n        escape?: string | Buffer;\n        /**\n         * Start handling records from the requested number of records.\n         */\n        from?: number;\n        /**\n         * Start handling records from the requested line number.\n         */\n        from_line?: number;\n        /**\n         * Generate two properties `info` and `record` where `info` is a snapshot of the info object at the time the record was created and `record` is the parsed array or object.\n         */\n        info?: boolean;\n        /**\n         * If true, ignore whitespace immediately following the delimiter (i.e. left-trim all fields), defaults to false.\n         * Does not remove whitespace in a quoted field.\n         */\n        ltrim?: boolean;\n        /**\n         * Maximum numer of characters to be contained in the field and line buffers before an exception is raised,\n         * used to guard against a wrong delimiter or record_delimiter,\n         * default to 128000 characters.\n         */\n        max_record_size?: number;\n        /**\n         * Name of header-record title to name objects by.\n         */\n        objname?: string;\n        /**\n         * Alter and filter records by executing a user defined function.\n         */\n        on_record?: (record: any, context: CastingContext) => any;\n        /**\n         * Optional character surrounding a field, one character only, defaults to double quotes.\n         */\n        quote?: string | boolean | Buffer | null;\n        /**\n         * Generate two properties raw and row where raw is the original CSV row content and row is the parsed array or object.\n         */\n        raw?: boolean;\n        /**\n         * Preserve quotes inside unquoted field.\n         */\n        relax?: boolean;\n        /**\n         * Discard inconsistent columns count, default to false.\n         */\n        relax_column_count?: boolean;\n        /**\n         * Discard inconsistent columns count when the record contains less fields than expected, default to false.\n         */\n        relax_column_count_less?: boolean;\n        /**\n         * Discard inconsistent columns count when the record contains more fields than expected, default to false.\n         */\n        relax_column_count_more?: boolean;\n        /**\n         * One or multiple characters used to delimit record rows; defaults to auto discovery if not provided.\n         * Supported auto discovery method are Linux (\"\\n\"), Apple (\"\\r\") and Windows (\"\\r\\n\") row delimiters.\n         */\n        record_delimiter?: string | string[] | Buffer | Buffer[];\n        /**\n         * If true, ignore whitespace immediately preceding the delimiter (i.e. right-trim all fields), defaults to false.\n         * Does not remove whitespace in a quoted field.\n         */\n        rtrim?: boolean;\n        /**\n         * Dont generate empty values for empty lines.\n         * Defaults to false\n         */\n        skip_empty_lines?: boolean;\n        /**\n         * Skip a line with error found inside and directly go process the next line.\n         */\n        skip_lines_with_error?: boolean;\n        /**\n         * Don't generate records for lines containing empty column values (column matching /\\s*\\/), defaults to false.\n         */\n        skip_lines_with_empty_values?: boolean;\n        /**\n         * Stop handling records after the requested number of records.\n         */\n        to?: number;\n        /**\n         * Stop handling records after the requested line number.\n         */\n        to_line?: number;\n        /**\n         * If true, ignore whitespace immediately around the delimiter, defaults to false.\n         * Does not remove whitespace in a quoted field.\n         */\n        trim?: boolean;\n    }\n\n    interface Info {\n        /**\n         * Count the number of lines being fully commented.\n         */\n        readonly comment_lines: number;\n        /**\n         * Count the number of processed empty lines.\n         */\n        readonly empty_lines: number;\n        /**\n         * The number of lines encountered in the source dataset, start at 1 for the first line.\n         */\n        readonly lines: number;\n        /**\n         * Count the number of processed records.\n         */\n        readonly records: number;\n        /**\n         * Number of non uniform records when `relax_column_count` is true.\n         */\n        readonly invalid_field_length: number;\n    }\n}\n\n\nimport * as csvParse from './index';\n\nexport = parse;\n\ndeclare function parse(input: Buffer | string, options?: csvParse.Options): any;\ndeclare namespace parse {}\n\n// Original definitions in https://github.com/DefinitelyTyped/DefinitelyTyped by: David Muller <https://github.com/davidm77>\n\n/// <reference types=\"node\" />\n\nimport * as stream from \"stream\";\n\nexport = parse;\n\ndeclare function parse(input: Buffer | string, options?: parse.Options, callback?: parse.Callback): parse.Parser;\ndeclare function parse(input: Buffer | string, callback?: parse.Callback): parse.Parser;\ndeclare function parse(options?: parse.Options, callback?: parse.Callback): parse.Parser;\ndeclare function parse(callback?: parse.Callback): parse.Parser;\ndeclare namespace parse {\n\n    type Callback = (err: Error | undefined, records: any | undefined, info: Info) => void;\n\n    interface Parser extends stream.Transform {}\n\n    class Parser {\n        constructor(options: Options);\n        \n        __push(line: any): any;\n        \n        __write(chars: any, end: any, callback: any): any;\n        \n        readonly options: Options\n        \n        readonly info: Info;\n    }\n\n    interface CastingContext {\n        readonly column: number | string;\n        readonly empty_lines: number;\n        readonly header: boolean;\n        readonly index: number;\n        readonly quoting: boolean;\n        readonly lines: number;\n        readonly records: number;\n        readonly invalid_field_length: number;\n    }\n\n    type CastingFunction = (value: string, context: CastingContext) => any;\n\n    type CastingDateFunction = (value: string, context: CastingContext) => Date;\n\n    type ColumnOption = string | undefined | null | false | { name: string };\n\n    interface Options {\n        /**\n         * If true, the parser will attempt to convert read data types to native types.\n         * @deprecated Use {@link cast}\n         */\n        auto_parse?: boolean | CastingFunction;\n        /**\n         * If true, the parser will attempt to convert read data types to dates. It requires the \"auto_parse\" option.\n         * @deprecated Use {@link cast_date}\n         */\n        auto_parse_date?: boolean | CastingDateFunction;\n        /**\n         * If true, detect and exclude the byte order mark (BOM) from the CSV input if present.\n         */\n        bom?: boolean;\n        /**\n         * If true, the parser will attempt to convert input string to native types.\n         * If a function, receive the value as first argument, a context as second argument and return a new value. More information about the context properties is available below.\n         */\n        cast?: boolean | CastingFunction;\n        /**\n         * If true, the parser will attempt to convert input string to dates.\n         * If a function, receive the value as argument and return a new value. It requires the \"auto_parse\" option. Be careful, it relies on Date.parse.\n         */\n        cast_date?: boolean | CastingDateFunction;\n        /**\n         * List of fields as an array,\n         * a user defined callback accepting the first line and returning the column names or true if autodiscovered in the first CSV line,\n         * default to null,\n         * affect the result data set in the sense that records will be objects instead of arrays.\n         */\n        columns?: ColumnOption[] | boolean | ((record: any) => ColumnOption[]);\n        /**\n         * Convert values into an array of values when columns are activated and\n         * when multiple columns of the same name are found.\n         */\n        columns_duplicates_to_array?: boolean;\n        /**\n         * Treat all the characters after this one as a comment, default to '' (disabled).\n         */\n        comment?: string;\n        /**\n         * Set the field delimiter. One character only, defaults to comma.\n         */\n        delimiter?: string | string[] | Buffer;\n        /**\n         * Set the escape character, one character only, defaults to double quotes.\n         */\n        escape?: string | Buffer;\n        /**\n         * Start handling records from the requested number of records.\n         */\n        from?: number;\n        /**\n         * Start handling records from the requested line number.\n         */\n        from_line?: number;\n        /**\n         * Generate two properties `info` and `record` where `info` is a snapshot of the info object at the time the record was created and `record` is the parsed array or object.\n         */\n        info?: boolean;\n        /**\n         * If true, ignore whitespace immediately following the delimiter (i.e. left-trim all fields), defaults to false.\n         * Does not remove whitespace in a quoted field.\n         */\n        ltrim?: boolean;\n        /**\n         * Maximum numer of characters to be contained in the field and line buffers before an exception is raised,\n         * used to guard against a wrong delimiter or record_delimiter,\n         * default to 128000 characters.\n         */\n        max_record_size?: number;\n        /**\n         * Name of header-record title to name objects by.\n         */\n        objname?: string;\n        /**\n         * Alter and filter records by executing a user defined function.\n         */\n        on_record?: (record: any, context: CastingContext) => any;\n        /**\n         * Optional character surrounding a field, one character only, defaults to double quotes.\n         */\n        quote?: string | boolean | Buffer | null;\n        /**\n         * Generate two properties raw and row where raw is the original CSV row content and row is the parsed array or object.\n         */\n        raw?: boolean;\n        /**\n         * Preserve quotes inside unquoted field.\n         */\n        relax?: boolean;\n        /**\n         * Discard inconsistent columns count, default to false.\n         */\n        relax_column_count?: boolean;\n        /**\n         * Discard inconsistent columns count when the record contains less fields than expected, default to false.\n         */\n        relax_column_count_less?: boolean;\n        /**\n         * Discard inconsistent columns count when the record contains more fields than expected, default to false.\n         */\n        relax_column_count_more?: boolean;\n        /**\n         * One or multiple characters used to delimit record rows; defaults to auto discovery if not provided.\n         * Supported auto discovery method are Linux (\"\\n\"), Apple (\"\\r\") and Windows (\"\\r\\n\") row delimiters.\n         */\n        record_delimiter?: string | string[] | Buffer | Buffer[];\n        /**\n         * If true, ignore whitespace immediately preceding the delimiter (i.e. right-trim all fields), defaults to false.\n         * Does not remove whitespace in a quoted field.\n         */\n        rtrim?: boolean;\n        /**\n         * Dont generate empty values for empty lines.\n         * Defaults to false\n         */\n        skip_empty_lines?: boolean;\n        /**\n         * Skip a line with error found inside and directly go process the next line.\n         */\n        skip_lines_with_error?: boolean;\n        /**\n         * Don't generate records for lines containing empty column values (column matching /\\s*\\/), defaults to false.\n         */\n        skip_lines_with_empty_values?: boolean;\n        /**\n         * Stop handling records after the requested number of records.\n         */\n        to?: number;\n        /**\n         * Stop handling records after the requested line number.\n         */\n        to_line?: number;\n        /**\n         * If true, ignore whitespace immediately around the delimiter, defaults to false.\n         * Does not remove whitespace in a quoted field.\n         */\n        trim?: boolean;\n    }\n\n    interface Info {\n        /**\n         * Count the number of lines being fully commented.\n         */\n        readonly comment_lines: number;\n        /**\n         * Count the number of processed empty lines.\n         */\n        readonly empty_lines: number;\n        /**\n         * The number of lines encountered in the source dataset, start at 1 for the first line.\n         */\n        readonly lines: number;\n        /**\n         * Count the number of processed records.\n         */\n        readonly records: number;\n        /**\n         * Number of non uniform records when `relax_column_count` is true.\n         */\n        readonly invalid_field_length: number;\n    }\n}\n\n\nimport * as csvParse from './index';\n\nexport = parse;\n\ndeclare function parse(input: Buffer | string, options?: csvParse.Options): any;\ndeclare namespace parse {}\n\ndeclare const equal: (a: any, b: any) => boolean;\nexport = equal;\n\n\ndeclare const equal: (a: any, b: any) => boolean;\nexport = equal;\n\n\ndeclare module 'fast-deep-equal' {\n    const equal: (a: any, b: any) => boolean;\n    export = equal;\n}\n\n\ndeclare const equal: (a: any, b: any) => boolean;\nexport = equal;\n\n\ndeclare module 'fast-json-stable-stringify' {\n  function stringify(obj: any): string;\n  export = stringify;\n}\n\n\ndeclare function stringify(value: any, replacer?: (key: string, value: any) => any, space?: string | number): string;\n\ndeclare namespace stringify {\n  export function stable(value: any, replacer?: (key: string, value: any) => any, space?: string | number): string;\n  export function stableStringify(value: any, replacer?: (key: string, value: any) => any, space?: string | number): string;\n}\n\nexport default stringify;\n\n\n// Definitions by: Carlos Ballesteros Velasco <https://github.com/soywiz>\n//                 Leon Yu <https://github.com/leonyu>\n//                 BendingBender <https://github.com/BendingBender>\n//                 Maple Miao <https://github.com/mapleeit>\n\n/// <reference types=\"node\" />\nimport * as stream from 'stream';\nimport * as http from 'http';\n\nexport = FormData;\n\n// Extracted because @types/node doesn't export interfaces.\ninterface ReadableOptions {\n  highWaterMark?: number;\n  encoding?: string;\n  objectMode?: boolean;\n  read?(this: stream.Readable, size: number): void;\n  destroy?(this: stream.Readable, error: Error | null, callback: (error: Error | null) => void): void;\n  autoDestroy?: boolean;\n}\n\ninterface Options extends ReadableOptions {\n  writable?: boolean;\n  readable?: boolean;\n  dataSize?: number;\n  maxDataSize?: number;\n  pauseStreams?: boolean;\n}\n\ndeclare class FormData extends stream.Readable {\n  constructor(options?: Options);\n  append(key: string, value: any, options?: FormData.AppendOptions | string): void;\n  getHeaders(userHeaders?: FormData.Headers): FormData.Headers;\n  submit(\n    params: string | FormData.SubmitOptions,\n    callback?: (error: Error | null, response: http.IncomingMessage) => void\n  ): http.ClientRequest;\n  getBuffer(): Buffer;\n  getBoundary(): string;\n  getLength(callback: (err: Error | null, length: number) => void): void;\n  getLengthSync(): number;\n  hasKnownLength(): boolean;\n}\n\ndeclare namespace FormData {\n  interface Headers {\n    [key: string]: any;\n  }\n\n  interface AppendOptions {\n    header?: string | Headers;\n    knownLength?: number;\n    filename?: string;\n    filepath?: string;\n    contentType?: string;\n  }\n\n  interface SubmitOptions extends http.RequestOptions {\n    protocol?: 'https:' | 'http:';\n  }\n}\n\n\n/// <reference types=\"node\" />\n\nimport * as stream from \"stream\";\nimport * as events from \"events\";\n\n\n// Markup data\n//-----------------------------------------------------------------------------------\ndeclare namespace MarkupData {\n    interface Location {\n        /**\n         * One-based line index\n         */\n        line: number;\n        /**\n         * One-based column index\n         */\n        col: number;\n        /**\n         * Zero-based first character index\n         */\n        startOffset: number;\n        /**\n         * Zero-based last character index\n         */\n        endOffset: number;\n    }\n\n    interface AttributesLocation {\n        [attributeName: string]: Location;\n    }\n\n    interface StartTagLocation extends Location {\n        /**\n         * Start tag attributes' location info\n         */\n        attrs: AttributesLocation\n    }\n\n    interface ElementLocation extends StartTagLocation {\n        /**\n         * Element's start tag location info.\n         */\n        startTag: StartTagLocation;\n        /**\n         * Element's end tag location info.\n         */\n        endTag: Location;\n    }\n}\n\n// Options\n//-----------------------------------------------------------------------------------\ndeclare namespace Options {\n    export interface ParserOptions {\n        /**\n         * Enables source code location information. When enabled, each node (except the root node) will have a `__location` property.\n         * If the node is not an empty element, `__location` will be a {@link MarkupData.ElementLocation} object, otherwise it will be {@link MarkupData.Location}.\n         * If the element was implicitly created by the parser (as part of [tree correction](https://html.spec.whatwg.org/multipage/syntax.html#an-introduction-to-error-handling-and-strange-cases-in-the-parser)), its `__location` property will be `undefined`.\n         *\n         * **Default:** `false`\n         */\n        locationInfo?: boolean;\n        /**\n         * Specifies the resulting tree format.\n         *\n         * **Default:** `treeAdapters.default`\n         */\n        treeAdapter?: AST.TreeAdapter;\n    }\n\n    export interface SAXParserOptions {\n        /**\n         * Enables source code location information for the tokens.\n         * When enabled, each token event handler will receive {@link MarkupData.Location} (or {@link MarkupData.StartTagLocation})\n         * object as its last argument.\n         */\n        locationInfo?: boolean;\n    }\n\n    export interface SerializerOptions {\n        /***\n         * Specifies input tree format.\n         *\n         * **Default:** `treeAdapters.default`\n         */\n        treeAdapter?: AST.TreeAdapter;\n    }\n}\n\n\n// AST\n//-----------------------------------------------------------------------------------\ndeclare namespace AST {\n    /**\n     * [Document mode](https://dom.spec.whatwg.org/#concept-document-limited-quirks).\n     */\n    type DocumentMode = 'no-quirks' | 'quirks' | 'limited-quirks';\n\n    // Default tree adapter\n    namespace Default {\n        /**\n         * Element attribute.\n         */\n        interface Attribute {\n            /**\n             * The name of the attribute.\n             */\n            name: string;\n            /**\n             * The value of the attribute.\n             */\n            value: string;\n            /**\n             * The namespace of the attribute.\n             */\n            namespace?: string;\n            /**\n             * The namespace-related prefix of the attribute.\n             */\n            prefix?: string;\n        }\n\n        /**\n         * [Default tree adapter]{@link parse5.treeAdapters} Node interface.\n         */\n        interface Node {\n            /**\n             * The name of the node. E.g. {@link Document} will have `nodeName` equal to '#document'`.\n             */\n            nodeName: string;\n        }\n\n        /**\n         * [Default tree adapter]{@link parse5.treeAdapters} ParentNode interface.\n         */\n        interface ParentNode {\n            /**\n             * Child nodes.\n             */\n            childNodes: Node[];\n        }\n\n        /**\n         * [Default tree adapter]{@link parse5.treeAdapters} DocumentType interface.\n         */\n        export interface DocumentType extends Node {\n            /**\n             * The name of the node.\n             */\n            nodeName: '#documentType';\n            /**\n             * Document type name.\n             */\n            name: string;\n            /**\n             * Document type public identifier.\n             */\n            publicId: string;\n            /**\n             * Document type system identifier.\n             */\n            systemId: string;\n        }\n\n        /**\n         * [Default tree adapter]{@link parse5.treeAdapters} Document interface.\n         */\n        export interface Document extends ParentNode {\n            /**\n             * The name of the node.\n             */\n            nodeName: '#document';\n            /**\n             * [Document mode](https://dom.spec.whatwg.org/#concept-document-limited-quirks).\n             */\n            mode: DocumentMode;\n        }\n\n        /**\n         * [Default tree adapter]{@link parse5.treeAdapters} DocumentFragment interface.\n         */\n        export interface DocumentFragment extends ParentNode {\n            /**\n             * The name of the node.\n             */\n            nodeName: '#document-fragment';\n        }\n\n        /**\n         * [Default tree adapter]{@link parse5.treeAdapters} Element interface.\n         */\n        export interface Element extends ParentNode {\n            /**\n             * The name of the node. Equals to element {@link tagName}.\n             */\n            nodeName: string;\n            /**\n             * Element tag name.\n             */\n            tagName: string;\n            /**\n             * Element namespace.\n             */\n            namespaceURI: string;\n            /**\n             * List of element attributes.\n             */\n            attrs: Attribute[];\n            /**\n             * Parent node.\n             */\n            parentNode: ParentNode;\n            /**\n             * Element source code location info. Available if location info is enabled via {@link Options.ParserOptions}.\n             */\n            __location?: MarkupData.ElementLocation;\n        }\n\n        /**\n         * [Default tree adapter]{@link parse5.treeAdapters} CommentNode interface.\n         */\n        export interface CommentNode extends Node {\n            /**\n             * The name of the node.\n             */\n            nodeName: '#comment';\n            /**\n             * Comment text.\n             */\n            data: string;\n            /**\n             * Parent node.\n             */\n            parentNode: ParentNode;\n            /**\n             * Comment source code location info. Available if location info is enabled via {@link Options.ParserOptions}.\n             */\n            __location?: MarkupData.Location;\n        }\n\n        /**\n         * [Default tree adapter]{@link parse5.treeAdapters} TextNode interface.\n         */\n        export interface TextNode extends Node {\n            /**\n             * The name of the node.\n             */\n            nodeName: '#text';\n            /**\n             * Text content.\n             */\n            value: string;\n            /**\n             * Parent node.\n             */\n            parentNode: ParentNode;\n            /**\n             * Text node source code location info. Available if location info is enabled via {@link Options.ParserOptions}.\n             */\n            __location?: MarkupData.Location;\n        }\n    }\n\n\n    // htmlparser2 tree adapter\n    namespace HtmlParser2 {\n        /**\n         * [htmlparser2 tree adapter]{@link parse5.treeAdapters} Node interface.\n         */\n        interface Node {\n            /**\n             * The type of the node. E.g. {@link Document} will have `type` equal to 'root'`.\n             */\n            type: string;\n            /**\n             * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible node {@link type}.\n             */\n            nodeType: number;\n            /**\n             * Parent node.\n             */\n            parent: ParentNode;\n            /**\n             * Same as {@link parent}. [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n             */\n            parentNode: ParentNode;\n            /**\n             * Previous sibling.\n             */\n            prev: Node;\n            /**\n             * Same as {@link prev}. [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n             */\n            previousSibling: Node;\n            /**\n             * Next sibling.\n             */\n            next: Node;\n            /**\n             * Same as {@link next}. [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n             */\n            nextSibling: Node;\n        }\n\n        /**\n         * [htmlparser2 tree adapter]{@link parse5.treeAdapters} ParentNode interface.\n         */\n        interface ParentNode extends Node {\n            /**\n             * Child nodes.\n             */\n            children: Node[];\n            /**\n             * Same as {@link children}. [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n             */\n            childNodes: Node[];\n            /**\n             * First child of the node.\n             */\n            firstChild: Node;\n            /**\n             * Last child of the node.\n             */\n            lastChild: Node;\n        }\n\n        /**\n         * [htmlparser2 tree adapter]{@link parse5.treeAdapters} DocumentType interface.\n         */\n        export interface DocumentType extends Node {\n            /**\n             * The type of the node.\n             */\n            type: 'directive';\n            /**\n             * Node name.\n             */\n            name: '!doctype';\n            /**\n             * Serialized doctype {@link name}, {@link publicId} and {@link systemId}.\n             */\n            data: string;\n            /**\n             * Document type name.\n             */\n            'x-name':string;\n            /**\n             * Document type public identifier.\n             */\n            'x-publicId': string;\n            /**\n             * Document type system identifier.\n             */\n            'x-systemId': string;\n        }\n\n        /**\n         * [htmlparser2 tree adapter]{@link parse5.treeAdapters} Document interface.\n         */\n        export interface Document extends ParentNode {\n            /**\n             * The type of the node.\n             */\n            type: 'root';\n            /**\n             * The name of the node.\n             */\n            name: 'root';\n            /**\n             * [Document mode](https://dom.spec.whatwg.org/#concept-document-limited-quirks).\n             */\n            'x-mode': DocumentMode;\n        }\n\n        /**\n         * [htmlparser2 tree adapter]{@link parse5.treeAdapters} DocumentFragment interface.\n         */\n        export interface DocumentFragment extends ParentNode {\n            /**\n             * The type of the node.\n             */\n            type: 'root';\n            /**\n             * The name of the node.\n             */\n            name: 'root';\n        }\n\n        /**\n         * [htmlparser2 tree adapter]{@link parse5.treeAdapters} Element interface.\n         */\n        export interface Element extends ParentNode {\n            /**\n             * The name of the node. Equals to element {@link tagName}.\n             */\n            name: string;\n            /**\n             * Element tag name.\n             */\n            tagName: string;\n            /**\n             * Element namespace.\n             */\n            namespace: string;\n            /**\n             * Element attributes.\n             */\n            attribs: { [name: string]: string };\n            /**\n             * Element attribute namespaces.\n             */\n            'x-attribsNamespace': { [name: string]: string };\n            /**\n             * Element attribute namespace-related prefixes.\n             */\n            'x-attribsPrefix': { [name: string]: string };\n            /**\n             * Element source code location info. Available if location info is enabled via {@link Options.ParserOptions}.\n             */\n            __location?: MarkupData.ElementLocation;\n        }\n\n        /**\n         * [htmlparser2 tree adapter]{@link parse5.treeAdapters} CommentNode interface.\n         */\n        export interface CommentNode extends Node {\n            /**\n             * The name of the node.\n             */\n            name: 'comment';\n            /**\n             * Comment text.\n             */\n            data: string;\n            /**\n             * Same as {@link data}. [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n             */\n            nodeValue: string;\n            /**\n             * Comment source code location info. Available if location info is enabled via {@link Options.ParserOptions}.\n             */\n            __location?: MarkupData.Location;\n        }\n\n        /**\n         * [htmlparser2 tree adapter]{@link parse5.treeAdapters} TextNode interface.\n         */\n        export interface TextNode extends Node {\n            /**\n             * The name of the node.\n             */\n            name: 'text';\n            /**\n             * Text content.\n             */\n            data: string;\n            /**\n             * Same as {@link data}. [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n             */\n            nodeValue: string;\n            /**\n             * Comment source code location info. Available if location info is enabled via {@link Options.ParserOptions}.\n             */\n            __location?: MarkupData.Location;\n        }\n    }\n\n\n    // Unions\n    // NOTE: we use `Object` in unions to support custom tree adapter implementations.\n    // TypeScript Handbook suggests to always use `any` instead of `Object`, but in that\n    // case language service hints `any` as type, instead of actual union name.\n    /**\n     * Generic Node interface.\n     * Cast to the actual AST interface (e.g. {@link parse5.AST.Default.Node}) to get access to the properties.\n     */\n    type Node = Default.Node | HtmlParser2.Node | Object;\n    /**\n     * Generic ParentNode interface.\n     * Cast to the actual AST interface (e.g. {@link parse5.AST.Default.ParentNode}) to get access to the properties.\n     */\n    type ParentNode = Default.ParentNode | HtmlParser2.ParentNode | Object;\n    /**\n     * Generic DocumentType interface.\n     * Cast to the actual AST interface (e.g. {@link parse5.AST.Default.DocumentType}) to get access to the properties.\n     */\n    type DocumentType = Default.DocumentType | HtmlParser2.DocumentType | Object;\n    /**\n     * Generic Document interface.\n     * Cast to the actual AST interface (e.g. {@link parse5.AST.Default.Document}) to get access to the properties.\n     */\n    type Document = Default.Document | HtmlParser2.Document | Object;\n    /**\n     * Generic DocumentFragment interface.\n     * Cast to the actual AST interface (e.g. {@link parse5.AST.Default.DocumentFragment}) to get access to the properties.\n     */\n    type DocumentFragment = Default.DocumentFragment | HtmlParser2.DocumentFragment | Object;\n    /**\n     * Generic Element interface.\n     * Cast to the actual AST interface (e.g. {@link parse5.AST.Default.Element}) to get access to the properties.\n     */\n    type Element = Default.Element | HtmlParser2.Element | Object;\n    /**\n     * Generic TextNode interface.\n     * Cast to the actual AST interface (e.g. {@link parse5.AST.Default.TextNode}) to get access to the properties.\n     */\n    type TextNode = Default.TextNode | HtmlParser2.TextNode | Object;\n    /**\n     * Generic CommentNode interface.\n     * Cast to the actual AST interface (e.g. {@link parse5.AST.Default.CommentNode}) to get access to the properties.\n     */\n    type CommentNode = Default.CommentNode | HtmlParser2.CommentNode | Object;\n\n\n    // Tree adapter interface\n    //-----------------------------------------------------------------------------------\n\n    /**\n     * Tree adapter is a set of utility functions that provides minimal required abstraction layer beetween parser and a specific AST format.\n     * Note that `TreeAdapter` is not designed to be a general purpose AST manipulation library. You can build such library\n     * on top of existing `TreeAdapter` or use one of the existing libraries from npm.\n     *\n     * @see [default implementation](https://github.com/inikulin/parse5/blob/master/lib/tree_adapters/default.js)\n     */\n    export interface TreeAdapter {\n        /**\n         * Creates a document node.\n         */\n        createDocument(): AST.Document;\n        /**\n         * Creates a document fragment node.\n         */\n        createDocumentFragment(): AST.DocumentFragment;\n        /**\n         * Creates an element node.\n         *\n         * @param tagName - Tag name of the element.\n         * @param namespaceURI - Namespace of the element.\n         * @param attrs - Attribute name-value pair array. Foreign attributes may contain `namespace` and `prefix` fields as well.\n         */\n        createElement(tagName: string, namespaceURI: string, attrs: AST.Default.Attribute[]): AST.Element;\n        /**\n         * Creates a comment node.\n         *\n         * @param data - Comment text.\n         */\n        createCommentNode(data: string): AST.CommentNode;\n        /**\n         * Appends a child node to the given parent node.\n         *\n         * @param parentNode - Parent node.\n         * @param newNode -  Child node.\n         */\n        appendChild(parentNode: AST.ParentNode, newNode: AST.Node): void;\n        /**\n         * Inserts a child node to the given parent node before the given reference node.\n         *\n         * @param parentNode - Parent node.\n         * @param newNode -  Child node.\n         * @param referenceNode -  Reference node.\n         */\n        insertBefore(parentNode: AST.ParentNode, newNode: AST.Node, referenceNode: AST.Node): void;\n        /**\n         * Sets the `<template>` element content element.\n         *\n         * @param templateElement - `<template>` element.\n         * @param contentElement -  Content element.\n         */\n        setTemplateContent(templateElement: AST.Element, contentElement: AST.DocumentFragment): void;\n        /**\n         * Returns the `<template>` element content element.\n         *\n         * @param templateElement - `<template>` element.\n         */\n        getTemplateContent(templateElement: AST.Element): AST.DocumentFragment;\n        /**\n         * Sets the document type. If the `document` already contains a document type node, the `name`, `publicId` and `systemId`\n         * properties of this node will be updated with the provided values. Otherwise, creates a new document type node\n         * with the given properties and inserts it into the `document`.\n         *\n         * @param document - Document node.\n         * @param name -  Document type name.\n         * @param publicId - Document type public identifier.\n         * @param systemId - Document type system identifier.\n         */\n        setDocumentType(document: AST.Document, name: string, publicId: string, systemId: string): void;\n        /**\n         * Sets the [document mode](https://dom.spec.whatwg.org/#concept-document-limited-quirks).\n         *\n         * @param document - Document node.\n         * @param mode - Document mode.\n         */\n        setDocumentMode(document: AST.Document, mode: AST.DocumentMode): void;\n        /**\n         * Returns [document mode](https://dom.spec.whatwg.org/#concept-document-limited-quirks).\n         *\n         * @param document - Document node.\n         */\n        getDocumentMode(document: AST.Document): AST.DocumentMode;\n        /**\n         * Removes a node from its parent.\n         *\n         * @param node - Node to remove.\n         */\n        detachNode(node: AST.Node): void;\n        /**\n         * Inserts text into a node. If the last child of the node is a text node, the provided text will be appended to the\n         * text node content. Otherwise, inserts a new text node with the given text.\n         *\n         * @param parentNode - Node to insert text into.\n         * @param text - Text to insert.\n         */\n        insertText(parentNode: AST.ParentNode, text: string): void;\n        /**\n         * Inserts text into a sibling node that goes before the reference node. If this sibling node is the text node,\n         * the provided text will be appended to the text node content. Otherwise, inserts a new sibling text node with\n         * the given text before the reference node.\n         *\n         * @param parentNode - Node to insert text into.\n         * @param text - Text to insert.\n         * @param referenceNode - Node to insert text before.\n         */\n        insertTextBefore(parentNode: AST.ParentNode, text: string, referenceNode: AST.Node): void;\n        /**\n         * Copies attributes to the given element. Only attributes that are not yet present in the element are copied.\n         *\n         * @param recipient - Element to copy attributes into.\n         * @param attrs - Attributes to copy.\n         */\n        adoptAttributes(recipient: AST.Element, attrs: AST.Default.Attribute[]): void;\n        /**\n         * Returns the first child of the given node.\n         *\n         * @param node - Node.\n         */\n        getFirstChild(node: AST.ParentNode): AST.Node;\n        /**\n         * Returns the given node's children in an array.\n         *\n         * @param node - Node.\n         */\n        getChildNodes(node: AST.ParentNode): AST.Node[];\n        /**\n         * Returns the given node's parent.\n         *\n         * @param node - Node.\n         */\n        getParentNode(node: AST.Node): AST.ParentNode;\n        /**\n         * Returns the given element's attributes in an array, in the form of name-value pairs.\n         * Foreign attributes may contain `namespace` and `prefix` fields as well.\n         *\n         * @param element - Element.\n         */\n        getAttrList(element: AST.Element): AST.Default.Attribute[];\n        /**\n         * Returns the given element's tag name.\n         *\n         * @param element - Element.\n         */\n        getTagName(element: AST.Element): string;\n        /**\n         * Returns the given element's namespace.\n         *\n         * @param element - Element.\n         */\n        getNamespaceURI(element: AST.Element): string;\n        /**\n         * Returns the given text node's content.\n         *\n         * @param textNode - Text node.\n         */\n        getTextNodeContent(textNode: AST.TextNode): string;\n        /**\n         * Returns the given comment node's content.\n         *\n         * @param commentNode - Comment node.\n         */\n        getCommentNodeContent(commentNode: AST.CommentNode): string;\n        /**\n         * Returns the given document type node's name.\n         *\n         * @param doctypeNode - Document type node.\n         */\n        getDocumentTypeNodeName(doctypeNode: AST.DocumentType): string;\n        /**\n         * Returns the given document type node's public identifier.\n         *\n         * @param doctypeNode - Document type node.\n         */\n        getDocumentTypeNodePublicId(doctypeNode: AST.DocumentType): string;\n        /**\n         * Returns the given document type node's system identifier.\n         *\n         * @param doctypeNode - Document type node.\n         */\n        getDocumentTypeNodeSystemId(doctypeNode: AST.DocumentType): string;\n        /**\n         * Determines if the given node is a text node.\n         *\n         * @param node - Node.\n         */\n        isTextNode(node: AST.Node): boolean;\n        /**\n         * Determines if the given node is a comment node.\n         *\n         * @param node - Node.\n         */\n        isCommentNode(node: AST.Node): boolean;\n        /**\n         * Determines if the given node is a document type node.\n         *\n         * @param node - Node.\n         */\n        isDocumentTypeNode(node: AST.Node): boolean;\n        /**\n         * Determines if the given node is an element.\n         *\n         * @param node - Node.\n         */\n        isElementNode(node: AST.Node): boolean;\n    }\n}\n\n\n// Included tree adapters\n//-----------------------------------------------------------------------------------\n\n/**\n * Provides built-in tree adapters that can be used for parsing and serialization.\n *\n * @example\n *```js\n *\n * const parse5 = require('parse5');\n *\n * // Uses the default tree adapter for parsing.\n * const document = parse5.parse('<div></div>', {\n *     treeAdapter: parse5.treeAdapters.default\n * });\n *\n * // Uses the htmlparser2 tree adapter with the SerializerStream.\n * const serializer = new parse5.SerializerStream(node, {\n *     treeAdapter: parse5.treeAdapters.htmlparser2\n * });\n * ```\n */\nexport var treeAdapters: {\n    /**\n     * Default tree format for parse5.\n     */\n    default: AST.TreeAdapter,\n    /**\n     * Quite popular [htmlparser2](https://github.com/fb55/htmlparser2) tree format\n     * (e.g. used by [cheerio](https://github.com/MatthewMueller/cheerio) and [jsdom](https://github.com/tmpvar/jsdom)).\n     */\n    htmlparser2: AST.TreeAdapter\n};\n\n\n// Shorthand methods\n//-----------------------------------------------------------------------------------\n\n/**\n * Parses an HTML string.\n *\n * @param html - Input HTML string.\n * @param options - Parsing options.\n *\n * @example\n * ```js\n *\n * const parse5 = require('parse5');\n *\n * const document = parse5.parse('<!DOCTYPE html><html><head></head><body>Hi there!</body></html>');\n *\n * console.log(document.childNodes[1].tagName); //> 'html'\n * ```\n */\nexport function parse(html: string, options?: Options.ParserOptions): AST.Document;\n\n/**\n * Parses an HTML fragment.\n *\n * @param fragmentContext - Parsing context element. If specified, given fragment will be parsed as if it was set to the context element's `innerHTML` property.\n * @param html - Input HTML fragment string.\n * @param options - Parsing options.\n *\n * @example\n * ```js\n *\n * const parse5 = require('parse5');\n *\n * const documentFragment = parse5.parseFragment('<table></table>');\n *\n * console.log(documentFragment.childNodes[0].tagName); //> 'table'\n *\n * // Parses the html fragment in the context of the parsed <table> element.\n * const trFragment = parser.parseFragment(documentFragment.childNodes[0], '<tr><td>Shake it, baby</td></tr>');\n *\n * console.log(trFragment.childNodes[0].childNodes[0].tagName); //> 'td'\n * ```\n */\nexport function parseFragment(fragmentContext: AST.Element, html: string, options?: Options.ParserOptions): AST.DocumentFragment;\nexport function parseFragment(html: string, options?: Options.ParserOptions): AST.DocumentFragment;\n\n/**\n * Serializes an AST node to an HTML string.\n *\n * @param node - Node to serialize.\n * @param options - Serialization options.\n *\n * @example\n * ```js\n *\n * const parse5 = require('parse5');\n *\n * const document = parse5.parse('<!DOCTYPE html><html><head></head><body>Hi there!</body></html>');\n *\n * // Serializes a document.\n * const html = parse5.serialize(document);\n *\n * // Serializes the <html> element content.\n * const str = parse5.serialize(document.childNodes[1]);\n *\n * console.log(str); //> '<head></head><body>Hi there!</body>'\n * ```\n */\nexport function serialize(node: AST.Node, options?: Options.SerializerOptions): string;\n\n\n// Parser stream\n//-----------------------------------------------------------------------------------\n\n/**\n * Streaming HTML parser with scripting support.\n * A [writable stream](https://nodejs.org/api/stream.html#stream_class_stream_writable).\n *\n * @example\n * ```js\n *\n * const parse5 = require('parse5');\n * const http = require('http');\n *\n * // Fetch the page content and obtain it's <head> node\n * http.get('http://inikulin.github.io/parse5/', res => {\n *    const parser = new parse5.ParserStream();\n *\n *    parser.once('finish', () => {\n *        console.log(parser.document.childNodes[1].childNodes[0].tagName); //> 'head'\n *    });\n *\n *    res.pipe(parser);\n * });\n * ```\n */\nexport class ParserStream extends stream.Writable {\n    /**\n     * @param options - Parsing options.\n     */\n    constructor(options?: Options.ParserOptions);\n\n    /**\n     * The resulting document node.\n     */\n    document: AST.Document;\n\n    /**\n     * Raised then parser encounters a `<script>` element.\n     * If this event has listeners, parsing will be suspended once it is emitted.\n     * So, if `<script>` has the `src` attribute, you can fetch it, execute and then resume parsing just like browsers do.\n     *\n     * @param listener.scriptElement - The script element that caused the event.\n     * @param listener.documentWrite - Write additional `html` at the current parsing position. Suitable for implementing the DOM `document.write` and `document.writeln` methods.\n     * @param listener.documentWrite.html - HTML to write.\n     * @param listener.resume - Resumes parsing.\n     *\n     * @example\n     * ```js\n     *\n     * const parse = require('parse5');\n     * const http = require('http');\n     *\n     * const parser = new parse5.ParserStream();\n     *\n     * parser.on('script', (scriptElement, documentWrite, resume) => {\n     *     const src = parse5.treeAdapters.default.getAttrList(scriptElement)[0].value;\n     *\n     *     http.get(src, res => {\n     *        // Fetch the script content, execute it with DOM built around `parser.document` and\n     *        // `document.write` implemented using `documentWrite`.\n     *        ...\n     *        // Then resume parsing.\n     *        resume();\n     *     });\n     * });\n     *\n     * parser.end('<script src=\"example.com/script.js\"></script>');\n     * ```\n     */\n    on(event: 'script', listener: (scriptElement: AST.Element, documentWrite: (html: string) => void, resume: () => void) => void): this;\n    /**\n     * WritableStream events\n     */\n    on(event: string, listener: Function): this;\n}\n\n\n// Plaint text conversion stream\n//-----------------------------------------------------------------------------------\n\n/**\n * Converts plain text files into HTML document as required by [HTML specification](https://html.spec.whatwg.org/#read-text).\n * A [writable stream](https://nodejs.org/api/stream.html#stream_class_stream_writable).\n *\n * @example\n * ```js\n *\n * const parse5 = require('parse5');\n * const fs = require('fs');\n *\n * const file = fs.createReadStream('war_and_peace.txt');\n * const converter = new parse5.PlainTextConversionStream();\n *\n * converter.once('finish', () => {\n *     console.log(converter.document.childNodes[1].childNodes[0].tagName); //> 'head'\n * });\n *\n * file.pipe(converter);\n * ```\n */\nexport class PlainTextConversionStream extends ParserStream { }\n\n\n// SAX parser\n//-----------------------------------------------------------------------------------\n/**\n * Streaming [SAX](https://en.wikipedia.org/wiki/Simple_API_for_XML)-style HTML parser.\n * A [transform stream](https://nodejs.org/api/stream.html#stream_class_stream_transform)\n * (which means you can pipe *through* it, see example).\n *\n * @example\n * ```js\n *\n * const parse5 = require('parse5');\n * const http = require('http');\n * const fs = require('fs');\n *\n * const file = fs.createWriteStream('/home/google.com.html');\n * const parser = new parse5.SAXParser();\n *\n * parser.on('text', text => {\n *    // Handle page text content\n *    ...\n * });\n *\n * http.get('http://google.com', res => {\n *    // SAXParser is the Transform stream, which means you can pipe\n *    // through it. So, you can analyze page content and, e.g., save it\n *    // to the file at the same time:\n *    res.pipe(parser).pipe(file);\n * });\n * ```\n */\nexport class SAXParser extends stream.Transform {\n    /**\n     * @param options - Parsing options.\n     */\n    constructor(options?: Options.SAXParserOptions);\n\n    /**\n     * Raised when the parser encounters a start tag.\n     *\n     * @param listener.name - Tag name.\n     * @param listener.attrs - List of attributes.\n     * @param listener.selfClosing - Indicates if the tag is self-closing.\n     * @param listener.location - Start tag source code location info. Available if location info is enabled via {@link Options.SAXParserOptions}.\n     */\n    on(event: 'startTag', listener: (name: string, attrs: AST.Default.Attribute[], selfClosing: boolean, location?: MarkupData.StartTagLocation) => void): this;\n    /**\n     * Raised then parser encounters an end tag.\n     *\n     * @param listener.name - Tag name.\n     * @param listener.location - End tag source code location info. Available if location info is enabled via {@link Options.SAXParserOptions}.\n     */\n    on(event: 'endTag', listener: (name: string, location?: MarkupData.Location) => void): this;\n    /**\n     * Raised then parser encounters a comment.\n     *\n     * @param listener.text - Comment text.\n     * @param listener.location - Comment source code location info. Available if location info is enabled via {@link Options.SAXParserOptions}.\n     */\n    on(event: 'comment', listener: (text: string, location?: MarkupData.Location) => void): this;\n    /**\n     * Raised then parser encounters text content.\n     *\n     * @param listener.text - Text content.\n     * @param listener.location - Text content code location info. Available if location info is enabled via {@link Options.SAXParserOptions}.\n     */\n    on(event: 'text', listener: (text: string, location?: MarkupData.Location) => void): this;\n    /**\n     * Raised then parser encounters a [document type declaration](https://en.wikipedia.org/wiki/Document_type_declaration).\n     *\n     * @param listener.name - Document type name.\n     * @param listener.publicId - Document type public identifier.\n     * @param listener.systemId - Document type system identifier.\n     * @param listener.location - Document type declaration source code location info. Available if location info is enabled via {@link Options.SAXParserOptions}.\n     */\n    on(event: 'doctype', listener: (name: string, publicId: string, systemId: string, location?: MarkupData.Location) => void): this;\n    /**\n     * TransformStream events\n     */\n    on(event: string, listener: Function): this;\n\n    /**\n     * Stops parsing. Useful if you want the parser to stop consuming CPU time once you've obtained the desired info\n     * from the input stream. Doesn't prevent piping, so that data will flow through the parser as usual.\n     *\n     * @example\n     * ```js\n     *\n     * const parse5 = require('parse5');\n     * const http = require('http');\n     * const fs = require('fs');\n     *\n     * const file = fs.createWriteStream('google.com.html');\n     * const parser = new parse5.SAXParser();\n     *\n     * parser.on('doctype', (name, publicId, systemId) => {\n     *    // Process doctype info ans stop parsing\n     *    ...\n     *    parser.stop();\n     * });\n     *\n     * http.get('http://google.com', res => {\n     *    // Despite the fact that parser.stop() was called whole\n     *    // content of the page will be written to the file\n     *    res.pipe(parser).pipe(file);\n     * });\n     * ```\n     */\n    stop(): void;\n}\n\n\n// Serializer stream\n//-----------------------------------------------------------------------------------\n\n/**\n * Streaming AST node to an HTML serializer.\n * A [readable stream](https://nodejs.org/api/stream.html#stream_class_stream_readable).\n *\n * @example\n * ```js\n *\n * const parse5 = require('parse5');\n * const fs = require('fs');\n *\n * const file = fs.createWriteStream('/home/index.html');\n *\n * // Serializes the parsed document to HTML and writes it to the file.\n * const document = parse5.parse('<body>Who is John Galt?</body>');\n * const serializer = new parse5.SerializerStream(document);\n *\n * serializer.pipe(file);\n * ```\n */\nexport class SerializerStream extends stream.Readable {\n    /**\n     * Streaming AST node to an HTML serializer. A readable stream.\n     *\n     * @param node - Node to serialize.\n     * @param options - Serialization options.\n     */\n    constructor(node: AST.Node, options?: Options.SerializerOptions);\n}\n\n\n// This file describes the package to typescript.\n\n/**\n * Returns the number of milliseconds since the page was loaded (if browser)\n * or the node process was started.\n */\ndeclare function now(): number;\nexport = now;\n\n\ndeclare module \"safe-buffer\" {\n  export class Buffer {\n    length: number\n    write(string: string, offset?: number, length?: number, encoding?: string): number;\n    toString(encoding?: string, start?: number, end?: number): string;\n    toJSON(): { type: 'Buffer', data: any[] };\n    equals(otherBuffer: Buffer): boolean;\n    compare(otherBuffer: Buffer, targetStart?: number, targetEnd?: number, sourceStart?: number, sourceEnd?: number): number;\n    copy(targetBuffer: Buffer, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;\n    slice(start?: number, end?: number): Buffer;\n    writeUIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeUIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    readUIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readUIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readUInt8(offset: number, noAssert?: boolean): number;\n    readUInt16LE(offset: number, noAssert?: boolean): number;\n    readUInt16BE(offset: number, noAssert?: boolean): number;\n    readUInt32LE(offset: number, noAssert?: boolean): number;\n    readUInt32BE(offset: number, noAssert?: boolean): number;\n    readInt8(offset: number, noAssert?: boolean): number;\n    readInt16LE(offset: number, noAssert?: boolean): number;\n    readInt16BE(offset: number, noAssert?: boolean): number;\n    readInt32LE(offset: number, noAssert?: boolean): number;\n    readInt32BE(offset: number, noAssert?: boolean): number;\n    readFloatLE(offset: number, noAssert?: boolean): number;\n    readFloatBE(offset: number, noAssert?: boolean): number;\n    readDoubleLE(offset: number, noAssert?: boolean): number;\n    readDoubleBE(offset: number, noAssert?: boolean): number;\n    swap16(): Buffer;\n    swap32(): Buffer;\n    swap64(): Buffer;\n    writeUInt8(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt16LE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt16BE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt32LE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt32BE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt8(value: number, offset: number, noAssert?: boolean): number;\n    writeInt16LE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt16BE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt32LE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt32BE(value: number, offset: number, noAssert?: boolean): number;\n    writeFloatLE(value: number, offset: number, noAssert?: boolean): number;\n    writeFloatBE(value: number, offset: number, noAssert?: boolean): number;\n    writeDoubleLE(value: number, offset: number, noAssert?: boolean): number;\n    writeDoubleBE(value: number, offset: number, noAssert?: boolean): number;\n    fill(value: any, offset?: number, end?: number): this;\n    indexOf(value: string | number | Buffer, byteOffset?: number, encoding?: string): number;\n    lastIndexOf(value: string | number | Buffer, byteOffset?: number, encoding?: string): number;\n    includes(value: string | number | Buffer, byteOffset?: number, encoding?: string): boolean;\n\n    /**\n     * Allocates a new buffer containing the given {str}.\n     *\n     * @param str String to store in buffer.\n     * @param encoding encoding to use, optional.  Default is 'utf8'\n     */\n     constructor (str: string, encoding?: string);\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     */\n    constructor (size: number);\n    /**\n     * Allocates a new buffer containing the given {array} of octets.\n     *\n     * @param array The octets to store.\n     */\n    constructor (array: Uint8Array);\n    /**\n     * Produces a Buffer backed by the same allocated memory as\n     * the given {ArrayBuffer}.\n     *\n     *\n     * @param arrayBuffer The ArrayBuffer with which to share memory.\n     */\n    constructor (arrayBuffer: ArrayBuffer);\n    /**\n     * Allocates a new buffer containing the given {array} of octets.\n     *\n     * @param array The octets to store.\n     */\n    constructor (array: any[]);\n    /**\n     * Copies the passed {buffer} data onto a new {Buffer} instance.\n     *\n     * @param buffer The buffer to copy.\n     */\n    constructor (buffer: Buffer);\n    prototype: Buffer;\n    /**\n     * Allocates a new Buffer using an {array} of octets.\n     *\n     * @param array\n     */\n    static from(array: any[]): Buffer;\n    /**\n     * When passed a reference to the .buffer property of a TypedArray instance,\n     * the newly created Buffer will share the same allocated memory as the TypedArray.\n     * The optional {byteOffset} and {length} arguments specify a memory range\n     * within the {arrayBuffer} that will be shared by the Buffer.\n     *\n     * @param arrayBuffer The .buffer property of a TypedArray or a new ArrayBuffer()\n     * @param byteOffset\n     * @param length\n     */\n    static from(arrayBuffer: ArrayBuffer, byteOffset?: number, length?: number): Buffer;\n    /**\n     * Copies the passed {buffer} data onto a new Buffer instance.\n     *\n     * @param buffer\n     */\n    static from(buffer: Buffer): Buffer;\n    /**\n     * Creates a new Buffer containing the given JavaScript string {str}.\n     * If provided, the {encoding} parameter identifies the character encoding.\n     * If not provided, {encoding} defaults to 'utf8'.\n     *\n     * @param str\n     */\n    static from(str: string, encoding?: string): Buffer;\n    /**\n     * Returns true if {obj} is a Buffer\n     *\n     * @param obj object to test.\n     */\n    static isBuffer(obj: any): obj is Buffer;\n    /**\n     * Returns true if {encoding} is a valid encoding argument.\n     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\n     *\n     * @param encoding string to test.\n     */\n    static isEncoding(encoding: string): boolean;\n    /**\n     * Gives the actual byte length of a string. encoding defaults to 'utf8'.\n     * This is not the same as String.prototype.length since that returns the number of characters in a string.\n     *\n     * @param string string to test.\n     * @param encoding encoding used to evaluate (defaults to 'utf8')\n     */\n    static byteLength(string: string, encoding?: string): number;\n    /**\n     * Returns a buffer which is the result of concatenating all the buffers in the list together.\n     *\n     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.\n     * If the list has exactly one item, then the first item of the list is returned.\n     * If the list has more than one item, then a new Buffer is created.\n     *\n     * @param list An array of Buffer objects to concatenate\n     * @param totalLength Total length of the buffers when concatenated.\n     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.\n     */\n    static concat(list: Buffer[], totalLength?: number): Buffer;\n    /**\n     * The same as buf1.compare(buf2).\n     */\n    static compare(buf1: Buffer, buf2: Buffer): number;\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).\n     *    If parameter is omitted, buffer will be filled with zeros.\n     * @param encoding encoding used for call to buf.fill while initalizing\n     */\n    static alloc(size: number, fill?: string | Buffer | number, encoding?: string): Buffer;\n    /**\n     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    static allocUnsafe(size: number): Buffer;\n    /**\n     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    static allocUnsafeSlow(size: number): Buffer;\n  }\n}\n\ndeclare module \"safe-buffer\" {\n  export class Buffer {\n    length: number\n    write(string: string, offset?: number, length?: number, encoding?: string): number;\n    toString(encoding?: string, start?: number, end?: number): string;\n    toJSON(): { type: 'Buffer', data: any[] };\n    equals(otherBuffer: Buffer): boolean;\n    compare(otherBuffer: Buffer, targetStart?: number, targetEnd?: number, sourceStart?: number, sourceEnd?: number): number;\n    copy(targetBuffer: Buffer, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;\n    slice(start?: number, end?: number): Buffer;\n    writeUIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeUIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    readUIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readUIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readUInt8(offset: number, noAssert?: boolean): number;\n    readUInt16LE(offset: number, noAssert?: boolean): number;\n    readUInt16BE(offset: number, noAssert?: boolean): number;\n    readUInt32LE(offset: number, noAssert?: boolean): number;\n    readUInt32BE(offset: number, noAssert?: boolean): number;\n    readInt8(offset: number, noAssert?: boolean): number;\n    readInt16LE(offset: number, noAssert?: boolean): number;\n    readInt16BE(offset: number, noAssert?: boolean): number;\n    readInt32LE(offset: number, noAssert?: boolean): number;\n    readInt32BE(offset: number, noAssert?: boolean): number;\n    readFloatLE(offset: number, noAssert?: boolean): number;\n    readFloatBE(offset: number, noAssert?: boolean): number;\n    readDoubleLE(offset: number, noAssert?: boolean): number;\n    readDoubleBE(offset: number, noAssert?: boolean): number;\n    swap16(): Buffer;\n    swap32(): Buffer;\n    swap64(): Buffer;\n    writeUInt8(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt16LE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt16BE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt32LE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt32BE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt8(value: number, offset: number, noAssert?: boolean): number;\n    writeInt16LE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt16BE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt32LE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt32BE(value: number, offset: number, noAssert?: boolean): number;\n    writeFloatLE(value: number, offset: number, noAssert?: boolean): number;\n    writeFloatBE(value: number, offset: number, noAssert?: boolean): number;\n    writeDoubleLE(value: number, offset: number, noAssert?: boolean): number;\n    writeDoubleBE(value: number, offset: number, noAssert?: boolean): number;\n    fill(value: any, offset?: number, end?: number): this;\n    indexOf(value: string | number | Buffer, byteOffset?: number, encoding?: string): number;\n    lastIndexOf(value: string | number | Buffer, byteOffset?: number, encoding?: string): number;\n    includes(value: string | number | Buffer, byteOffset?: number, encoding?: string): boolean;\n\n    /**\n     * Allocates a new buffer containing the given {str}.\n     *\n     * @param str String to store in buffer.\n     * @param encoding encoding to use, optional.  Default is 'utf8'\n     */\n     constructor (str: string, encoding?: string);\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     */\n    constructor (size: number);\n    /**\n     * Allocates a new buffer containing the given {array} of octets.\n     *\n     * @param array The octets to store.\n     */\n    constructor (array: Uint8Array);\n    /**\n     * Produces a Buffer backed by the same allocated memory as\n     * the given {ArrayBuffer}.\n     *\n     *\n     * @param arrayBuffer The ArrayBuffer with which to share memory.\n     */\n    constructor (arrayBuffer: ArrayBuffer);\n    /**\n     * Allocates a new buffer containing the given {array} of octets.\n     *\n     * @param array The octets to store.\n     */\n    constructor (array: any[]);\n    /**\n     * Copies the passed {buffer} data onto a new {Buffer} instance.\n     *\n     * @param buffer The buffer to copy.\n     */\n    constructor (buffer: Buffer);\n    prototype: Buffer;\n    /**\n     * Allocates a new Buffer using an {array} of octets.\n     *\n     * @param array\n     */\n    static from(array: any[]): Buffer;\n    /**\n     * When passed a reference to the .buffer property of a TypedArray instance,\n     * the newly created Buffer will share the same allocated memory as the TypedArray.\n     * The optional {byteOffset} and {length} arguments specify a memory range\n     * within the {arrayBuffer} that will be shared by the Buffer.\n     *\n     * @param arrayBuffer The .buffer property of a TypedArray or a new ArrayBuffer()\n     * @param byteOffset\n     * @param length\n     */\n    static from(arrayBuffer: ArrayBuffer, byteOffset?: number, length?: number): Buffer;\n    /**\n     * Copies the passed {buffer} data onto a new Buffer instance.\n     *\n     * @param buffer\n     */\n    static from(buffer: Buffer): Buffer;\n    /**\n     * Creates a new Buffer containing the given JavaScript string {str}.\n     * If provided, the {encoding} parameter identifies the character encoding.\n     * If not provided, {encoding} defaults to 'utf8'.\n     *\n     * @param str\n     */\n    static from(str: string, encoding?: string): Buffer;\n    /**\n     * Returns true if {obj} is a Buffer\n     *\n     * @param obj object to test.\n     */\n    static isBuffer(obj: any): obj is Buffer;\n    /**\n     * Returns true if {encoding} is a valid encoding argument.\n     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\n     *\n     * @param encoding string to test.\n     */\n    static isEncoding(encoding: string): boolean;\n    /**\n     * Gives the actual byte length of a string. encoding defaults to 'utf8'.\n     * This is not the same as String.prototype.length since that returns the number of characters in a string.\n     *\n     * @param string string to test.\n     * @param encoding encoding used to evaluate (defaults to 'utf8')\n     */\n    static byteLength(string: string, encoding?: string): number;\n    /**\n     * Returns a buffer which is the result of concatenating all the buffers in the list together.\n     *\n     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.\n     * If the list has exactly one item, then the first item of the list is returned.\n     * If the list has more than one item, then a new Buffer is created.\n     *\n     * @param list An array of Buffer objects to concatenate\n     * @param totalLength Total length of the buffers when concatenated.\n     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.\n     */\n    static concat(list: Buffer[], totalLength?: number): Buffer;\n    /**\n     * The same as buf1.compare(buf2).\n     */\n    static compare(buf1: Buffer, buf2: Buffer): number;\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).\n     *    If parameter is omitted, buffer will be filled with zeros.\n     * @param encoding encoding used for call to buf.fill while initalizing\n     */\n    static alloc(size: number, fill?: string | Buffer | number, encoding?: string): Buffer;\n    /**\n     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    static allocUnsafe(size: number): Buffer;\n    /**\n     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    static allocUnsafeSlow(size: number): Buffer;\n  }\n}\n\n// Type definitions for TweetNaCl.js\n\nexport as namespace nacl;\n\ndeclare var nacl: nacl;\nexport = nacl;\n\ndeclare namespace nacl {\n    export interface BoxKeyPair {\n        publicKey: Uint8Array;\n        secretKey: Uint8Array;\n    }\n\n    export interface SignKeyPair {\n        publicKey: Uint8Array;\n        secretKey: Uint8Array;\n    }\n\n    export interface secretbox {\n        (msg: Uint8Array, nonce: Uint8Array, key: Uint8Array): Uint8Array;\n        open(box: Uint8Array, nonce: Uint8Array, key: Uint8Array): Uint8Array | false;\n        readonly keyLength: number;\n        readonly nonceLength: number;\n        readonly overheadLength: number;\n    }\n\n    export interface scalarMult {\n        (n: Uint8Array, p: Uint8Array): Uint8Array;\n        base(n: Uint8Array): Uint8Array;\n        readonly scalarLength: number;\n        readonly groupElementLength: number;\n    }\n\n    namespace box {\n        export interface open {\n            (msg: Uint8Array, nonce: Uint8Array, publicKey: Uint8Array, secretKey: Uint8Array): Uint8Array | false;\n            after(box: Uint8Array, nonce: Uint8Array, key: Uint8Array): Uint8Array | false;\n        }\n\n        export interface keyPair {\n            (): BoxKeyPair;\n            fromSecretKey(secretKey: Uint8Array): BoxKeyPair;\n        }\n    }\n\n    export interface box {\n        (msg: Uint8Array, nonce: Uint8Array, publicKey: Uint8Array, secretKey: Uint8Array): Uint8Array;\n        before(publicKey: Uint8Array, secretKey: Uint8Array): Uint8Array;\n        after(msg: Uint8Array, nonce: Uint8Array, key: Uint8Array): Uint8Array;\n        open: box.open;\n        keyPair: box.keyPair;\n        readonly publicKeyLength: number;\n        readonly secretKeyLength: number;\n        readonly sharedKeyLength: number;\n        readonly nonceLength: number;\n        readonly overheadLength: number;\n    }\n\n    namespace sign {\n        export interface detached {\n            (msg: Uint8Array, secretKey: Uint8Array): Uint8Array;\n            verify(msg: Uint8Array, sig: Uint8Array, publicKey: Uint8Array): boolean;\n        }\n\n        export interface keyPair {\n            (): SignKeyPair;\n            fromSecretKey(secretKey: Uint8Array): SignKeyPair;\n            fromSeed(secretKey: Uint8Array): SignKeyPair;\n        }\n    }\n\n    export interface sign {\n        (msg: Uint8Array, secretKey: Uint8Array): Uint8Array;\n        open(signedMsg: Uint8Array, publicKey: Uint8Array): Uint8Array | null;\n        detached: sign.detached;\n        keyPair: sign.keyPair;\n        readonly publicKeyLength: number;\n        readonly secretKeyLength: number;\n        readonly seedLength: number;\n        readonly signatureLength: number;\n    }\n\n    export interface hash {\n        (msg: Uint8Array): Uint8Array;\n        readonly hashLength: number;\n    }\n}\n\ndeclare interface nacl {\n    randomBytes(n: number): Uint8Array;\n    secretbox: nacl.secretbox;\n    scalarMult: nacl.scalarMult;\n    box: nacl.box;\n    sign: nacl.sign;\n    hash: nacl.hash;\n    verify(x: Uint8Array, y: Uint8Array): boolean;\n    setPRNG(fn: (x: Uint8Array, n: number) => void): void;\n}\n\n\nexport interface URIComponents {\n    scheme?: string;\n    userinfo?: string;\n    host?: string;\n    port?: number | string;\n    path?: string;\n    query?: string;\n    fragment?: string;\n    reference?: string;\n    error?: string;\n}\nexport interface URIOptions {\n    scheme?: string;\n    reference?: string;\n    tolerant?: boolean;\n    absolutePath?: boolean;\n    iri?: boolean;\n    unicodeSupport?: boolean;\n    domainHost?: boolean;\n}\nexport interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> {\n    scheme: string;\n    parse(components: ParentComponents, options: Options): Components;\n    serialize(components: Components, options: Options): ParentComponents;\n    unicodeSupport?: boolean;\n    domainHost?: boolean;\n    absolutePath?: boolean;\n}\nexport interface URIRegExps {\n    NOT_SCHEME: RegExp;\n    NOT_USERINFO: RegExp;\n    NOT_HOST: RegExp;\n    NOT_PATH: RegExp;\n    NOT_PATH_NOSCHEME: RegExp;\n    NOT_QUERY: RegExp;\n    NOT_FRAGMENT: RegExp;\n    ESCAPE: RegExp;\n    UNRESERVED: RegExp;\n    OTHER_CHARS: RegExp;\n    PCT_ENCODED: RegExp;\n    IPV4ADDRESS: RegExp;\n    IPV6ADDRESS: RegExp;\n}\nexport declare const SCHEMES: {\n    [scheme: string]: URISchemeHandler;\n};\nexport declare function pctEncChar(chr: string): string;\nexport declare function pctDecChars(str: string): string;\nexport declare function parse(uriString: string, options?: URIOptions): URIComponents;\nexport declare function removeDotSegments(input: string): string;\nexport declare function serialize(components: URIComponents, options?: URIOptions): string;\nexport declare function resolveComponents(base: URIComponents, relative: URIComponents, options?: URIOptions, skipNormalization?: boolean): URIComponents;\nexport declare function resolve(baseURI: string, relativeURI: string, options?: URIOptions): string;\nexport declare function normalize(uri: string, options?: URIOptions): string;\nexport declare function normalize(uri: URIComponents, options?: URIOptions): URIComponents;\nexport declare function equal(uriA: string, uriB: string, options?: URIOptions): boolean;\nexport declare function equal(uriA: URIComponents, uriB: URIComponents, options?: URIOptions): boolean;\nexport declare function escapeComponent(str: string, options?: URIOptions): string;\nexport declare function unescapeComponent(str: string, options?: URIOptions): string;\n\n\nexport interface URIComponents {\n    scheme?: string;\n    userinfo?: string;\n    host?: string;\n    port?: number | string;\n    path?: string;\n    query?: string;\n    fragment?: string;\n    reference?: string;\n    error?: string;\n}\nexport interface URIOptions {\n    scheme?: string;\n    reference?: string;\n    tolerant?: boolean;\n    absolutePath?: boolean;\n    iri?: boolean;\n    unicodeSupport?: boolean;\n    domainHost?: boolean;\n}\nexport interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> {\n    scheme: string;\n    parse(components: ParentComponents, options: Options): Components;\n    serialize(components: Components, options: Options): ParentComponents;\n    unicodeSupport?: boolean;\n    domainHost?: boolean;\n    absolutePath?: boolean;\n}\nexport interface URIRegExps {\n    NOT_SCHEME: RegExp;\n    NOT_USERINFO: RegExp;\n    NOT_HOST: RegExp;\n    NOT_PATH: RegExp;\n    NOT_PATH_NOSCHEME: RegExp;\n    NOT_QUERY: RegExp;\n    NOT_FRAGMENT: RegExp;\n    ESCAPE: RegExp;\n    UNRESERVED: RegExp;\n    OTHER_CHARS: RegExp;\n    PCT_ENCODED: RegExp;\n    IPV4ADDRESS: RegExp;\n    IPV6ADDRESS: RegExp;\n}\nexport declare const SCHEMES: {\n    [scheme: string]: URISchemeHandler;\n};\nexport declare function pctEncChar(chr: string): string;\nexport declare function pctDecChars(str: string): string;\nexport declare function parse(uriString: string, options?: URIOptions): URIComponents;\nexport declare function removeDotSegments(input: string): string;\nexport declare function serialize(components: URIComponents, options?: URIOptions): string;\nexport declare function resolveComponents(base: URIComponents, relative: URIComponents, options?: URIOptions, skipNormalization?: boolean): URIComponents;\nexport declare function resolve(baseURI: string, relativeURI: string, options?: URIOptions): string;\nexport declare function normalize(uri: string, options?: URIOptions): string;\nexport declare function normalize(uri: URIComponents, options?: URIOptions): URIComponents;\nexport declare function equal(uriA: string, uriB: string, options?: URIOptions): boolean;\nexport declare function equal(uriA: URIComponents, uriB: URIComponents, options?: URIOptions): boolean;\nexport declare function escapeComponent(str: string, options?: URIOptions): string;\nexport declare function unescapeComponent(str: string, options?: URIOptions): string;\n\n\nexport * from \"./uri\";\n\n\nimport { URIRegExps } from \"./uri\";\ndeclare const _default: URIRegExps;\nexport default _default;\n\n\nimport { URIRegExps } from \"./uri\";\nexport declare function buildExps(isIRI: boolean): URIRegExps;\ndeclare const _default: URIRegExps;\nexport default _default;\n\n\nimport { URISchemeHandler } from \"../uri\";\ndeclare const handler: URISchemeHandler;\nexport default handler;\n\n\nimport { URISchemeHandler } from \"../uri\";\ndeclare const handler: URISchemeHandler;\nexport default handler;\n\n\nimport { URISchemeHandler, URIComponents } from \"../uri\";\nexport interface MailtoHeaders {\n    [hfname: string]: string;\n}\nexport interface MailtoComponents extends URIComponents {\n    to: Array<string>;\n    headers?: MailtoHeaders;\n    subject?: string;\n    body?: string;\n}\ndeclare const handler: URISchemeHandler<MailtoComponents>;\nexport default handler;\n\n\nimport { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nexport interface URNComponents extends URIComponents {\n    nid?: string;\n    nss?: string;\n}\nexport interface URNOptions extends URIOptions {\n    nid?: string;\n}\ndeclare const handler: URISchemeHandler<URNComponents, URNOptions>;\nexport default handler;\n\n\nimport { URISchemeHandler, URIOptions } from \"../uri\";\nimport { URNComponents } from \"./urn\";\nexport interface UUIDComponents extends URNComponents {\n    uuid?: string;\n}\ndeclare const handler: URISchemeHandler<UUIDComponents, URIOptions, URNComponents>;\nexport default handler;\n\n\nimport { URISchemeHandler, URIComponents } from \"../uri\";\nexport interface WSComponents extends URIComponents {\n    resourceName?: string;\n    secure?: boolean;\n}\ndeclare const handler: URISchemeHandler;\nexport default handler;\n\n\nimport { URISchemeHandler } from \"../uri\";\ndeclare const handler: URISchemeHandler;\nexport default handler;\n\n\nexport interface URIComponents {\n    scheme?: string;\n    userinfo?: string;\n    host?: string;\n    port?: number | string;\n    path?: string;\n    query?: string;\n    fragment?: string;\n    reference?: string;\n    error?: string;\n}\nexport interface URIOptions {\n    scheme?: string;\n    reference?: string;\n    tolerant?: boolean;\n    absolutePath?: boolean;\n    iri?: boolean;\n    unicodeSupport?: boolean;\n    domainHost?: boolean;\n}\nexport interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> {\n    scheme: string;\n    parse(components: ParentComponents, options: Options): Components;\n    serialize(components: Components, options: Options): ParentComponents;\n    unicodeSupport?: boolean;\n    domainHost?: boolean;\n    absolutePath?: boolean;\n}\nexport interface URIRegExps {\n    NOT_SCHEME: RegExp;\n    NOT_USERINFO: RegExp;\n    NOT_HOST: RegExp;\n    NOT_PATH: RegExp;\n    NOT_PATH_NOSCHEME: RegExp;\n    NOT_QUERY: RegExp;\n    NOT_FRAGMENT: RegExp;\n    ESCAPE: RegExp;\n    UNRESERVED: RegExp;\n    OTHER_CHARS: RegExp;\n    PCT_ENCODED: RegExp;\n    IPV4ADDRESS: RegExp;\n    IPV6ADDRESS: RegExp;\n}\nexport declare const SCHEMES: {\n    [scheme: string]: URISchemeHandler;\n};\nexport declare function pctEncChar(chr: string): string;\nexport declare function pctDecChars(str: string): string;\nexport declare function parse(uriString: string, options?: URIOptions): URIComponents;\nexport declare function removeDotSegments(input: string): string;\nexport declare function serialize(components: URIComponents, options?: URIOptions): string;\nexport declare function resolveComponents(base: URIComponents, relative: URIComponents, options?: URIOptions, skipNormalization?: boolean): URIComponents;\nexport declare function resolve(baseURI: string, relativeURI: string, options?: URIOptions): string;\nexport declare function normalize(uri: string, options?: URIOptions): string;\nexport declare function normalize(uri: URIComponents, options?: URIOptions): URIComponents;\nexport declare function equal(uriA: string, uriB: string, options?: URIOptions): boolean;\nexport declare function equal(uriA: URIComponents, uriB: URIComponents, options?: URIOptions): boolean;\nexport declare function escapeComponent(str: string, options?: URIOptions): string;\nexport declare function unescapeComponent(str: string, options?: URIOptions): string;\n\n\nexport declare function merge(...sets: Array<string>): string;\nexport declare function subexp(str: string): string;\nexport declare function typeOf(o: any): string;\nexport declare function toUpperCase(str: string): string;\nexport declare function toArray(obj: any): Array<any>;\nexport declare function assign(target: object, source: any): any;\n"}, "_meta": {"timestamp": 1755554583.2538, "specifier": "@openfn/language-http@3.1.11"}}